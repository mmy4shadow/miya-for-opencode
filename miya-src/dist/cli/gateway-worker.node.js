#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    CLOSE_TIMEOUT: 30000,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error("Cannot require module "+"bufferutil");})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error("Cannot require module "+"utf-8-validate");})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
  var { isBlob, isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options, cb) {
      this._bufferedBytes += options[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      }).catch((err) => {
        process.nextTick(onError, this, err, cb);
      });
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._state = DEFAULT;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err, cb) {
    if (typeof cb === "function")
      cb(err);
    for (let i = 0;i < sender._queue.length; i++) {
      const params = sender._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function")
        callback(err);
    }
  }
  function onError(sender, err, cb) {
    callCallbacks(sender, err, cb);
    sender.onerror(err);
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var { isBlob } = require_validation();
  var {
    BINARY_TYPES,
    CLOSE_TIMEOUT,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket2 extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket2.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._closeTimeout = options.closeTimeout;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket2.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket2.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket2.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket2.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket2.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket2, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket2.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket2.prototype.addEventListener = addEventListener;
  WebSocket2.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket2;
  function initAsClient(websocket, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      closeTimeout: CLOSE_TIMEOUT,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    websocket._closeTimeout = opts.closeTimeout;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket2.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket2.CLOSING;
    websocket._errorEmitted = true;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket2.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream) {
    stream.resume();
  }
  function senderOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket.readyState === WebSocket2.CLOSED)
      return;
    if (websocket.readyState === WebSocket2.OPEN) {
      websocket._readyState = WebSocket2.CLOSING;
      setCloseTimer(websocket);
    }
    this._socket.end();
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function setCloseTimer(websocket) {
    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), websocket._closeTimeout);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket2.CLOSING;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && this._readableState.length !== 0) {
      const chunk = this.read(this._readableState.length);
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket2.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket2.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket2 = require_websocket();
  var { Duplex } = __require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket2 = require_websocket();
  var { CLOSE_TIMEOUT, GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        closeTimeout: CLOSE_TIMEOUT,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket: WebSocket2,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 13 && version !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
});

// src/cli/gateway-worker.ts
import * as fs63 from "node:fs";
import * as path62 from "node:path";

// src/cli/bun-node-compat.ts
import { spawnSync as nodeSpawnSync } from "node:child_process";
import { createServer } from "node:http";
import * as fs from "node:fs";
import * as path from "node:path";

// node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// src/cli/bun-node-compat.ts
function createRequestFromRaw(input) {
  const methodUpper = input.method.toUpperCase();
  const init = {
    method: methodUpper,
    headers: input.headers
  };
  if (input.body && methodUpper !== "GET" && methodUpper !== "HEAD" && methodUpper !== "OPTIONS") {
    init.body = Buffer.from(input.body);
  }
  return new Request(input.url, init);
}
async function readRequestBody(req) {
  if (req.method === "GET" || req.method === "HEAD" || req.method === "OPTIONS")
    return;
  const chunks = [];
  for await (const chunk of req) {
    if (typeof chunk === "string") {
      chunks.push(Buffer.from(chunk));
    } else {
      chunks.push(chunk);
    }
  }
  if (chunks.length === 0)
    return;
  return Buffer.concat(chunks);
}
function toNodeStatusText(status) {
  if (status >= 200 && status < 300)
    return "OK";
  if (status === 400)
    return "Bad Request";
  if (status === 401)
    return "Unauthorized";
  if (status === 403)
    return "Forbidden";
  if (status === 404)
    return "Not Found";
  if (status === 410)
    return "Gone";
  if (status === 500)
    return "Internal Server Error";
  if (status === 503)
    return "Service Unavailable";
  return "Response";
}
async function writeNodeResponse(res, response) {
  const headers = {};
  response.headers.forEach((value, key) => {
    headers[key] = value;
  });
  const body = response.body ? Buffer.from(await response.arrayBuffer()) : null;
  if (body && !("content-length" in headers)) {
    headers["content-length"] = String(body.length);
  }
  res.writeHead(response.status, headers);
  if (body) {
    res.end(body);
  } else {
    res.end();
  }
}
async function writeUpgradeRejection(socket, response) {
  const fallback = response ?? new Response("websocket upgrade failed", { status: 400 });
  const statusText = toNodeStatusText(fallback.status);
  const body = Buffer.from(await fallback.text());
  const headerLines = [
    `HTTP/1.1 ${fallback.status} ${statusText}`,
    "Connection: close",
    `Content-Length: ${body.length}`
  ];
  fallback.headers.forEach((value, key) => {
    headerLines.push(`${key}: ${value}`);
  });
  socket.write(`${headerLines.join(`\r
`)}\r
\r
`);
  if (body.length > 0) {
    socket.write(body);
  }
  socket.destroy();
}
function createNodeCompatWebSocket(raw) {
  const channels = new Set;
  return {
    raw,
    channels,
    send(payload) {
      if (raw.readyState === raw.OPEN) {
        raw.send(payload);
      }
    },
    close() {
      raw.close();
    },
    subscribe(channel) {
      channels.add(channel);
    }
  };
}
function normalizeWebSocketMessage(data, isBinary) {
  if (!isBinary) {
    return data.toString();
  }
  if (Buffer.isBuffer(data)) {
    return data.toString("utf-8");
  }
  return String(data);
}
function createBunServeCompat(options) {
  const host = options.hostname ?? "127.0.0.1";
  const requestedPort = Number(options.port ?? 0);
  let activePort = requestedPort;
  const sockets = new Set;
  const rawToCompat = new WeakMap;
  const pendingUpgradeData = new WeakMap;
  const wss = new import_websocket_server.default({ noServer: true });
  const server = createServer(async (req, res) => {
    const hostHeader = String(req.headers.host ?? `${host}:${activePort}`);
    const url = new URL(req.url ?? "/", `http://${hostHeader}`);
    const headers = new Headers;
    for (const [key, value] of Object.entries(req.headers)) {
      if (Array.isArray(value)) {
        for (const item of value)
          headers.append(key, item);
      } else if (typeof value === "string") {
        headers.set(key, value);
      }
    }
    const body = await readRequestBody(req);
    const request = createRequestFromRaw({
      url: url.toString(),
      method: req.method ?? "GET",
      headers,
      body
    });
    const upgrade = () => false;
    const response = await options.fetch(request, { upgrade });
    if (response instanceof Response) {
      await writeNodeResponse(res, response);
      return;
    }
    res.writeHead(204);
    res.end();
  });
  server.on("upgrade", async (req, socket, head) => {
    const hostHeader = String(req.headers.host ?? `${host}:${activePort}`);
    const url = new URL(req.url ?? "/", `http://${hostHeader}`);
    const headers = new Headers;
    for (const [key, value] of Object.entries(req.headers)) {
      if (Array.isArray(value)) {
        for (const item of value)
          headers.append(key, item);
      } else if (typeof value === "string") {
        headers.set(key, value);
      }
    }
    const request = createRequestFromRaw({
      url: url.toString(),
      method: req.method ?? "GET",
      headers
    });
    let upgradeRequested = false;
    const response = await options.fetch(request, {
      upgrade(candidate, upgradeOptions) {
        if (candidate !== request)
          return false;
        upgradeRequested = true;
        pendingUpgradeData.set(request, upgradeOptions?.data);
        return true;
      }
    });
    if (!upgradeRequested) {
      await writeUpgradeRejection(socket, response instanceof Response ? response : undefined);
      return;
    }
    wss.handleUpgrade(req, socket, head, (ws) => {
      const compat = createNodeCompatWebSocket(ws);
      sockets.add(compat);
      rawToCompat.set(ws, compat);
      const data = pendingUpgradeData.get(request);
      pendingUpgradeData.delete(request);
      if (data !== undefined) {
        Object.assign(compat, { data });
      }
      options.websocket?.open?.(compat);
      ws.on("message", (payload, isBinary) => {
        const message = normalizeWebSocketMessage(payload, isBinary);
        options.websocket?.message?.(compat, message);
      });
      ws.on("close", () => {
        sockets.delete(compat);
        rawToCompat.delete(ws);
        options.websocket?.close?.(compat);
      });
    });
  });
  server.listen(requestedPort, host);
  const addr = server.address();
  if (addr && typeof addr === "object") {
    activePort = addr.port;
  }
  return {
    get port() {
      const latest = server.address();
      if (latest && typeof latest === "object") {
        return latest.port;
      }
      return activePort;
    },
    publish(channel, payload) {
      for (const ws of sockets) {
        if (!ws.channels.has(channel))
          continue;
        ws.send(payload);
      }
    },
    stop(force = false) {
      for (const ws of sockets) {
        try {
          if (force) {
            ws.raw.terminate();
          } else {
            ws.close();
          }
        } catch {}
      }
      try {
        wss.close();
      } catch {}
      try {
        server.close();
      } catch {}
    }
  };
}
function createBunSpawnSyncCompat(command, options = {}) {
  const [bin, ...args] = command;
  if (!bin) {
    return {
      exitCode: 1,
      stdout: new Uint8Array,
      stderr: Buffer.from("spawn_missing_binary", "utf-8")
    };
  }
  const stdoutMode = options.stdout ?? "pipe";
  const stderrMode = options.stderr ?? "pipe";
  const proc = nodeSpawnSync(bin, args, {
    cwd: options.cwd,
    env: options.env,
    stdio: ["ignore", stdoutMode, stderrMode],
    windowsHide: true
  });
  return {
    exitCode: proc.status ?? (proc.error ? 1 : 0),
    stdout: proc.stdout ? Buffer.from(proc.stdout) : new Uint8Array,
    stderr: proc.stderr ? Buffer.from(proc.stderr) : new Uint8Array
  };
}
function createBunWhichCompat(bin) {
  const target = String(bin ?? "").trim();
  if (!target)
    return null;
  const pathValue = String(process.env.PATH ?? "");
  const pathExtRaw = String(process.env.PATHEXT ?? ".EXE;.CMD;.BAT;.COM");
  const pathExt = pathExtRaw.split(";").map((item) => item.trim()).filter(Boolean);
  const hasExt = /\.[a-z0-9]+$/i.test(target);
  const candidates = [];
  for (const base of pathValue.split(path.delimiter)) {
    const dir = base.trim();
    if (!dir)
      continue;
    const joined = path.join(dir, target);
    candidates.push(joined);
    if (process.platform === "win32" && !hasExt) {
      for (const ext of pathExt) {
        candidates.push(joined + ext.toLowerCase());
        candidates.push(joined + ext.toUpperCase());
      }
    }
  }
  for (const candidate of candidates) {
    try {
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    } catch {}
  }
  return null;
}
function createBunFileCompat(file) {
  return fs.readFileSync(file);
}
function ensureBunNodeCompat() {
  const runtime = globalThis;
  const existing = runtime.Bun;
  if (existing?.__miyaNodeCompat)
    return;
  const compat = {
    __miyaNodeCompat: true,
    which: createBunWhichCompat,
    serve: createBunServeCompat,
    spawnSync: createBunSpawnSyncCompat,
    file: createBunFileCompat
  };
  const merged = {
    ...existing ? existing : {},
    ...compat
  };
  runtime.Bun = merged;
  globalThis.Bun = merged;
}

// src/gateway/index.ts
import { createHash as createHash19, createHmac as createHmac2, randomUUID as randomUUID24 } from "node:crypto";
import * as fs62 from "node:fs";
import * as os5 from "node:os";
import * as path61 from "node:path";

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  config: () => config,
  clone: () => clone,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = new Set);
    inst._zod.traits.add(name);
    initializer(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error;
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path2) {
  if (!path2)
    return obj;
  return path2.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error2, path2 = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path2, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path2 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path2) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(` ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`   at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 1,
  patch: 8
};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :   ${issue2.expected}    ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :   ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     : ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :     "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `    ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue2.origin} daxilind yanl dyr`;
      default:
        return `Yanl dyr`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a mxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mnim" : "ms de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "slo";
      }
      case "string": {
        return "etzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${issue2.expected}, obdreno ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue2.origin}`;
      default:
        return `Neplatn vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/da.js
var error6 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "st",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslt",
    date: "ISO-dato",
    time: "ISO-klokkeslt",
    duration: "ISO-varighed",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error6()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/de.js
var error7 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue2.origin}`;
      default:
        return `Ungltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error7()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error8()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${issue2.expected}, riceviis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error9()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/es.js
var error10 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "nmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "nmero grande",
    symbol: "smbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funcin",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeracin",
    union: "unin",
    literal: "literal",
    promise: "promesa",
    void: "vaco",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType3(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function es_default() {
  return {
    localeError: error10()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fa.js
var error11 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected}  ${parsedType3(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")} `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"  `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"  `;
        }
        if (_issue.format === "includes") {
          return ` :   "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :    ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function fa_default() {
  return {
    localeError: error11()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fi.js
var error12 = () => {
  const Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error12()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : ${issue2.expected} attendu, ${parsedType3(issue2.input)} reu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error13()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr-CA.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${issue2.expected}, reu ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error14()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/he.js
var error15 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: " ",
    emoji: "'",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "  64",
    base64url: "  64  ",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :  ${issue2.expected},  ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :   "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :    ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :     ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function he_default() {
  return {
    localeError: error15()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/hu.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szm";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tmb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${issue2.expected}, a kapott rtk ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue2.origin}`;
      default:
        return `rvnytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error16()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/id.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error17()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/is.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error18 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a hafa" },
    file: { unit: "bti", verb: "a hafa" },
    array: { unit: "hluti", verb: "a hafa" },
    set: { unit: "hluti", verb: "a hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tmi",
    date: "ISO dagsetning",
    time: "ISO tmi",
    duration: "ISO tmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tlugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi:  slst inn ${parsedType3(issue2.input)} ar sem  a vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} s ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of lti: gert er r fyrir a ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lti: gert er r fyrir a ${issue2.origin} s ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `gildur strengur: verur a enda  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `gildur strengur: verur a innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error18()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/it.js
var error19 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error19()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ja.js
var error20 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `: ${issue2.expected}${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `: ${stringifyPrimitive(issue2.values[0])}`;
        return `: ${joinValues(issue2.values, "")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `: ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function ja_default() {
  return {
    localeError: error20()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ka.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "",
    boolean: "",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: ""
  };
  return typeMap[t] ?? t;
};
var error21 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "",
    email: "- ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "-",
    date: "",
    time: "",
    duration: "",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  - ${joinValues(issue2.values, "|")}-`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return ` :  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"-`;
        }
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"-`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}- `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${issue2.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${issue2.origin}-`;
      default:
        return ` `;
    }
  };
};
function ka_default() {
  return {
    localeError: error21()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/km.js
var error22 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  ${issue2.expected}  ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  ${stringifyPrimitive(issue2.values[0])}`;
        return `  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `  ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ``;
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function km_default() {
  return {
    localeError: error22()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ko.js
var error23 = () => {
  const Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},   ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, " ")}   `;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "";
        if (sizing) {
          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"()  `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return ` : ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function ko_default() {
  return {
    localeError: error23()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/lt.js
var parsedType5 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
};
var parsedTypeFromType = (t, data = undefined) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skaiius";
    }
    case "bigint": {
      return "sveikasis skaiius";
    }
    case "string": {
      return "eilut";
    }
    case "boolean": {
      return "login reikm";
    }
    case "undefined":
    case "void": {
      return "neapibrta reikm";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === undefined)
        return "neinomas objektas";
      if (data === null)
        return "nulin reikm";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    case "null": {
      return "nulin reikm";
    }
  }
  return t;
};
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error24 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne ilgesn kaip",
          notInclusive: "turi bti trumpesn kaip"
        },
        bigger: {
          inclusive: "turi bti ne trumpesn kaip",
          notInclusive: "turi bti ilgesn kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne didesnis kaip",
          notInclusive: "turi bti maesnis kaip"
        },
        bigger: {
          inclusive: "turi bti ne maesnis kaip",
          notInclusive: "turi bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "vestis",
    email: "el. pato adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 ukoduota eilut",
    base64url: "base64url ukoduota eilut",
    json_string: "JSON eilut",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "vestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType5(issue2.input)}, o tiktasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo bti vienas i ${joinValues(issue2.values, "|")} pasirinkim`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut privalo prasidti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut privalo traukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error24()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/mk.js
var error25 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},  ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function mk_default() {
  return {
    localeError: error25()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ms.js
var error26 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error26()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/nl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error27()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/no.js
var error28 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error28()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ota.js
var error29 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${issue2.expected}, alnan ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        }
        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue2.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue2.origin} iin tannmayan kymet var.`;
      default:
        return `Kymet tannamad.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error29()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ps.js
var error30 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected} ,  ${parsedType6(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"   `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"    `;
        }
        if (_issue.format === "includes") {
          return ` :  "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :   ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin} `;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin} `;
      default:
        return ` `;
    }
  };
};
function ps_default() {
  return {
    localeError: error30()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pl.js
var error31 = () => {
  const Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue2.origin}`;
      default:
        return `Nieprawidowe dane wejciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error31()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pt.js
var error32 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${issue2.expected}, recebido ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue2.origin}`;
      default:
        return `Campo invlido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error32()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error33 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ru_default() {
  return {
    localeError: error33()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sl.js
var error34 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${issue2.expected}, prejeto ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error34()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sv.js
var error35 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${issue2.expected}, fick ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error35()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ta.js
var error36 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " " : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        }
        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return ` `;
    }
  };
};
function ta_default() {
  return {
    localeError: error36()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/th.js
var error37 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `:  ${issue2.expected}  ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `:  ${stringifyPrimitive(issue2.values[0])}`;
        return `:  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `:  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue2.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function th_default() {
  return {
    localeError: error37()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/tr.js
var parsedType6 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error38 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${issue2.expected}, alnan ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue2.origin} iinde geersiz deer`;
      default:
        return `Geersiz deer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error38()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/uk.js
var error39 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :  ${issue2.expected},  ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function uk_default() {
  return {
    localeError: error39()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ur.js
var error40 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  : ${issue2.expected}   ${parsedType7(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  : ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, "|")}     `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"    `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return `  `;
    }
  };
};
function ur_default() {
  return {
    localeError: error40()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/vi.js
var error41 = () => {
  const Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${issue2.expected}, nhn c ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue2.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue2.origin}`;
      default:
        return `u vo khng hp l`;
    }
  };
};
function vi_default() {
  return {
    localeError: error41()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-CN.js
var error42 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "(NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} (value)`;
      default:
        return ``;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error42()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-TW.js
var error43 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` "${_issue.prefix}" `;
        }
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} `;
      default:
        return ``;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error43()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/yo.js
var error44 = () => {
  const Sizable = {
    string: { unit: "mi", verb: "n" },
    file: { unit: "bytes", verb: "n" },
    array: { unit: "nkan", verb: "n" },
    set: { unit: "nkan", verb: "n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmb";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "r bwl",
    email: "drs ml",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "kk ISO",
    date: "j ISO",
    time: "kk ISO",
    duration: "kk t p ISO",
    ipv4: "drs IPv4",
    ipv6: "drs IPv6",
    cidrv4: "gbgb IPv4",
    cidrv6: "gbgb IPv6",
    base64: "r t a k n base64",
    base64url: "r base64url",
    json_string: "r JSON",
    e164: "nmb E.164",
    jwt: "JWT",
    template_literal: "r bwl"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `bwl ae: a n lti fi ${issue2.expected}, m a r ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `bwl ae: a n lti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `yn ae: yan kan lra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T p j: a n lti j p ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T p j: a n lti j ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kr ju: a n lti j p ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kr ju: a n lti j ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `r ae: gbd br pl "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `r ae: gbd par pl "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `r ae: gbd n "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `r ae: gbd b pr mu ${_issue.pattern}`;
        return `Ae: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${issue2.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${issue2.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function yo_default() {
  return {
    localeError: error44()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var globalRegistry = /* @__PURE__ */ registry();
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.minimum = exclusiveMinimum;
                json.exclusiveMinimum = true;
              } else {
                json.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.maximum = exclusiveMaximum;
                json.exclusiveMaximum = true;
              } else {
                json.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json.anyOf = options;
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
              if (rest) {
                json.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json.items.anyOf.push(rest);
              }
              json.minItems = prefixItems.length;
              if (!rest) {
                json.maxItems = prefixItems.length;
              }
            } else {
              json.items = prefixItems;
              if (rest) {
                json.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.enum = [val];
              } else {
                json.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file.minLength = minimum;
            if (maximum !== undefined)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {} else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  exports_util.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", shape ? exports_util.objectClone(shape) : {});
      return this.shape;
    },
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", exports_util.objectClone(shape));
      return this.shape;
    },
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", exports_util.objectClone(shape));
      return this.shape;
    },
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
config(en_default());
// node_modules/@opencode-ai/plugin/dist/tool.js
function tool(input) {
  return input;
}
tool.schema = exports_external;
// src/adapters/openclaw/client.ts
import { randomUUID as randomUUID2 } from "node:crypto";
import * as path10 from "node:path";

// src/daemon/launcher.ts
import { spawn } from "node:child_process";
import { randomUUID } from "node:crypto";
import * as fs8 from "node:fs";
import * as path8 from "node:path";
import { fileURLToPath } from "node:url";

// src/settings/registry.ts
function entry(input) {
  return {
    ...input,
    requiresEvidence: input.risk === "HIGH"
  };
}
function cloneValue(value) {
  return JSON.parse(JSON.stringify(value));
}
function keySegments(key) {
  return key.split(".").map((segment) => segment.trim()).filter((segment) => segment.length > 0);
}
function getNestedValue(root, key) {
  if (!root || typeof root !== "object")
    return;
  const segments = keySegments(key);
  let current = root;
  for (const segment of segments) {
    if (!current || typeof current !== "object")
      return;
    current = current[segment];
  }
  return current;
}
function setNestedValue(root, key, value) {
  const segments = keySegments(key);
  if (segments.length === 0)
    return;
  let current = root;
  for (let index = 0;index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const next = current[segment];
    if (!next || typeof next !== "object" || Array.isArray(next)) {
      current[segment] = {};
    }
    current = current[segment];
  }
  current[segments[segments.length - 1]] = value;
}
var SETTINGS_REGISTRY = [
  entry({
    key: "ui.language",
    type: "enum",
    enumValues: ["zh-CN"],
    defaultValue: "zh-CN",
    risk: "LOW",
    description: ""
  }),
  entry({
    key: "ui.theme",
    type: "enum",
    enumValues: ["dark", "light", "system"],
    defaultValue: "dark",
    risk: "LOW",
    description: ""
  }),
  entry({
    key: "ui.dashboard.openOnStart",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: ""
  }),
  entry({
    key: "ui.dashboard.dockAutoLaunch",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: " Windows Dock"
  }),
  entry({
    key: "ui.dashboard.autoOpenCooldownMs",
    type: "integer",
    minimum: 1e4,
    maximum: 1440000,
    defaultValue: 120000,
    risk: "LOW",
    description: ""
  }),
  entry({
    key: "ui.dashboard.startPage",
    type: "enum",
    enumValues: [
      "overview",
      "autopilot",
      "approvals",
      "intake",
      "runtime",
      "jobs",
      "skills",
      "killswitch"
    ],
    defaultValue: "overview",
    risk: "LOW",
    description: ""
  }),
  entry({
    key: "ui.dashboard.refreshMs",
    type: "integer",
    minimum: 200,
    maximum: 5000,
    defaultValue: 800,
    risk: "LOW",
    description: ""
  }),
  entry({
    key: "autopilot.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "autopilot.maxCycles",
    type: "integer",
    minimum: 1,
    maximum: 20,
    defaultValue: 8,
    risk: "MED",
    description: "+"
  }),
  entry({
    key: "autopilot.noInterruptChat",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "autopilot.stallDetection.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "autopilot.stallDetection.maxNoImprovementCycles",
    type: "integer",
    minimum: 1,
    maximum: 10,
    defaultValue: 3,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "autopilot.iterationDoneRequired",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "approval.mode",
    type: "enum",
    enumValues: ["self"],
    defaultValue: "self",
    risk: "MED",
    description: ""
  }),
  entry({
    key: "approval.requireEvidence",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "approval.signers",
    type: "object",
    defaultValue: {
      executor: true,
      verifier: true
    },
    risk: "MED",
    description: ""
  }),
  entry({
    key: "approval.tier.default",
    type: "enum",
    enumValues: ["LIGHT", "STANDARD", "THOROUGH"],
    defaultValue: "STANDARD",
    risk: "MED",
    description: ""
  }),
  entry({
    key: "approval.tier.irreversible",
    type: "enum",
    enumValues: ["THOROUGH"],
    defaultValue: "THOROUGH",
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "approval.onDeny.activateKillSwitch",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "intake.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "intake.triggers.configChange",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "intake.triggers.skillOrToolchainChange",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "/ skill "
  }),
  entry({
    key: "intake.triggers.highRiskAction",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "intake.triggers.directiveContent",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "intake.policy.autoWhitelistOnApprove",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "intake.policy.autoBlacklistOnReject",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "intake.policy.defaultRejectScope",
    type: "enum",
    enumValues: ["CONTENT_FINGERPRINT", "PAGE", "PATH_PREFIX", "DOMAIN"],
    defaultValue: "CONTENT_FINGERPRINT",
    risk: "MED",
    description: ""
  }),
  entry({
    key: "intake.policy.allowTrialRunOption",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "intake.stats.windowN",
    type: "integer",
    minimum: 3,
    maximum: 50,
    defaultValue: 10,
    risk: "MED",
    description: " N"
  }),
  entry({
    key: "intake.stats.hardDenyWhenUsefulLessThanRejected",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: " U<R "
  }),
  entry({
    key: "intake.stats.downrankThresholdRatioX100",
    type: "integer",
    minimum: 100,
    maximum: 500,
    defaultValue: 150,
    risk: "MED",
    description: "X100 150  1.5 "
  }),
  entry({
    key: "intake.stats.downrankExplorePercent",
    type: "integer",
    minimum: 0,
    maximum: 100,
    defaultValue: 30,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "intake.stats.sourceUnit",
    type: "enum",
    enumValues: ["DOMAIN_PATH_PREFIX", "DOMAIN", "PATH_PREFIX"],
    defaultValue: "DOMAIN_PATH_PREFIX",
    risk: "MED",
    description: ""
  }),
  entry({
    key: "killswitch.active",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "killswitch.lockdownOnHighRisk",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "killswitch.unlockPolicy",
    type: "enum",
    enumValues: ["explicit"],
    defaultValue: "explicit",
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "killswitch.stopTargets",
    type: "object",
    defaultValue: {
      desktop: true,
      outbound: true,
      exec: true,
      browser: true,
      voice: false
    },
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "gateway.bindHost",
    type: "string",
    defaultValue: "127.0.0.1",
    risk: "MED",
    description: "Gateway "
  }),
  entry({
    key: "gateway.port",
    type: "integer",
    minimum: 1024,
    maximum: 65535,
    defaultValue: 17321,
    risk: "MED",
    description: "Gateway "
  }),
  entry({
    key: "gateway.baseUrl",
    type: "string",
    defaultValue: "http://127.0.0.1:17321",
    risk: "MED",
    description: "Gateway  URL"
  }),
  entry({
    key: "gateway.wsPath",
    type: "string",
    defaultValue: "/ws",
    risk: "MED",
    description: "Gateway WebSocket "
  }),
  entry({
    key: "gateway.staticSpa.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "gateway.auth.mode",
    type: "enum",
    enumValues: ["localToken", "none"],
    defaultValue: "localToken",
    risk: "HIGH",
    description: "Gateway "
  }),
  entry({
    key: "runtime.backpressure.max_in_flight",
    type: "integer",
    minimum: 1,
    maximum: 128,
    defaultValue: 8,
    risk: "MED",
    description: "Gateway "
  }),
  entry({
    key: "runtime.backpressure.max_queued",
    type: "integer",
    minimum: 1,
    maximum: 1024,
    defaultValue: 64,
    risk: "MED",
    description: "Gateway "
  }),
  entry({
    key: "runtime.backpressure.queue_timeout_ms",
    type: "integer",
    minimum: 100,
    maximum: 120000,
    defaultValue: 15000,
    risk: "MED",
    description: "Gateway "
  }),
  entry({
    key: "runtime.backpressure.daemon_max_pending_requests",
    type: "integer",
    minimum: 4,
    maximum: 1024,
    defaultValue: 64,
    risk: "MED",
    description: "Daemon Launcher "
  }),
  entry({
    key: "runtime.notifications.job_toast",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: "/ toast "
  }),
  entry({
    key: "runtime.multimodal.test_mode",
    type: "boolean",
    defaultValue: false,
    risk: "LOW",
    description: ""
  }),
  entry({
    key: "security.ownerCheck",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: " Owner  owner_mode_required "
  }),
  entry({
    key: "security.voiceprint.strict",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "skills.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "skills.packages",
    type: "array",
    defaultValue: [],
    risk: "MED",
    description: ""
  }),
  entry({
    key: "skills.versionLock.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "skills.compat.openCodeNative",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: " OpenCode "
  }),
  entry({
    key: "desktop.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "desktop.preferUia",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: " UIA "
  }),
  entry({
    key: "desktop.requirePreSendScreenshotVerify",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "desktop.requirePostActionVerify",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "desktop.focusPolicy",
    type: "enum",
    enumValues: ["strict", "relaxed"],
    defaultValue: "strict",
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "outbound.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "outbound.channels",
    type: "object",
    defaultValue: {
      qq: true,
      wechat: true
    },
    risk: "HIGH",
    description: " QQ/"
  }),
  entry({
    key: "outbound.requireDraftInChat",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "outbound.requireVerifierSign",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: " verifier "
  }),
  entry({
    key: "voice.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "voice.input.stt",
    type: "enum",
    enumValues: ["local", "off"],
    defaultValue: "local",
    risk: "MED",
    description: " STT "
  }),
  entry({
    key: "voice.output.tts",
    type: "enum",
    enumValues: ["local", "off"],
    defaultValue: "local",
    risk: "MED",
    description: " TTS "
  }),
  entry({
    key: "voice.wakeWord.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "voice.oneShotMode",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "voice.routeToChat",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: ""
  }),
  entry({
    key: "git.autoPush.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "git.autoPush.remote",
    type: "string",
    defaultValue: "https://github.com/mmy4shadow/miya-for-opencode.git",
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "git.autoPush.branchPattern",
    type: "string",
    defaultValue: "refs/heads/miya/<session-id>",
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "git.autoPush.maxFileSizeMB",
    type: "integer",
    minimum: 1,
    maximum: 50,
    defaultValue: 2,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "git.autoPush.blockWhenKillSwitchActive",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: ""
  }),
  entry({
    key: "git.autoPush.excludeGlobs",
    type: "array",
    defaultValue: [
      ".opencode/**",
      ".venv/**",
      "node_modules/**",
      "**/*.pem",
      "**/*.key",
      "**/.env*"
    ],
    risk: "HIGH",
    description: ""
  })
];
var REGISTRY_MAP = new Map(SETTINGS_REGISTRY.map((item) => [item.key, item]));
function leafSchema(entryValue) {
  if (entryValue.type === "boolean")
    return { type: "boolean" };
  if (entryValue.type === "integer") {
    const schema = { type: "integer" };
    if (typeof entryValue.minimum === "number")
      schema.minimum = entryValue.minimum;
    if (typeof entryValue.maximum === "number")
      schema.maximum = entryValue.maximum;
    return schema;
  }
  if (entryValue.type === "string")
    return { type: "string" };
  if (entryValue.type === "enum") {
    return { type: "string", enum: [...entryValue.enumValues ?? []] };
  }
  if (entryValue.type === "array")
    return { type: "array" };
  return { type: "object" };
}
function setSchemaAtPath(root, key, schema) {
  const segments = keySegments(key);
  if (segments.length === 0)
    return;
  let current = root;
  for (let index = 0;index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const existing = current[segment];
    if (!existing || typeof existing !== "object") {
      current[segment] = {
        type: "object",
        additionalProperties: true,
        properties: {}
      };
    }
    const node = current[segment];
    if (!node.properties || typeof node.properties !== "object") {
      node.properties = {};
    }
    current = node.properties;
  }
  current[segments[segments.length - 1]] = schema;
}
function getSettingEntry(key) {
  return REGISTRY_MAP.get(key);
}
function listSettingEntries() {
  return SETTINGS_REGISTRY.map((item) => cloneValue(item));
}
function buildDefaultConfig() {
  const config2 = {};
  for (const item of SETTINGS_REGISTRY) {
    setNestedValue(config2, item.key, cloneValue(item.defaultValue));
  }
  return config2;
}
function buildRegistryDocument() {
  return {
    version: 1,
    generatedAt: new Date().toISOString(),
    settings: listSettingEntries()
  };
}
function buildSchemaDocument() {
  const rootProperties = {};
  for (const item of SETTINGS_REGISTRY) {
    setSchemaAtPath(rootProperties, item.key, leafSchema(item));
  }
  return {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    title: "Miya Config",
    type: "object",
    additionalProperties: true,
    properties: rootProperties
  };
}
// src/settings/store.ts
import * as fs3 from "node:fs";
import * as path3 from "node:path";
// src/workflow/state.ts
import * as fs2 from "node:fs";
import * as path2 from "node:path";
var DEFAULT_STATE = {
  loopEnabled: true,
  autoContinue: true,
  maxIterationsPerWindow: 8,
  iterationCompleted: 0,
  windowStartIteration: 0,
  awaitingConfirmation: false,
  strictQualityGate: false,
  lastDone: [],
  lastMissing: [],
  lastUnresolved: [],
  autoContinueIteration: -1,
  autoContinueAt: new Date(0).toISOString(),
  updatedAt: new Date(0).toISOString()
};
function getMiyaRuntimeDir(projectDir) {
  const normalized = path2.resolve(projectDir);
  if (path2.basename(normalized).toLowerCase() === ".opencode") {
    return path2.join(normalized, "miya");
  }
  return path2.join(normalized, ".opencode", "miya");
}
function getLoopStatePath(projectDir) {
  return path2.join(getMiyaRuntimeDir(projectDir), "loop-state.json");
}
function readStateFile(filePath) {
  if (!fs2.existsSync(filePath)) {
    return { sessions: {} };
  }
  try {
    const raw = fs2.readFileSync(filePath, "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    return { sessions: parsed.sessions };
  } catch {
    return { sessions: {} };
  }
}
function getSessionState(projectDir, sessionID) {
  const filePath = getLoopStatePath(projectDir);
  const state = readStateFile(filePath);
  const current = state.sessions[sessionID];
  if (!current) {
    return { ...DEFAULT_STATE };
  }
  return {
    ...DEFAULT_STATE,
    ...current
  };
}
// src/settings/store.ts
var EMPTY_PATCH = { set: {}, unset: [] };
function runtimeFile(projectDir, fileName) {
  return path3.join(getMiyaRuntimeDir(projectDir), fileName);
}
function ensureDir(file2) {
  fs3.mkdirSync(path3.dirname(file2), { recursive: true });
}
function cloneValue2(value) {
  return JSON.parse(JSON.stringify(value));
}
function writeJson(file2, value) {
  ensureDir(file2);
  fs3.writeFileSync(file2, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function readJsonObject(file2) {
  if (!fs3.existsSync(file2))
    return {};
  try {
    const parsed = JSON.parse(fs3.readFileSync(file2, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return {};
    }
    return parsed;
  } catch {
    return {};
  }
}
function riskRank(risk) {
  if (risk === "HIGH")
    return 3;
  if (risk === "MED")
    return 2;
  return 1;
}
function maxRisk(current, next) {
  return riskRank(next) > riskRank(current) ? next : current;
}
function deepEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}
function normalizePathToKey(input) {
  const trimmed = input.trim();
  if (!trimmed)
    return "";
  if (trimmed.startsWith("/")) {
    return trimmed.split("/").map((segment) => segment.trim()).filter((segment) => segment.length > 0).join(".");
  }
  return trimmed;
}
function normalizePatchObject(input) {
  if ("jsonPatch" in input && Array.isArray(input.jsonPatch)) {
    return normalizePatchInput(input.jsonPatch);
  }
  if ("patch" in input && input.patch !== undefined) {
    return normalizePatchInput(input.patch);
  }
  const setRaw = "set" in input && input.set && typeof input.set === "object" ? input.set : null;
  const unsetRaw = "unset" in input && Array.isArray(input.unset) ? input.unset : ("reset" in input) && Array.isArray(input.reset) ? input.reset : null;
  if (setRaw || unsetRaw) {
    const patch2 = {
      set: {},
      unset: []
    };
    const errors3 = [];
    if (setRaw) {
      for (const [key, value] of Object.entries(setRaw)) {
        const normalizedKey = normalizePathToKey(key);
        if (!normalizedKey) {
          errors3.push(`Invalid set key: ${key}`);
          continue;
        }
        patch2.set[normalizedKey] = value;
      }
    }
    if (unsetRaw) {
      for (const key of unsetRaw) {
        const normalizedKey = normalizePathToKey(String(key));
        if (!normalizedKey) {
          errors3.push(`Invalid unset key: ${String(key)}`);
          continue;
        }
        patch2.unset.push(normalizedKey);
      }
    }
    patch2.unset = [...new Set(patch2.unset)];
    return { patch: patch2, errors: errors3 };
  }
  const patch = { set: {}, unset: [] };
  for (const [key, value] of Object.entries(input)) {
    const normalizedKey = normalizePathToKey(key);
    if (!normalizedKey)
      continue;
    patch.set[normalizedKey] = value;
  }
  return { patch, errors: [] };
}
function normalizeJsonPatchArray(input) {
  const patch = { set: {}, unset: [] };
  const errors3 = [];
  for (const item of input) {
    if (!item || typeof item !== "object" || Array.isArray(item)) {
      errors3.push("JSON Patch item must be an object.");
      continue;
    }
    const op = String(item.op ?? "").toLowerCase();
    const pathValue = String(item.path ?? "");
    const key = normalizePathToKey(pathValue);
    if (!key) {
      errors3.push(`JSON Patch path is invalid: ${pathValue}`);
      continue;
    }
    if (op === "remove") {
      patch.unset.push(key);
      continue;
    }
    if (op === "add" || op === "replace" || op === "set") {
      patch.set[key] = item.value;
      continue;
    }
    errors3.push(`Unsupported JSON Patch operation: ${op}`);
  }
  patch.unset = [...new Set(patch.unset)];
  return { patch, errors: errors3 };
}
function validateValueType(entryValue, value) {
  const valueType = entryValue.type;
  if (valueType === "boolean") {
    return typeof value === "boolean" ? null : `Expected boolean for ${entryValue.key}.`;
  }
  if (valueType === "integer") {
    if (typeof value !== "number" || !Number.isInteger(value)) {
      return `Expected integer for ${entryValue.key}.`;
    }
    if (typeof entryValue.minimum === "number" && value < entryValue.minimum) {
      return `${entryValue.key} must be >= ${entryValue.minimum}.`;
    }
    if (typeof entryValue.maximum === "number" && value > entryValue.maximum) {
      return `${entryValue.key} must be <= ${entryValue.maximum}.`;
    }
    return null;
  }
  if (valueType === "string") {
    return typeof value === "string" ? null : `Expected string for ${entryValue.key}.`;
  }
  if (valueType === "enum") {
    if (typeof value !== "string") {
      return `Expected enum string for ${entryValue.key}.`;
    }
    const options = entryValue.enumValues ?? [];
    if (!options.includes(value)) {
      return `${entryValue.key} must be one of: ${options.join(", ")}.`;
    }
    return null;
  }
  if (valueType === "object") {
    return value && typeof value === "object" && !Array.isArray(value) ? null : `Expected object for ${entryValue.key}.`;
  }
  if (valueType === "array") {
    return Array.isArray(value) ? null : `Expected array for ${entryValue.key}.`;
  }
  return `Unsupported type for ${entryValue.key}.`;
}
function mergeConfigWithDefaults(raw) {
  const merged = cloneValue2(raw);
  for (const item of listSettingEntries()) {
    const current = getNestedValue(merged, item.key);
    if (current === undefined) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
      continue;
    }
    const issue2 = validateValueType(item, current);
    if (issue2) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
    }
  }
  return merged;
}
function ensureSettingsFiles(projectDir) {
  const registryPath = runtimeFile(projectDir, "registry.json");
  const schemaPath = runtimeFile(projectDir, "schema.json");
  const configPath = runtimeFile(projectDir, "config.json");
  writeJson(registryPath, buildRegistryDocument());
  writeJson(schemaPath, buildSchemaDocument());
  if (!fs3.existsSync(configPath)) {
    writeJson(configPath, buildDefaultConfig());
    return;
  }
  const raw = readJsonObject(configPath);
  const normalized = mergeConfigWithDefaults(raw);
  writeJson(configPath, normalized);
}
function readConfig(projectDir) {
  ensureSettingsFiles(projectDir);
  const raw = readJsonObject(runtimeFile(projectDir, "config.json"));
  return mergeConfigWithDefaults(raw);
}
function writeConfig(projectDir, config2) {
  ensureSettingsFiles(projectDir);
  writeJson(runtimeFile(projectDir, "config.json"), mergeConfigWithDefaults(config2));
}
function normalizePatchInput(input) {
  if (!input) {
    return {
      patch: cloneValue2(EMPTY_PATCH),
      errors: ["Patch payload is empty."]
    };
  }
  if (Array.isArray(input)) {
    return normalizeJsonPatchArray(input);
  }
  if (typeof input !== "object") {
    return {
      patch: cloneValue2(EMPTY_PATCH),
      errors: ["Patch payload must be an object or JSON Patch array."]
    };
  }
  return normalizePatchObject(input);
}
function validateConfigPatch(projectDir, patchInput) {
  const currentConfig = readConfig(projectDir);
  const normalized = normalizePatchInput(patchInput);
  const errors3 = [...normalized.errors];
  const warnings = [];
  const changes = [];
  const keysToCheck = [
    ...Object.keys(normalized.patch.set),
    ...normalized.patch.unset
  ];
  const uniqueKeys = [...new Set(keysToCheck)];
  for (const key of uniqueKeys) {
    const setting = getSettingEntry(key);
    if (!setting) {
      errors3.push(`Unknown setting key: ${key}`);
      continue;
    }
    const isReset = normalized.patch.unset.includes(key);
    const nextValue = isReset ? cloneValue2(setting.defaultValue) : normalized.patch.set[key];
    const previousValue = getNestedValue(currentConfig, key);
    const issue2 = validateValueType(setting, nextValue);
    if (issue2) {
      errors3.push(issue2);
      continue;
    }
    if (deepEqual(previousValue, nextValue)) {
      warnings.push(`${key} is unchanged.`);
      continue;
    }
    changes.push({
      key,
      operation: isReset ? "reset" : "set",
      risk: setting.risk,
      description: setting.description,
      previousValue,
      nextValue,
      requiresEvidence: setting.requiresEvidence
    });
  }
  let highestRisk = "LOW";
  for (const change of changes) {
    highestRisk = maxRisk(highestRisk, change.risk);
  }
  if (normalized.patch.set["outbound.enabled"] === true && normalized.patch.set["desktop.requirePreSendScreenshotVerify"] === false) {
    errors3.push("outbound.enabled=true  desktop.requirePreSendScreenshotVerify  false");
  }
  if (changes.length === 0 && errors3.length === 0) {
    warnings.push("Patch has no effective changes.");
  }
  const requiredSafetyTier = highestRisk === "HIGH" ? "THOROUGH" : highestRisk === "MED" ? "STANDARD" : "LIGHT";
  return {
    ok: errors3.length === 0 && changes.length > 0,
    errors: errors3,
    warnings,
    normalizedPatch: normalized.patch,
    changes,
    maxRisk: highestRisk,
    requiresEvidence: changes.some((change) => change.requiresEvidence),
    requiredSafetyTier
  };
}
function applyConfigPatch(projectDir, validation) {
  const config2 = readConfig(projectDir);
  for (const change of validation.changes) {
    setNestedValue(config2, change.key, cloneValue2(change.nextValue));
  }
  writeConfig(projectDir, config2);
  return {
    updatedConfig: readConfig(projectDir),
    applied: validation.changes
  };
}
// src/safety/evidence.ts
var LARGE_FILE_LIMIT = 2 * 1024 * 1024;

// src/safety/store.ts
import * as fs7 from "node:fs";
import * as path7 from "node:path";

// src/security/system-keyring.ts
import { spawnSync } from "node:child_process";
import {
  createCipheriv,
  createDecipheriv,
  createHash,
  randomBytes
} from "node:crypto";
import * as fs4 from "node:fs";
import * as path4 from "node:path";
function keyFile(projectDir) {
  return path4.join(getMiyaRuntimeDir(projectDir), "security", "master.key");
}
function ensureDir2(file2) {
  fs4.mkdirSync(path4.dirname(file2), { recursive: true });
}
function toBase64(text) {
  return Buffer.from(text, "utf-8").toString("base64");
}
function fromBase64(base643) {
  return Buffer.from(base643, "base64").toString("utf-8");
}
function hasPowerShell() {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const result = spawnSync(shell, [
    "-NoProfile",
    "-NonInteractive",
    "-Command",
    "$PSVersionTable.PSVersion.ToString()"
  ], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 1500
  });
  return result.status === 0;
}
function encryptWithDpapi(plainText) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const script = [
    `$plain = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('${toBase64(plainText)}'))`,
    "$secure = ConvertTo-SecureString -String $plain -AsPlainText -Force",
    "ConvertFrom-SecureString -SecureString $secure"
  ].join("; ");
  const result = spawnSync(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2000
  });
  if (result.status !== 0)
    return null;
  const out = result.stdout.trim();
  return out.length > 0 ? out : null;
}
function decryptWithDpapi(blob) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const escaped = blob.replace(/'/g, "''");
  const script = [
    `$secure = ConvertTo-SecureString '${escaped}'`,
    "$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secure)",
    "$plain = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)",
    "[Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)",
    "[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($plain))"
  ].join("; ");
  const result = spawnSync(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2000
  });
  if (result.status !== 0)
    return null;
  const out = result.stdout.trim();
  if (!out)
    return null;
  try {
    return fromBase64(out);
  } catch {
    return null;
  }
}
function deriveFallbackKey(projectDir) {
  const file2 = keyFile(projectDir);
  if (fs4.existsSync(file2)) {
    return fs4.readFileSync(file2);
  }
  const entropy = randomBytes(32);
  ensureDir2(file2);
  fs4.writeFileSync(file2, entropy);
  return entropy;
}
function encryptFallback(projectDir, plainText) {
  const key = deriveFallbackKey(projectDir);
  const iv = randomBytes(12);
  const cipher = createCipheriv("aes-256-gcm", createHash("sha256").update(key).digest(), iv);
  const payload = Buffer.concat([
    cipher.update(plainText, "utf-8"),
    cipher.final()
  ]);
  return {
    version: 1,
    alg: "aes256gcm",
    payload: payload.toString("base64"),
    iv: iv.toString("base64"),
    tag: cipher.getAuthTag().toString("base64")
  };
}
function decryptFallback(projectDir, envelope) {
  if (!envelope.iv || !envelope.tag)
    return null;
  try {
    const key = deriveFallbackKey(projectDir);
    const decipher = createDecipheriv("aes-256-gcm", createHash("sha256").update(key).digest(), Buffer.from(envelope.iv, "base64"));
    decipher.setAuthTag(Buffer.from(envelope.tag, "base64"));
    const plain = Buffer.concat([
      decipher.update(Buffer.from(envelope.payload, "base64")),
      decipher.final()
    ]);
    return plain.toString("utf-8");
  } catch {
    return null;
  }
}
function encodeEnvelope(envelope) {
  return `miya-sec:${Buffer.from(JSON.stringify(envelope), "utf-8").toString("base64")}`;
}
function decodeEnvelope(raw) {
  if (!raw.startsWith("miya-sec:"))
    return null;
  const body = raw.slice("miya-sec:".length);
  try {
    const parsed = JSON.parse(Buffer.from(body, "base64").toString("utf-8"));
    if (!parsed || parsed.version !== 1)
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function encryptSensitiveValue(projectDir, plainText) {
  const normalized = String(plainText ?? "");
  if (!normalized)
    return normalized;
  if (process.platform === "win32" && hasPowerShell()) {
    const dpapi = encryptWithDpapi(normalized);
    if (dpapi) {
      return encodeEnvelope({
        version: 1,
        alg: "dpapi",
        payload: dpapi
      });
    }
  }
  return encodeEnvelope(encryptFallback(projectDir, normalized));
}
function decryptSensitiveValue(projectDir, rawValue) {
  const raw = String(rawValue ?? "");
  if (!raw.startsWith("miya-sec:"))
    return raw;
  const envelope = decodeEnvelope(raw);
  if (!envelope)
    return raw;
  if (envelope.alg === "dpapi") {
    const decoded = decryptWithDpapi(envelope.payload);
    return decoded ?? raw;
  }
  const fallback = decryptFallback(projectDir, envelope);
  return fallback ?? raw;
}

// src/safety/state-machine.ts
import * as fs6 from "node:fs";
import * as path6 from "node:path";

// src/policy/index.ts
import { createHash as createHash2 } from "node:crypto";
import * as fs5 from "node:fs";
import * as path5 from "node:path";
var POLICY_DOMAINS = [
  "outbound_send",
  "desktop_control",
  "shell_exec",
  "fs_write",
  "memory_read",
  "memory_write",
  "memory_delete",
  "training",
  "media_generate",
  "read_only_research",
  "local_build"
];
function nowIso() {
  return new Date().toISOString();
}
function policyFile(projectDir) {
  return path5.join(getMiyaRuntimeDir(projectDir), "policy.json");
}
function defaultPolicy() {
  return {
    version: 1,
    updatedAt: nowIso(),
    domains: {
      outbound_send: "running",
      desktop_control: "running",
      shell_exec: "running",
      fs_write: "running",
      memory_read: "running",
      memory_write: "running",
      memory_delete: "running",
      training: "running",
      media_generate: "running",
      read_only_research: "running",
      local_build: "running"
    },
    outbound: {
      allowedChannels: ["qq", "wechat"],
      requireArchAdvisorApproval: true,
      requireAllowlist: true,
      minIntervalMs: 4000,
      burstWindowMs: 60000,
      burstLimit: 3,
      duplicateWindowMs: 60000
    }
  };
}
function readPolicy(projectDir) {
  const file2 = policyFile(projectDir);
  if (!fs5.existsSync(file2)) {
    const base = defaultPolicy();
    fs5.mkdirSync(path5.dirname(file2), { recursive: true });
    fs5.writeFileSync(file2, `${JSON.stringify(base, null, 2)}
`, "utf-8");
    return base;
  }
  try {
    const parsed = JSON.parse(fs5.readFileSync(file2, "utf-8"));
    const base = defaultPolicy();
    const parsedDomains = parsed.domains && typeof parsed.domains === "object" ? parsed.domains : {};
    return {
      ...base,
      ...parsed,
      domains: {
        ...base.domains,
        ...parsedDomains
      },
      outbound: {
        ...base.outbound,
        ...parsed.outbound ?? {}
      }
    };
  } catch {
    return defaultPolicy();
  }
}
function writePolicy(projectDir, patch) {
  const file2 = policyFile(projectDir);
  const current = readPolicy(projectDir);
  const next = {
    ...current,
    ...patch,
    outbound: {
      ...current.outbound,
      ...patch.outbound ?? {}
    },
    updatedAt: nowIso()
  };
  fs5.mkdirSync(path5.dirname(file2), { recursive: true });
  fs5.writeFileSync(file2, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function hashPolicy(policy) {
  return createHash2("sha256").update(JSON.stringify({
    version: policy.version,
    domains: policy.domains,
    outbound: policy.outbound
  })).digest("hex");
}
function currentPolicyHash(projectDir) {
  return hashPolicy(readPolicy(projectDir));
}
function assertPolicyHash(projectDir, providedHash) {
  const hash2 = currentPolicyHash(projectDir);
  if (!providedHash) {
    return { ok: false, hash: hash2, reason: "missing_policy_hash" };
  }
  if (providedHash !== hash2) {
    return { ok: false, hash: hash2, reason: "policy_hash_mismatch" };
  }
  return { ok: true, hash: hash2 };
}
function isDomainRunning(projectDir, domain2) {
  const policy = readPolicy(projectDir);
  return policy.domains[domain2] === "running";
}
function isPolicyDomain(value) {
  return typeof value === "string" && POLICY_DOMAINS.includes(value);
}

// src/safety/state-machine.ts
function nowIso2() {
  return new Date().toISOString();
}
function stateFile(projectDir) {
  return path6.join(getMiyaRuntimeDir(projectDir), "safety-state.json");
}
function auditFile(projectDir) {
  return path6.join(getMiyaRuntimeDir(projectDir), "safety-state-audit.jsonl");
}
function ensureDir3(filePath) {
  fs6.mkdirSync(path6.dirname(filePath), { recursive: true });
}
function defaultState() {
  return {
    version: 1,
    updatedAt: nowIso2(),
    globalState: "running",
    domains: Object.fromEntries(POLICY_DOMAINS.map((domain2) => [domain2, "running"]))
  };
}
function writeState(projectDir, state) {
  const file2 = stateFile(projectDir);
  const next = {
    ...state,
    updatedAt: nowIso2()
  };
  ensureDir3(file2);
  fs6.writeFileSync(file2, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function readSafetyState(projectDir) {
  const file2 = stateFile(projectDir);
  if (!fs6.existsSync(file2)) {
    const created = defaultState();
    return writeState(projectDir, created);
  }
  try {
    const parsed = JSON.parse(fs6.readFileSync(file2, "utf-8"));
    const base = defaultState();
    const domains = {
      ...base.domains,
      ...parsed.domains ?? {}
    };
    return {
      ...base,
      ...parsed,
      domains
    };
  } catch {
    return defaultState();
  }
}
function appendAudit(projectDir, row) {
  const file2 = auditFile(projectDir);
  ensureDir3(file2);
  fs6.appendFileSync(file2, `${JSON.stringify(row)}
`, "utf-8");
}
function syncPolicyDomain(projectDir, domain2, state) {
  const policy = readPolicy(projectDir);
  const mapped = state === "running" ? "running" : "paused";
  if (policy.domains[domain2] === mapped)
    return;
  writePolicy(projectDir, {
    domains: {
      ...policy.domains,
      [domain2]: mapped
    }
  });
}
function transitionSafetyState(projectDir, input) {
  const current = readSafetyState(projectDir);
  const next = {
    ...current,
    globalState: input.globalState ?? current.globalState,
    reason: input.reason,
    traceID: input.traceID ?? current.traceID,
    domains: {
      ...current.domains,
      ...input.domains ?? {}
    }
  };
  const written = writeState(projectDir, next);
  for (const domain2 of POLICY_DOMAINS) {
    syncPolicyDomain(projectDir, domain2, written.domains[domain2]);
  }
  appendAudit(projectDir, {
    id: `safety_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    at: nowIso2(),
    source: input.source,
    reason: input.reason,
    traceID: input.traceID,
    policyHash: input.policyHash,
    globalState: written.globalState,
    domains: input.domains ?? {}
  });
  return written;
}
function isDomainExecutionAllowed(projectDir, domain2) {
  const state = readSafetyState(projectDir);
  if (state.globalState === "killed")
    return false;
  return state.domains[domain2] === "running";
}

// src/safety/tier.ts
var SAFETY_RANK = {
  LIGHT: 1,
  STANDARD: 2,
  THOROUGH: 3
};
function tierAtLeast(current, required2) {
  return SAFETY_RANK[current] >= SAFETY_RANK[required2];
}

// src/safety/store.ts
var TOKEN_TTL_MS = 120000;
var TOKEN_LIMIT_PER_SESSION = 200;
function runtimeFile2(projectDir, name) {
  return path7.join(getMiyaRuntimeDir(projectDir), name);
}
function ensureDir4(file2) {
  fs7.mkdirSync(path7.dirname(file2), { recursive: true });
}
function readJson(file2, fallback) {
  if (!fs7.existsSync(file2))
    return fallback;
  try {
    return JSON.parse(fs7.readFileSync(file2, "utf-8"));
  } catch {
    return fallback;
  }
}
function writeJson2(file2, value) {
  ensureDir4(file2);
  fs7.writeFileSync(file2, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function nowIso3() {
  return new Date().toISOString();
}
function syncGatewayStatus(projectDir, status) {
  const file2 = runtimeFile2(projectDir, "gateway.json");
  if (!fs7.existsSync(file2))
    return;
  const current = readJson(file2, {});
  if (!current || typeof current !== "object")
    return;
  writeJson2(file2, { ...current, status });
}
function listRecentSelfApprovalRecords(projectDir, limit = 10) {
  const file2 = runtimeFile2(projectDir, "self-approval.json");
  const current = readJson(file2, { records: [] });
  return current.records.slice(0, Math.max(1, limit));
}
function readTokenStore(projectDir) {
  const file2 = runtimeFile2(projectDir, "approval-tokens.json");
  const store = readJson(file2, { tokens: {} });
  const decoded = { tokens: {} };
  for (const [sessionID, tokens] of Object.entries(store.tokens ?? {})) {
    const plainSession = decryptSensitiveValue(projectDir, sessionID);
    decoded.tokens[plainSession] = {};
    for (const [hash2, token] of Object.entries(tokens ?? {})) {
      const plainHash = decryptSensitiveValue(projectDir, hash2);
      decoded.tokens[plainSession][plainHash] = {
        ...token,
        request_hash: decryptSensitiveValue(projectDir, token.request_hash),
        action: decryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  return decoded;
}
function writeTokenStore(projectDir, store) {
  const file2 = runtimeFile2(projectDir, "approval-tokens.json");
  const encoded = { tokens: {} };
  for (const [sessionID, tokens] of Object.entries(store.tokens ?? {})) {
    const safeSession = encryptSensitiveValue(projectDir, sessionID);
    encoded.tokens[safeSession] = {};
    for (const [hash2, token] of Object.entries(tokens ?? {})) {
      const safeHash = encryptSensitiveValue(projectDir, hash2);
      encoded.tokens[safeSession][safeHash] = {
        ...token,
        request_hash: encryptSensitiveValue(projectDir, token.request_hash),
        action: encryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  writeJson2(file2, encoded);
}
function saveApprovalToken(projectDir, sessionID, token, ttlMs = TOKEN_TTL_MS) {
  const store = readTokenStore(projectDir);
  const created = new Date;
  const expires = new Date(created.getTime() + ttlMs);
  const next = {
    ...token,
    created_at: created.toISOString(),
    expires_at: expires.toISOString()
  };
  const sessionTokens = store.tokens[sessionID] ?? {};
  sessionTokens[token.request_hash] = next;
  const normalized = Object.values(sessionTokens).sort((a, b) => Date.parse(b.created_at) - Date.parse(a.created_at)).slice(0, TOKEN_LIMIT_PER_SESSION);
  store.tokens[sessionID] = Object.fromEntries(normalized.map((entry2) => [entry2.request_hash, entry2]));
  writeTokenStore(projectDir, store);
  return next;
}
function findApprovalToken(projectDir, sessionID, requestHashes, requiredTier) {
  const store = readTokenStore(projectDir);
  const sessionTokens = store.tokens[sessionID] ?? {};
  const now = Date.now();
  for (const hash2 of requestHashes) {
    const token = sessionTokens[hash2];
    if (!token)
      continue;
    const expiresAt = Date.parse(token.expires_at);
    if (!Number.isFinite(expiresAt) || expiresAt < now)
      continue;
    if (!tierAtLeast(token.tier, requiredTier))
      continue;
    return token;
  }
  return null;
}
function readKillSwitch(projectDir) {
  return readJson(runtimeFile2(projectDir, "kill-switch.json"), {
    active: false
  });
}
function activateKillSwitch(projectDir, reason, traceID) {
  const next = {
    active: true,
    reason,
    trace_id: traceID,
    activated_at: nowIso3()
  };
  writeJson2(runtimeFile2(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_activate",
    reason,
    traceID,
    globalState: "killed",
    domains: {}
  });
  syncGatewayStatus(projectDir, "killswitch");
  return next;
}
function releaseKillSwitch(projectDir) {
  const next = { active: false };
  writeJson2(runtimeFile2(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_release",
    reason: "manual_release",
    globalState: "running",
    domains: {}
  });
  syncGatewayStatus(projectDir, "running");
  return next;
}

// src/settings/tools.ts
var z = tool.schema;
// src/utils/safe-interval.ts
function safeInterval(taskName, intervalMs, run, options) {
  const maxConsecutiveErrors = Math.max(1, Math.floor(options?.maxConsecutiveErrors ?? 3));
  const cooldownMs = Math.max(1000, Math.floor(options?.cooldownMs ?? 30000));
  let running = false;
  let consecutiveErrors = 0;
  let cooldownUntilMs = 0;
  return setInterval(() => {
    if (running)
      return;
    if (Date.now() < cooldownUntilMs)
      return;
    running = true;
    Promise.resolve(run()).then(() => {
      consecutiveErrors = 0;
    }).catch((error45) => {
      consecutiveErrors += 1;
      if (consecutiveErrors >= maxConsecutiveErrors) {
        cooldownUntilMs = Date.now() + cooldownMs;
        consecutiveErrors = 0;
      }
      options?.onError?.({
        taskName,
        error: error45,
        consecutiveErrors: Math.max(1, consecutiveErrors),
        cooldownUntilMs: cooldownUntilMs > Date.now() ? cooldownUntilMs : undefined
      });
    }).finally(() => {
      running = false;
    });
  }, Math.max(10, Math.floor(intervalMs)));
}

// node_modules/zod/v4/classic/external.js
var exports_external2 = {};
__export(exports_external2, {
  xor: () => xor,
  xid: () => xid4,
  void: () => _void4,
  uuidv7: () => uuidv72,
  uuidv6: () => uuidv62,
  uuidv4: () => uuidv42,
  uuid: () => uuid5,
  util: () => exports_util2,
  url: () => url2,
  uppercase: () => _uppercase2,
  unknown: () => unknown2,
  union: () => union2,
  undefined: () => _undefined6,
  ulid: () => ulid4,
  uint64: () => uint642,
  uint32: () => uint322,
  tuple: () => tuple2,
  trim: () => _trim2,
  treeifyError: () => treeifyError2,
  transform: () => transform2,
  toUpperCase: () => _toUpperCase2,
  toLowerCase: () => _toLowerCase2,
  toJSONSchema: () => toJSONSchema2,
  templateLiteral: () => templateLiteral2,
  symbol: () => symbol2,
  superRefine: () => superRefine2,
  success: () => success2,
  stringbool: () => stringbool2,
  stringFormat: () => stringFormat2,
  string: () => string5,
  strictObject: () => strictObject2,
  startsWith: () => _startsWith2,
  slugify: () => _slugify,
  size: () => _size2,
  setErrorMap: () => setErrorMap2,
  set: () => set2,
  safeParseAsync: () => safeParseAsync4,
  safeParse: () => safeParse4,
  safeEncodeAsync: () => safeEncodeAsync4,
  safeEncode: () => safeEncode4,
  safeDecodeAsync: () => safeDecodeAsync4,
  safeDecode: () => safeDecode4,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  regex: () => _regex2,
  refine: () => refine2,
  record: () => record2,
  readonly: () => readonly2,
  property: () => _property2,
  promise: () => promise2,
  prettifyError: () => prettifyError2,
  preprocess: () => preprocess2,
  prefault: () => prefault2,
  positive: () => _positive2,
  pipe: () => pipe2,
  partialRecord: () => partialRecord2,
  parseAsync: () => parseAsync4,
  parse: () => parse7,
  overwrite: () => _overwrite2,
  optional: () => optional2,
  object: () => object2,
  number: () => number5,
  nullish: () => nullish4,
  nullable: () => nullable2,
  null: () => _null6,
  normalize: () => _normalize2,
  nonpositive: () => _nonpositive2,
  nonoptional: () => nonoptional2,
  nonnegative: () => _nonnegative2,
  never: () => never2,
  negative: () => _negative2,
  nativeEnum: () => nativeEnum2,
  nanoid: () => nanoid4,
  nan: () => nan2,
  multipleOf: () => _multipleOf2,
  minSize: () => _minSize2,
  minLength: () => _minLength2,
  mime: () => _mime2,
  meta: () => meta2,
  maxSize: () => _maxSize2,
  maxLength: () => _maxLength2,
  map: () => map2,
  mac: () => mac2,
  lte: () => _lte2,
  lt: () => _lt2,
  lowercase: () => _lowercase2,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject2,
  locales: () => exports_locales2,
  literal: () => literal2,
  length: () => _length2,
  lazy: () => lazy2,
  ksuid: () => ksuid4,
  keyof: () => keyof2,
  jwt: () => jwt2,
  json: () => json2,
  iso: () => exports_iso2,
  ipv6: () => ipv64,
  ipv4: () => ipv44,
  intersection: () => intersection2,
  int64: () => int642,
  int32: () => int322,
  int: () => int2,
  instanceof: () => _instanceof2,
  includes: () => _includes2,
  httpUrl: () => httpUrl2,
  hostname: () => hostname4,
  hex: () => hex4,
  hash: () => hash2,
  guid: () => guid4,
  gte: () => _gte2,
  gt: () => _gt2,
  globalRegistry: () => globalRegistry2,
  getErrorMap: () => getErrorMap2,
  function: () => _function2,
  fromJSONSchema: () => fromJSONSchema,
  formatError: () => formatError2,
  float64: () => float642,
  float32: () => float322,
  flattenError: () => flattenError2,
  file: () => file2,
  exactOptional: () => exactOptional,
  enum: () => _enum4,
  endsWith: () => _endsWith2,
  encodeAsync: () => encodeAsync4,
  encode: () => encode4,
  emoji: () => emoji4,
  email: () => email4,
  e164: () => e1644,
  discriminatedUnion: () => discriminatedUnion2,
  describe: () => describe2,
  decodeAsync: () => decodeAsync4,
  decode: () => decode4,
  date: () => date7,
  custom: () => custom2,
  cuid2: () => cuid24,
  cuid: () => cuid6,
  core: () => exports_core4,
  config: () => config2,
  coerce: () => exports_coerce2,
  codec: () => codec2,
  clone: () => clone2,
  cidrv6: () => cidrv64,
  cidrv4: () => cidrv44,
  check: () => check2,
  catch: () => _catch4,
  boolean: () => boolean5,
  bigint: () => bigint5,
  base64url: () => base64url4,
  base64: () => base644,
  array: () => array2,
  any: () => any2,
  _function: () => _function2,
  _default: () => _default4,
  _ZodString: () => _ZodString2,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID2,
  ZodVoid: () => ZodVoid2,
  ZodUnknown: () => ZodUnknown2,
  ZodUnion: () => ZodUnion2,
  ZodUndefined: () => ZodUndefined2,
  ZodUUID: () => ZodUUID2,
  ZodURL: () => ZodURL2,
  ZodULID: () => ZodULID2,
  ZodType: () => ZodType2,
  ZodTuple: () => ZodTuple2,
  ZodTransform: () => ZodTransform2,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodSymbol: () => ZodSymbol2,
  ZodSuccess: () => ZodSuccess2,
  ZodStringFormat: () => ZodStringFormat2,
  ZodString: () => ZodString2,
  ZodSet: () => ZodSet2,
  ZodRecord: () => ZodRecord2,
  ZodRealError: () => ZodRealError2,
  ZodReadonly: () => ZodReadonly2,
  ZodPromise: () => ZodPromise2,
  ZodPrefault: () => ZodPrefault2,
  ZodPipe: () => ZodPipe2,
  ZodOptional: () => ZodOptional2,
  ZodObject: () => ZodObject2,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodNumber: () => ZodNumber2,
  ZodNullable: () => ZodNullable2,
  ZodNull: () => ZodNull2,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNever: () => ZodNever2,
  ZodNanoID: () => ZodNanoID2,
  ZodNaN: () => ZodNaN2,
  ZodMap: () => ZodMap2,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral2,
  ZodLazy: () => ZodLazy2,
  ZodKSUID: () => ZodKSUID2,
  ZodJWT: () => ZodJWT2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodIntersection: () => ZodIntersection2,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2,
  ZodIPv6: () => ZodIPv62,
  ZodIPv4: () => ZodIPv42,
  ZodGUID: () => ZodGUID2,
  ZodFunction: () => ZodFunction2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFile: () => ZodFile2,
  ZodExactOptional: () => ZodExactOptional,
  ZodError: () => ZodError2,
  ZodEnum: () => ZodEnum2,
  ZodEmoji: () => ZodEmoji2,
  ZodEmail: () => ZodEmail2,
  ZodE164: () => ZodE1642,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodDefault: () => ZodDefault2,
  ZodDate: () => ZodDate2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodCustom: () => ZodCustom2,
  ZodCodec: () => ZodCodec2,
  ZodCatch: () => ZodCatch2,
  ZodCUID2: () => ZodCUID22,
  ZodCUID: () => ZodCUID3,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodBoolean: () => ZodBoolean2,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBigInt: () => ZodBigInt2,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBase64: () => ZodBase642,
  ZodArray: () => ZodArray2,
  ZodAny: () => ZodAny2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  $output: () => $output2,
  $input: () => $input2,
  $brand: () => $brand2
});

// node_modules/zod/v4/core/index.js
var exports_core4 = {};
__export(exports_core4, {
  version: () => version2,
  util: () => exports_util2,
  treeifyError: () => treeifyError2,
  toJSONSchema: () => toJSONSchema2,
  toDotPath: () => toDotPath2,
  safeParseAsync: () => safeParseAsync3,
  safeParse: () => safeParse3,
  safeEncodeAsync: () => safeEncodeAsync3,
  safeEncode: () => safeEncode3,
  safeDecodeAsync: () => safeDecodeAsync3,
  safeDecode: () => safeDecode3,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  process: () => process2,
  prettifyError: () => prettifyError2,
  parseAsync: () => parseAsync3,
  parse: () => parse5,
  meta: () => meta,
  locales: () => exports_locales2,
  isValidJWT: () => isValidJWT2,
  isValidBase64URL: () => isValidBase64URL2,
  isValidBase64: () => isValidBase642,
  initializeContext: () => initializeContext,
  globalRegistry: () => globalRegistry2,
  globalConfig: () => globalConfig2,
  formatError: () => formatError2,
  flattenError: () => flattenError2,
  finalize: () => finalize,
  extractDefs: () => extractDefs,
  encodeAsync: () => encodeAsync3,
  encode: () => encode3,
  describe: () => describe,
  decodeAsync: () => decodeAsync3,
  decode: () => decode3,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  config: () => config2,
  clone: () => clone2,
  _xor: () => _xor,
  _xid: () => _xid2,
  _void: () => _void3,
  _uuidv7: () => _uuidv72,
  _uuidv6: () => _uuidv62,
  _uuidv4: () => _uuidv42,
  _uuid: () => _uuid2,
  _url: () => _url2,
  _uppercase: () => _uppercase2,
  _unknown: () => _unknown2,
  _union: () => _union2,
  _undefined: () => _undefined5,
  _ulid: () => _ulid2,
  _uint64: () => _uint642,
  _uint32: () => _uint322,
  _tuple: () => _tuple2,
  _trim: () => _trim2,
  _transform: () => _transform2,
  _toUpperCase: () => _toUpperCase2,
  _toLowerCase: () => _toLowerCase2,
  _templateLiteral: () => _templateLiteral2,
  _symbol: () => _symbol2,
  _superRefine: () => _superRefine2,
  _success: () => _success2,
  _stringbool: () => _stringbool2,
  _stringFormat: () => _stringFormat2,
  _string: () => _string2,
  _startsWith: () => _startsWith2,
  _slugify: () => _slugify,
  _size: () => _size2,
  _set: () => _set2,
  _safeParseAsync: () => _safeParseAsync2,
  _safeParse: () => _safeParse2,
  _safeEncodeAsync: () => _safeEncodeAsync2,
  _safeEncode: () => _safeEncode2,
  _safeDecodeAsync: () => _safeDecodeAsync2,
  _safeDecode: () => _safeDecode2,
  _regex: () => _regex2,
  _refine: () => _refine2,
  _record: () => _record2,
  _readonly: () => _readonly2,
  _property: () => _property2,
  _promise: () => _promise2,
  _positive: () => _positive2,
  _pipe: () => _pipe2,
  _parseAsync: () => _parseAsync2,
  _parse: () => _parse2,
  _overwrite: () => _overwrite2,
  _optional: () => _optional2,
  _number: () => _number2,
  _nullable: () => _nullable2,
  _null: () => _null5,
  _normalize: () => _normalize2,
  _nonpositive: () => _nonpositive2,
  _nonoptional: () => _nonoptional2,
  _nonnegative: () => _nonnegative2,
  _never: () => _never2,
  _negative: () => _negative2,
  _nativeEnum: () => _nativeEnum2,
  _nanoid: () => _nanoid2,
  _nan: () => _nan2,
  _multipleOf: () => _multipleOf2,
  _minSize: () => _minSize2,
  _minLength: () => _minLength2,
  _min: () => _gte2,
  _mime: () => _mime2,
  _maxSize: () => _maxSize2,
  _maxLength: () => _maxLength2,
  _max: () => _lte2,
  _map: () => _map2,
  _mac: () => _mac,
  _lte: () => _lte2,
  _lt: () => _lt2,
  _lowercase: () => _lowercase2,
  _literal: () => _literal2,
  _length: () => _length2,
  _lazy: () => _lazy2,
  _ksuid: () => _ksuid2,
  _jwt: () => _jwt2,
  _isoTime: () => _isoTime2,
  _isoDuration: () => _isoDuration2,
  _isoDateTime: () => _isoDateTime2,
  _isoDate: () => _isoDate2,
  _ipv6: () => _ipv62,
  _ipv4: () => _ipv42,
  _intersection: () => _intersection2,
  _int64: () => _int642,
  _int32: () => _int322,
  _int: () => _int2,
  _includes: () => _includes2,
  _guid: () => _guid2,
  _gte: () => _gte2,
  _gt: () => _gt2,
  _float64: () => _float642,
  _float32: () => _float322,
  _file: () => _file2,
  _enum: () => _enum3,
  _endsWith: () => _endsWith2,
  _encodeAsync: () => _encodeAsync2,
  _encode: () => _encode2,
  _emoji: () => _emoji4,
  _email: () => _email2,
  _e164: () => _e1642,
  _discriminatedUnion: () => _discriminatedUnion2,
  _default: () => _default3,
  _decodeAsync: () => _decodeAsync2,
  _decode: () => _decode2,
  _date: () => _date2,
  _custom: () => _custom2,
  _cuid2: () => _cuid22,
  _cuid: () => _cuid3,
  _coercedString: () => _coercedString2,
  _coercedNumber: () => _coercedNumber2,
  _coercedDate: () => _coercedDate2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedBigint: () => _coercedBigint2,
  _cidrv6: () => _cidrv62,
  _cidrv4: () => _cidrv42,
  _check: () => _check2,
  _catch: () => _catch3,
  _boolean: () => _boolean2,
  _bigint: () => _bigint2,
  _base64url: () => _base64url2,
  _base64: () => _base642,
  _array: () => _array2,
  _any: () => _any2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  JSONSchema: () => exports_json_schema2,
  Doc: () => Doc2,
  $output: () => $output2,
  $input: () => $input2,
  $constructor: () => $constructor2,
  $brand: () => $brand2,
  $ZodXor: () => $ZodXor,
  $ZodXID: () => $ZodXID2,
  $ZodVoid: () => $ZodVoid2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUUID: () => $ZodUUID2,
  $ZodURL: () => $ZodURL2,
  $ZodULID: () => $ZodULID2,
  $ZodType: () => $ZodType2,
  $ZodTuple: () => $ZodTuple2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodString: () => $ZodString2,
  $ZodSet: () => $ZodSet2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRealError: () => $ZodRealError2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodPromise: () => $ZodPromise2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPipe: () => $ZodPipe2,
  $ZodOptional: () => $ZodOptional2,
  $ZodObjectJIT: () => $ZodObjectJIT2,
  $ZodObject: () => $ZodObject2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNull: () => $ZodNull2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNever: () => $ZodNever2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNaN: () => $ZodNaN2,
  $ZodMap: () => $ZodMap2,
  $ZodMAC: () => $ZodMAC,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodLazy: () => $ZodLazy2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodJWT: () => $ZodJWT2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODate: () => $ZodISODate2,
  $ZodIPv6: () => $ZodIPv62,
  $ZodIPv4: () => $ZodIPv42,
  $ZodGUID: () => $ZodGUID2,
  $ZodFunction: () => $ZodFunction2,
  $ZodFile: () => $ZodFile2,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodError: () => $ZodError2,
  $ZodEnum: () => $ZodEnum2,
  $ZodEncodeError: () => $ZodEncodeError2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEmail: () => $ZodEmail2,
  $ZodE164: () => $ZodE1642,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDate: () => $ZodDate2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodCustom: () => $ZodCustom2,
  $ZodCodec: () => $ZodCodec2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCatch: () => $ZodCatch2,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCUID: () => $ZodCUID3,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBase64: () => $ZodBase642,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodArray: () => $ZodArray2,
  $ZodAny: () => $ZodAny2
});

// node_modules/zod/v4/core/core.js
var NEVER2 = Object.freeze({
  status: "aborted"
});
function $constructor2(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: new Set
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0;i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand2 = Symbol("zod_brand");

class $ZodAsyncError2 extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError2 extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig2 = {};
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
// node_modules/zod/v4/core/util.js
var exports_util2 = {};
__export(exports_util2, {
  unwrapMessage: () => unwrapMessage2,
  uint8ArrayToHex: () => uint8ArrayToHex2,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url2,
  uint8ArrayToBase64: () => uint8ArrayToBase642,
  stringifyPrimitive: () => stringifyPrimitive2,
  slugify: () => slugify,
  shallowClone: () => shallowClone2,
  safeExtend: () => safeExtend2,
  required: () => required2,
  randomString: () => randomString2,
  propertyKeyTypes: () => propertyKeyTypes2,
  promiseAllObject: () => promiseAllObject2,
  primitiveTypes: () => primitiveTypes2,
  prefixIssues: () => prefixIssues2,
  pick: () => pick2,
  partial: () => partial2,
  parsedType: () => parsedType7,
  optionalKeys: () => optionalKeys2,
  omit: () => omit2,
  objectClone: () => objectClone2,
  numKeys: () => numKeys2,
  nullish: () => nullish3,
  normalizeParams: () => normalizeParams2,
  mergeDefs: () => mergeDefs2,
  merge: () => merge2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  joinValues: () => joinValues2,
  issue: () => issue2,
  isPlainObject: () => isPlainObject2,
  isObject: () => isObject2,
  hexToUint8Array: () => hexToUint8Array2,
  getSizableOrigin: () => getSizableOrigin2,
  getParsedType: () => getParsedType2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getEnumValues: () => getEnumValues2,
  getElementAtPath: () => getElementAtPath2,
  floatSafeRemainder: () => floatSafeRemainder2,
  finalizeIssue: () => finalizeIssue2,
  extend: () => extend2,
  escapeRegex: () => escapeRegex2,
  esc: () => esc2,
  defineLazy: () => defineLazy2,
  createTransparentProxy: () => createTransparentProxy2,
  cloneDef: () => cloneDef2,
  clone: () => clone2,
  cleanRegex: () => cleanRegex2,
  cleanEnum: () => cleanEnum2,
  captureStackTrace: () => captureStackTrace2,
  cached: () => cached2,
  base64urlToUint8Array: () => base64urlToUint8Array2,
  base64ToUint8Array: () => base64ToUint8Array2,
  assignProp: () => assignProp2,
  assertNotEqual: () => assertNotEqual2,
  assertNever: () => assertNever2,
  assertIs: () => assertIs2,
  assertEqual: () => assertEqual2,
  assert: () => assert2,
  allowsEval: () => allowsEval2,
  aborted: () => aborted2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  Class: () => Class2,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {}
function assertNever2(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert2(_) {}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === undefined;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING2 = Symbol("evaluating");
function defineLazy2(object2, key, getter) {
  let value = undefined;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING2) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING2;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone2(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs2(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef2(schema) {
  return mergeDefs2(schema._zod.def);
}
function getElementAtPath2(obj, path8) {
  if (!path8)
    return obj;
  return path8.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc2(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace2 = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval2 = cached2(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject2(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone2(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes2 = new Set(["string", "number", "symbol"]);
var primitiveTypes2 = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES2 = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick2(schema, mask) {
  const currDef = schema._zod.def;
  const checks3 = currDef.checks;
  const hasChecks = checks3 && checks3.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function omit2(schema, mask) {
  const currDef = schema._zod.def;
  const checks3 = currDef.checks;
  const hasChecks = checks3 && checks3.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks3 = schema._zod.def.checks;
  const hasChecks = checks3 && checks3.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    }
  });
  return clone2(schema, def);
}
function safeExtend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    }
  });
  return clone2(schema, def);
}
function merge2(a, b) {
  const def = mergeDefs2(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone2(a, def);
}
function partial2(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks3 = currDef.checks;
  const hasChecks = checks3 && checks3.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function required2(Class2, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    }
  });
  return clone2(schema, def);
}
function aborted2(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues2(path8, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path8);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config3.customError?.(iss)) ?? unwrapMessage2(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType7(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array2(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase642(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array2(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array2(base643 + padding);
}
function uint8ArrayToBase64url2(bytes) {
  return uint8ArrayToBase642(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array2(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex2(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class2 {
  constructor(..._args) {}
}

// node_modules/zod/v4/core/errors.js
var initializer3 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError2 = $constructor2("$ZodError", initializer3);
var $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
function flattenError2(error45, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error45.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error45, mapper = (issue3) => issue3.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error46) => {
    for (const issue3 of error46.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error45);
  return fieldErrors;
}
function treeifyError2(error45, mapper = (issue3) => issue3.message) {
  const result = { errors: [] };
  const processError = (error46, path8 = []) => {
    var _a, _b;
    for (const issue3 of error46.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path8, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error45);
  return result;
}
function toDotPath2(_path) {
  const segs = [];
  const path8 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path8) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error45) {
  const lines = [];
  const issues = [...error45.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(` ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`   at ${toDotPath2(issue3.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse2 = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse5 = /* @__PURE__ */ _parse2($ZodRealError2);
var _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync3 = /* @__PURE__ */ _parseAsync2($ZodRealError2);
var _safeParse2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
var _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
var _encode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse2(_Err)(schema, value, ctx);
};
var encode3 = /* @__PURE__ */ _encode2($ZodRealError2);
var _decode2 = (_Err) => (schema, value, _ctx) => {
  return _parse2(_Err)(schema, value, _ctx);
};
var decode3 = /* @__PURE__ */ _decode2($ZodRealError2);
var _encodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync2(_Err)(schema, value, ctx);
};
var encodeAsync3 = /* @__PURE__ */ _encodeAsync2($ZodRealError2);
var _decodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync2(_Err)(schema, value, _ctx);
};
var decodeAsync3 = /* @__PURE__ */ _decodeAsync2($ZodRealError2);
var _safeEncode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse2(_Err)(schema, value, ctx);
};
var safeEncode3 = /* @__PURE__ */ _safeEncode2($ZodRealError2);
var _safeDecode2 = (_Err) => (schema, value, _ctx) => {
  return _safeParse2(_Err)(schema, value, _ctx);
};
var safeDecode3 = /* @__PURE__ */ _safeDecode2($ZodRealError2);
var _safeEncodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync2(_Err)(schema, value, ctx);
};
var safeEncodeAsync3 = /* @__PURE__ */ _safeEncodeAsync2($ZodRealError2);
var _safeDecodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync2(_Err)(schema, value, _ctx);
};
var safeDecodeAsync3 = /* @__PURE__ */ _safeDecodeAsync2($ZodRealError2);
// node_modules/zod/v4/core/regexes.js
var exports_regexes2 = {};
__export(exports_regexes2, {
  xid: () => xid3,
  uuid7: () => uuid72,
  uuid6: () => uuid62,
  uuid4: () => uuid42,
  uuid: () => uuid3,
  uppercase: () => uppercase2,
  unicodeEmail: () => unicodeEmail2,
  undefined: () => _undefined4,
  ulid: () => ulid3,
  time: () => time3,
  string: () => string4,
  sha512_hex: () => sha512_hex2,
  sha512_base64url: () => sha512_base64url2,
  sha512_base64: () => sha512_base642,
  sha384_hex: () => sha384_hex2,
  sha384_base64url: () => sha384_base64url2,
  sha384_base64: () => sha384_base642,
  sha256_hex: () => sha256_hex2,
  sha256_base64url: () => sha256_base64url2,
  sha256_base64: () => sha256_base642,
  sha1_hex: () => sha1_hex2,
  sha1_base64url: () => sha1_base64url2,
  sha1_base64: () => sha1_base642,
  rfc5322Email: () => rfc5322Email2,
  number: () => number4,
  null: () => _null4,
  nanoid: () => nanoid3,
  md5_hex: () => md5_hex2,
  md5_base64url: () => md5_base64url2,
  md5_base64: () => md5_base642,
  mac: () => mac,
  lowercase: () => lowercase2,
  ksuid: () => ksuid3,
  ipv6: () => ipv63,
  ipv4: () => ipv43,
  integer: () => integer2,
  idnEmail: () => idnEmail2,
  html5Email: () => html5Email2,
  hostname: () => hostname3,
  hex: () => hex3,
  guid: () => guid3,
  extendedDuration: () => extendedDuration2,
  emoji: () => emoji3,
  email: () => email3,
  e164: () => e1643,
  duration: () => duration3,
  domain: () => domain2,
  datetime: () => datetime3,
  date: () => date5,
  cuid2: () => cuid23,
  cuid: () => cuid5,
  cidrv6: () => cidrv63,
  cidrv4: () => cidrv43,
  browserEmail: () => browserEmail2,
  boolean: () => boolean4,
  bigint: () => bigint4,
  base64url: () => base64url3,
  base64: () => base643
});
var cuid5 = /^[cC][^\s-]{8,}$/;
var cuid23 = /^[0-9a-z]+$/;
var ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid3 = /^[0-9a-vA-V]{20}$/;
var ksuid3 = /^[A-Za-z0-9]{27}$/;
var nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
var duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid3 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid42 = /* @__PURE__ */ uuid3(4);
var uuid62 = /* @__PURE__ */ uuid3(6);
var uuid72 = /* @__PURE__ */ uuid3(7);
var email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail2 = unicodeEmail2;
var browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji3() {
  return new RegExp(_emoji3, "u");
}
var ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter2) => {
  const escapedDelim = escapeRegex2(delimiter2 ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url3 = /^[A-Za-z0-9_-]*$/;
var hostname3 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e1643 = /^\+[1-9]\d{6,14}$/;
var dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time4 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time4}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
var string4 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint4 = /^-?\d+n?$/;
var integer2 = /^-?\d+$/;
var number4 = /^-?\d+(?:\.\d+)?$/;
var boolean4 = /^(?:true|false)$/i;
var _null4 = /^null$/i;
var _undefined4 = /^undefined$/i;
var lowercase2 = /^[^A-Z]*$/;
var uppercase2 = /^[^a-z]*$/;
var hex3 = /^[0-9a-fA-F]*$/;
function fixedBase642(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url2(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex2 = /^[0-9a-fA-F]{32}$/;
var md5_base642 = /* @__PURE__ */ fixedBase642(22, "==");
var md5_base64url2 = /* @__PURE__ */ fixedBase64url2(22);
var sha1_hex2 = /^[0-9a-fA-F]{40}$/;
var sha1_base642 = /* @__PURE__ */ fixedBase642(27, "=");
var sha1_base64url2 = /* @__PURE__ */ fixedBase64url2(27);
var sha256_hex2 = /^[0-9a-fA-F]{64}$/;
var sha256_base642 = /* @__PURE__ */ fixedBase642(43, "=");
var sha256_base64url2 = /* @__PURE__ */ fixedBase64url2(43);
var sha384_hex2 = /^[0-9a-fA-F]{96}$/;
var sha384_base642 = /* @__PURE__ */ fixedBase642(64, "");
var sha384_base64url2 = /* @__PURE__ */ fixedBase64url2(64);
var sha512_hex2 = /^[0-9a-fA-F]{128}$/;
var sha512_base642 = /* @__PURE__ */ fixedBase642(86, "==");
var sha512_base64url2 = /* @__PURE__ */ fixedBase64url2(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap2 = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer2;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck2.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck2.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck2.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck2.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck2.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck2.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin2(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const escapedRegex = escapeRegex2(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
var $ZodCheckProperty2 = /* @__PURE__ */ $constructor2("$ZodCheckProperty", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
    }
    handleCheckPropertyResult2(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType2 = /* @__PURE__ */ $constructor2("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc2 {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version2 = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks3 = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks3.unshift(inst);
  }
  for (const ch of checks3) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks3.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks4, ctx) => {
      let isAborted = aborted2(payload);
      let asyncResult;
      for (const ch of checks4) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError2;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted2(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted2(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted2(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks3, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2;
        return result.then((result2) => runChecks(result2, checks3, ctx));
      }
      return runChecks(result, checks3, ctx);
    };
  }
  defineLazy2(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse3(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  $ZodString2.init(inst, def);
});
var $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid3(v));
  } else
    def.pattern ?? (def.pattern = uuid3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid23);
  $ZodStringFormat2.init(inst, def);
});
var $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv43);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor2("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv43);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base643);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase642(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase642(padded);
}
var $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url3);
  $ZodStringFormat2.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL2(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e1643);
  $ZodStringFormat2.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat2.init(inst, def);
  $ZodNumber2.init(inst, def);
});
var $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = boolean4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = bigint4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat2.init(inst, def);
  $ZodBigInt2.init(inst, def);
});
var $ZodSymbol2 = /* @__PURE__ */ $constructor2("$ZodSymbol", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined2 = /* @__PURE__ */ $constructor2("$ZodUndefined", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _undefined4;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _null4;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny2 = /* @__PURE__ */ $constructor2("$ZodAny", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid2 = /* @__PURE__ */ $constructor2("$ZodVoid", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate2 = /* @__PURE__ */ $constructor2("$ZodDate", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
      } else {
        handleArrayResult2(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult2(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef2(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall2(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult2(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
  $ZodType2.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached2(() => normalizeDef2(def));
  defineLazy2(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject3 = isObject2;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult2(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall2(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT2 = /* @__PURE__ */ $constructor2("$ZodObjectJIT", (inst, def) => {
  $ZodObject2.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached2(() => normalizeDef2(def));
  const generateFastpass = (shape) => {
    const doc2 = new Doc2(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc2(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc2.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc2.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc2(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc2.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc2.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc2.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc2.write(`payload.value = newResult;`);
    doc2.write(`return payload;`);
    const fn = doc2.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig2.jitless;
  const allowsEval3 = allowsEval2;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall2([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted2(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
var $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy2(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy2(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults2(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults2(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor2("$ZodXor", (inst, def) => {
  $ZodUnion2.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion2.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy2(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached2(() => {
    const opts = def.options;
    const map2 = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults2(payload, left2, right2);
      });
    }
    return handleIntersectionResults2(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  const unrecKeys = new Map;
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple2 = /* @__PURE__ */ $constructor2("$ZodTuple", (inst, def) => {
  $ZodType2.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
      } else {
        handleTupleResult2(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
        } else {
          handleTupleResult2(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = new Set;
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number4.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues2(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues2(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap2 = /* @__PURE__ */ $constructor2("$ZodMap", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet2 = /* @__PURE__ */ $constructor2("$ZodSet", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult2(result2, payload)));
      } else
        handleSetResult2(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
  $ZodType2.init(inst, def);
  const values = getEnumValues2(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile2 = /* @__PURE__ */ $constructor2("$ZodFile", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError2;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult2(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult2(r, payload.value));
      return handleOptionalResult2(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor2("$ZodExactOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : undefined;
  });
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult2(result2, def));
    }
    return handleDefaultResult2(result, def);
  };
});
function handleDefaultResult2(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult2(result2, inst));
    }
    return handleNonOptionalResult2(result, inst);
  };
});
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess2 = /* @__PURE__ */ $constructor2("$ZodSuccess", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN2 = /* @__PURE__ */ $constructor2("$ZodNaN", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult2(right2, def.in, ctx));
      }
      return handlePipeResult2(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult2(left2, def.out, ctx));
    }
    return handlePipeResult2(left, def.out, ctx);
  };
});
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec2 = /* @__PURE__ */ $constructor2("$ZodCodec", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult2(left2, def, ctx));
      }
      return handleCodecAResult2(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult2(right2, def, ctx));
      }
      return handleCodecAResult2(right, def, ctx);
    }
  };
});
function handleCodecAResult2(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.out, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.in, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult2(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult2);
    }
    return handleReadonlyResult2(result);
  };
});
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("$ZodTemplateLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes2.has(typeof part)) {
      regexParts.push(escapeRegex2(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction2 = /* @__PURE__ */ $constructor2("$ZodFunction", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse5(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse5(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync3(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync3(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple2({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise2 = /* @__PURE__ */ $constructor2("$ZodPromise", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy2 = /* @__PURE__ */ $constructor2("$ZodLazy", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "innerType", () => def.getter());
  defineLazy2(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy2(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy2(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);
  defineLazy2(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
  $ZodCheck2.init(inst, def);
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
    }
    handleRefineResult2(r, payload, input, inst);
    return;
  };
});
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales2 = {};
__export(exports_locales2, {
  zhTW: () => zh_TW_default2,
  zhCN: () => zh_CN_default2,
  yo: () => yo_default2,
  vi: () => vi_default2,
  uz: () => uz_default,
  ur: () => ur_default2,
  uk: () => uk_default2,
  ua: () => ua_default2,
  tr: () => tr_default2,
  th: () => th_default2,
  ta: () => ta_default2,
  sv: () => sv_default2,
  sl: () => sl_default2,
  ru: () => ru_default2,
  pt: () => pt_default2,
  ps: () => ps_default2,
  pl: () => pl_default2,
  ota: () => ota_default2,
  no: () => no_default2,
  nl: () => nl_default2,
  ms: () => ms_default2,
  mk: () => mk_default2,
  lt: () => lt_default2,
  ko: () => ko_default2,
  km: () => km_default2,
  kh: () => kh_default2,
  ka: () => ka_default2,
  ja: () => ja_default2,
  it: () => it_default2,
  is: () => is_default2,
  id: () => id_default2,
  hy: () => hy_default,
  hu: () => hu_default2,
  he: () => he_default2,
  frCA: () => fr_CA_default2,
  fr: () => fr_default2,
  fi: () => fi_default2,
  fa: () => fa_default2,
  es: () => es_default2,
  eo: () => eo_default2,
  en: () => en_default2,
  de: () => de_default2,
  da: () => da_default2,
  cs: () => cs_default2,
  ca: () => ca_default2,
  bg: () => bg_default,
  be: () => be_default2,
  az: () => az_default2,
  ar: () => ar_default2
});

// node_modules/zod/v4/locales/ar.js
var error45 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `  :   instanceof ${issue3.expected}    ${received}`;
        }
        return `  :   ${expected}    ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `  :   ${stringifyPrimitive2(issue3.values[0])}`;
        return `  :     : ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `   :    ${issue3.origin ?? ""} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue3.origin ?? ""} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `  :   ${issue3.origin}   ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `  :   ${issue3.origin}   ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `  :     "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "" : ""} ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, " ")}`;
      case "invalid_key":
        return `    ${issue3.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue3.origin}`;
      default:
        return "  ";
    }
  };
};
function ar_default2() {
  return {
    localeError: error45()
  };
}
// node_modules/zod/v4/locales/az.js
var error46 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Yanl dyr: gzlniln instanceof ${issue3.expected}, daxil olan ${received}`;
        }
        return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive2(issue3.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue3.origin ?? "dyr"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue3.origin ?? "dyr"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue3.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue3.origin} daxilind yanl dyr`;
      default:
        return `Yanl dyr`;
    }
  };
};
function az_default2() {
  return {
    localeError: error46()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error47 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :  instanceof ${issue3.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` :  ${stringifyPrimitive2(issue3.values[0])}`;
        return ` :    ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue3.origin ?? ""}  ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue3.origin ?? ""}   ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue3.origin}  ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue3.origin}   ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue3.divisor}`;
      case "unrecognized_keys":
        return ` ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue3.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue3.origin}`;
      default:
        return ` `;
    }
  };
};
function be_default2() {
  return {
    localeError: error47()
  };
}
// node_modules/zod/v4/locales/bg.js
var error48 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :  instanceof ${issue3.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` :  ${stringifyPrimitive2(issue3.values[0])}`;
        return ` :    ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` :   ${issue3.origin ?? ""}   ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue3.origin ?? ""}   ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` :   ${issue3.origin}   ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue3.origin}   ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :     ${_issue.pattern}`;
        let invalid_adj = "";
        if (_issue.format === "emoji")
          invalid_adj = "";
        if (_issue.format === "datetime")
          invalid_adj = "";
        if (_issue.format === "date")
          invalid_adj = "";
        if (_issue.format === "time")
          invalid_adj = "";
        if (_issue.format === "duration")
          invalid_adj = "";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "" : ""} ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue3.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue3.origin}`;
      default:
        return ` `;
    }
  };
};
function bg_default() {
  return {
    localeError: error48()
  };
}
// node_modules/zod/v4/locales/ca.js
var error49 = () => {
  const Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Tipus invlid: s'esperava instanceof ${issue3.expected}, s'ha rebut ${received}`;
        }
        return `Tipus invlid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a mxim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingus ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a mnim" : "ms de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingus ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${issue3.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function ca_default2() {
  return {
    localeError: error49()
  };
}
// node_modules/zod/v4/locales/cs.js
var error50 = () => {
  const Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "slo",
    string: "etzec",
    function: "funkce",
    array: "pole"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Neplatn vstup: oekvno instanceof ${issue3.expected}, obdreno ${received}`;
        }
        return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je pli velk: ${issue3.origin ?? "hodnota"} mus mt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli velk: ${issue3.origin ?? "hodnota"} mus bt ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je pli mal: ${issue3.origin ?? "hodnota"} mus mt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli mal: ${issue3.origin ?? "hodnota"} mus bt ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue3.origin}`;
      default:
        return `Neplatn vstup`;
    }
  };
};
function cs_default2() {
  return {
    localeError: error50()
  };
}
// node_modules/zod/v4/locales/da.js
var error51 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslt",
    date: "ISO-dato",
    time: "ISO-klokkeslt",
    duration: "ISO-varighed",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "st",
    file: "fil"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue3.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig vrdi: forventede ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default2() {
  return {
    localeError: error51()
  };
}
// node_modules/zod/v4/locales/de.js
var error52 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ungltige Eingabe: erwartet instanceof ${issue3.expected}, erhalten ${received}`;
        }
        return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue3.origin}`;
      default:
        return `Ungltige Eingabe`;
    }
  };
};
function de_default2() {
  return {
    localeError: error52()
  };
}
// node_modules/zod/v4/locales/en.js
var error53 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default2() {
  return {
    localeError: error53()
  };
}
// node_modules/zod/v4/locales/eo.js
var error54 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Nevalida enigo: atendiis instanceof ${issue3.expected}, riceviis ${received}`;
        }
        return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendiis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} losilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default2() {
  return {
    localeError: error54()
  };
}
// node_modules/zod/v4/locales/es.js
var error55 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "nmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "nmero grande",
    symbol: "smbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funcin",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeracin",
    union: "unin",
    literal: "literal",
    promise: "promesa",
    void: "vaco",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entrada invlida: se esperaba instanceof ${issue3.expected}, recibido ${received}`;
        }
        return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing) {
          return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function es_default2() {
  return {
    localeError: error55()
  };
}
// node_modules/zod/v4/locales/fa.js
var error56 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :  instanceof ${issue3.expected}  ${received}  `;
        }
        return ` :  ${expected}  ${received}  `;
      }
      case "invalid_value":
        if (issue3.values.length === 1) {
          return ` :  ${stringifyPrimitive2(issue3.values[0])} `;
        }
        return ` :    ${joinValues2(issue3.values, "|")} `;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` : ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` : ${issue3.origin}  ${adj}${issue3.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue3.origin}  ${adj}${issue3.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"  `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"  `;
        }
        if (_issue.format === "includes") {
          return ` :   "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :    ${_issue.pattern}   `;
        }
        return `${FormatDictionary[_issue.format] ?? issue3.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue3.divisor} `;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue3.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue3.origin}`;
      default:
        return ` `;
    }
  };
};
function fa_default2() {
  return {
    localeError: error56()
  };
}
// node_modules/zod/v4/locales/fi.js
var error57 = () => {
  const Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue3.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syte`;
    }
  };
};
function fi_default2() {
  return {
    localeError: error57()
  };
}
// node_modules/zod/v4/locales/fr.js
var error58 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entre invalide : instanceof ${issue3.expected} attendu, ${received} reu`;
        }
        return `Entre invalide : ${expected} attendu, ${received} reu`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit tre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit tre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_default2() {
  return {
    localeError: error58()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error59 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entre invalide : attendu instanceof ${issue3.expected}, reu ${received}`;
        }
        return `Entre invalide : attendu ${expected}, reu ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_CA_default2() {
  return {
    localeError: error59()
  };
}
// node_modules/zod/v4/locales/he.js
var error60 = () => {
  const TypeNames = {
    string: { label: "", gender: "f" },
    number: { label: "", gender: "m" },
    boolean: { label: " ", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "", gender: "m" },
    array: { label: "", gender: "m" },
    object: { label: "", gender: "m" },
    null: { label: "  (null)", gender: "m" },
    undefined: { label: "   (undefined)", gender: "m" },
    symbol: { label: " (Symbol)", gender: "m" },
    function: { label: "", gender: "f" },
    map: { label: " (Map)", gender: "f" },
    set: { label: " (Set)", gender: "f" },
    file: { label: "", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "  ", gender: "m" },
    value: { label: "", gender: "m" }
  };
  const Sizable = {
    string: { unit: "", shortLabel: "", longLabel: "" },
    file: { unit: "", shortLabel: "", longLabel: "" },
    array: { unit: "", shortLabel: "", longLabel: "" },
    set: { unit: "", shortLabel: "", longLabel: "" },
    number: { unit: "", shortLabel: "", longLabel: "" }
  };
  const typeEntry = (t) => t ? TypeNames[t] : undefined;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? " " : " ";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "", gender: "m" },
    email: { label: " ", gender: "f" },
    url: { label: " ", gender: "f" },
    emoji: { label: "'", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "  ISO", gender: "m" },
    date: { label: " ISO", gender: "m" },
    time: { label: " ISO", gender: "m" },
    duration: { label: "  ISO", gender: "m" },
    ipv4: { label: " IPv4", gender: "f" },
    ipv6: { label: " IPv6", gender: "f" },
    cidrv4: { label: " IPv4", gender: "m" },
    cidrv6: { label: " IPv6", gender: "m" },
    base64: { label: "  64", gender: "f" },
    base64url: { label: "  64  ", gender: "f" },
    json_string: { label: " JSON", gender: "f" },
    e164: { label: " E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "", gender: "m" },
    includes: { label: "", gender: "m" },
    lowercase: { label: "", gender: "m" },
    starts_with: { label: "", gender: "m" },
    uppercase: { label: "", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expectedKey = issue3.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `  :   instanceof ${issue3.expected},  ${received}`;
        }
        return `  :   ${expected},  ${received}`;
      }
      case "invalid_value": {
        if (issue3.values.length === 1) {
          return `  :    ${stringifyPrimitive2(issue3.values[0])}`;
        }
        const stringified = issue3.values.map((v) => stringifyPrimitive2(v));
        if (issue3.values.length === 2) {
          return `  :    ${stringified[0]}  ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `  :    ${restValues}  ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue3.origin);
        const subject = withDefinite(issue3.origin ?? "value");
        if (issue3.origin === "string") {
          return `${sizing?.longLabel ?? ""} : ${subject}   ${issue3.maximum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? " " : " "}`.trim();
        }
        if (issue3.origin === "number") {
          const comparison = issue3.inclusive ? `   -${issue3.maximum}` : ` -${issue3.maximum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue3.origin === "array" || issue3.origin === "set") {
          const verb = issue3.origin === "set" ? "" : "";
          const comparison = issue3.inclusive ? `${issue3.maximum} ${sizing?.unit ?? ""}  ` : ` -${issue3.maximum} ${sizing?.unit ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue3.inclusive ? "<=" : "<";
        const be = verbFor(issue3.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? ""} : ${subject} ${be} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue3.origin);
        const subject = withDefinite(issue3.origin ?? "value");
        if (issue3.origin === "string") {
          return `${sizing?.shortLabel ?? ""} : ${subject}   ${issue3.minimum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? " " : ""}`.trim();
        }
        if (issue3.origin === "number") {
          const comparison = issue3.inclusive ? `   -${issue3.minimum}` : ` -${issue3.minimum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue3.origin === "array" || issue3.origin === "set") {
          const verb = issue3.origin === "set" ? "" : "";
          if (issue3.minimum === 1 && issue3.inclusive) {
            const singularPhrase = issue3.origin === "set" ? "  " : "  ";
            return ` : ${subject} ${verb}  ${singularPhrase}`;
          }
          const comparison = issue3.inclusive ? `${issue3.minimum} ${sizing?.unit ?? ""}  ` : ` -${issue3.minimum} ${sizing?.unit ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue3.inclusive ? ">=" : ">";
        const be = verbFor(issue3.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? ""} : ${subject} ${be} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `    ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "" : "";
        return `${noun}  ${adjective}`;
      }
      case "not_multiple_of":
        return `  :     ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "" : ""}  ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key": {
        return `   `;
      }
      case "invalid_union":
        return "  ";
      case "invalid_element": {
        const place = withDefinite(issue3.origin ?? "array");
        return `   ${place}`;
      }
      default:
        return `  `;
    }
  };
};
function he_default2() {
  return {
    localeError: error60()
  };
}
// node_modules/zod/v4/locales/hu.js
var error61 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "szm",
    array: "tmb"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `rvnytelen bemenet: a vrt rtk instanceof ${issue3.expected}, a kapott rtk ${received}`;
        }
        return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive2(issue3.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tl nagy: ${issue3.origin ?? "rtk"} mrete tl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue3.origin ?? "rtk"} tl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tl kicsi: a bemeneti rtk ${issue3.origin} mrete tl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tl kicsi: a bemeneti rtk ${issue3.origin} tl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue3.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue3.origin}`;
      default:
        return `rvnytelen bemenet`;
    }
  };
};
function hu_default2() {
  return {
    localeError: error61()
  };
}
// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["", "", "", "", "", "", ""];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "" : "");
}
var error62 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: ". ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `    instanceof ${issue3.expected},   ${received}`;
        }
        return `    ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `    ${stringifyPrimitive2(issue3.values[1])}`;
        return `      ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue3.origin ?? "")}  ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue3.origin ?? "")}  ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue3.origin)}  ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue3.origin)}  ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `     "${_issue.prefix}"-`;
        if (_issue.format === "ends_with")
          return `     "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return `     "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `     ${_issue.pattern} `;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `      ${issue3.divisor}-`;
      case "unrecognized_keys":
        return ` ${issue3.keys.length > 1 ? "" : ""}. ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `  ${withDefiniteArticle(issue3.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${withDefiniteArticle(issue3.origin)}-`;
      default:
        return ` `;
    }
  };
};
function hy_default() {
  return {
    localeError: error62()
  };
}
// node_modules/zod/v4/locales/id.js
var error63 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue3.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default2() {
  return {
    localeError: error63()
  };
}
// node_modules/zod/v4/locales/is.js
var error64 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a hafa" },
    file: { unit: "bti", verb: "a hafa" },
    array: { unit: "hluti", verb: "a hafa" },
    set: { unit: "hluti", verb: "a hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tmi",
    date: "ISO dagsetning",
    time: "ISO tmi",
    duration: "ISO tmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tlugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmer",
    array: "fylki"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue3.expected}`;
        }
        return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert r fyrir ${stringifyPrimitive2(issue3.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of strt: gert er r fyrir a ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${issue3.origin ?? "gildi"} s ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of lti: gert er r fyrir a ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lti: gert er r fyrir a ${issue3.origin} s ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `gildur strengur: verur a enda  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `gildur strengur: verur a innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default2() {
  return {
    localeError: error64()
  };
}
// node_modules/zod/v4/locales/it.js
var error65 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input non valido: atteso instanceof ${issue3.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default2() {
  return {
    localeError: error65()
  };
}
// node_modules/zod/v4/locales/ja.js
var error66 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `: instanceof ${issue3.expected}${received}`;
        }
        return `: ${expected}${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `: ${stringifyPrimitive2(issue3.values[0])}`;
        return `: ${joinValues2(issue3.values, "")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "" : "";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `: ${issue3.origin ?? ""}${issue3.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue3.origin ?? ""}${issue3.maximum.toString()}${adj}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "" : "";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `: ${issue3.origin}${issue3.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue3.origin}${issue3.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `: ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, "")}`;
      case "invalid_key":
        return `${issue3.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue3.origin}`;
      default:
        return ``;
    }
  };
};
function ja_default2() {
  return {
    localeError: error66()
  };
}
// node_modules/zod/v4/locales/ka.js
var error67 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "- ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "-",
    date: "",
    time: "",
    duration: "",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    string: "",
    boolean: "",
    function: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :  instanceof ${issue3.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` :  ${stringifyPrimitive2(issue3.values[0])}`;
        return ` :  - ${joinValues2(issue3.values, "|")}-`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` :  ${issue3.origin ?? ""} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return ` :  ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` :  ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return ` :  ${issue3.origin}  ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"-`;
        }
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"-`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` :   ${issue3.divisor}- `;
      case "unrecognized_keys":
        return ` ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `  ${issue3.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${issue3.origin}-`;
      default:
        return ` `;
    }
  };
};
function ka_default2() {
  return {
    localeError: error67()
  };
}
// node_modules/zod/v4/locales/km.js
var error68 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `  instanceof ${issue3.expected}  ${received}`;
        }
        return `  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `  ${stringifyPrimitive2(issue3.values[0])}`;
        return `  ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `  ${issue3.origin ?? ""} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue3.origin ?? ""} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `  ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `  ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `  ${issue3.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue3.origin}`;
      case "invalid_union":
        return ``;
      case "invalid_element":
        return ` ${issue3.origin}`;
      default:
        return ``;
    }
  };
};
function km_default2() {
  return {
    localeError: error68()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default2() {
  return km_default2();
}
// node_modules/zod/v4/locales/ko.js
var error69 = () => {
  const Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :   instanceof ${issue3.expected},   ${received}`;
        }
        return ` :   ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` :  ${stringifyPrimitive2(issue3.values[0])}  `;
        return ` : ${joinValues2(issue3.values, " ")}   `;
      case "too_big": {
        const adj = issue3.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "";
        if (sizing)
          return `${issue3.origin ?? ""}  : ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? ""}  : ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "";
        if (sizing) {
          return `${issue3.origin ?? ""}  : ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? ""}  : ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"()  `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue3.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue3.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return ` : ${issue3.origin}`;
      default:
        return ` `;
    }
  };
};
function ko_default2() {
  return {
    localeError: error69()
  };
}
// node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter2 = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber2(number5) {
  const abs = Math.abs(number5);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error70 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne ilgesn kaip",
          notInclusive: "turi bti trumpesn kaip"
        },
        bigger: {
          inclusive: "turi bti ne trumpesn kaip",
          notInclusive: "turi bti ilgesn kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne didesnis kaip",
          notInclusive: "turi bti maesnis kaip"
        },
        bigger: {
          inclusive: "turi bti ne maesnis kaip",
          notInclusive: "turi bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "vestis",
    email: "el. pato adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 ukoduota eilut",
    base64url: "base64url ukoduota eilut",
    json_string: "JSON eilut",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "vestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skaiius",
    bigint: "sveikasis skaiius",
    string: "eilut",
    boolean: "login reikm",
    undefined: "neapibrta reikm",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin reikm"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Gautas tipas ${received}, o tiktasi - instanceof ${issue3.expected}`;
        }
        return `Gautas tipas ${received}, o tiktasi - ${expected}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo bti ${stringifyPrimitive2(issue3.values[0])}`;
        return `Privalo bti vienas i ${joinValues2(issue3.values, "|")} pasirinkim`;
      case "too_big": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikm")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue3.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikm")} turi bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikm")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue3.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikm")} turi bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilut privalo prasidti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut privalo traukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function lt_default2() {
  return {
    localeError: error70()
  };
}
// node_modules/zod/v4/locales/mk.js
var error71 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :   instanceof ${issue3.expected},  ${received}`;
        }
        return ` :   ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return ` :    ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` :   ${issue3.origin ?? ""}   ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue3.origin ?? ""}   ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` :   ${issue3.origin}   ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue3.origin}   ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? " " : " "}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue3.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue3.origin}`;
      default:
        return ` `;
    }
  };
};
function mk_default2() {
  return {
    localeError: error71()
  };
}
// node_modules/zod/v4/locales/ms.js
var error72 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue3.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default2() {
  return {
    localeError: error72()
  };
}
// node_modules/zod/v4/locales/nl.js
var error73 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue3.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const longName = issue3.origin === "date" ? "laat" : issue3.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const shortName = issue3.origin === "date" ? "vroeg" : issue3.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default2() {
  return {
    localeError: error73()
  };
}
// node_modules/zod/v4/locales/no.js
var error74 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ugyldig input: forventet instanceof ${issue3.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til  ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til  ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til  ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til  ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default2() {
  return {
    localeError: error74()
  };
}
// node_modules/zod/v4/locales/ota.js
var error75 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Fsit giren: umulan instanceof ${issue3.expected}, alnan ${received}`;
        }
        return `Fsit giren: umulan ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla byk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla kk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        }
        return `Fazla kk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue3.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue3.origin} iin tannmayan kymet var.`;
      default:
        return `Kymet tannamad.`;
    }
  };
};
function ota_default2() {
  return {
    localeError: error75()
  };
}
// node_modules/zod/v4/locales/ps.js
var error76 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :  instanceof ${issue3.expected} ,  ${received}  `;
        }
        return ` :  ${expected} ,  ${received}  `;
      }
      case "invalid_value":
        if (issue3.values.length === 1) {
          return ` :  ${stringifyPrimitive2(issue3.values[0])} `;
        }
        return ` :    ${joinValues2(issue3.values, "|")}  `;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` : ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` : ${issue3.origin}  ${adj}${issue3.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue3.origin}  ${adj}${issue3.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"   `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"    `;
        }
        if (_issue.format === "includes") {
          return ` :  "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :   ${_issue.pattern}   `;
        }
        return `${FormatDictionary[_issue.format] ?? issue3.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue3.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue3.origin} `;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue3.origin} `;
      default:
        return ` `;
    }
  };
};
function ps_default2() {
  return {
    localeError: error76()
  };
}
// node_modules/zod/v4/locales/pl.js
var error77 = () => {
  const Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue3.expected}, otrzymano ${received}`;
        }
        return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za dua warto: oczekiwano, e ${issue3.origin ?? "warto"} bdzie mie ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt du(y/a/e): oczekiwano, e ${issue3.origin ?? "warto"} bdzie wynosi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za maa warto: oczekiwano, e ${issue3.origin ?? "warto"} bdzie mie ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue3.origin ?? "warto"} bdzie wynosi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue3.origin}`;
      default:
        return `Nieprawidowe dane wejciowe`;
    }
  };
};
function pl_default2() {
  return {
    localeError: error77()
  };
}
// node_modules/zod/v4/locales/pt.js
var error78 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmero",
    null: "nulo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Tipo invlido: esperado instanceof ${issue3.expected}, recebido ${received}`;
        }
        return `Tipo invlido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue3.origin}`;
      default:
        return `Campo invlido`;
    }
  };
};
function pt_default2() {
  return {
    localeError: error78()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error79 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :  instanceof ${issue3.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` :  ${stringifyPrimitive2(issue3.values[0])}`;
        return ` :    ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue3.origin ?? ""}   ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue3.origin}   ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue3.origin}  ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "" : ""} ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue3.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue3.origin}`;
      default:
        return `  `;
    }
  };
};
function ru_default2() {
  return {
    localeError: error79()
  };
}
// node_modules/zod/v4/locales/sl.js
var error80 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tevilo",
    array: "tabela"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Neveljaven vnos: priakovano instanceof ${issue3.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: priakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default2() {
  return {
    localeError: error80()
  };
}
// node_modules/zod/v4/locales/sv.js
var error81 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ogiltig inmatning: frvntat instanceof ${issue3.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fr stor(t): frvntade ${issue3.origin ?? "vrdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `Fr stor(t): frvntat ${issue3.origin ?? "vrdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fr lite(t): frvntade ${issue3.origin ?? "vrdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Fr lite(t): frvntade ${issue3.origin ?? "vrdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue3.origin ?? "vrdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default2() {
  return {
    localeError: error81()
  };
}
// node_modules/zod/v4/locales/ta.js
var error82 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` :  instanceof ${issue3.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` :  ${stringifyPrimitive2(issue3.values[0])}`;
        return ` :  ${joinValues2(issue3.values, "|")}  `;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` :  ${issue3.origin ?? ""} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""}   `;
        }
        return ` :  ${issue3.origin ?? ""} ${adj}${issue3.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` :  ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}   `;
        }
        return ` :  ${issue3.origin} ${adj}${issue3.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue3.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue3.origin}   `;
      default:
        return ` `;
    }
  };
};
function ta_default2() {
  return {
    localeError: error82()
  };
}
// node_modules/zod/v4/locales/th.js
var error83 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `:  instanceof ${issue3.expected}  ${received}`;
        }
        return `:  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `:  ${stringifyPrimitive2(issue3.values[0])}`;
        return `:  ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "" : "";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `: ${issue3.origin ?? ""} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue3.origin ?? ""} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "" : "";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `: ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `: ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `:  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue3.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue3.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue3.origin}`;
      default:
        return ``;
    }
  };
};
function th_default2() {
  return {
    localeError: error83()
  };
}
// node_modules/zod/v4/locales/tr.js
var error84 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Geersiz deer: beklenen instanceof ${issue3.expected}, alnan ${received}`;
        }
        return `Geersiz deer: beklenen ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ok byk: beklenen ${issue3.origin ?? "deer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue3.origin ?? "deer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ok kk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue3.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue3.origin} iinde geersiz deer`;
      default:
        return `Geersiz deer`;
    }
  };
};
function tr_default2() {
  return {
    localeError: error84()
  };
}
// node_modules/zod/v4/locales/uk.js
var error85 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `  :  instanceof ${issue3.expected},  ${received}`;
        }
        return `  :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `  :  ${stringifyPrimitive2(issue3.values[0])}`;
        return ` :    ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` : ,  ${issue3.origin ?? ""} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` : ,  ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ,  ${issue3.origin}  ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue3.divisor}`;
      case "unrecognized_keys":
        return ` ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue3.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue3.origin}`;
      default:
        return `  `;
    }
  };
};
function uk_default2() {
  return {
    localeError: error85()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default2() {
  return uk_default2();
}
// node_modules/zod/v4/locales/ur.js
var error86 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `  : instanceof ${issue3.expected}   ${received}  `;
        }
        return `  : ${expected}   ${received}  `;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `  : ${stringifyPrimitive2(issue3.values[0])}  `;
        return ` : ${joinValues2(issue3.values, "|")}     `;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` : ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` : ${issue3.origin}  ${adj}${issue3.minimum.toString()} ${sizing.unit}   `;
        }
        return ` : ${issue3.origin}  ${adj}${issue3.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"    `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue3.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue3.keys.length > 1 ? "" : ""}: ${joinValues2(issue3.keys, " ")}`;
      case "invalid_key":
        return `${issue3.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue3.origin}   `;
      default:
        return `  `;
    }
  };
};
function ur_default2() {
  return {
    localeError: error86()
  };
}
// node_modules/zod/v4/locales/uz.js
var error87 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bolishi kerak" },
    file: { unit: "bayt", verb: "bolishi kerak" },
    array: { unit: "element", verb: "bolishi kerak" },
    set: { unit: "element", verb: "bolishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Notogri kirish: kutilgan instanceof ${issue3.expected}, qabul qilingan ${received}`;
        }
        return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Notogri kirish: kutilgan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Notogri variant: quyidagilardan biri kutilgan ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Notogri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Notogri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Notogri satr: "${_issue.includes}" ni oz ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Notogri ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${issue3.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${issue3.origin} da notogri qiymat`;
      default:
        return `Notogri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error87()
  };
}
// node_modules/zod/v4/locales/vi.js
var error88 = () => {
  const Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s",
    array: "mng"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `u vo khng hp l: mong i instanceof ${issue3.expected}, nhn c ${received}`;
        }
        return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Qu ln: mong i ${issue3.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue3.origin ?? "gi tr"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Qu nh: mong i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu nh: mong i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue3.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue3.origin}`;
      default:
        return `u vo khng hp l`;
    }
  };
};
function vi_default2() {
  return {
    localeError: error88()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error89 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: "(null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` instanceof ${issue3.expected} ${received}`;
        }
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` ${stringifyPrimitive2(issue3.values[0])}`;
        return ` ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` ${issue3.origin ?? ""} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue3.origin ?? ""} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` ${issue3.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue3.origin} (value)`;
      default:
        return ``;
    }
  };
};
function zh_CN_default2() {
  return {
    localeError: error89()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error90 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return ` instanceof ${issue3.expected} ${received}`;
        }
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return ` ${stringifyPrimitive2(issue3.values[0])}`;
        return ` ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue3.origin ?? ""}  ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return ` ${issue3.origin}  ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue3.origin}  ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return ` "${_issue.prefix}" `;
        }
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return ` ${issue3.divisor} `;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "" : ""}${joinValues2(issue3.keys, "")}`;
      case "invalid_key":
        return `${issue3.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue3.origin} `;
      default:
        return ``;
    }
  };
};
function zh_TW_default2() {
  return {
    localeError: error90()
  };
}
// node_modules/zod/v4/locales/yo.js
var error91 = () => {
  const Sizable = {
    string: { unit: "mi", verb: "n" },
    file: { unit: "bytes", verb: "n" },
    array: { unit: "nkan", verb: "n" },
    set: { unit: "nkan", verb: "n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "r bwl",
    email: "drs ml",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "kk ISO",
    date: "j ISO",
    time: "kk ISO",
    duration: "kk t p ISO",
    ipv4: "drs IPv4",
    ipv6: "drs IPv6",
    cidrv4: "gbgb IPv4",
    cidrv6: "gbgb IPv6",
    base64: "r t a k n base64",
    base64url: "r base64url",
    json_string: "r JSON",
    e164: "nmb E.164",
    jwt: "JWT",
    template_literal: "r bwl"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmb",
    array: "akop"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType7(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `bwl ae: a n lti fi instanceof ${issue3.expected}, m a r ${received}`;
        }
        return `bwl ae: a n lti fi ${expected}, m a r ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `bwl ae: a n lti fi ${stringifyPrimitive2(issue3.values[0])}`;
        return `yn ae: yan kan lra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T p j: a n lti j p ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `T p j: a n lti j ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Kr ju: a n lti j p ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `Kr ju: a n lti j ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `r ae: gbd br pl "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `r ae: gbd par pl "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `r ae: gbd n "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `r ae: gbd b pr mu ${_issue.pattern}`;
        return `Ae: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${issue3.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${issue3.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function yo_default2() {
  return {
    localeError: error91()
  };
}
// node_modules/zod/v4/core/registries.js
var _a;
var $output2 = Symbol("ZodOutput");
var $input2 = Symbol("ZodInput");

class $ZodRegistry2 {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry2() {
  return new $ZodRegistry2;
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry2());
var globalRegistry2 = globalThis.__zod_globalRegistry;
// node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _mac(Class3, params) {
  return new Class3({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
var TimePrecision2 = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
function _undefined5(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _void3(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _positive2(params) {
  return _gt2(0, params);
}
function _negative2(params) {
  return _lt2(0, params);
}
function _nonpositive2(params) {
  return _lte2(0, params);
}
function _nonnegative2(params) {
  return _gte2(0, params);
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _property2(property, schema, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema,
    ...normalizeParams2(params)
  });
}
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite2((input) => slugify(input));
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    ...normalizeParams2(params)
  });
}
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
function _xor(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams2(params)
  });
}
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone2(defaultValue);
    }
  });
}
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch3(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
function _superRefine2(fn) {
  const ch = _check2((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue2(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check2(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck2({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry2.get(inst) ?? {};
      globalRegistry2.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck2({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry2.get(inst) ?? {};
      globalRegistry2.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec2;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec2;
}
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry2,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {}),
    io: params?.io ?? "output",
    counter: 0,
    seen: new Map,
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? undefined
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming2(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = new Map;
  for (const entry2 of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry2[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry2[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry2[0]);
    }
  }
  const makeURI = (entry2) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry2[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry2[1].defId ?? entry2[1].schema.id ?? `schema${ctx.counter++}`;
      entry2[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry2[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry2[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry2) => {
    if (entry2[1].schema.$ref) {
      return;
    }
    const seen = entry2[1];
    const { ref, defId } = makeURI(entry2);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry2 of ctx.seen.entries()) {
      const seen = entry2[1];
      if (seen.cycle) {
        throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
      }
    }
  }
  for (const entry2 of ctx.seen.entries()) {
    const seen = entry2[1];
    if (schema === entry2[0]) {
      extractToDef(entry2);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry2[0])?.id;
      if (schema !== entry2[0] && ext) {
        extractToDef(entry2);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry2[0])?.id;
    if (id) {
      extractToDef(entry2);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry2);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry2);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry2 of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry2[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {} else {}
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry2 of ctx.seen.entries()) {
    const seen = entry2[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {} else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming2(def.element, ctx);
  if (def.type === "set")
    return isTransforming2(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming2(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming2(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming2(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming2(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming2(item, ctx))
        return true;
    }
    if (def.rest && isTransforming2(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
// node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  json2.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minLength = minimum;
  if (typeof maximum === "number")
    json2.maxLength = maximum;
  if (format) {
    json2.format = formatMap[format] ?? format;
    if (json2.format === "")
      delete json2.format;
    if (format === "time") {
      delete json2.format;
    }
  }
  if (contentEncoding)
    json2.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json2.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json2.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json2.type = "integer";
  else
    json2.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.minimum = exclusiveMinimum;
      json2.exclusiveMinimum = true;
    } else {
      json2.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json2.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json2.minimum;
      else
        delete json2.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.maximum = exclusiveMaximum;
      json2.exclusiveMaximum = true;
    } else {
      json2.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json2.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json2.maximum;
      else
        delete json2.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json2.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json2, _params) => {
  if (ctx.target === "openapi-3.0") {
    json2.type = "string";
    json2.nullable = true;
    json2.enum = [null];
  } else {
    json2.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {};
var unknownProcessor = (_schema, _ctx, _json, _params) => {};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json2, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues2(def.entries);
  if (values.every((v) => typeof v === "number"))
    json2.type = "number";
  if (values.every((v) => typeof v === "string"))
    json2.type = "string";
  json2.enum = values;
};
var literalProcessor = (schema, ctx, json2, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === undefined) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {}
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {} else if (vals.length === 1) {
    const val = vals[0];
    json2.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.enum = [val];
    } else {
      json2.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json2.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json2.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json2.type = "boolean";
    if (vals.every((v) => v === null))
      json2.type = "null";
    json2.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== undefined)
    file2.minLength = minimum;
  if (maximum !== undefined)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file2);
  }
};
var successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
  json2.type = "array";
  json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  json2.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === undefined;
    } else {
      return v.optout === undefined;
    }
  }));
  if (requiredKeys.size > 0) {
    json2.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json2.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json2.additionalProperties = false;
  } else if (def.catchall) {
    json2.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json2.oneOf = options;
  } else {
    json2.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json2.prefixItems = prefixItems;
    if (rest) {
      json2.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json2.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json2.items.anyOf.push(rest);
    }
    json2.minItems = prefixItems.length;
    if (!rest) {
      json2.maxItems = prefixItems.length;
    }
  } else {
    json2.items = prefixItems;
    if (rest) {
      json2.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (const pattern of patterns) {
      json2.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json2.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json2.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json2.nullable = true;
  } else {
    json2.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(undefined);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema2(input, params) {
  if ("_idmap" in input) {
    const registry3 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry2 of registry3._idmap.entries()) {
      const [_, schema] = entry2;
      process2(schema, ctx2);
    }
    const schemas3 = {};
    const external2 = {
      registry: registry3,
      uri: params?.uri,
      defs
    };
    ctx2.external = external2;
    for (const entry2 of registry3._idmap.entries()) {
      const [key, schema] = entry2;
      extractDefs(ctx2, schema);
      schemas3[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas3.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas: schemas3 };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
// node_modules/zod/v4/core/json-schema-generator.js
class JSONSchemaGenerator2 {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema2 = {};
// node_modules/zod/v4/classic/schemas.js
var exports_schemas4 = {};
__export(exports_schemas4, {
  xor: () => xor,
  xid: () => xid4,
  void: () => _void4,
  uuidv7: () => uuidv72,
  uuidv6: () => uuidv62,
  uuidv4: () => uuidv42,
  uuid: () => uuid5,
  url: () => url2,
  unknown: () => unknown2,
  union: () => union2,
  undefined: () => _undefined6,
  ulid: () => ulid4,
  uint64: () => uint642,
  uint32: () => uint322,
  tuple: () => tuple2,
  transform: () => transform2,
  templateLiteral: () => templateLiteral2,
  symbol: () => symbol2,
  superRefine: () => superRefine2,
  success: () => success2,
  stringbool: () => stringbool2,
  stringFormat: () => stringFormat2,
  string: () => string5,
  strictObject: () => strictObject2,
  set: () => set2,
  refine: () => refine2,
  record: () => record2,
  readonly: () => readonly2,
  promise: () => promise2,
  preprocess: () => preprocess2,
  prefault: () => prefault2,
  pipe: () => pipe2,
  partialRecord: () => partialRecord2,
  optional: () => optional2,
  object: () => object2,
  number: () => number5,
  nullish: () => nullish4,
  nullable: () => nullable2,
  null: () => _null6,
  nonoptional: () => nonoptional2,
  never: () => never2,
  nativeEnum: () => nativeEnum2,
  nanoid: () => nanoid4,
  nan: () => nan2,
  meta: () => meta2,
  map: () => map2,
  mac: () => mac2,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject2,
  literal: () => literal2,
  lazy: () => lazy2,
  ksuid: () => ksuid4,
  keyof: () => keyof2,
  jwt: () => jwt2,
  json: () => json2,
  ipv6: () => ipv64,
  ipv4: () => ipv44,
  intersection: () => intersection2,
  int64: () => int642,
  int32: () => int322,
  int: () => int2,
  instanceof: () => _instanceof2,
  httpUrl: () => httpUrl2,
  hostname: () => hostname4,
  hex: () => hex4,
  hash: () => hash2,
  guid: () => guid4,
  function: () => _function2,
  float64: () => float642,
  float32: () => float322,
  file: () => file2,
  exactOptional: () => exactOptional,
  enum: () => _enum4,
  emoji: () => emoji4,
  email: () => email4,
  e164: () => e1644,
  discriminatedUnion: () => discriminatedUnion2,
  describe: () => describe2,
  date: () => date7,
  custom: () => custom2,
  cuid2: () => cuid24,
  cuid: () => cuid6,
  codec: () => codec2,
  cidrv6: () => cidrv64,
  cidrv4: () => cidrv44,
  check: () => check2,
  catch: () => _catch4,
  boolean: () => boolean5,
  bigint: () => bigint5,
  base64url: () => base64url4,
  base64: () => base644,
  array: () => array2,
  any: () => any2,
  _function: () => _function2,
  _default: () => _default4,
  _ZodString: () => _ZodString2,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID2,
  ZodVoid: () => ZodVoid2,
  ZodUnknown: () => ZodUnknown2,
  ZodUnion: () => ZodUnion2,
  ZodUndefined: () => ZodUndefined2,
  ZodUUID: () => ZodUUID2,
  ZodURL: () => ZodURL2,
  ZodULID: () => ZodULID2,
  ZodType: () => ZodType2,
  ZodTuple: () => ZodTuple2,
  ZodTransform: () => ZodTransform2,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodSymbol: () => ZodSymbol2,
  ZodSuccess: () => ZodSuccess2,
  ZodStringFormat: () => ZodStringFormat2,
  ZodString: () => ZodString2,
  ZodSet: () => ZodSet2,
  ZodRecord: () => ZodRecord2,
  ZodReadonly: () => ZodReadonly2,
  ZodPromise: () => ZodPromise2,
  ZodPrefault: () => ZodPrefault2,
  ZodPipe: () => ZodPipe2,
  ZodOptional: () => ZodOptional2,
  ZodObject: () => ZodObject2,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodNumber: () => ZodNumber2,
  ZodNullable: () => ZodNullable2,
  ZodNull: () => ZodNull2,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNever: () => ZodNever2,
  ZodNanoID: () => ZodNanoID2,
  ZodNaN: () => ZodNaN2,
  ZodMap: () => ZodMap2,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral2,
  ZodLazy: () => ZodLazy2,
  ZodKSUID: () => ZodKSUID2,
  ZodJWT: () => ZodJWT2,
  ZodIntersection: () => ZodIntersection2,
  ZodIPv6: () => ZodIPv62,
  ZodIPv4: () => ZodIPv42,
  ZodGUID: () => ZodGUID2,
  ZodFunction: () => ZodFunction2,
  ZodFile: () => ZodFile2,
  ZodExactOptional: () => ZodExactOptional,
  ZodEnum: () => ZodEnum2,
  ZodEmoji: () => ZodEmoji2,
  ZodEmail: () => ZodEmail2,
  ZodE164: () => ZodE1642,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodDefault: () => ZodDefault2,
  ZodDate: () => ZodDate2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodCustom: () => ZodCustom2,
  ZodCodec: () => ZodCodec2,
  ZodCatch: () => ZodCatch2,
  ZodCUID2: () => ZodCUID22,
  ZodCUID: () => ZodCUID3,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodBoolean: () => ZodBoolean2,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBigInt: () => ZodBigInt2,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBase64: () => ZodBase642,
  ZodArray: () => ZodArray2,
  ZodAny: () => ZodAny2
});

// node_modules/zod/v4/classic/checks.js
var exports_checks4 = {};
__export(exports_checks4, {
  uppercase: () => _uppercase2,
  trim: () => _trim2,
  toUpperCase: () => _toUpperCase2,
  toLowerCase: () => _toLowerCase2,
  startsWith: () => _startsWith2,
  slugify: () => _slugify,
  size: () => _size2,
  regex: () => _regex2,
  property: () => _property2,
  positive: () => _positive2,
  overwrite: () => _overwrite2,
  normalize: () => _normalize2,
  nonpositive: () => _nonpositive2,
  nonnegative: () => _nonnegative2,
  negative: () => _negative2,
  multipleOf: () => _multipleOf2,
  minSize: () => _minSize2,
  minLength: () => _minLength2,
  mime: () => _mime2,
  maxSize: () => _maxSize2,
  maxLength: () => _maxLength2,
  lte: () => _lte2,
  lt: () => _lt2,
  lowercase: () => _lowercase2,
  length: () => _length2,
  includes: () => _includes2,
  gte: () => _gte2,
  gt: () => _gt2,
  endsWith: () => _endsWith2
});

// node_modules/zod/v4/classic/iso.js
var exports_iso2 = {};
__export(exports_iso2, {
  time: () => time4,
  duration: () => duration4,
  datetime: () => datetime4,
  date: () => date6,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2
});
var ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
  $ZodISODateTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
var ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
  $ZodISODate2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
var ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
  $ZodISOTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
var ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
  $ZodISODuration2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer4 = (inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError2(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError2(inst, mapper)
    },
    addIssue: {
      value: (issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError2 = $constructor2("ZodError", initializer4);
var ZodRealError2 = $constructor2("ZodError", initializer4, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse7 = /* @__PURE__ */ _parse2(ZodRealError2);
var parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
var safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
var safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
var encode4 = /* @__PURE__ */ _encode2(ZodRealError2);
var decode4 = /* @__PURE__ */ _decode2(ZodRealError2);
var encodeAsync4 = /* @__PURE__ */ _encodeAsync2(ZodRealError2);
var decodeAsync4 = /* @__PURE__ */ _decodeAsync2(ZodRealError2);
var safeEncode4 = /* @__PURE__ */ _safeEncode2(ZodRealError2);
var safeDecode4 = /* @__PURE__ */ _safeDecode2(ZodRealError2);
var safeEncodeAsync4 = /* @__PURE__ */ _safeEncodeAsync2(ZodRealError2);
var safeDecodeAsync4 = /* @__PURE__ */ _safeDecodeAsync2(ZodRealError2);

// node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
  $ZodType2.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks4) => {
    return inst.clone(exports_util2.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks4.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  };
  inst.parse = (data, params) => parse7(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse4(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode4(inst, data, params);
  inst.decode = (data, params) => decode4(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync4(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync4(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode4(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode4(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync4(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync4(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine2(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite2(fn));
  inst.optional = () => optional2(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable2(inst);
  inst.nullish = () => optional2(nullable2(inst));
  inst.nonoptional = (params) => nonoptional2(inst, params);
  inst.array = () => array2(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection2(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform2(tx));
  inst.default = (def2) => _default4(inst, def2);
  inst.prefault = (def2) => prefault2(inst, def2);
  inst.catch = (params) => _catch4(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly2(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry2.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry2.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry2.get(inst);
    }
    const cl = inst.clone();
    globalRegistry2.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex2(...args));
  inst.includes = (...args) => inst.check(_includes2(...args));
  inst.startsWith = (...args) => inst.check(_startsWith2(...args));
  inst.endsWith = (...args) => inst.check(_endsWith2(...args));
  inst.min = (...args) => inst.check(_minLength2(...args));
  inst.max = (...args) => inst.check(_maxLength2(...args));
  inst.length = (...args) => inst.check(_length2(...args));
  inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase2(params));
  inst.uppercase = (params) => inst.check(_uppercase2(params));
  inst.trim = () => inst.check(_trim2());
  inst.normalize = (...args) => inst.check(_normalize2(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase2());
  inst.toUpperCase = () => inst.check(_toUpperCase2());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString2 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  _ZodString2.init(inst, def);
  inst.email = (params) => inst.check(_email2(ZodEmail2, params));
  inst.url = (params) => inst.check(_url2(ZodURL2, params));
  inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
  inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
  inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
  inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
  inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
  inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
  inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
  inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
  inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
  inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
  inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
  inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
  inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
  inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
  inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
  inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
  inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
  inst.datetime = (params) => inst.check(datetime4(params));
  inst.date = (params) => inst.check(date6(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration4(params));
});
function string5(params) {
  return _string2(ZodString2, params);
}
var ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  _ZodString2.init(inst, def);
});
var ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
  $ZodEmail2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function email4(params) {
  return _email2(ZodEmail2, params);
}
var ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
  $ZodGUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function guid4(params) {
  return _guid2(ZodGUID2, params);
}
var ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
  $ZodUUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function uuid5(params) {
  return _uuid2(ZodUUID2, params);
}
function uuidv42(params) {
  return _uuidv42(ZodUUID2, params);
}
function uuidv62(params) {
  return _uuidv62(ZodUUID2, params);
}
function uuidv72(params) {
  return _uuidv72(ZodUUID2, params);
}
var ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
  $ZodURL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function url2(params) {
  return _url2(ZodURL2, params);
}
function httpUrl2(params) {
  return _url2(ZodURL2, {
    protocol: /^https?$/,
    hostname: exports_regexes2.domain,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
  $ZodEmoji2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function emoji4(params) {
  return _emoji4(ZodEmoji2, params);
}
var ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
  $ZodNanoID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function nanoid4(params) {
  return _nanoid2(ZodNanoID2, params);
}
var ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
  $ZodCUID3.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid6(params) {
  return _cuid3(ZodCUID3, params);
}
var ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
  $ZodCUID22.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid24(params) {
  return _cuid22(ZodCUID22, params);
}
var ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
  $ZodULID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ulid4(params) {
  return _ulid2(ZodULID2, params);
}
var ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
  $ZodXID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function xid4(params) {
  return _xid2(ZodXID2, params);
}
var ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
  $ZodKSUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ksuid4(params) {
  return _ksuid2(ZodKSUID2, params);
}
var ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
  $ZodIPv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv44(params) {
  return _ipv42(ZodIPv42, params);
}
var ZodMAC = /* @__PURE__ */ $constructor2("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
  $ZodIPv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv64(params) {
  return _ipv62(ZodIPv62, params);
}
var ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv44(params) {
  return _cidrv42(ZodCIDRv42, params);
}
var ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv64(params) {
  return _cidrv62(ZodCIDRv62, params);
}
var ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
  $ZodBase642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base644(params) {
  return _base642(ZodBase642, params);
}
var ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
  $ZodBase64URL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base64url4(params) {
  return _base64url2(ZodBase64URL2, params);
}
var ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
  $ZodE1642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function e1644(params) {
  return _e1642(ZodE1642, params);
}
var ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
  $ZodJWT2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function jwt2(params) {
  return _jwt2(ZodJWT2, params);
}
var ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function stringFormat2(format, fnOrRegex, _params = {}) {
  return _stringFormat2(ZodCustomStringFormat2, format, fnOrRegex, _params);
}
function hostname4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hostname", exports_regexes2.hostname, _params);
}
function hex4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hex", exports_regexes2.hex, _params);
}
function hash2(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes2[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat2(ZodCustomStringFormat2, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
  $ZodNumber2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params);
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt2(0, params));
  inst.nonnegative = (params) => inst.check(_gte2(0, params));
  inst.negative = (params) => inst.check(_lt2(0, params));
  inst.nonpositive = (params) => inst.check(_lte2(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  inst.step = (value, params) => inst.check(_multipleOf2(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number5(params) {
  return _number2(ZodNumber2, params);
}
var ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat2.init(inst, def);
  ZodNumber2.init(inst, def);
});
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
function float322(params) {
  return _float322(ZodNumberFormat2, params);
}
function float642(params) {
  return _float642(ZodNumberFormat2, params);
}
function int322(params) {
  return _int322(ZodNumberFormat2, params);
}
function uint322(params) {
  return _uint322(ZodNumberFormat2, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
  $ZodBoolean2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean5(params) {
  return _boolean2(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor2("ZodBigInt", (inst, def) => {
  $ZodBigInt2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params);
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.positive = (params) => inst.check(_gt2(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt2(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte2(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte2(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint5(params) {
  return _bigint2(ZodBigInt2, params);
}
var ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat2.init(inst, def);
  ZodBigInt2.init(inst, def);
});
function int642(params) {
  return _int642(ZodBigIntFormat2, params);
}
function uint642(params) {
  return _uint642(ZodBigIntFormat2, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor2("ZodSymbol", (inst, def) => {
  $ZodSymbol2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol2(params) {
  return _symbol2(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor2("ZodUndefined", (inst, def) => {
  $ZodUndefined2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined6(params) {
  return _undefined5(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
  $ZodNull2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null6(params) {
  return _null5(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor2("ZodAny", (inst, def) => {
  $ZodAny2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any2() {
  return _any2(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
  $ZodUnknown2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown2() {
  return _unknown2(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
  $ZodNever2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never2(params) {
  return _never2(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor2("ZodVoid", (inst, def) => {
  $ZodVoid2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void4(params) {
  return _void3(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor2("ZodDate", (inst, def) => {
  $ZodDate2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params);
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date7(params) {
  return _date2(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
  $ZodArray2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength2(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
  inst.length = (len, params) => inst.check(_length2(len, params));
  inst.unwrap = () => inst.element;
});
function array2(element, params) {
  return _array2(ZodArray2, element, params);
}
function keyof2(schema) {
  const shape = schema._zod.def.shape;
  return _enum4(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
  $ZodObjectJIT2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params);
  exports_util2.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum4(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util2.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util2.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util2.merge(inst, other);
  inst.pick = (mask) => exports_util2.pick(inst, mask);
  inst.omit = (mask) => exports_util2.omit(inst, mask);
  inst.partial = (...args) => exports_util2.partial(ZodOptional2, inst, args[0]);
  inst.required = (...args) => exports_util2.required(ZodNonOptional2, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: never2(),
    ...exports_util2.normalizeParams(params)
  });
}
function looseObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: unknown2(),
    ...exports_util2.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor2("ZodXor", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodDiscriminatedUnion2.init(inst, def);
});
function discriminatedUnion2(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
  $ZodIntersection2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection2(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor2("ZodTuple", (inst, def) => {
  $ZodTuple2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple2(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
  $ZodRecord2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record2(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function partialRecord2(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = undefined;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...exports_util2.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor2("ZodMap", (inst, def) => {
  $ZodMap2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize2(...args));
  inst.nonempty = (params) => inst.check(_minSize2(1, params));
  inst.max = (...args) => inst.check(_maxSize2(...args));
  inst.size = (...args) => inst.check(_size2(...args));
});
function map2(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor2("ZodSet", (inst, def) => {
  $ZodSet2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params);
  inst.min = (...args) => inst.check(_minSize2(...args));
  inst.nonempty = (params) => inst.check(_minSize2(1, params));
  inst.max = (...args) => inst.check(_maxSize2(...args));
  inst.size = (...args) => inst.check(_size2(...args));
});
function set2(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
  $ZodEnum2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function nativeEnum2(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
  $ZodLiteral2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal2(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util2.normalizeParams(params)
  });
}
var ZodFile2 = /* @__PURE__ */ $constructor2("ZodFile", (inst, def) => {
  $ZodFile2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params);
  inst.min = (size, params) => inst.check(_minSize2(size, params));
  inst.max = (size, params) => inst.check(_maxSize2(size, params));
  inst.mime = (types, params) => inst.check(_mime2(Array.isArray(types) ? types : [types], params));
});
function file2(params) {
  return _file2(ZodFile2, params);
}
var ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
  $ZodTransform2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(exports_util2.issue(issue3, payload.value, def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util2.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor2("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
  $ZodNullable2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable2(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish4(innerType) {
  return optional2(nullable2(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
  $ZodDefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default4(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
  $ZodPrefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
  $ZodNonOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSuccess2 = /* @__PURE__ */ $constructor2("ZodSuccess", (inst, def) => {
  $ZodSuccess2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success2(innerType) {
  return new ZodSuccess2({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
  $ZodCatch2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch4(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor2("ZodNaN", (inst, def) => {
  $ZodNaN2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan2(params) {
  return _nan2(ZodNaN2, params);
}
var ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
  $ZodPipe2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec2 = /* @__PURE__ */ $constructor2("ZodCodec", (inst, def) => {
  ZodPipe2.init(inst, def);
  $ZodCodec2.init(inst, def);
});
function codec2(in_, out, params) {
  return new ZodCodec2({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
  $ZodReadonly2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly2(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral2(parts, params) {
  return new ZodTemplateLiteral2({
    type: "template_literal",
    parts,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor2("ZodLazy", (inst, def) => {
  $ZodLazy2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy2(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor2("ZodPromise", (inst, def) => {
  $ZodPromise2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise2(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor2("ZodFunction", (inst, def) => {
  $ZodFunction2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function2(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple2(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
var ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
  $ZodCustom2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  return _superRefine2(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof2(cls, params = {}) {
  const inst = new ZodCustom2({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool2 = (...args) => _stringbool2({
  Codec: ZodCodec2,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json2(params) {
  const jsonSchema = lazy2(() => {
    return union2([string5(params), number5(), boolean5(), _null6(), array2(jsonSchema), record2(string5(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess2(fn, schema) {
  return pipe2(transform2(fn), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode2 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap2(map3) {
  config2({
    customError: map3
  });
}
function getErrorMap2() {
  return config2().customError;
}
var ZodFirstPartyTypeKind2;
(function(ZodFirstPartyTypeKind3) {})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
// node_modules/zod/v4/classic/from-json-schema.js
var z2 = {
  ...exports_schemas4,
  ...exports_checks4,
  iso: exports_iso2
};
var RECOGNIZED_KEYS = new Set([
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  "type",
  "enum",
  "const",
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  "minLength",
  "maxLength",
  "pattern",
  "format",
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  "description",
  "default",
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path8 = ref.slice(1).split("/").filter(Boolean);
  if (path8.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path8[0] === defsKey) {
    const key = path8[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== undefined) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z2.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== undefined) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== undefined) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z2.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== undefined) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z2.null();
    }
    if (enumValues.length === 0) {
      return z2.never();
    }
    if (enumValues.length === 1) {
      return z2.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z2.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z2.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z2.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== undefined) {
    return z2.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z2.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z2.union(typeSchemas);
  }
  if (!type) {
    return z2.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z2.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z2.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z2.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z2.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z2.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z2.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z2.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z2.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z2.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z2.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z2.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z2.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z2.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z2.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z2.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z2.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z2.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z2.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z2.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z2.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z2.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z2.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z2.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z2.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z2.number().int() : z2.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z2.boolean();
      break;
    }
    case "null": {
      zodSchema = z2.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z2.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z2.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z2.object(shape).passthrough();
        const recordSchema = z2.looseRecord(keySchema, valueSchema);
        zodSchema = z2.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z2.string().regex(new RegExp(pattern));
          looseRecords.push(z2.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z2.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z2.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z2.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2;i < schemasToIntersect.length; i++) {
            result = z2.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z2.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : undefined;
        if (rest) {
          zodSchema = z2.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z2.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z2.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z2.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : undefined;
        if (rest) {
          zodSchema = z2.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z2.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z2.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z2.maxLength(schema.maxItems));
        }
      } else if (items !== undefined) {
        const element = convertSchema(items, ctx);
        let arraySchema = z2.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z2.array(z2.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== undefined) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z2.any() : z2.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z2.union(options);
    baseSchema = hasExplicitType ? z2.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z2.xor(options);
    baseSchema = hasExplicitType ? z2.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z2.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx;i < schema.allOf.length; i++) {
        result = z2.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z2.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z2.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z2.any() : z2.never();
  }
  const version3 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version3,
    defs,
    refs: new Map,
    processing: new Set,
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry2
  };
  return convertSchema(schema, ctx);
}
// node_modules/zod/v4/classic/coerce.js
var exports_coerce2 = {};
__export(exports_coerce2, {
  string: () => string6,
  number: () => number6,
  date: () => date8,
  boolean: () => boolean6,
  bigint: () => bigint6
});
function string6(params) {
  return _coercedString2(ZodString2, params);
}
function number6(params) {
  return _coercedNumber2(ZodNumber2, params);
}
function boolean6(params) {
  return _coercedBoolean2(ZodBoolean2, params);
}
function bigint6(params) {
  return _coercedBigint2(ZodBigInt2, params);
}
function date8(params) {
  return _coercedDate2(ZodDate2, params);
}

// node_modules/zod/v4/classic/external.js
config2(en_default2());
// src/daemon/ws-protocol.ts
var JsonValue = exports_external2.lazy(() => exports_external2.union([
  exports_external2.string(),
  exports_external2.number(),
  exports_external2.boolean(),
  exports_external2.null(),
  exports_external2.array(JsonValue),
  exports_external2.record(exports_external2.string(), JsonValue)
]));
var JsonObject = exports_external2.record(exports_external2.string(), JsonValue);
var DaemonHelloFrameSchema = exports_external2.object({
  type: exports_external2.literal("hello"),
  clientID: exports_external2.string().min(1).max(120).optional(),
  role: exports_external2.enum(["plugin", "ui", "unknown"]).default("plugin"),
  protocolVersion: exports_external2.string().default("1.0"),
  auth: exports_external2.object({
    token: exports_external2.string().min(1)
  }).optional()
});
var DaemonRequestFrameSchema = exports_external2.object({
  type: exports_external2.literal("request"),
  id: exports_external2.string().min(1),
  method: exports_external2.string().min(1),
  params: JsonObject.default({})
});
var DaemonResponseFrameSchema = exports_external2.object({
  type: exports_external2.literal("response"),
  id: exports_external2.string(),
  ok: exports_external2.boolean(),
  result: JsonValue.optional(),
  error: exports_external2.object({
    code: exports_external2.string(),
    message: exports_external2.string(),
    details: JsonValue.optional()
  }).optional()
});
var DaemonEventFrameSchema = exports_external2.object({
  type: exports_external2.literal("event"),
  event: exports_external2.string().min(1),
  payload: JsonValue
});
var DaemonPingFrameSchema = exports_external2.object({
  type: exports_external2.literal("ping"),
  ts: exports_external2.number().int().nonnegative()
});
var DaemonPongFrameSchema = exports_external2.object({
  type: exports_external2.literal("pong"),
  ts: exports_external2.number().int().nonnegative()
});
var DaemonIncomingFrameSchema = exports_external2.union([
  DaemonHelloFrameSchema,
  DaemonRequestFrameSchema,
  DaemonPingFrameSchema
]);
var DaemonOutgoingFrameSchema = exports_external2.union([
  DaemonResponseFrameSchema,
  DaemonEventFrameSchema,
  DaemonPongFrameSchema
]);
function parseDaemonOutgoingFrame(input) {
  try {
    const value = typeof input === "string" ? JSON.parse(input) : input;
    const frame = DaemonOutgoingFrameSchema.parse(value);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}

// src/daemon/launcher.ts
var runtimes = new Map;
function launcherIdlePruneMs() {
  return Math.max(5000, Number(process.env.MIYA_DAEMON_IDLE_PRUNE_MS ?? 15000));
}
function touchRuntime(runtime) {
  runtime.lastAccessAtMs = Date.now();
}
function pruneIdleRuntimes(exceptProjectDir) {
  const now = Date.now();
  const idleMs = launcherIdlePruneMs();
  for (const [projectDir, runtime] of runtimes) {
    if (exceptProjectDir && projectDir === exceptProjectDir)
      continue;
    if (runtime.pending.size > 0)
      continue;
    if (runtime.listeners.size > 0)
      continue;
    if (now - runtime.lastAccessAtMs < idleMs)
      continue;
    cleanupRuntime(runtime);
    if (runtime.lifecycleMode !== "service_experimental") {
      cleanupExistingDaemon(projectDir);
    }
    try {
      fs8.rmSync(runtime.parentLockFile, { force: true });
    } catch {}
    runtimes.delete(projectDir);
  }
}
function emitLauncherEvent(runtime, type, payload) {
  if (runtime.listeners.size === 0)
    return;
  const event = {
    type,
    at: nowIso4(),
    payload,
    snapshot: { ...runtime.snapshot }
  };
  for (const listener of runtime.listeners) {
    try {
      listener(event);
    } catch {}
  }
}
function syncBackpressureSnapshot(runtime) {
  runtime.snapshot.pendingRequests = runtime.pending.size;
  runtime.snapshot.rejectedRequests = runtime.rejectedRequests;
  runtime.snapshot.lastRejectReason = runtime.lastRejectReason;
}
function nowIso4() {
  return new Date().toISOString();
}
function parsePsycheSignalHubSnapshot(raw) {
  if (!raw || typeof raw !== "object" || Array.isArray(raw))
    return;
  const row = raw;
  const running = row.running === true;
  const sequence = Number(row.sequence);
  const ageMs = Number(row.ageMs);
  const stale = row.stale === true;
  const consecutiveFailures = Number(row.consecutiveFailures);
  const sampleIntervalMs = Number(row.sampleIntervalMs);
  const burstIntervalMs = Number(row.burstIntervalMs);
  const staleAfterMs = Number(row.staleAfterMs);
  if (!Number.isFinite(sequence) || !Number.isFinite(ageMs) || !Number.isFinite(consecutiveFailures) || !Number.isFinite(sampleIntervalMs) || !Number.isFinite(burstIntervalMs) || !Number.isFinite(staleAfterMs)) {
    return;
  }
  return {
    running,
    sequence: Math.max(0, Math.floor(sequence)),
    sampledAt: typeof row.sampledAt === "string" ? row.sampledAt : undefined,
    ageMs: Math.max(0, Math.floor(ageMs)),
    stale,
    consecutiveFailures: Math.max(0, Math.floor(consecutiveFailures)),
    lastError: typeof row.lastError === "string" && row.lastError.trim().length > 0 ? row.lastError.trim() : undefined,
    sampleIntervalMs: Math.max(0, Math.floor(sampleIntervalMs)),
    burstIntervalMs: Math.max(0, Math.floor(burstIntervalMs)),
    staleAfterMs: Math.max(0, Math.floor(staleAfterMs))
  };
}
function daemonDir(projectDir) {
  return path8.join(getMiyaRuntimeDir(projectDir), "daemon");
}
function daemonPidFile(projectDir) {
  return path8.join(daemonDir(projectDir), "daemon.pid");
}
function daemonLauncherStoreFile(projectDir) {
  return path8.join(daemonDir(projectDir), "launcher.runtime.json");
}
function daemonLogFile(projectDir, kind) {
  return path8.join(daemonDir(projectDir), kind === "stdout" ? "host.stdout.log" : "host.stderr.log");
}
function ensureDaemonDir(projectDir) {
  fs8.mkdirSync(daemonDir(projectDir), { recursive: true });
}
function safeWriteJson(filePath, payload) {
  fs8.mkdirSync(path8.dirname(filePath), { recursive: true });
  fs8.writeFileSync(filePath, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
}
function safeReadJson(filePath) {
  if (!fs8.existsSync(filePath))
    return null;
  try {
    const parsed = JSON.parse(fs8.readFileSync(filePath, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed))
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function toDaemonLock(raw) {
  if (!raw)
    return null;
  const pid = Number(raw.pid);
  const wsPort = Number(raw.wsPort);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  if (!Number.isFinite(pid) || !Number.isFinite(wsPort) || !token || !updatedAt)
    return null;
  return { pid, wsPort, token, updatedAt };
}
function readLauncherPersistedState(projectDir) {
  const parsed = safeReadJson(daemonLauncherStoreFile(projectDir));
  const desiredState = parsed?.desiredState === "stopped" || parsed?.desired_state === "stopped" ? "stopped" : "running";
  return {
    desiredState,
    runEpoch: Math.max(1, Math.floor(Number(parsed?.runEpoch ?? 1))),
    retryHalted: parsed?.retryHalted === true,
    retryHaltedUntilMs: Math.max(0, Math.floor(Number(parsed?.retryHaltedUntilMs ?? 0))),
    consecutiveLaunchFailures: Math.max(0, Math.floor(Number(parsed?.consecutiveLaunchFailures ?? 0))),
    lastRejectReason: typeof parsed?.lastRejectReason === "string" && parsed.lastRejectReason.trim().length > 0 ? parsed.lastRejectReason : undefined,
    manualStopUntilMs: Math.max(0, Math.floor(Number(parsed?.manualStopUntilMs ?? 0)))
  };
}
function writeLauncherPersistedState(runtime) {
  safeWriteJson(runtime.runtimeStoreFile, {
    desiredState: runtime.desiredState,
    runEpoch: runtime.runEpoch,
    retryHalted: runtime.retryHalted,
    retryHaltedUntilMs: runtime.retryHaltedUntilMs,
    consecutiveLaunchFailures: runtime.consecutiveLaunchFailures,
    lastRejectReason: runtime.lastRejectReason,
    manualStopUntilMs: runtime.manualStopUntilMs,
    updatedAt: nowIso4()
  });
}
function resolveHostScriptPath() {
  const here = path8.dirname(fileURLToPath(import.meta.url));
  const tsFile = path8.join(here, "host.ts");
  const jsFile = path8.join(here, "host.js");
  if (fs8.existsSync(tsFile))
    return tsFile;
  return jsFile;
}
function noteLaunchFailure(runtime, reason) {
  runtime.consecutiveLaunchFailures += 1;
  runtime.lastRejectReason = reason;
  if (runtime.consecutiveLaunchFailures >= runtime.maxConsecutiveLaunchFailures) {
    runtime.retryHalted = true;
    runtime.retryHaltedUntilMs = Date.now() + runtime.retryHaltCooldownMs;
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = `Miya Daemon Retry Halted (${reason})`;
    setLifecycleState(runtime, "BACKOFF", runtime.snapshot.statusText);
  } else if (runtime.lifecycleState !== "STOPPING" && runtime.lifecycleState !== "STOPPED") {
    setLifecycleState(runtime, "DEGRADED", "Miya Daemon Reconnecting");
  }
  writeLauncherPersistedState(runtime);
  syncBackpressureSnapshot(runtime);
}
function resetLaunchFailureState(runtime) {
  runtime.consecutiveLaunchFailures = 0;
  runtime.retryHalted = false;
  runtime.retryHaltedUntilMs = 0;
  runtime.lastRejectReason = undefined;
  writeLauncherPersistedState(runtime);
  syncBackpressureSnapshot(runtime);
}
function resolveBunBinary() {
  if (process.platform === "win32") {
    const byExe = Bun.which("bun.exe");
    if (byExe)
      return byExe;
    const byBun = Bun.which("bun");
    if (byBun) {
      if (byBun.toLowerCase().endsWith(".cmd")) {
        const exeCandidate = byBun.slice(0, -4) + ".exe";
        if (fs8.existsSync(exeCandidate))
          return exeCandidate;
      }
      return byBun;
    }
  } else {
    const byWhich = Bun.which("bun") ?? Bun.which("bun.exe");
    if (byWhich)
      return byWhich;
  }
  const execBase = path8.basename(process.execPath).toLowerCase();
  if (execBase === "bun" || execBase === "bun.exe")
    return process.execPath;
  return null;
}
function resolveLifecycleMode(projectDir) {
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "service")
    return "service_experimental";
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "coupled")
    return "coupled";
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime ?? {};
  return runtime.service_mode_experimental === true ? "service_experimental" : "coupled";
}
function syncLifecycleSnapshot(runtime) {
  runtime.snapshot.desiredState = runtime.desiredState;
  runtime.snapshot.lifecycleState = runtime.lifecycleState;
  runtime.snapshot.runEpoch = runtime.runEpoch;
  runtime.snapshot.retryHalted = runtime.retryHalted;
  runtime.snapshot.retryHaltedUntil = runtime.retryHaltedUntilMs > 0 ? new Date(runtime.retryHaltedUntilMs).toISOString() : undefined;
  runtime.snapshot.manualStopUntil = runtime.manualStopUntilMs > 0 ? new Date(runtime.manualStopUntilMs).toISOString() : undefined;
}
function setLifecycleState(runtime, state, statusText) {
  runtime.lifecycleState = state;
  if (typeof statusText === "string" && statusText.trim().length > 0) {
    runtime.snapshot.statusText = statusText;
  }
  syncLifecycleSnapshot(runtime);
}
function shouldRunForEpoch(runtime, epoch) {
  if (runtime.desiredState !== "running")
    return false;
  if (runtime.runEpoch !== epoch)
    return false;
  if (Date.now() < runtime.manualStopUntilMs)
    return false;
  if (runtime.retryHalted) {
    if (runtime.retryHaltedUntilMs > 0 && Date.now() >= runtime.retryHaltedUntilMs) {
      resetLaunchFailureState(runtime);
      writeLauncherPersistedState(runtime);
      return true;
    }
    return false;
  }
  return true;
}
function requestRunningState(runtime, options) {
  const explicit = options?.explicit === true;
  let changed = false;
  if (explicit) {
    if (runtime.manualStopUntilMs !== 0) {
      runtime.manualStopUntilMs = 0;
      changed = true;
    }
    if (runtime.launchCooldownUntilMs !== 0) {
      runtime.launchCooldownUntilMs = 0;
      changed = true;
    }
    if (runtime.retryHalted || runtime.retryHaltedUntilMs > 0 || runtime.consecutiveLaunchFailures > 0 || runtime.lastRejectReason) {
      runtime.consecutiveLaunchFailures = 0;
      runtime.retryHalted = false;
      runtime.retryHaltedUntilMs = 0;
      runtime.lastRejectReason = undefined;
      changed = true;
      syncBackpressureSnapshot(runtime);
    }
  }
  if (runtime.desiredState !== "running") {
    runtime.desiredState = "running";
    runtime.runEpoch += 1;
    changed = true;
    if (runtime.lifecycleState === "STOPPED" || runtime.lifecycleState === "STOPPING") {
      setLifecycleState(runtime, "STARTING", "Miya Daemon Booting");
    }
  } else if (runtime.lifecycleState === "STOPPED" || runtime.lifecycleState === "STOPPING") {
    setLifecycleState(runtime, "STARTING", "Miya Daemon Booting");
    changed = true;
  }
  if (changed) {
    writeLauncherPersistedState(runtime);
  }
  syncLifecycleSnapshot(runtime);
  return runtime.runEpoch;
}
function spawnDaemon(runtime) {
  const epoch = runtime.runEpoch;
  if (!shouldRunForEpoch(runtime, epoch)) {
    return "skipped";
  }
  if (runtime.lifecycleMode === "service_experimental") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Service Mode (attach only)";
    return "skipped";
  }
  const now = Date.now();
  if (now - runtime.lastSpawnAttemptAtMs < 3000) {
    return "skipped";
  }
  runtime.lastSpawnAttemptAtMs = now;
  cleanupExistingDaemon(runtime.projectDir);
  const bunBinary = resolveBunBinary();
  if (!bunBinary) {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (bun_not_found)";
    noteLaunchFailure(runtime, "bun_not_found");
    return "failed";
  }
  const binaryBase = path8.basename(bunBinary).toLowerCase();
  if (binaryBase.includes("powershell") || binaryBase === "pwsh.exe") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (invalid_runtime_binary)";
    noteLaunchFailure(runtime, "invalid_runtime_binary");
    return "failed";
  }
  const hostScript = resolveHostScriptPath();
  let hostStdout;
  let hostStderr;
  try {
    hostStdout = fs8.openSync(daemonLogFile(runtime.projectDir, "stdout"), "a");
    hostStderr = fs8.openSync(daemonLogFile(runtime.projectDir, "stderr"), "a");
    const child = spawn(bunBinary, [
      hostScript,
      "--project-dir",
      runtime.projectDir,
      "--parent-lock-file",
      runtime.parentLockFile,
      "--token",
      runtime.daemonToken
    ], {
      cwd: runtime.projectDir,
      detached: true,
      stdio: ["ignore", hostStdout, hostStderr],
      windowsHide: true
    });
    child.unref();
  } catch {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Spawn Failed";
    noteLaunchFailure(runtime, "spawn_failed");
    return "failed";
  } finally {
    if (typeof hostStdout === "number") {
      try {
        fs8.closeSync(hostStdout);
      } catch {}
    }
    if (typeof hostStderr === "number") {
      try {
        fs8.closeSync(hostStderr);
      } catch {}
    }
  }
  setLifecycleState(runtime, "STARTING", "Miya Daemon Booting");
  return "spawned";
}
function readPidFile(projectDir) {
  const file3 = daemonPidFile(projectDir);
  if (!fs8.existsSync(file3))
    return null;
  const raw = fs8.readFileSync(file3, "utf-8").trim();
  const pid = Number(raw);
  if (!Number.isFinite(pid) || pid <= 0)
    return null;
  return pid;
}
function isPidAlive(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function cleanupExistingDaemon(projectDir) {
  const stalePid = readPidFile(projectDir);
  if (!stalePid || !isPidAlive(stalePid))
    return;
  try {
    process.kill(stalePid);
  } catch {}
}
function writeParentLock(runtime) {
  safeWriteJson(runtime.parentLockFile, {
    pid: process.pid,
    plugin: "miya",
    updatedAt: nowIso4()
  });
}
function connectWebSocket(runtime, lock, epoch) {
  if (!shouldRunForEpoch(runtime, epoch))
    return;
  const url3 = `ws://127.0.0.1:${lock.wsPort}/ws?token=${encodeURIComponent(runtime.daemonToken)}`;
  const ws = new WebSocket(url3);
  runtime.ws = ws;
  setLifecycleState(runtime, "STARTING", "Miya Daemon Connecting");
  ws.onopen = () => {
    if (!shouldRunForEpoch(runtime, epoch)) {
      try {
        ws.close();
      } catch {}
      return;
    }
    resetLaunchFailureState(runtime);
    runtime.connected = true;
    runtime.reconnectBackoffMs = 1000;
    runtime.snapshot.statusText = "Miya Daemon Connected";
    runtime.snapshot.connected = true;
    runtime.snapshot.port = lock.wsPort;
    runtime.snapshot.pid = lock.pid;
    setLifecycleState(runtime, "CONNECTED", runtime.snapshot.statusText);
    const hello = DaemonHelloFrameSchema.parse({
      type: "hello",
      clientID: `plugin-${process.pid}`,
      role: "plugin",
      protocolVersion: "1.0",
      auth: { token: runtime.daemonToken }
    });
    ws.send(JSON.stringify(hello));
    startHeartbeat(runtime);
    startStatusPoll(runtime, epoch);
  };
  ws.onmessage = (event) => {
    if (runtime.runEpoch !== epoch)
      return;
    const parsed = parseDaemonOutgoingFrame(event.data);
    if (!parsed.frame)
      return;
    const frame = parsed.frame;
    if (frame.type === "pong") {
      runtime.lastPongAt = Date.now();
      if (runtime.pingWatchdog)
        clearTimeout(runtime.pingWatchdog);
      return;
    }
    if (frame.type === "response") {
      if (frame.id === "hello" && frame.ok)
        return;
      const pending = runtime.pending.get(frame.id);
      if (pending) {
        runtime.pending.delete(frame.id);
        clearTimeout(pending.timeout);
        syncBackpressureSnapshot(runtime);
        if (frame.ok) {
          pending.resolve(frame.result);
        } else {
          pending.reject(new Error(frame.error?.message ?? "daemon_request_failed"));
        }
      }
      return;
    }
    if (frame.type === "event" && frame.event === "daemon.ready") {
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.connected = true;
      emitLauncherEvent(runtime, "daemon.ready");
      return;
    }
    if (frame.type === "event" && frame.event === "job.progress") {
      const payload = frame.payload && typeof frame.payload === "object" && !Array.isArray(frame.payload) ? frame.payload : {};
      runtime.snapshot.activeJobID = typeof payload.jobID === "string" ? payload.jobID : runtime.snapshot.activeJobID;
      runtime.snapshot.activeJobProgress = typeof payload.progress === "number" ? Math.floor(payload.progress) : runtime.snapshot.activeJobProgress;
      runtime.snapshot.statusText = typeof payload.status === "string" && payload.status ? payload.status : runtime.snapshot.statusText;
      emitLauncherEvent(runtime, "job.progress", payload);
    }
  };
  ws.onerror = () => {
    if (runtime.runEpoch !== epoch)
      return;
    dispatchLifecycleEvent(runtime, {
      type: "ws.error",
      epoch,
      reason: "ws_error"
    });
  };
  ws.onclose = () => {
    if (runtime.runEpoch !== epoch)
      return;
    dispatchLifecycleEvent(runtime, {
      type: "ws.closed",
      epoch,
      reason: "ws_closed"
    });
  };
}
function daemonRequest(runtime, method, params, timeoutMs = 8000) {
  touchRuntime(runtime);
  if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN) {
    runtime.lastRejectReason = "ws_not_open";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(new Error("daemon_ws_not_open"));
  }
  if (runtime.pending.size >= runtime.maxPendingRequests) {
    runtime.lastRejectReason = "overloaded";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(new Error(`daemon_backpressure_overloaded:pending=${runtime.pending.size}:max=${runtime.maxPendingRequests}`));
  }
  runtime.reqSeq += 1;
  const id = `req-${runtime.reqSeq}`;
  const frame = DaemonRequestFrameSchema.parse({
    type: "request",
    id,
    method,
    params
  });
  return new Promise((resolve2, reject) => {
    const timeout = setTimeout(() => {
      runtime.pending.delete(id);
      runtime.lastRejectReason = "timeout";
      runtime.rejectedRequests += 1;
      syncBackpressureSnapshot(runtime);
      reject(new Error("daemon_request_timeout"));
    }, Math.max(1000, timeoutMs));
    runtime.pending.set(id, { resolve: resolve2, reject, timeout });
    syncBackpressureSnapshot(runtime);
    runtime.ws?.send(JSON.stringify(frame));
  });
}
function startHeartbeat(runtime) {
  stopHeartbeat(runtime);
  runtime.pingTimer = safeInterval("launcher.ping", 1e4, () => {
    if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN)
      return;
    const ping = DaemonPingFrameSchema.parse({
      type: "ping",
      ts: Date.now()
    });
    runtime.ws.send(JSON.stringify(ping));
    if (runtime.pingWatchdog)
      clearTimeout(runtime.pingWatchdog);
    runtime.pingWatchdog = setTimeout(() => {
      if (runtime.ws && runtime.ws.readyState === WebSocket.OPEN) {
        runtime.ws.close();
      }
    }, 30000);
  });
}
function stopHeartbeat(runtime) {
  if (runtime.pingTimer)
    clearInterval(runtime.pingTimer);
  runtime.pingTimer = undefined;
  if (runtime.pingWatchdog)
    clearTimeout(runtime.pingWatchdog);
  runtime.pingWatchdog = undefined;
}
function startStatusPoll(runtime, epoch) {
  stopStatusPoll(runtime);
  runtime.statusTimer = safeInterval("launcher.status.poll", 3000, async () => {
    if (!shouldRunForEpoch(runtime, epoch))
      return;
    try {
      const data = await daemonRequest(runtime, "daemon.status.get", {});
      if (!data || typeof data !== "object")
        return;
      runtime.snapshot.connected = true;
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.uptimeSec = typeof data.uptimeSec === "number" ? data.uptimeSec : runtime.snapshot.uptimeSec;
      runtime.snapshot.cpuPercent = typeof data.cpuPercent === "number" ? data.cpuPercent : runtime.snapshot.cpuPercent;
      runtime.snapshot.vramUsedMB = typeof data.vramUsedMB === "number" ? data.vramUsedMB : runtime.snapshot.vramUsedMB;
      runtime.snapshot.vramTotalMB = typeof data.vramTotalMB === "number" ? data.vramTotalMB : runtime.snapshot.vramTotalMB;
      runtime.snapshot.lastSeenAt = typeof data.lastSeenAt === "string" ? data.lastSeenAt : runtime.snapshot.lastSeenAt;
      runtime.snapshot.psycheSignalHub = parsePsycheSignalHubSnapshot(data.psycheSignalHub) ?? runtime.snapshot.psycheSignalHub;
    } catch (error92) {
      dispatchLifecycleEvent(runtime, {
        type: "health.fail",
        epoch,
        reason: error92 instanceof Error && error92.message.trim().length > 0 ? `status_poll:${error92.message.trim()}` : "status_poll_failed"
      });
    }
  });
}
function stopStatusPoll(runtime) {
  if (runtime.statusTimer)
    clearInterval(runtime.statusTimer);
  runtime.statusTimer = undefined;
}
function rejectPendingRequests(runtime, reason) {
  for (const [requestID, pending] of runtime.pending) {
    runtime.pending.delete(requestID);
    clearTimeout(pending.timeout);
    pending.reject(new Error(reason));
  }
  syncBackpressureSnapshot(runtime);
}
function scheduleReconnect(runtime, event) {
  const epoch = event.epoch;
  if (!shouldRunForEpoch(runtime, epoch))
    return;
  if (runtime.reconnectTimer)
    return;
  const wait = Math.max(250, Math.min(30000, typeof event.waitMs === "number" && Number.isFinite(event.waitMs) ? Math.floor(event.waitMs) : runtime.reconnectBackoffMs));
  runtime.reconnectBackoffMs = Math.min(Math.max(500, wait) * 2, 30000);
  setLifecycleState(runtime, "BACKOFF", `Miya Daemon Backoff (${wait}ms)`);
  runtime.reconnectTimer = setTimeout(() => {
    runtime.reconnectTimer = undefined;
    dispatchLifecycleEvent(runtime, {
      type: "reconnect.timer",
      epoch,
      reason: event.reason
    });
  }, wait);
}
function dispatchLifecycleEvent(runtime, event) {
  if (event.epoch !== runtime.runEpoch)
    return;
  switch (event.type) {
    case "reconnect.requested": {
      scheduleReconnect(runtime, {
        epoch: event.epoch,
        reason: event.reason,
        waitMs: event.waitMs
      });
      return;
    }
    case "reconnect.timer": {
      if (!shouldRunForEpoch(runtime, event.epoch))
        return;
      ensureDaemonLaunched(runtime, event.epoch);
      return;
    }
    case "ws.closed": {
      if (!shouldRunForEpoch(runtime, event.epoch))
        return;
      noteLaunchFailure(runtime, event.reason ?? "ws_closed");
      runtime.connected = false;
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Disconnected";
      setLifecycleState(runtime, "DEGRADED", runtime.snapshot.statusText);
      emitLauncherEvent(runtime, "daemon.disconnected");
      stopHeartbeat(runtime);
      stopStatusPoll(runtime);
      rejectPendingRequests(runtime, "daemon_ws_closed");
      runtime.ws = undefined;
      dispatchLifecycleEvent(runtime, {
        type: "reconnect.requested",
        epoch: event.epoch,
        reason: event.reason ?? "ws_closed"
      });
      return;
    }
    case "ws.error":
    case "health.fail": {
      if (!shouldRunForEpoch(runtime, event.epoch))
        return;
      runtime.connected = false;
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Reconnecting";
      if (runtime.lifecycleState !== "STOPPED" && runtime.lifecycleState !== "STOPPING") {
        setLifecycleState(runtime, "DEGRADED", runtime.snapshot.statusText);
      }
      if (runtime.ws && runtime.ws.readyState <= WebSocket.OPEN) {
        try {
          runtime.ws.close();
        } catch {}
      }
      dispatchLifecycleEvent(runtime, {
        type: "reconnect.requested",
        epoch: event.epoch,
        reason: event.reason ?? event.type
      });
      return;
    }
  }
}
function ensureDaemonLaunched(runtime, epoch = runtime.runEpoch) {
  if (!shouldRunForEpoch(runtime, epoch)) {
    if (Date.now() < runtime.manualStopUntilMs) {
      setLifecycleState(runtime, "STOPPED", "Miya Daemon Manual Cooldown");
      runtime.snapshot.connected = false;
    } else if (runtime.retryHalted) {
      setLifecycleState(runtime, "BACKOFF", "Miya Daemon Retry Halted");
      runtime.snapshot.connected = false;
    } else if (runtime.desiredState === "stopped") {
      setLifecycleState(runtime, "STOPPED", "Miya Daemon Stopped");
      runtime.snapshot.connected = false;
    }
    return;
  }
  writeParentLock(runtime);
  if (Date.now() < runtime.launchCooldownUntilMs) {
    return;
  }
  const lock = toDaemonLock(safeReadJson(runtime.daemonLockFile));
  const lockFresh = lock && Number.isFinite(Date.parse(lock.updatedAt)) && Date.now() - Date.parse(lock.updatedAt) < 30000;
  const lockOwnedByLauncher = runtime.lifecycleMode === "service_experimental" ? Boolean(lock) && (runtime.daemonToken ? lock?.token === runtime.daemonToken : true) : Boolean(lock) && lock?.token === runtime.daemonToken;
  if (!lockFresh || !lockOwnedByLauncher) {
    if (runtime.lifecycleMode === "service_experimental") {
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Service Mode (waiting for daemon lock)";
      setLifecycleState(runtime, "BACKOFF", runtime.snapshot.statusText);
      dispatchLifecycleEvent(runtime, {
        type: "reconnect.requested",
        epoch,
        reason: "service_mode_wait_lock"
      });
      return;
    }
    if (runtime.reconnectTimer) {
      return;
    }
    const spawnResult = spawnDaemon(runtime);
    if (spawnResult === "failed") {
      runtime.reconnectBackoffMs = Math.max(runtime.reconnectBackoffMs, 15000);
      runtime.launchCooldownUntilMs = Date.now() + 15000;
    }
    dispatchLifecycleEvent(runtime, {
      type: "reconnect.requested",
      epoch,
      reason: `spawn_${spawnResult}`
    });
    return;
  }
  if (!runtime.ws || runtime.ws.readyState >= WebSocket.CLOSING) {
    connectWebSocket(runtime, lock, epoch);
  }
}
function cleanupRuntime(runtime) {
  setLifecycleState(runtime, "STOPPING", "Miya Daemon Stopping");
  if (runtime.parentBeatTimer)
    clearInterval(runtime.parentBeatTimer);
  runtime.parentBeatTimer = undefined;
  if (runtime.reconnectTimer)
    clearTimeout(runtime.reconnectTimer);
  runtime.reconnectTimer = undefined;
  stopHeartbeat(runtime);
  stopStatusPoll(runtime);
  for (const pending of runtime.pending.values()) {
    clearTimeout(pending.timeout);
    pending.reject(new Error("launcher_shutdown"));
  }
  runtime.pending.clear();
  syncBackpressureSnapshot(runtime);
  runtime.listeners.clear();
  try {
    runtime.ws?.close();
  } catch {}
  runtime.ws = undefined;
  runtime.connected = false;
  runtime.snapshot.connected = false;
  setLifecycleState(runtime, "STOPPED", "Miya Daemon Stopped");
}
function ensureMiyaLauncher(projectDir) {
  pruneIdleRuntimes(projectDir);
  const existing = runtimes.get(projectDir);
  if (existing) {
    touchRuntime(existing);
    const shouldWake = existing.desiredState === "running";
    if (shouldWake) {
      const epoch2 = requestRunningState(existing);
      ensureDaemonLaunched(existing, epoch2);
    } else {
      existing.connected = false;
      existing.snapshot.connected = false;
      if (Date.now() < existing.manualStopUntilMs) {
        setLifecycleState(existing, "STOPPED", "Miya Daemon Manual Cooldown");
      } else {
        setLifecycleState(existing, "STOPPED", "Miya Daemon Stopped");
      }
    }
    syncBackpressureSnapshot(existing);
    return { ...existing.snapshot };
  }
  ensureDaemonDir(projectDir);
  const lifecycleMode = resolveLifecycleMode(projectDir);
  const config3 = readConfig(projectDir);
  const persisted = readLauncherPersistedState(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const configuredMaxPending = typeof backpressure?.daemon_max_pending_requests === "number" ? Number(backpressure.daemon_max_pending_requests) : Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64);
  const configuredMaxFailures = typeof backpressure?.daemon_max_consecutive_failures === "number" ? Number(backpressure.daemon_max_consecutive_failures) : Number(process.env.MIYA_DAEMON_MAX_CONSECUTIVE_FAILURES ?? 5);
  const configuredManualStopCooldown = typeof backpressure?.daemon_manual_stop_cooldown_ms === "number" ? Number(backpressure.daemon_manual_stop_cooldown_ms) : Number(process.env.MIYA_DAEMON_MANUAL_STOP_COOLDOWN_MS ?? 180000);
  const configuredRetryHaltCooldown = typeof backpressure?.daemon_retry_halt_cooldown_ms === "number" ? Number(backpressure.daemon_retry_halt_cooldown_ms) : Number(process.env.MIYA_DAEMON_RETRY_HALT_COOLDOWN_MS ?? 300000);
  const daemonToken = lifecycleMode === "service_experimental" ? String(process.env.MIYA_DAEMON_SERVICE_TOKEN ?? process.env.MIYA_DAEMON_TOKEN ?? "") : randomUUID();
  const desiredState = persisted.desiredState;
  const initialLifecycleState = desiredState === "stopped" ? "STOPPED" : persisted.retryHalted ? "BACKOFF" : "STARTING";
  const initialStatusText = lifecycleMode === "service_experimental" ? daemonToken ? "Miya Daemon Service Mode (attach only)" : "Miya Daemon Service Mode (token missing)" : desiredState === "stopped" ? Date.now() < persisted.manualStopUntilMs ? "Miya Daemon Manual Cooldown" : "Miya Daemon Stopped" : persisted.retryHalted ? "Miya Daemon Retry Halted" : "Miya Daemon Booting";
  const runtime = {
    projectDir,
    lifecycleMode,
    daemonToken,
    desiredState,
    lifecycleState: initialLifecycleState,
    runEpoch: Math.max(1, persisted.runEpoch),
    parentLockFile: path8.join(daemonDir(projectDir), "parent.lock.json"),
    daemonLockFile: path8.join(daemonDir(projectDir), "daemon.lock.json"),
    runtimeStoreFile: daemonLauncherStoreFile(projectDir),
    reconnectBackoffMs: 1000,
    connected: false,
    reqSeq: 0,
    pending: new Map,
    maxPendingRequests: Math.max(4, Math.floor(configuredMaxPending)),
    rejectedRequests: 0,
    lastRejectReason: undefined,
    listeners: new Set,
    lastSpawnAttemptAtMs: 0,
    launchCooldownUntilMs: 0,
    manualStopUntilMs: persisted.manualStopUntilMs,
    manualStopCooldownMs: Math.max(1e4, Math.floor(configuredManualStopCooldown)),
    consecutiveLaunchFailures: persisted.consecutiveLaunchFailures,
    retryHalted: persisted.retryHalted,
    retryHaltedUntilMs: persisted.retryHaltedUntilMs,
    retryHaltCooldownMs: Math.max(30000, Math.floor(configuredRetryHaltCooldown)),
    maxConsecutiveLaunchFailures: Math.max(1, Math.floor(configuredMaxFailures)),
    lastAccessAtMs: Date.now(),
    snapshot: {
      connected: false,
      statusText: initialStatusText,
      desiredState,
      lifecycleState: initialLifecycleState,
      runEpoch: Math.max(1, persisted.runEpoch),
      retryHalted: persisted.retryHalted,
      retryHaltedUntil: persisted.retryHaltedUntilMs > 0 ? new Date(persisted.retryHaltedUntilMs).toISOString() : undefined,
      manualStopUntil: persisted.manualStopUntilMs > 0 ? new Date(persisted.manualStopUntilMs).toISOString() : undefined,
      lifecycleMode,
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso4()
    }
  };
  syncLifecycleSnapshot(runtime);
  syncBackpressureSnapshot(runtime);
  runtimes.set(projectDir, runtime);
  writeLauncherPersistedState(runtime);
  writeParentLock(runtime);
  runtime.parentBeatTimer = safeInterval("launcher.parent.beat", 1e4, () => {
    writeParentLock(runtime);
  });
  const epoch = runtime.desiredState === "running" ? requestRunningState(runtime) : runtime.runEpoch;
  ensureDaemonLaunched(runtime, epoch);
  return { ...runtime.snapshot };
}
function getLauncherDaemonSnapshot(projectDir) {
  const runtime = runtimes.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      statusText: "Miya Daemon Not Started",
      desiredState: "stopped",
      lifecycleState: "STOPPED",
      runEpoch: 0,
      retryHalted: false,
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso4()
    };
  }
  touchRuntime(runtime);
  syncLifecycleSnapshot(runtime);
  syncBackpressureSnapshot(runtime);
  return { ...runtime.snapshot };
}
function getLauncherBackpressureStats(projectDir) {
  const runtime = runtimes.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      maxPendingRequests: Math.max(4, Math.floor(Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64))),
      pendingRequests: 0,
      rejectedRequests: 0
    };
  }
  touchRuntime(runtime);
  syncBackpressureSnapshot(runtime);
  return {
    connected: runtime.connected,
    maxPendingRequests: runtime.maxPendingRequests,
    pendingRequests: runtime.snapshot.pendingRequests,
    rejectedRequests: runtime.snapshot.rejectedRequests,
    lastRejectReason: runtime.snapshot.lastRejectReason
  };
}
function stopMiyaLauncher(projectDir) {
  const runtime = runtimes.get(projectDir);
  if (!runtime) {
    const persisted = readLauncherPersistedState(projectDir);
    const manualStopCooldownMs = Math.max(1e4, Math.floor(Number(process.env.MIYA_DAEMON_MANUAL_STOP_COOLDOWN_MS ?? 180000)));
    safeWriteJson(daemonLauncherStoreFile(projectDir), {
      ...persisted,
      desiredState: "stopped",
      runEpoch: Math.max(1, persisted.runEpoch) + 1,
      manualStopUntilMs: Date.now() + manualStopCooldownMs,
      updatedAt: nowIso4()
    });
    return;
  }
  touchRuntime(runtime);
  runtime.desiredState = "stopped";
  runtime.runEpoch += 1;
  runtime.manualStopUntilMs = Date.now() + runtime.manualStopCooldownMs;
  runtime.connected = false;
  runtime.snapshot.connected = false;
  setLifecycleState(runtime, "STOPPING", "Miya Daemon Stopping");
  writeLauncherPersistedState(runtime);
  cleanupRuntime(runtime);
  if (runtime.lifecycleMode !== "service_experimental") {
    cleanupExistingDaemon(projectDir);
  }
  try {
    fs8.rmSync(runtime.parentLockFile, { force: true });
  } catch {}
  writeLauncherPersistedState(runtime);
  runtimes.delete(projectDir);
}
function subscribeLauncherEvents(projectDir, listener) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes.get(projectDir);
  if (!runtime)
    return () => {};
  touchRuntime(runtime);
  runtime.listeners.add(listener);
  return () => {
    const current = runtimes.get(projectDir);
    current?.listeners.delete(listener);
  };
}
async function waitForDaemonConnection(runtime, timeoutMs) {
  const epoch = requestRunningState(runtime, { explicit: true });
  if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected)
    return;
  const startedAt = Date.now();
  while (Date.now() - startedAt < timeoutMs) {
    ensureDaemonLaunched(runtime, epoch);
    if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected)
      return;
    await new Promise((resolve2) => setTimeout(resolve2, 150));
  }
  throw new Error("daemon_connect_timeout");
}
async function daemonInvoke(projectDir, method, params, timeoutMs = 60000) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes.get(projectDir);
  if (!runtime)
    throw new Error("daemon_runtime_missing");
  touchRuntime(runtime);
  await waitForDaemonConnection(runtime, Math.min(timeoutMs, 15000));
  return daemonRequest(runtime, method, params, timeoutMs);
}
process.on("exit", () => {
  for (const runtime of runtimes.values()) {
    cleanupRuntime(runtime);
    try {
      fs8.rmSync(runtime.parentLockFile, { force: true });
    } catch {}
  }
});

// src/daemon/client.ts
class MiyaClient {
  projectDir;
  constructor(projectDir) {
    this.projectDir = projectDir;
    ensureMiyaLauncher(projectDir);
  }
  async runFluxImageGenerate(input) {
    return daemonInvoke(this.projectDir, "daemon.flux.generate", input, 240000);
  }
  async runSovitsTts(input) {
    return daemonInvoke(this.projectDir, "daemon.sovits.tts", input, 180000);
  }
  async runAsrTranscribe(input) {
    return daemonInvoke(this.projectDir, "daemon.asr.transcribe", input, 180000);
  }
  async runFluxTraining(input) {
    return daemonInvoke(this.projectDir, "daemon.training.flux", input, 35 * 60000);
  }
  async runSovitsTraining(input) {
    return daemonInvoke(this.projectDir, "daemon.training.sovits", input, 35 * 60000);
  }
  async requestTrainingCancel(jobID) {
    await daemonInvoke(this.projectDir, "daemon.training.cancel", { jobID }, 15000);
  }
  async getPythonRuntimeStatus() {
    return daemonInvoke(this.projectDir, "daemon.python.env.get", {}, 15000);
  }
  async getModelLockStatus() {
    return daemonInvoke(this.projectDir, "daemon.model.locks.get", {}, 15000);
  }
  async getModelUpdatePlan(target) {
    return daemonInvoke(this.projectDir, "daemon.model.update.plan", target ? { target } : {}, 20000);
  }
  async applyModelUpdate(target) {
    return daemonInvoke(this.projectDir, "daemon.model.update.apply", target ? { target } : {}, 30000);
  }
  async runIsolatedProcess(input) {
    return daemonInvoke(this.projectDir, "daemon.process.run_isolated", input, Math.max(30000, input.timeoutMs ?? 120000) + 1e4);
  }
  async psycheConsult(input) {
    return daemonInvoke(this.projectDir, "daemon.psyche.consult", input, 15000);
  }
  async psycheOutcome(input) {
    return daemonInvoke(this.projectDir, "daemon.psyche.outcome", input, 15000);
  }
  async psycheSignalsGet() {
    return daemonInvoke(this.projectDir, "daemon.psyche.signals.get", {}, 1e4);
  }
  async psycheSlowBrainGet() {
    return daemonInvoke(this.projectDir, "daemon.psyche.slowbrain.get", {}, 1e4);
  }
  async psycheSlowBrainRetrain(input) {
    return daemonInvoke(this.projectDir, "daemon.psyche.slowbrain.retrain", {
      force: input?.force === true,
      minOutcomes: typeof input?.minOutcomes === "number" && Number.isFinite(input.minOutcomes) ? input.minOutcomes : undefined
    }, 20000);
  }
  async psycheSlowBrainRollback(versionID) {
    return daemonInvoke(this.projectDir, "daemon.psyche.slowbrain.rollback", { versionID: versionID?.trim() || undefined }, 15000);
  }
}
var clients = new Map;
function getMiyaClient(projectDir) {
  const existing = clients.get(projectDir);
  if (existing)
    return existing;
  const created = new MiyaClient(projectDir);
  clients.set(projectDir, created);
  return created;
}

// src/daemon/python-runtime.ts
import * as path9 from "node:path";
function venvDir(projectDir) {
  return path9.join(getMiyaRuntimeDir(projectDir), "venv");
}
function venvPythonPath(projectDir) {
  return process.platform === "win32" ? path9.join(venvDir(projectDir), "Scripts", "python.exe") : path9.join(venvDir(projectDir), "bin", "python");
}

// src/adapters/standard.ts
function toAdapterEvidence(input) {
  return {
    kind: "adapter.execution",
    version: "v1",
    adapter: input.adapter,
    auditID: input.auditID,
    ok: input.ok,
    summary: input.summary,
    raw: input.raw,
    diagnostics: input.diagnostics
  };
}

// src/adapters/openclaw/client.ts
class OpenClawAdapter {
  projectDir;
  constructor(projectDir) {
    this.projectDir = projectDir;
  }
  validateInput(input) {
    return Boolean(input && typeof input.method === "string" && input.method.trim().length > 0);
  }
  injectPermission(auditID) {
    return {
      audit_id: auditID,
      adapter: "openclaw"
    };
  }
  async execute(input) {
    if (!this.validateInput(input)) {
      return {
        ok: false,
        error: {
          code: "invalid_input",
          message: "openclaw_adapter_input_invalid"
        }
      };
    }
    const req = {
      id: `rpc_${randomUUID2()}`,
      method: input.method,
      params: input.params ?? {}
    };
    const daemon = getMiyaClient(this.projectDir);
    const py = venvPythonPath(this.projectDir);
    const server = path10.join(this.projectDir, "miya-src", "src", "adapters", "openclaw", "server.py");
    const proc = await daemon.runIsolatedProcess({
      kind: "shell.exec",
      command: py,
      args: [server],
      cwd: this.projectDir,
      timeoutMs: Math.max(1000, input.timeoutMs ?? 15000),
      env: {
        MIYA_ADAPTER_RPC_REQ: JSON.stringify(req)
      },
      metadata: {
        stage: "adapter.openclaw.rpc",
        method: input.method
      },
      resource: {
        priority: 85,
        vramMB: 0
      }
    });
    if (proc.exitCode !== 0) {
      return {
        ok: false,
        error: {
          code: "adapter_subprocess_failed",
          message: proc.stderr || proc.stdout || `exit_code_${String(proc.exitCode)}`
        }
      };
    }
    const lines = String(proc.stdout || "").split(/\r?\n/).map((item) => item.trim()).filter(Boolean);
    const last = lines.at(-1);
    if (!last) {
      return {
        ok: false,
        error: {
          code: "adapter_invalid_response",
          message: "openclaw_adapter_empty_stdout"
        }
      };
    }
    try {
      const parsed = JSON.parse(last);
      if (!parsed.ok) {
        return {
          ok: false,
          error: parsed.error ?? {
            code: "adapter_error",
            message: "openclaw_adapter_error"
          }
        };
      }
      return {
        ok: true,
        result: parsed.result
      };
    } catch (error92) {
      return {
        ok: false,
        error: {
          code: "adapter_parse_failed",
          message: error92 instanceof Error ? error92.message : String(error92),
          details: { stdout: proc.stdout }
        }
      };
    }
  }
  normalizeOutput(raw, auditID) {
    return toAdapterEvidence({
      adapter: "openclaw",
      auditID,
      ok: raw.ok,
      summary: raw.ok ? "openclaw_adapter_ok" : `openclaw_adapter_failed:${raw.error?.code ?? "unknown"}`,
      raw,
      diagnostics: raw.ok ? undefined : { error: raw.error }
    });
  }
}

// src/autoflow/state.ts
import * as fs9 from "node:fs";
import * as path11 from "node:path";
var DEFAULT_MAX_FIX_ROUNDS = 3;
var MAX_HISTORY = 120;
function nowIso5() {
  return new Date().toISOString();
}
function stateFilePath(projectDir) {
  return path11.join(getMiyaRuntimeDir(projectDir), "autoflow-state.json");
}
function normalizeFixRounds(value) {
  if (!Number.isFinite(value))
    return DEFAULT_MAX_FIX_ROUNDS;
  return Math.max(1, Math.min(10, Math.floor(Number(value))));
}
function normalizeState(sessionID, raw) {
  const createdAt = raw?.createdAt ?? nowIso5();
  const history = Array.isArray(raw?.history) ? raw?.history.slice(-MAX_HISTORY).map((item) => ({
    at: String(item.at ?? createdAt),
    phase: item.phase ?? "planning",
    event: String(item.event ?? "unknown"),
    summary: String(item.summary ?? "")
  })) : [];
  const fixCommands = Array.isArray(raw?.fixCommands) ? raw.fixCommands.map(String).map((item) => item.trim()).filter(Boolean) : [];
  const recentVerificationHashes = Array.isArray(raw?.recentVerificationHashes) ? raw.recentVerificationHashes.map(String).slice(-3) : [];
  const planTasks = Array.isArray(raw?.planTasks) ? raw.planTasks : [];
  return {
    sessionID,
    goal: String(raw?.goal ?? "").trim(),
    phase: raw?.phase ?? "planning",
    createdAt,
    updatedAt: raw?.updatedAt ?? createdAt,
    maxFixRounds: normalizeFixRounds(raw?.maxFixRounds),
    fixRound: Number.isFinite(raw?.fixRound) ? Math.max(0, Math.floor(Number(raw?.fixRound))) : 0,
    verificationCommand: raw?.verificationCommand ? String(raw.verificationCommand) : undefined,
    fixCommands,
    planTasks,
    recentVerificationHashes,
    lastError: raw?.lastError ? String(raw.lastError) : undefined,
    lastDag: raw?.lastDag && Number.isFinite(raw.lastDag.total) ? {
      total: Math.max(0, Math.floor(Number(raw.lastDag.total))),
      completed: Math.max(0, Math.floor(Number(raw.lastDag.completed))),
      failed: Math.max(0, Math.floor(Number(raw.lastDag.failed))),
      blocked: Math.max(0, Math.floor(Number(raw.lastDag.blocked)))
    } : undefined,
    history
  };
}
function readStore(projectDir) {
  const file3 = stateFilePath(projectDir);
  if (!fs9.existsSync(file3))
    return { sessions: {} };
  try {
    const parsed = JSON.parse(fs9.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const sessions = {};
    for (const [sessionID, state] of Object.entries(parsed.sessions)) {
      sessions[sessionID] = normalizeState(sessionID, state);
    }
    return { sessions };
  } catch {
    return { sessions: {} };
  }
}
function listAutoflowSessions(projectDir, limit = 50) {
  const store = readStore(projectDir);
  return Object.values(store.sessions).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, Math.min(200, limit)));
}
// src/autoflow/persistent.ts
import * as fs10 from "node:fs";
import * as path12 from "node:path";
var DEFAULT_CONFIG = {
  enabled: true,
  resumeCooldownMs: 2500,
  maxAutoResumes: 8,
  maxConsecutiveResumeFailures: 3,
  resumeTimeoutMs: 90000
};
function storeFile(projectDir) {
  return path12.join(getMiyaRuntimeDir(projectDir), "autoflow-persistent.json");
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeConfig(raw) {
  return {
    enabled: raw?.enabled !== false,
    resumeCooldownMs: clamp(Number(raw?.resumeCooldownMs ?? DEFAULT_CONFIG.resumeCooldownMs), 500, 120000),
    maxAutoResumes: clamp(Number(raw?.maxAutoResumes ?? DEFAULT_CONFIG.maxAutoResumes), 1, 50),
    maxConsecutiveResumeFailures: clamp(Number(raw?.maxConsecutiveResumeFailures ?? DEFAULT_CONFIG.maxConsecutiveResumeFailures), 1, 20),
    resumeTimeoutMs: clamp(Number(raw?.resumeTimeoutMs ?? DEFAULT_CONFIG.resumeTimeoutMs), 3000, 10 * 60000)
  };
}
function normalizeRuntime(sessionID, raw) {
  return {
    sessionID,
    resumeAttempts: clamp(Number(raw?.resumeAttempts ?? 0), 0, 1000),
    resumeFailures: clamp(Number(raw?.resumeFailures ?? 0), 0, 1000),
    userStopped: Boolean(raw?.userStopped),
    stopIntentToken: raw?.stopIntentToken ? String(raw.stopIntentToken) : undefined,
    stopIntentSource: raw?.stopIntentSource === "system" || raw?.stopIntentSource === "user" ? raw.stopIntentSource : undefined,
    stopIntentRequestedAt: raw?.stopIntentRequestedAt ? String(raw.stopIntentRequestedAt) : undefined,
    stopIntentAckedAt: raw?.stopIntentAckedAt ? String(raw.stopIntentAckedAt) : undefined,
    lastStopAt: raw?.lastStopAt ? String(raw.lastStopAt) : undefined,
    lastStopType: raw?.lastStopType ? String(raw.lastStopType) : undefined,
    lastStopReason: raw?.lastStopReason ? String(raw.lastStopReason) : undefined,
    lastResumeAt: raw?.lastResumeAt ? String(raw.lastResumeAt) : undefined,
    lastOutcomePhase: raw?.lastOutcomePhase ? String(raw.lastOutcomePhase) : undefined,
    lastOutcomeSummary: raw?.lastOutcomeSummary ? String(raw.lastOutcomeSummary) : undefined
  };
}
function readStore2(projectDir) {
  const file3 = storeFile(projectDir);
  if (!fs10.existsSync(file3))
    return { config: DEFAULT_CONFIG, sessions: {} };
  try {
    const parsed = JSON.parse(fs10.readFileSync(file3, "utf-8"));
    const sessionsRaw = parsed.sessions && typeof parsed.sessions === "object" ? parsed.sessions : {};
    const sessions = Object.fromEntries(Object.entries(sessionsRaw).map(([sessionID, runtime]) => [
      sessionID,
      normalizeRuntime(sessionID, runtime)
    ]));
    return {
      config: normalizeConfig(parsed.config),
      sessions
    };
  } catch {
    return { config: DEFAULT_CONFIG, sessions: {} };
  }
}
function readAutoflowPersistentConfig(projectDir) {
  return readStore2(projectDir).config;
}
function getAutoflowPersistentRuntimeSnapshot(projectDir, limit = 50) {
  const store = readStore2(projectDir);
  return Object.values(store.sessions).sort((a, b) => Date.parse(b.lastStopAt ?? b.lastResumeAt ?? "") - Date.parse(a.lastStopAt ?? a.lastResumeAt ?? "")).slice(0, Math.max(1, Math.min(200, limit)));
}
// src/autopilot/stats.ts
import * as fs11 from "node:fs";
import * as path13 from "node:path";
var RECENT_LIMIT = 40;
function statsFile(projectDir) {
  return path13.join(getMiyaRuntimeDir(projectDir), "autopilot-stats.json");
}
function nowIso6() {
  return new Date().toISOString();
}
function defaultStats() {
  return {
    totalRuns: 0,
    successRuns: 0,
    failedRuns: 0,
    rollbackRuns: 0,
    rollbackSuccessRuns: 0,
    verificationRuns: 0,
    verificationFailedRuns: 0,
    totalRetries: 0,
    streakSuccess: 0,
    streakFailure: 0,
    lastFailureReason: undefined,
    updatedAt: nowIso6(),
    recent: []
  };
}
function readAutopilotStats(projectDir) {
  const file3 = statsFile(projectDir);
  if (!fs11.existsSync(file3))
    return defaultStats();
  try {
    const parsed = JSON.parse(fs11.readFileSync(file3, "utf-8"));
    return {
      ...defaultStats(),
      ...parsed,
      recent: Array.isArray(parsed.recent) ? parsed.recent.slice(0, RECENT_LIMIT).map((item) => ({
        at: String(item.at ?? nowIso6()),
        success: Boolean(item.success),
        commandCount: Math.max(0, Number(item.commandCount ?? 0)),
        retryCount: Math.max(0, Number(item.retryCount ?? 0)),
        verificationAttempted: Boolean(item.verificationAttempted),
        verificationPassed: Boolean(item.verificationPassed),
        rollbackAttempted: Boolean(item.rollbackAttempted),
        rollbackSucceeded: Boolean(item.rollbackSucceeded),
        failureReason: typeof item.failureReason === "string" ? item.failureReason.slice(0, 200) : undefined
      })) : [],
      updatedAt: typeof parsed.updatedAt === "string" && parsed.updatedAt.trim().length > 0 ? parsed.updatedAt : nowIso6()
    };
  } catch {
    return defaultStats();
  }
}
// src/canvas/state.ts
import { randomUUID as randomUUID3 } from "node:crypto";
import * as fs12 from "node:fs";
import * as path14 from "node:path";
function nowIso7() {
  return new Date().toISOString();
}
function filePath(projectDir) {
  return path14.join(getMiyaRuntimeDir(projectDir), "canvas.json");
}
function ensureDir5(file3) {
  fs12.mkdirSync(path14.dirname(file3), { recursive: true });
}
function defaultState2() {
  return {
    activeDocID: undefined,
    docs: {},
    events: []
  };
}
function readCanvasState(projectDir) {
  const file3 = filePath(projectDir);
  if (!fs12.existsSync(file3))
    return defaultState2();
  try {
    const parsed = JSON.parse(fs12.readFileSync(file3, "utf-8"));
    return {
      activeDocID: parsed.activeDocID,
      docs: parsed.docs ?? {},
      events: Array.isArray(parsed.events) ? parsed.events : []
    };
  } catch {
    return defaultState2();
  }
}
function writeCanvasState(projectDir, state) {
  const file3 = filePath(projectDir);
  ensureDir5(file3);
  fs12.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
  return state;
}
function pushEvent(state, input) {
  state.events = [
    {
      id: `canvas_evt_${randomUUID3()}`,
      kind: input.kind,
      docID: input.docID,
      at: nowIso7(),
      actor: input.actor
    },
    ...state.events
  ].slice(0, 400);
}
function openCanvasDoc(projectDir, input) {
  const state = readCanvasState(projectDir);
  const id = `canvas_${randomUUID3()}`;
  const now = nowIso7();
  const doc3 = {
    id,
    title: input.title,
    type: input.type ?? "markdown",
    content: input.content ?? "",
    createdAt: now,
    updatedAt: now
  };
  state.docs[id] = doc3;
  state.activeDocID = id;
  pushEvent(state, {
    kind: "open",
    docID: id,
    actor: input.actor ?? "gateway"
  });
  writeCanvasState(projectDir, state);
  return doc3;
}
function renderCanvasDoc(projectDir, input) {
  const state = readCanvasState(projectDir);
  const doc3 = state.docs[input.docID];
  if (!doc3)
    return null;
  doc3.content = input.merge ? `${doc3.content}
${input.content}` : input.content;
  doc3.updatedAt = nowIso7();
  state.activeDocID = doc3.id;
  pushEvent(state, {
    kind: "render",
    docID: doc3.id,
    actor: input.actor ?? "gateway"
  });
  writeCanvasState(projectDir, state);
  return doc3;
}
function closeCanvasDoc(projectDir, docID, actor = "gateway") {
  const state = readCanvasState(projectDir);
  const doc3 = state.docs[docID];
  if (!doc3)
    return null;
  if (state.activeDocID === docID) {
    state.activeDocID = undefined;
  }
  pushEvent(state, { kind: "close", docID, actor });
  writeCanvasState(projectDir, state);
  return doc3;
}
function listCanvasDocs(projectDir) {
  const state = readCanvasState(projectDir);
  return Object.values(state.docs).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function getCanvasDoc(projectDir, docID) {
  const state = readCanvasState(projectDir);
  return state.docs[docID] ?? null;
}

// src/capability/schema.ts
function normalizeUnique(values) {
  return [...new Set(values.map((item) => item.trim()).filter(Boolean))];
}
function inferSideEffects(capabilityID) {
  const id = capabilityID.toLowerCase();
  const effects = [];
  if (id.includes("send") || id.includes("outbound") || id.includes("invoke"))
    effects.push("network");
  if (id.includes("desktop") || id.includes("voice") || id.includes("media"))
    effects.push("desktop");
  if (id.includes("config") || id.includes("write") || id.includes("set") || id.includes("patch") || id.includes("install") || id.includes("update") || id.includes("rollback")) {
    effects.push("filesystem");
  }
  if (id.includes("process") || id.includes("daemon") || id.includes("run"))
    effects.push("process");
  if (id.includes("memory") || id.includes("learning"))
    effects.push("memory");
  if (effects.length === 0)
    effects.push("none");
  return normalizeUnique(effects);
}
function inferPermissions(capabilityID) {
  const id = capabilityID.toLowerCase();
  const permissions = [];
  if (id.includes("channels.message.send") || id.includes("outbound"))
    permissions.push("external_message");
  if (id.includes("desktop"))
    permissions.push("desktop_control");
  if (id.includes("config") || id.includes("patch") || id.includes("write"))
    permissions.push("fs_write");
  if (id.includes("memory"))
    permissions.push("memory_write");
  if (id.includes("security"))
    permissions.push("security_sensitive");
  if (permissions.length === 0)
    permissions.push("read_only");
  return normalizeUnique(permissions);
}
function defaultAuditFields(capabilityID) {
  return normalizeUnique([
    "traceID",
    "sessionID",
    "policyHash",
    "inputHash",
    "resultHash",
    capabilityID.includes("channels.message.send") ? "payloadHash" : ""
  ]);
}
function buildSchema(id, input) {
  return {
    id,
    version: input?.version ?? "1.0.0",
    inputs: input?.inputs ?? {
      type: "object",
      additionalProperties: true
    },
    outputs: input?.outputs ?? {
      type: "object",
      additionalProperties: true
    },
    sideEffects: normalizeUnique(input?.sideEffects ?? inferSideEffects(id)),
    permissions: normalizeUnique(input?.permissions ?? inferPermissions(id)),
    auditFields: normalizeUnique(input?.auditFields ?? defaultAuditFields(id)),
    fallbackPlan: input?.fallbackPlan ?? "degrade_to_safe_mode_with_audit_and_request_human_confirmation"
  };
}
function buildGatewayCapabilitySchemas(methods) {
  return methods.slice().sort((a, b) => a.localeCompare(b)).map((method) => buildSchema(`gateway.${method}`));
}
function buildSkillCapabilitySchemas(skills) {
  return skills.map((skill) => buildSchema(`skill.${skill.id}`, {
    version: skill.frontmatter.version || "1.0.0",
    permissions: Array.isArray(skill.frontmatter.permissions) && skill.frontmatter.permissions.length > 0 ? skill.frontmatter.permissions : inferPermissions(skill.id),
    inputs: {
      source: skill.source,
      bins: skill.frontmatter.bins ?? [],
      env: skill.frontmatter.env ?? [],
      platforms: skill.frontmatter.platforms ?? []
    },
    outputs: {
      loadable: skill.gate.loadable,
      reasons: skill.gate.reasons
    },
    fallbackPlan: skill.gate.loadable ? "fallback_to_builtin_or_human_assist_if_runtime_error" : "deny_load_and_emit_governance_reason"
  }));
}

// src/channels/pairing-store.ts
import * as fs13 from "node:fs";
import * as path15 from "node:path";

// src/channels/types.ts
var CHANNEL_NAMES = [
  "qq",
  "wechat",
  "telegram",
  "slack",
  "discord",
  "whatsapp",
  "google_chat",
  "signal",
  "imessage",
  "teams",
  "webchat"
];
function isChannelName(value) {
  return typeof value === "string" && CHANNEL_NAMES.includes(value);
}

// src/channels/pairing-store.ts
function nowIso8() {
  return new Date().toISOString();
}
function filePath2(projectDir) {
  return path15.join(getMiyaRuntimeDir(projectDir), "channels.json");
}
function ensureDir6(file3) {
  fs13.mkdirSync(path15.dirname(file3), { recursive: true });
}
function defaultChannelState(name) {
  return {
    name,
    enabled: name === "webchat",
    connected: name === "webchat",
    updatedAt: nowIso8(),
    allowlist: [],
    contactTiers: {}
  };
}
function defaultStore() {
  const channels = {};
  for (const name of CHANNEL_NAMES) {
    channels[name] = defaultChannelState(name);
  }
  return { channels, pairs: [] };
}
function readChannelStore(projectDir) {
  const file3 = filePath2(projectDir);
  if (!fs13.existsSync(file3)) {
    return defaultStore();
  }
  try {
    const parsed = JSON.parse(fs13.readFileSync(file3, "utf-8"));
    const fallback = defaultStore();
    const mergedChannels = {};
    for (const name of CHANNEL_NAMES) {
      const channel = {
        ...fallback.channels[name],
        ...parsed.channels?.[name] ?? {}
      };
      const allowlist = Array.isArray(channel.allowlist) ? channel.allowlist.map((item) => decryptSensitiveValue(projectDir, String(item))) : [];
      const contactTiersRaw = channel.contactTiers && typeof channel.contactTiers === "object" ? channel.contactTiers : {};
      const contactTiers = {};
      for (const [senderID, tier] of Object.entries(contactTiersRaw)) {
        const decoded = decryptSensitiveValue(projectDir, senderID);
        if (tier === "owner" || tier === "friend") {
          contactTiers[decoded] = tier;
        }
      }
      mergedChannels[name] = {
        ...channel,
        allowlist,
        contactTiers
      };
    }
    const pairs = Array.isArray(parsed.pairs) ? parsed.pairs : [];
    return {
      channels: mergedChannels,
      pairs: pairs.map((pair) => ({
        ...pair,
        senderID: decryptSensitiveValue(projectDir, pair.senderID),
        displayName: pair.displayName ? decryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
        messagePreview: pair.messagePreview ? decryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
      }))
    };
  } catch {
    return defaultStore();
  }
}
function writeChannelStore(projectDir, store) {
  const file3 = filePath2(projectDir);
  ensureDir6(file3);
  const encrypted = {
    channels: Object.fromEntries(Object.entries(store.channels).map(([name, state]) => {
      const contactTiers = {};
      for (const [senderID, tier] of Object.entries(state.contactTiers ?? {})) {
        contactTiers[encryptSensitiveValue(projectDir, senderID)] = tier;
      }
      return [
        name,
        {
          ...state,
          allowlist: state.allowlist.map((item) => encryptSensitiveValue(projectDir, item)),
          contactTiers
        }
      ];
    })),
    pairs: store.pairs.map((pair) => ({
      ...pair,
      senderID: encryptSensitiveValue(projectDir, pair.senderID),
      displayName: pair.displayName ? encryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
      messagePreview: pair.messagePreview ? encryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
    }))
  };
  fs13.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function listChannelStates(projectDir) {
  const store = readChannelStore(projectDir);
  return Object.values(store.channels).sort((a, b) => a.name.localeCompare(b.name));
}
function upsertChannelState(projectDir, name, patch) {
  const store = readChannelStore(projectDir);
  const next = {
    ...store.channels[name],
    ...patch,
    name,
    updatedAt: nowIso8()
  };
  store.channels[name] = next;
  writeChannelStore(projectDir, store);
  return next;
}
function ensurePairRequest(projectDir, input) {
  const store = readChannelStore(projectDir);
  const existing = store.pairs.find((item) => item.channel === input.channel && item.senderID === input.senderID && item.status === "pending");
  if (existing)
    return existing;
  const next = {
    id: `pair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    channel: input.channel,
    senderID: input.senderID,
    displayName: input.displayName,
    messagePreview: input.messagePreview,
    status: "pending",
    requestedAt: nowIso8()
  };
  store.pairs = [next, ...store.pairs].slice(0, 1000);
  writeChannelStore(projectDir, store);
  return next;
}
function resolvePairRequest(projectDir, pairID, status) {
  const store = readChannelStore(projectDir);
  const pair = store.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending")
    return null;
  pair.status = status;
  pair.resolvedAt = nowIso8();
  if (status === "approved") {
    const channel = store.channels[pair.channel];
    const ownerByEnv = new Set(String(process.env.MIYA_OWNER_IDS ?? "").split(",").map((item) => item.trim()).filter(Boolean));
    if (!channel.allowlist.includes(pair.senderID)) {
      channel.allowlist = [...channel.allowlist, pair.senderID].sort();
    }
    const currentTier = channel.contactTiers?.[pair.senderID];
    const resolvedTier = currentTier ?? (ownerByEnv.has(pair.senderID) ? "owner" : "friend");
    channel.contactTiers = {
      ...channel.contactTiers ?? {},
      [pair.senderID]: resolvedTier
    };
    channel.updatedAt = nowIso8();
  }
  writeChannelStore(projectDir, store);
  return pair;
}
function listPairRequests(projectDir, status) {
  const store = readChannelStore(projectDir);
  const pairs = status ? store.pairs.filter((item) => item.status === status) : store.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function isSenderAllowed(projectDir, channel, senderID) {
  const store = readChannelStore(projectDir);
  const allowed = store.channels[channel].allowlist;
  return allowed.includes(senderID);
}
function getContactTier(projectDir, channel, senderID) {
  const store = readChannelStore(projectDir);
  const state = store.channels[channel];
  if (!state.allowlist.includes(senderID))
    return null;
  return state.contactTiers?.[senderID] ?? "friend";
}
function setContactTier(projectDir, channel, senderID, tier) {
  const store = readChannelStore(projectDir);
  const state = store.channels[channel];
  const allowlist = state.allowlist.includes(senderID) ? state.allowlist : [...state.allowlist, senderID].sort();
  const next = {
    ...state,
    allowlist,
    contactTiers: {
      ...state.contactTiers ?? {},
      [senderID]: tier
    },
    updatedAt: nowIso8()
  };
  store.channels[channel] = next;
  writeChannelStore(projectDir, store);
  return next;
}
function listContactTiers(projectDir, channel) {
  const store = readChannelStore(projectDir);
  const channels = channel ? [channel] : [...CHANNEL_NAMES];
  const rows = [];
  for (const name of channels) {
    const state = store.channels[name];
    const mapping = state.contactTiers ?? {};
    for (const senderID of state.allowlist) {
      rows.push({
        channel: name,
        senderID,
        tier: mapping[senderID] ?? "friend"
      });
    }
  }
  return rows.sort((a, b) => `${a.channel}:${a.senderID}`.localeCompare(`${b.channel}:${b.senderID}`));
}
// src/channels/service.ts
import { createHash as createHash5, randomUUID as randomUUID8 } from "node:crypto";
import * as fs18 from "node:fs";
import * as path20 from "node:path";

// src/channel/outbound/shared.ts
import { createHash as createHash4, randomUUID as randomUUID6 } from "node:crypto";
import * as fs15 from "node:fs";

// src/model/paths.ts
import * as path16 from "node:path";
var MODEL_ROOT_ENV = "MIYA_MODEL_ROOT_DIR";
var MIYA_ROOT_SEGMENTS = [".opencode", "miya"];
var MIYA_MODEL_BRANCH = {
  vision: "shi jue",
  image: "tu pian",
  voiceprint: "shi bie",
  voice: "sheng yin"
};
var MIYA_MODEL_NAME = {
  qwen3vl: "Qwen3VL-4B-Instruct-Q4_K_M",
  fluxSchnell: "FLUX.1 schnell",
  fluxKlein: "FLUX.2 [klein] 4BApache-2.0",
  eres2net: "eres2net",
  sovits: "GPT-SoVITS-v2pro-20250604",
  whisper: "Whisper-Small"
};
function normalizeProjectDir(projectDir) {
  return path16.resolve(projectDir);
}
function isOpenCodeRoot(projectDir) {
  return path16.basename(projectDir).toLowerCase() === ".opencode";
}
function normalizeModelRoot(projectDir, root) {
  const trimmed = root.trim();
  if (!trimmed)
    return path16.join(getMiyaDataRootDir(projectDir), "model");
  if (path16.isAbsolute(trimmed))
    return path16.normalize(trimmed);
  return path16.normalize(path16.join(projectDir, trimmed));
}
function getMiyaDataRootDir(projectDir) {
  const normalized = normalizeProjectDir(projectDir);
  if (isOpenCodeRoot(normalized)) {
    return path16.join(normalized, "miya");
  }
  return path16.join(normalized, ...MIYA_ROOT_SEGMENTS);
}
function getMiyaModelRootDir(projectDir) {
  const envRoot = process.env[MODEL_ROOT_ENV];
  if (typeof envRoot === "string" && envRoot.trim()) {
    return normalizeModelRoot(projectDir, envRoot);
  }
  return path16.join(getMiyaDataRootDir(projectDir), "model");
}
function getMiyaModelPath(projectDir, ...segments) {
  return path16.join(getMiyaModelRootDir(projectDir), ...segments);
}
function getMiyaVisionTempDir(projectDir, ...segments) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.vision, "lin shi", ...segments);
}
function getMiyaImageTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.image, "lin shi");
}
function getMiyaVoiceTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voice, "lin shi");
}
function getMiyaQwen3VlModelDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.vision, MIYA_MODEL_NAME.qwen3vl);
}
function getMiyaVoiceprintModelDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, MIYA_MODEL_NAME.eres2net);
}
function getMiyaVoiceprintSampleDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, "ben ren");
}

// src/channel/outbound/vision-action-bridge.ts
import { spawnSync as spawnSync2 } from "node:child_process";
import { createHash as createHash3, randomUUID as randomUUID5 } from "node:crypto";
import * as fs14 from "node:fs";
import * as path17 from "node:path";

// src/desktop/action-engine.ts
import { randomUUID as randomUUID4 } from "node:crypto";
var desktopPerceptionRouteSchemaV2 = exports_external2.enum([
  "L0_ACTION_MEMORY",
  "L1_UIA",
  "L2_OCR",
  "L3_SOM_VLM"
]);
var desktopActionKindSchema = exports_external2.enum([
  "focus",
  "click",
  "type",
  "hotkey",
  "scroll",
  "drag",
  "assert"
]);
var desktopSingleStepActionSchema = exports_external2.enum([
  "focus",
  "click",
  "type",
  "enter",
  "scroll",
  "assert",
  "retry",
  "done"
]);
var desktopSingleStepCoordinateSchema = exports_external2.object({
  x: exports_external2.number().int().min(0).max(32767),
  y: exports_external2.number().int().min(0).max(32767)
}).strict();
var desktopSingleStepDecisionSchemaInternal = exports_external2.object({
  action: desktopSingleStepActionSchema,
  coordinate: desktopSingleStepCoordinateSchema.nullable(),
  content: exports_external2.string().max(4000)
}).strict().superRefine((value, ctx) => {
  const hasCoordinate = Boolean(value.coordinate);
  const hasContent = value.content.trim().length > 0;
  if ((value.action === "focus" || value.action === "click") && !hasCoordinate && !hasContent) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: `${value.action} requires coordinate or content`
    });
  }
  if ((value.action === "type" || value.action === "assert") && !hasContent) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: `${value.action} requires content`
    });
  }
});
var desktopSingleStepDecisionSchema = desktopSingleStepDecisionSchemaInternal;
function parseJsonObjectFromText(input) {
  const text = input.trim();
  if (!text)
    throw new Error("single_step_decision_empty");
  try {
    return JSON.parse(text);
  } catch {
    const start = text.indexOf("{");
    const end = text.lastIndexOf("}");
    if (start >= 0 && end > start) {
      const sliced = text.slice(start, end + 1);
      return JSON.parse(sliced);
    }
    throw new Error("single_step_decision_not_json");
  }
}
function normalizeSingleStepAction(raw) {
  const normalized = raw.trim().toLowerCase();
  const mapped = {
    focus: "focus",
    activate: "focus",
    click: "click",
    tap: "click",
    type: "type",
    input: "type",
    enter: "enter",
    send: "enter",
    scroll: "scroll",
    assert: "assert",
    verify: "assert",
    retry: "retry",
    done: "done",
    complete: "done",
    completed: "done",
    finish: "done",
    finished: "done",
    stop: "done"
  };
  const action = mapped[normalized];
  if (!action)
    throw new Error(`single_step_action_unsupported:${raw}`);
  return action;
}
function parseDesktopSingleStepDecision(input) {
  const rawObject = typeof input === "string" ? parseJsonObjectFromText(input) : input && typeof input === "object" ? input : (() => {
    throw new Error("single_step_decision_invalid");
  })();
  const raw = rawObject;
  const allowedKeys = new Set(["action", "coordinate", "content"]);
  const unexpectedKey = Object.keys(raw).find((key) => !allowedKeys.has(key));
  if (unexpectedKey) {
    throw new Error(`single_step_decision_extra_field:${unexpectedKey}`);
  }
  const normalized = {
    action: normalizeSingleStepAction(String(raw.action ?? "")),
    coordinate: raw.coordinate == null ? null : raw.coordinate,
    content: typeof raw.content === "string" ? raw.content : String(raw.content ?? "")
  };
  return desktopSingleStepDecisionSchema.parse(normalized);
}
function buildDesktopSingleStepPromptKit() {
  return {
    protocol: "desktop_single_step_prompt.v1",
    ruleVersion: "2026-02-17",
    responseSchema: {
      type: "json_object",
      required: ["action", "coordinate", "content"],
      forbidExtraKeys: true
    },
    rules: [
      " JSON  action/coordinate/content ",
      " coordinatex/y",
      " focus",
      ' {"action":"retry","coordinate":null,"content":"element_not_found"}',
      ' {"action":"done","coordinate":null,"content":"completed"}',
      ""
    ],
    fewShot: [
      {
        observation: ": QQ (1720,980)",
        output: {
          action: "click",
          coordinate: { x: 1720, y: 980 },
          content: "send_button"
        }
      },
      {
        observation: "8",
        output: {
          action: "focus",
          coordinate: { x: 860, y: 996 },
          content: "chat_input"
        }
      },
      {
        observation: "OCR Alice",
        output: {
          action: "retry",
          coordinate: null,
          content: "element_not_found"
        }
      },
      {
        observation: "",
        output: {
          action: "done",
          coordinate: null,
          content: "completed"
        }
      }
    ]
  };
}
var desktopPointSchema = exports_external2.object({
  x: exports_external2.number().int().min(0).max(32767),
  y: exports_external2.number().int().min(0).max(32767)
});
var desktopActionTargetSchema = exports_external2.object({
  mode: exports_external2.enum(["window", "coordinates", "text", "selector"]),
  value: exports_external2.string().trim().min(1).max(300).optional(),
  point: desktopPointSchema.optional()
}).superRefine((value, ctx) => {
  if (value.mode === "coordinates" && !value.point) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: "coordinates target requires point"
    });
  }
  if (value.mode !== "coordinates" && !value.value) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: `${value.mode} target requires value`
    });
  }
});
var desktopActionAssertSchema = exports_external2.object({
  type: exports_external2.enum(["window", "text", "image"]),
  expected: exports_external2.string().trim().min(1).max(300),
  contains: exports_external2.boolean().default(true)
});
var desktopActionSchema = exports_external2.object({
  id: exports_external2.string().trim().min(1).max(120),
  kind: desktopActionKindSchema,
  route: desktopPerceptionRouteSchemaV2.default("L1_UIA"),
  target: desktopActionTargetSchema.optional(),
  text: exports_external2.string().max(4000).optional(),
  keys: exports_external2.array(exports_external2.string().trim().min(1).max(20)).min(1).max(5).optional(),
  scrollDeltaY: exports_external2.number().int().min(-9600).max(9600).optional(),
  dragTo: desktopPointSchema.optional(),
  assert: desktopActionAssertSchema.optional(),
  timeoutMs: exports_external2.number().int().min(50).max(60000).optional(),
  notes: exports_external2.string().trim().max(240).optional()
}).superRefine((action, ctx) => {
  if (action.kind === "focus" && !action.target) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: "focus action requires target"
    });
  }
  if (action.kind === "click" && !action.target) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: "click action requires target"
    });
  }
  if (action.kind === "type" && !action.text) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: "type action requires text"
    });
  }
  if (action.kind === "hotkey" && (!action.keys || action.keys.length === 0)) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: "hotkey action requires keys"
    });
  }
  if (action.kind === "scroll" && (!Number.isFinite(action.scrollDeltaY) || action.scrollDeltaY === 0)) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: "scroll action requires non-zero scrollDeltaY"
    });
  }
  if (action.kind === "drag") {
    if (!action.target || action.target.mode !== "coordinates" || !action.target.point) {
      ctx.addIssue({
        code: exports_external2.ZodIssueCode.custom,
        message: "drag action requires coordinates target"
      });
    }
    if (!action.dragTo) {
      ctx.addIssue({
        code: exports_external2.ZodIssueCode.custom,
        message: "drag action requires dragTo"
      });
    }
  }
  if (action.kind === "assert" && !action.assert) {
    ctx.addIssue({
      code: exports_external2.ZodIssueCode.custom,
      message: "assert action requires assert payload"
    });
  }
});
function parseScrollDelta(content) {
  const text = content.trim().toLowerCase();
  const fromNumber = Number(text);
  if (Number.isFinite(fromNumber) && fromNumber !== 0) {
    return Math.max(-9600, Math.min(9600, Math.floor(fromNumber)));
  }
  if (text.includes("up") || text.includes(""))
    return 720;
  return -720;
}
function targetFromDecision(input) {
  const coordinate = input.decision.coordinate;
  if (coordinate) {
    return {
      mode: "coordinates",
      point: {
        x: coordinate.x,
        y: coordinate.y
      }
    };
  }
  const hint = input.decision.content.trim() || input.fallbackHint?.trim();
  if (!hint)
    return;
  return {
    mode: "text",
    value: hint
  };
}
function buildDesktopActionFromSingleStepDecision(input) {
  const routeLevel = input.routeLevel ?? "L1_UIA";
  const stepID = input.stepID?.trim() || "single_step_action";
  const decision = input.decision;
  if (decision.action === "retry")
    return { executable: false, status: "retry" };
  if (decision.action === "done")
    return { executable: false, status: "done" };
  if (decision.action === "focus") {
    return {
      executable: true,
      action: desktopActionSchema.parse({
        id: stepID,
        kind: "focus",
        route: routeLevel,
        target: targetFromDecision({
          decision,
          fallbackHint: input.fallbackHint
        }) ?? {
          mode: "window",
          value: input.fallbackHint?.trim() || "Desktop"
        }
      })
    };
  }
  if (decision.action === "click") {
    return {
      executable: true,
      action: desktopActionSchema.parse({
        id: stepID,
        kind: "click",
        route: routeLevel,
        target: targetFromDecision({
          decision,
          fallbackHint: input.fallbackHint
        })
      })
    };
  }
  if (decision.action === "type") {
    return {
      executable: true,
      action: desktopActionSchema.parse({
        id: stepID,
        kind: "type",
        route: routeLevel,
        target: targetFromDecision({
          decision,
          fallbackHint: input.fallbackHint
        }),
        text: decision.content
      })
    };
  }
  if (decision.action === "enter") {
    return {
      executable: true,
      action: desktopActionSchema.parse({
        id: stepID,
        kind: "hotkey",
        route: routeLevel,
        keys: ["enter"]
      })
    };
  }
  if (decision.action === "scroll") {
    return {
      executable: true,
      action: desktopActionSchema.parse({
        id: stepID,
        kind: "scroll",
        route: routeLevel,
        scrollDeltaY: parseScrollDelta(decision.content)
      })
    };
  }
  return {
    executable: true,
    action: desktopActionSchema.parse({
      id: stepID,
      kind: "assert",
      route: routeLevel,
      assert: {
        type: "text",
        expected: decision.content,
        contains: true
      }
    })
  };
}
var desktopActionSafetySchema = exports_external2.object({
  inputMutex: exports_external2.boolean().default(true),
  abortOnUserInterference: exports_external2.boolean().default(true)
});
var desktopActionPlanSchemaV2 = exports_external2.object({
  protocol: exports_external2.literal("desktop_action_plan.v2"),
  planID: exports_external2.string().trim().min(1).max(120),
  createdAt: exports_external2.string().trim().min(1).max(80),
  source: exports_external2.string().trim().min(1).max(120),
  context: exports_external2.object({
    appName: exports_external2.string().trim().max(120).optional(),
    windowHint: exports_external2.string().trim().max(240).optional(),
    routeLevel: desktopPerceptionRouteSchemaV2.optional()
  }),
  safety: desktopActionSafetySchema,
  actions: exports_external2.array(desktopActionSchema).min(1).max(50)
});
function nowIso9() {
  return new Date().toISOString();
}
function normalizePlanAction(action, index, routeLevel) {
  const raw = action && typeof action === "object" ? action : {};
  const withID = {
    ...raw,
    id: typeof raw.id === "string" && raw.id.trim().length > 0 ? raw.id.trim() : `action_${index + 1}`,
    route: typeof raw.route === "string" && desktopPerceptionRouteSchemaV2.safeParse(raw.route).success ? raw.route : routeLevel ?? "L1_UIA"
  };
  return desktopActionSchema.parse(withID);
}
function defaultActions(input) {
  const targetWindow = input.windowHint || input.appName || "Desktop";
  return [
    desktopActionSchema.parse({
      id: "focus_window",
      kind: "focus",
      route: input.routeLevel ?? "L1_UIA",
      target: {
        mode: "window",
        value: targetWindow
      },
      notes: "Bring target window to foreground before further actions."
    }),
    desktopActionSchema.parse({
      id: "assert_window",
      kind: "assert",
      route: input.routeLevel ?? "L1_UIA",
      assert: {
        type: "window",
        expected: targetWindow,
        contains: true
      }
    })
  ];
}
function buildDesktopActionPlanV2FromRequest(request) {
  const routeLevel = request.routeLevel;
  const actions = Array.isArray(request.actions) && request.actions.length > 0 ? request.actions.map((item, index) => normalizePlanAction(item, index, routeLevel)) : defaultActions({
    appName: request.appName,
    windowHint: request.windowHint,
    routeLevel
  });
  const safety = desktopActionSafetySchema.parse({
    inputMutex: request.safety?.inputMutex,
    abortOnUserInterference: request.safety?.abortOnUserInterference
  });
  return desktopActionPlanSchemaV2.parse({
    protocol: "desktop_action_plan.v2",
    planID: `dap_${randomUUID4()}`,
    createdAt: nowIso9(),
    source: request.source?.trim() || "miya.desktop.v2",
    context: {
      appName: request.appName?.trim() || undefined,
      windowHint: request.windowHint?.trim() || undefined,
      routeLevel
    },
    safety,
    actions
  });
}
function buildDesktopSingleStepPlanFromDecision(input) {
  const decision = desktopSingleStepDecisionSchema.parse(input.decision);
  const routeLevel = input.routeLevel ?? "L1_UIA";
  const stepIndex = Math.max(1, Math.floor(Number(input.stepIndex ?? 1) || 1));
  const targetHint = input.windowHint?.trim() || input.appName?.trim() || "";
  const converted = buildDesktopActionFromSingleStepDecision({
    decision,
    routeLevel,
    stepID: `step_${stepIndex}_main`,
    fallbackHint: targetHint || undefined
  });
  if (!converted.executable) {
    return {
      decision,
      executable: false,
      status: converted.status
    };
  }
  const actions = [];
  const shouldAutoFocus = input.enforceFocusBeforeAction !== false && converted.action.kind !== "focus" && converted.action.kind !== "assert" && targetHint.length > 0;
  if (shouldAutoFocus) {
    actions.push(desktopActionSchema.parse({
      id: `step_${stepIndex}_focus_guard`,
      kind: "focus",
      route: routeLevel,
      target: {
        mode: "window",
        value: targetHint
      },
      notes: "Auto focus guard before executing single-step action."
    }));
  }
  actions.push(converted.action);
  return {
    decision,
    executable: true,
    status: "ready",
    plan: buildDesktopActionPlanV2FromRequest({
      source: input.source?.trim() || "miya.desktop.single_step",
      appName: input.appName?.trim() || undefined,
      windowHint: input.windowHint?.trim() || undefined,
      routeLevel,
      safety: input.safety,
      actions
    })
  };
}
function parseDesktopActionPlanV2(input) {
  return desktopActionPlanSchemaV2.parse(input);
}
function buildDesktopOutboundHumanActions(input) {
  const actions = [
    desktopActionSchema.parse({
      id: "focus_window",
      kind: "focus",
      route: input.routeLevel,
      target: {
        mode: "window",
        value: input.appName
      }
    }),
    desktopActionSchema.parse({
      id: "select_destination",
      kind: "click",
      route: input.routeLevel,
      target: input.selectedCandidateId ? {
        mode: "selector",
        value: `som_candidate_${input.selectedCandidateId}`
      } : {
        mode: "text",
        value: input.destination
      }
    })
  ];
  if (input.hasMedia) {
    actions.push(desktopActionSchema.parse({
      id: "paste_media",
      kind: "hotkey",
      route: input.routeLevel,
      keys: ["ctrl", "v"]
    }));
  }
  if (input.hasText) {
    actions.push(desktopActionSchema.parse({
      id: "type_text",
      kind: "type",
      route: input.routeLevel,
      text: "<payload_text>"
    }));
  }
  actions.push(desktopActionSchema.parse({
    id: "submit_send",
    kind: "hotkey",
    route: input.routeLevel,
    keys: ["enter"]
  }));
  actions.push(desktopActionSchema.parse({
    id: "assert_receipt",
    kind: "assert",
    route: input.routeLevel,
    assert: {
      type: "window",
      expected: input.destination,
      contains: true
    }
  }));
  return actions;
}

// src/channel/outbound/vision-action-bridge.ts
var desktopIntentSchema = exports_external2.object({
  kind: exports_external2.literal("desktop_outbound_send"),
  channel: exports_external2.enum(["qq", "wechat"]),
  appName: exports_external2.enum(["QQ", "WeChat"]),
  destination: exports_external2.string().trim().min(1),
  payloadHash: exports_external2.string().trim().min(8),
  hasText: exports_external2.boolean(),
  hasMedia: exports_external2.boolean(),
  risk: exports_external2.enum(["LOW", "MEDIUM", "HIGH"]).default("LOW")
});
var somCandidateSchema = exports_external2.object({
  id: exports_external2.number().int().positive(),
  label: exports_external2.string().trim().max(120).optional(),
  coarse: exports_external2.object({
    row: exports_external2.number().int().min(0).max(9),
    col: exports_external2.number().int().min(0).max(9)
  }),
  roi: exports_external2.object({
    x: exports_external2.number().int().min(0),
    y: exports_external2.number().int().min(0),
    width: exports_external2.number().int().min(1),
    height: exports_external2.number().int().min(1)
  }),
  center: exports_external2.object({
    x: exports_external2.number().int().min(0),
    y: exports_external2.number().int().min(0)
  }),
  confidence: exports_external2.number().min(0).max(1).optional()
});
var ocrBoxSchema = exports_external2.object({
  x: exports_external2.number().int().min(0),
  y: exports_external2.number().int().min(0),
  width: exports_external2.number().int().min(1),
  height: exports_external2.number().int().min(1),
  text: exports_external2.string().trim().min(1).max(240),
  confidence: exports_external2.number().min(0).max(1).optional()
});
var desktopScreenStateSchema = exports_external2.object({
  windowFingerprint: exports_external2.string().trim().max(240).optional(),
  captureMethod: exports_external2.enum([
    "wgc_hwnd",
    "print_window",
    "dxgi_duplication",
    "uia_only",
    "unknown"
  ]).default("unknown"),
  display: exports_external2.object({
    width: exports_external2.number().int().min(640).max(16384),
    height: exports_external2.number().int().min(480).max(16384)
  }),
  uiaAvailable: exports_external2.boolean(),
  ocrAvailable: exports_external2.boolean(),
  somCandidates: exports_external2.array(somCandidateSchema).max(120).optional(),
  ocrText: exports_external2.string().trim().max(4000).optional(),
  ocrBoxes: exports_external2.array(ocrBoxSchema).max(200).optional(),
  lastOcrFingerprint: exports_external2.string().trim().max(240).optional()
});
var actionPlanStepSchema = exports_external2.object({
  id: exports_external2.string().min(1),
  kind: exports_external2.enum([
    "focus_window",
    "resolve_target",
    "prepare_media",
    "commit_media",
    "prepare_text",
    "commit_text",
    "submit_send",
    "verify_receipt"
  ]),
  via: exports_external2.enum(["L0_ACTION_MEMORY", "L1_UIA", "L2_OCR", "L3_SOM_VLM"]),
  verify: exports_external2.array(exports_external2.enum(["uia_hit_test", "pixel_fingerprint", "window_fingerprint"])).max(3)
});
var desktopActionPlanSchema = exports_external2.object({
  protocol: exports_external2.literal("vision_action_bridge.v1"),
  intent: desktopIntentSchema,
  screen_state: desktopScreenStateSchema,
  action_plan: exports_external2.object({
    routeLevel: exports_external2.enum(["L0_ACTION_MEMORY", "L1_UIA", "L2_OCR", "L3_SOM_VLM"]),
    replaySkillId: exports_external2.string().trim().max(120).optional(),
    memoryHit: exports_external2.boolean(),
    tokenPolicy: exports_external2.object({
      defaultNoVlm: exports_external2.literal(true),
      roiOnlyWhenVlm: exports_external2.literal(true),
      promptTemplate: exports_external2.literal("som_candidate_index_v1"),
      schemaMode: exports_external2.literal("json_only"),
      maxVlmCallsPerStep: exports_external2.number().int().min(1).max(2)
    }),
    som: exports_external2.object({
      enabled: exports_external2.boolean(),
      selectionSource: exports_external2.enum(["memory", "heuristic", "vlm", "none"]),
      selectedCandidateId: exports_external2.number().int().positive().optional(),
      vlmCallsBudget: exports_external2.number().int().min(0).max(2),
      vlmCallsPlanned: exports_external2.number().int().min(0).max(2),
      candidates: exports_external2.array(somCandidateSchema).max(120)
    }),
    brains: exports_external2.object({
      fastBrain: exports_external2.object({
        role: exports_external2.literal("FAST_ACTION_MEMORY_REPLAY"),
        active: exports_external2.boolean(),
        replaySkillId: exports_external2.string().trim().max(120).optional()
      }),
      slowBrain: exports_external2.object({
        role: exports_external2.literal("SLOW_TASK_PLANNER"),
        active: exports_external2.boolean(),
        planningRoute: exports_external2.enum(["L1_UIA", "L2_OCR", "L3_SOM_VLM"]).optional(),
        promoteReplaySkillOnSuccess: exports_external2.literal(true)
      })
    }),
    humanActions: exports_external2.array(desktopActionSchema).min(3).max(24),
    steps: exports_external2.array(actionPlanStepSchema).min(3).max(12)
  })
});
function nowIso10() {
  return new Date().toISOString();
}
function clamp2(value, min, max) {
  if (!Number.isFinite(value))
    return min;
  return Math.max(min, Math.min(max, value));
}
function normalizeDestination(value) {
  return String(value ?? "").trim().toLowerCase().replace(/\s+/g, " ");
}
function runtimeDir(projectDir) {
  return path17.join(getMiyaRuntimeDir(projectDir), "channels");
}
function actionMemoryFile(projectDir) {
  return path17.join(runtimeDir(projectDir), "desktop-action-memory.json");
}
function metricsFile(projectDir) {
  return path17.join(runtimeDir(projectDir), "desktop-automation-metrics.json");
}
function replaySkillFile(projectDir) {
  return path17.join(runtimeDir(projectDir), "desktop-replay-skills.json");
}
function readJsonFile(file3, fallback) {
  if (!fs14.existsSync(file3))
    return fallback;
  try {
    const parsed = JSON.parse(fs14.readFileSync(file3, "utf-8"));
    return parsed;
  } catch {
    return fallback;
  }
}
function writeJsonFile(file3, value) {
  fs14.mkdirSync(path17.dirname(file3), { recursive: true });
  fs14.writeFileSync(file3, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function buildMemoryKey(intent) {
  return [
    intent.channel,
    intent.appName.toLowerCase(),
    createHash3("sha1").update(normalizeDestination(intent.destination)).digest("hex").slice(0, 10)
  ].join("|");
}
function normalizeMemoryStore(raw) {
  if (!raw || !Array.isArray(raw.records))
    return { records: [] };
  const normalized = raw.records.filter((row) => row && typeof row === "object").map((row) => ({
    id: String(row.id ?? randomUUID5()),
    key: String(row.key ?? ""),
    channel: row.channel === "wechat" ? "wechat" : "qq",
    appName: row.appName === "WeChat" ? "WeChat" : "QQ",
    destination: String(row.destination ?? ""),
    routeLevel: normalizeRoute(row.routeLevel),
    replaySkillId: String(row.replaySkillId ?? ""),
    windowFingerprint: row.windowFingerprint ? String(row.windowFingerprint) : undefined,
    somCandidateId: typeof row.somCandidateId === "number" && Number.isFinite(row.somCandidateId) ? Math.floor(row.somCandidateId) : undefined,
    successCount: Math.max(0, Math.floor(Number(row.successCount ?? 0) || 0)),
    failCount: Math.max(0, Math.floor(Number(row.failCount ?? 0) || 0)),
    createdAt: String(row.createdAt ?? nowIso10()),
    updatedAt: String(row.updatedAt ?? nowIso10()),
    lastSuccessAt: row.lastSuccessAt ? String(row.lastSuccessAt) : undefined,
    avgLatencyMs: clamp2(Number(row.avgLatencyMs ?? 0), 0, 60000)
  })).filter((row) => row.key.length > 0);
  return {
    records: normalized.slice(0, 800)
  };
}
function normalizeRoute(value) {
  if (value === "L0_ACTION_MEMORY")
    return "L0_ACTION_MEMORY";
  if (value === "L1_UIA")
    return "L1_UIA";
  if (value === "L2_OCR")
    return "L2_OCR";
  return "L3_SOM_VLM";
}
function readActionMemory(projectDir) {
  const store = readJsonFile(actionMemoryFile(projectDir), {
    records: []
  });
  const normalized = normalizeMemoryStore(store);
  writeJsonFile(actionMemoryFile(projectDir), normalized);
  return normalized;
}
function writeActionMemory(projectDir, store) {
  writeJsonFile(actionMemoryFile(projectDir), normalizeMemoryStore(store));
}
function normalizeReplaySkillStore(raw) {
  if (!raw || !Array.isArray(raw.records))
    return { records: [] };
  const normalized = raw.records.filter((row) => row && typeof row === "object").map((row) => {
    const stepKinds = Array.isArray(row.stepKinds) ? row.stepKinds.map((item) => String(item ?? "").trim()).filter(Boolean).filter((item) => actionPlanStepSchema.shape.kind.options.includes(item)) : [];
    const verifyPolicy = Array.isArray(row.verifyPolicy) ? [
      ...new Set(row.verifyPolicy.map((item) => String(item ?? "").trim()).filter(Boolean))
    ] : [];
    return {
      id: String(row.id ?? randomUUID5()),
      key: String(row.key ?? ""),
      channel: row.channel === "wechat" ? "wechat" : "qq",
      appName: row.appName === "WeChat" ? "WeChat" : "QQ",
      destination: normalizeDestination(String(row.destination ?? "")),
      routeLevel: normalizeRoute(row.routeLevel),
      stepKinds,
      verifyPolicy,
      somCandidateId: typeof row.somCandidateId === "number" && Number.isFinite(row.somCandidateId) ? Math.floor(row.somCandidateId) : undefined,
      windowFingerprint: row.windowFingerprint ? String(row.windowFingerprint) : undefined,
      successCount: Math.max(0, Math.floor(Number(row.successCount ?? 0) || 0)),
      avgLatencyMs: clamp2(Number(row.avgLatencyMs ?? 0), 0, 60000),
      createdAt: String(row.createdAt ?? nowIso10()),
      updatedAt: String(row.updatedAt ?? nowIso10()),
      lastSuccessAt: row.lastSuccessAt ? String(row.lastSuccessAt) : undefined
    };
  }).filter((row) => row.key.length > 0).slice(0, 1000);
  return {
    records: normalized.sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt))
  };
}
function readReplaySkills(projectDir) {
  const store = readJsonFile(replaySkillFile(projectDir), { records: [] });
  const normalized = normalizeReplaySkillStore(store);
  writeJsonFile(replaySkillFile(projectDir), normalized);
  return normalized;
}
function writeReplaySkills(projectDir, store) {
  writeJsonFile(replaySkillFile(projectDir), normalizeReplaySkillStore(store));
}
function promoteSlowBrainReplaySkill(projectDir, input) {
  if (!input.sent)
    return;
  if (input.actionPlan.action_plan.memoryHit)
    return;
  const replaySkillId = String(input.actionPlan.action_plan.replaySkillId ?? "").trim();
  if (!replaySkillId)
    return;
  const key = buildMemoryKey(input.intent);
  const routeLevel = input.actionPlan.action_plan.routeLevel;
  const steps = input.actionPlan.action_plan.steps;
  const stepKinds = steps.map((step) => step.kind);
  const verifyPolicy = [...new Set(steps.flatMap((step) => step.verify))];
  const now = nowIso10();
  const store = readReplaySkills(projectDir);
  const index = store.records.findIndex((row) => row.id === replaySkillId || row.key === key);
  const existing = index >= 0 ? store.records[index] : undefined;
  const previousRuns = existing?.successCount ?? 0;
  const avgLatencyMs = previousRuns <= 0 ? input.latencyMs : Number((((existing?.avgLatencyMs ?? input.latencyMs) * previousRuns + input.latencyMs) / (previousRuns + 1)).toFixed(2));
  const next = {
    id: existing?.id ?? replaySkillId,
    key,
    channel: input.intent.channel,
    appName: input.intent.appName,
    destination: normalizeDestination(input.intent.destination),
    routeLevel,
    stepKinds,
    verifyPolicy,
    somCandidateId: input.actionPlan.action_plan.som.selectedCandidateId ?? existing?.somCandidateId,
    windowFingerprint: input.screenState.windowFingerprint ?? existing?.windowFingerprint,
    successCount: previousRuns + 1,
    avgLatencyMs,
    createdAt: existing?.createdAt ?? now,
    updatedAt: now,
    lastSuccessAt: now
  };
  if (index >= 0)
    store.records[index] = next;
  else
    store.records.unshift(next);
  writeReplaySkills(projectDir, store);
}
function listDesktopReplaySkills(projectDir, limit = 100) {
  const normalizedLimit = Math.max(1, Math.min(500, Math.floor(Number(limit) || 100)));
  return readReplaySkills(projectDir).records.slice(0, normalizedLimit);
}
function memoryExpiryMs() {
  const raw = Number(process.env.MIYA_DESKTOP_ACTION_MEMORY_TTL_MS ?? 30 * 24 * 3600 * 1000);
  if (!Number.isFinite(raw))
    return 30 * 24 * 3600 * 1000;
  return Math.max(3600000, Math.min(180 * 24 * 3600 * 1000, Math.floor(raw)));
}
function isMemoryRecordHot(record3, screen) {
  const updatedAt = Date.parse(record3.updatedAt);
  if (!Number.isFinite(updatedAt))
    return false;
  if (Date.now() - updatedAt > memoryExpiryMs())
    return false;
  if (record3.failCount > record3.successCount + 1)
    return false;
  if (record3.windowFingerprint && screen.windowFingerprint && record3.windowFingerprint !== screen.windowFingerprint) {
    return false;
  }
  return true;
}
function defaultSomCandidates(screen) {
  const width = screen.display.width;
  const height = screen.display.height;
  const cellW = Math.max(1, Math.floor(width / 10));
  const cellH = Math.max(1, Math.floor(height / 10));
  const candidates = [];
  let id = 1;
  for (let row = 0;row < 10; row += 1) {
    for (let col = 0;col < 10; col += 1) {
      const x = col * cellW;
      const y = row * cellH;
      candidates.push({
        id,
        coarse: { row, col },
        roi: {
          x,
          y,
          width: Math.max(1, Math.min(cellW, width - x)),
          height: Math.max(1, Math.min(cellH, height - y))
        },
        center: {
          x: Math.max(0, Math.min(width - 1, x + Math.floor(cellW / 2))),
          y: Math.max(0, Math.min(height - 1, y + Math.floor(cellH / 2)))
        }
      });
      id += 1;
    }
  }
  return candidates;
}
function normalizeSomCandidates(input) {
  const base = Array.isArray(input.somCandidates) && input.somCandidates.length > 0 ? input.somCandidates : Array.isArray(input.ocrBoxes) && input.ocrBoxes.length > 0 ? candidatesFromOcr(input) : defaultSomCandidates(input);
  return base.filter((row) => row && Number.isFinite(row.id)).sort((a, b) => a.id - b.id).slice(0, 120);
}
function chooseSomCandidateByHeuristic(candidates, intent) {
  const destination = normalizeDestination(intent.destination);
  const sendHints = [
    "send",
    "",
    " ",
    "sent",
    "deliver",
    "",
    ""
  ];
  const destinationMatch = candidates.find((item) => {
    const label = normalizeDestination(item.label ?? "");
    return label.length > 0 && destination.length > 0 && label.includes(destination);
  });
  if (destinationMatch)
    return destinationMatch.id;
  const sendMatch = candidates.find((item) => {
    const label = String(item.label ?? "").toLowerCase();
    return sendHints.some((hint) => label.includes(hint));
  });
  if (sendMatch)
    return sendMatch.id;
  return;
}
function normCompact(value) {
  return String(value ?? "").toLowerCase().replace(/\s+/g, "").trim();
}
function containsNormalized(text, target) {
  const t = normCompact(text);
  const q = normCompact(target);
  if (!t || !q)
    return false;
  return t.includes(q);
}
function candidatesFromOcr(input) {
  const boxes = Array.isArray(input.ocrBoxes) ? input.ocrBoxes : [];
  if (boxes.length === 0)
    return [];
  const width = input.display.width;
  const height = input.display.height;
  let id = 1001;
  return boxes.map((box) => {
    const centerX = Math.max(0, Math.min(width - 1, box.x + Math.floor(box.width / 2)));
    const centerY = Math.max(0, Math.min(height - 1, box.y + Math.floor(box.height / 2)));
    const row = Math.max(0, Math.min(9, Math.floor(centerY / Math.max(1, height) * 10)));
    const col = Math.max(0, Math.min(9, Math.floor(centerX / Math.max(1, width) * 10)));
    return {
      id: id++,
      label: box.text.slice(0, 120),
      coarse: { row, col },
      roi: {
        x: Math.max(0, Math.min(width - 1, box.x)),
        y: Math.max(0, Math.min(height - 1, box.y)),
        width: Math.max(1, Math.min(box.width, width - box.x)),
        height: Math.max(1, Math.min(box.height, height - box.y))
      },
      center: { x: centerX, y: centerY },
      confidence: typeof box.confidence === "number" ? clamp2(box.confidence, 0, 1) : undefined
    };
  }).slice(0, 80);
}
function chooseSomCandidateFromOcr(candidates, intent, screenState) {
  if (!Array.isArray(screenState.ocrBoxes) || screenState.ocrBoxes.length === 0)
    return;
  const sendHints = [
    "send",
    "",
    "sent",
    "deliver",
    "",
    "",
    "",
    "send to"
  ];
  const destination = intent.destination;
  const scored = candidates.map((item) => {
    const label = String(item.label ?? "");
    let score = 0;
    if (containsNormalized(label, destination))
      score += 2.2;
    if (sendHints.some((hint) => containsNormalized(label, hint)))
      score += 1.6;
    score += item.center.y / Math.max(1, screenState.display.height) * 0.45;
    score += item.center.x / Math.max(1, screenState.display.width) * 0.25;
    if (typeof item.confidence === "number")
      score += item.confidence * 0.4;
    return { id: item.id, score };
  });
  scored.sort((a, b) => b.score - a.score);
  const top = scored[0];
  if (!top || top.score < 1.35)
    return;
  return top.id;
}
function parseCommandSpec(raw) {
  const input = raw.trim();
  if (!input)
    return null;
  const tokens = [];
  let current = "";
  let quote = null;
  for (let i = 0;i < input.length; i += 1) {
    const ch = input[i] ?? "";
    if ((ch === '"' || ch === "'") && (!quote || quote === ch)) {
      quote = quote ? null : ch;
      continue;
    }
    if (!quote && /\s/.test(ch)) {
      if (current)
        tokens.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current)
    tokens.push(current);
  if (tokens.length === 0)
    return null;
  return { command: tokens[0], args: tokens.slice(1) };
}
function resolveSomVlmCommand() {
  const explicit = String(process.env.MIYA_VISION_LOCAL_CMD ?? "").trim();
  if (explicit) {
    const parsed = parseCommandSpec(explicit);
    if (parsed)
      return { ...parsed, shell: false };
    return { command: explicit, args: [], shell: true };
  }
  const backend = String(process.env.MIYA_QWEN3VL_CMD ?? "").trim();
  if (backend) {
    const parsed = parseCommandSpec(backend);
    if (parsed)
      return { ...parsed, shell: false };
    return { command: backend, args: [], shell: true };
  }
  return null;
}
function runSomVlmSelector(input) {
  const command = resolveSomVlmCommand();
  if (!command || input.candidates.length === 0 || input.maxCalls <= 0) {
    return { selectedCandidateId: undefined, callsUsed: 0 };
  }
  const timeoutMsRaw = Number(process.env.MIYA_DESKTOP_VLM_SELECTOR_TIMEOUT_MS ?? 2800);
  const timeoutMs = Number.isFinite(timeoutMsRaw) ? Math.max(600, Math.min(12000, Math.floor(timeoutMsRaw))) : 2800;
  const attempts = Math.max(1, Math.min(2, input.maxCalls));
  let callsUsed = 0;
  for (let i = 0;i < attempts; i += 1) {
    callsUsed += 1;
    const candidateWindow = input.candidates.slice(0, i === 0 ? 32 : 16);
    const payload = JSON.stringify({
      mode: "som_candidate_select",
      protocol: "vision_action_bridge.v1",
      promptTemplate: "som_candidate_index_v1",
      schema: {
        type: "object",
        required: ["candidateId"],
        properties: {
          candidateId: { type: "integer" },
          confidence: { type: "number" }
        }
      },
      intent: {
        kind: input.intent.kind,
        channel: input.intent.channel,
        destination: input.intent.destination,
        hasText: input.intent.hasText,
        hasMedia: input.intent.hasMedia
      },
      screen_state: {
        captureMethod: input.screenState.captureMethod,
        display: input.screenState.display,
        windowFingerprint: input.screenState.windowFingerprint,
        lastOcrFingerprint: input.screenState.lastOcrFingerprint,
        ocrText: String(input.screenState.ocrText ?? "").slice(0, 1200)
      },
      candidates: candidateWindow.map((row) => ({
        id: row.id,
        label: row.label,
        coarse: row.coarse,
        roi: row.roi,
        center: row.center
      }))
    });
    try {
      const run = spawnSync2(command.command, command.args, {
        input: payload,
        timeout: timeoutMs,
        encoding: "utf-8",
        shell: command.shell,
        windowsHide: true,
        stdio: ["pipe", "pipe", "pipe"]
      });
      if (run.error || run.signal || run.status !== 0)
        continue;
      const parsed = JSON.parse(String(run.stdout ?? "").trim());
      const candidateIdRaw = Number(parsed.candidateId ?? parsed.selectedCandidateId ?? parsed.id ?? Number.NaN);
      if (!Number.isFinite(candidateIdRaw))
        continue;
      const candidateId = Math.max(1, Math.floor(candidateIdRaw));
      if (candidateWindow.some((item) => item.id === candidateId)) {
        return {
          selectedCandidateId: candidateId,
          callsUsed
        };
      }
    } catch {}
  }
  return { selectedCandidateId: undefined, callsUsed };
}
function buildSteps(route, intent) {
  const steps = [
    {
      id: "focus_window",
      kind: "focus_window",
      via: route,
      verify: ["window_fingerprint"]
    },
    {
      id: "resolve_target",
      kind: "resolve_target",
      via: route,
      verify: ["uia_hit_test", "pixel_fingerprint"]
    }
  ];
  if (intent.hasMedia) {
    steps.push({
      id: "prepare_media",
      kind: "prepare_media",
      via: route,
      verify: ["window_fingerprint"]
    });
    steps.push({
      id: "commit_media",
      kind: "commit_media",
      via: route,
      verify: ["uia_hit_test"]
    });
  }
  if (intent.hasText) {
    steps.push({
      id: "prepare_text",
      kind: "prepare_text",
      via: route,
      verify: ["window_fingerprint"]
    });
    steps.push({
      id: "commit_text",
      kind: "commit_text",
      via: route,
      verify: ["uia_hit_test"]
    });
  }
  steps.push({
    id: "submit_send",
    kind: "submit_send",
    via: route,
    verify: ["uia_hit_test", "pixel_fingerprint"]
  });
  steps.push({
    id: "verify_receipt",
    kind: "verify_receipt",
    via: route,
    verify: ["window_fingerprint"]
  });
  return steps;
}
function buildDesktopActionPlan(input) {
  const intent = desktopIntentSchema.parse(input.intent);
  const screenState = desktopScreenStateSchema.parse(input.screenState);
  const memory = readActionMemory(input.projectDir);
  const memoryKey = buildMemoryKey(intent);
  const matchedMemory = memory.records.find((row) => row.key === memoryKey && isMemoryRecordHot(row, screenState));
  const somCandidates = normalizeSomCandidates(screenState);
  let routeLevel = "L3_SOM_VLM";
  if (matchedMemory)
    routeLevel = "L0_ACTION_MEMORY";
  else if (screenState.uiaAvailable)
    routeLevel = "L1_UIA";
  else if (screenState.ocrAvailable)
    routeLevel = "L2_OCR";
  let selectedCandidateId;
  let selectionSource = "none";
  let vlmCallsPlanned = 0;
  let maxVlmCallsPerStep = 2;
  if (routeLevel === "L0_ACTION_MEMORY" && matchedMemory?.somCandidateId) {
    selectedCandidateId = matchedMemory.somCandidateId;
    selectionSource = "memory";
  } else {
    const heuristic = chooseSomCandidateByHeuristic(somCandidates, intent);
    if (heuristic) {
      selectedCandidateId = heuristic;
      selectionSource = "heuristic";
    }
  }
  if (routeLevel === "L2_OCR" && !selectedCandidateId) {
    const ocrSelected = chooseSomCandidateFromOcr(somCandidates, intent, screenState);
    if (ocrSelected) {
      selectedCandidateId = ocrSelected;
      selectionSource = "heuristic";
    } else {
      routeLevel = "L3_SOM_VLM";
    }
  }
  if (routeLevel === "L3_SOM_VLM" && !selectedCandidateId) {
    const maxVlmCallsRaw = Number(process.env.MIYA_DESKTOP_VLM_MAX_CALLS ?? 2);
    const maxVlmCalls = Number.isFinite(maxVlmCallsRaw) ? Math.max(1, Math.min(2, Math.floor(maxVlmCallsRaw))) : 2;
    maxVlmCallsPerStep = maxVlmCalls;
    const vlmSelected = runSomVlmSelector({
      intent,
      screenState,
      candidates: somCandidates,
      maxCalls: maxVlmCalls
    });
    vlmCallsPlanned = vlmSelected.callsUsed;
    if (vlmSelected.selectedCandidateId) {
      selectedCandidateId = vlmSelected.selectedCandidateId;
      selectionSource = "vlm";
    }
  }
  const vlmCallsBudget = routeLevel === "L3_SOM_VLM" ? Math.max(0, maxVlmCallsPerStep - vlmCallsPlanned) : 0;
  const replaySkillId = matchedMemory?.replaySkillId || `desktop_replay_${intent.channel}_${createHash3("sha1").update(memoryKey).digest("hex").slice(0, 8)}`;
  const somCandidatesForPlan = routeLevel === "L2_OCR" || routeLevel === "L3_SOM_VLM" ? somCandidates : [];
  const fastBrainActive = routeLevel === "L0_ACTION_MEMORY" && Boolean(matchedMemory);
  const slowBrainRoute = routeLevel === "L0_ACTION_MEMORY" ? undefined : routeLevel;
  return desktopActionPlanSchema.parse({
    protocol: "vision_action_bridge.v1",
    intent,
    screen_state: screenState,
    action_plan: {
      routeLevel,
      replaySkillId,
      memoryHit: Boolean(matchedMemory),
      tokenPolicy: {
        defaultNoVlm: true,
        roiOnlyWhenVlm: true,
        promptTemplate: "som_candidate_index_v1",
        schemaMode: "json_only",
        maxVlmCallsPerStep
      },
      som: {
        enabled: routeLevel === "L2_OCR" || routeLevel === "L3_SOM_VLM",
        selectionSource,
        selectedCandidateId,
        vlmCallsBudget,
        vlmCallsPlanned,
        candidates: somCandidatesForPlan
      },
      brains: {
        fastBrain: {
          role: "FAST_ACTION_MEMORY_REPLAY",
          active: fastBrainActive,
          replaySkillId
        },
        slowBrain: {
          role: "SLOW_TASK_PLANNER",
          active: !fastBrainActive,
          planningRoute: slowBrainRoute,
          promoteReplaySkillOnSuccess: true
        }
      },
      humanActions: buildDesktopOutboundHumanActions({
        routeLevel,
        appName: intent.appName,
        destination: intent.destination,
        hasText: intent.hasText,
        hasMedia: intent.hasMedia,
        selectedCandidateId
      }),
      steps: buildSteps(routeLevel, intent)
    }
  });
}
function normalizeMetrics(raw) {
  const fallbackNow = nowIso10();
  const asNumArray = (rows) => Array.isArray(rows) ? rows.map((item) => Number(item)).filter((item) => Number.isFinite(item) && item >= 0).map((item) => Math.floor(item)) : [];
  return {
    createdAt: String(raw.createdAt ?? fallbackNow),
    updatedAt: String(raw.updatedAt ?? fallbackNow),
    totalRuns: Math.max(0, Math.floor(Number(raw.totalRuns ?? 0) || 0)),
    successfulRuns: Math.max(0, Math.floor(Number(raw.successfulRuns ?? 0) || 0)),
    vlmCalls: Math.max(0, Math.floor(Number(raw.vlmCalls ?? 0) || 0)),
    somRuns: Math.max(0, Math.floor(Number(raw.somRuns ?? 0) || 0)),
    somSuccessRuns: Math.max(0, Math.floor(Number(raw.somSuccessRuns ?? 0) || 0)),
    highRiskRuns: Math.max(0, Math.floor(Number(raw.highRiskRuns ?? 0) || 0)),
    highRiskMisfireRuns: Math.max(0, Math.floor(Number(raw.highRiskMisfireRuns ?? 0) || 0)),
    reuseRuns: Math.max(0, Math.floor(Number(raw.reuseRuns ?? 0) || 0)),
    firstRuns: Math.max(0, Math.floor(Number(raw.firstRuns ?? 0) || 0)),
    reuseLatencyMs: asNumArray(raw.reuseLatencyMs).slice(-500),
    firstLatencyMs: asNumArray(raw.firstLatencyMs).slice(-500)
  };
}
function readMetrics(projectDir) {
  const fallback = {
    createdAt: nowIso10(),
    updatedAt: nowIso10(),
    totalRuns: 0,
    successfulRuns: 0,
    vlmCalls: 0,
    somRuns: 0,
    somSuccessRuns: 0,
    highRiskRuns: 0,
    highRiskMisfireRuns: 0,
    reuseRuns: 0,
    firstRuns: 0,
    reuseLatencyMs: [],
    firstLatencyMs: []
  };
  const parsed = readJsonFile(metricsFile(projectDir), fallback);
  const normalized = normalizeMetrics(parsed);
  writeJsonFile(metricsFile(projectDir), normalized);
  return normalized;
}
function writeMetrics(projectDir, metrics) {
  writeJsonFile(metricsFile(projectDir), normalizeMetrics(metrics));
}
function pushLatency(rows, value) {
  const next = [...rows, Math.max(0, Math.floor(value))];
  return next.slice(-500);
}
function p95(rows) {
  if (rows.length === 0)
    return 0;
  const sorted = [...rows].sort((a, b) => a - b);
  const index = Math.min(sorted.length - 1, Math.ceil(sorted.length * 0.95) - 1);
  return sorted[index] ?? 0;
}
function readAcceptanceThresholds() {
  const maxVlmCallRatio = clamp2(Number(process.env.MIYA_DESKTOP_KPI_MAX_VLM_RATIO ?? 0.2), 0, 1);
  const minSomPathHitRate = clamp2(Number(process.env.MIYA_DESKTOP_KPI_MIN_SOM_HIT_RATE ?? 0.95), 0, 1);
  const maxReuseTaskP95Ms = clamp2(Number(process.env.MIYA_DESKTOP_KPI_MAX_REUSE_P95_MS ?? 1500), 200, 120000);
  const maxHighRiskMisfireRate = clamp2(Number(process.env.MIYA_DESKTOP_KPI_MAX_HIGH_RISK_MISFIRE_RATE ?? 0), 0, 1);
  return {
    maxVlmCallRatio: Number(maxVlmCallRatio.toFixed(4)),
    minSomPathHitRate: Number(minSomPathHitRate.toFixed(4)),
    maxReuseTaskP95Ms: Math.floor(maxReuseTaskP95Ms),
    maxHighRiskMisfireRate: Number(maxHighRiskMisfireRate.toFixed(4))
  };
}
function evaluateDesktopAutomationAcceptance(metrics, kpi) {
  const thresholds = readAcceptanceThresholds();
  const checks5 = {
    vlmCallRatio: metrics.totalRuns === 0 ? true : kpi.vlmCallRatio <= thresholds.maxVlmCallRatio,
    somPathHitRate: metrics.somRuns === 0 ? true : kpi.somPathHitRate >= thresholds.minSomPathHitRate,
    reuseTaskP95Ms: metrics.reuseRuns === 0 ? true : kpi.reuseTaskP95Ms <= thresholds.maxReuseTaskP95Ms,
    highRiskMisfireRate: metrics.highRiskRuns === 0 ? true : kpi.highRiskMisfireRate <= thresholds.maxHighRiskMisfireRate
  };
  return {
    pass: checks5.vlmCallRatio && checks5.somPathHitRate && checks5.reuseTaskP95Ms && checks5.highRiskMisfireRate,
    thresholds,
    checks: checks5,
    sample: {
      totalRuns: metrics.totalRuns,
      somRuns: metrics.somRuns,
      reuseRuns: metrics.reuseRuns,
      highRiskRuns: metrics.highRiskRuns
    }
  };
}
function recordDesktopActionOutcome(projectDir, input) {
  const intent = desktopIntentSchema.parse(input.intent);
  const screenState = desktopScreenStateSchema.parse(input.screenState);
  const plan = desktopActionPlanSchema.parse(input.actionPlan);
  const latencyMs = Math.max(0, Math.floor(Number(input.latencyMs) || 0));
  const memory = readActionMemory(projectDir);
  const key = buildMemoryKey(intent);
  const existingIndex = memory.records.findIndex((row) => row.key === key);
  const now = nowIso10();
  const existing = existingIndex >= 0 ? memory.records[existingIndex] : undefined;
  const successCount = (existing?.successCount ?? 0) + (input.sent ? 1 : 0);
  const failCount = (existing?.failCount ?? 0) + (input.sent ? 0 : 1);
  const previousAvg = existing?.avgLatencyMs ?? latencyMs;
  const previousRuns = Math.max(0, (existing?.successCount ?? 0) + (existing?.failCount ?? 0));
  const avgLatencyMs = previousRuns <= 0 ? latencyMs : Number(((previousAvg * previousRuns + latencyMs) / (previousRuns + 1)).toFixed(2));
  const nextRecord = {
    id: existing?.id ?? randomUUID5(),
    key,
    channel: intent.channel,
    appName: intent.appName,
    destination: normalizeDestination(intent.destination),
    routeLevel: plan.action_plan.routeLevel,
    replaySkillId: plan.action_plan.replaySkillId ?? existing?.replaySkillId ?? `desktop_replay_${intent.channel}_${createHash3("sha1").update(key).digest("hex").slice(0, 8)}`,
    windowFingerprint: screenState.windowFingerprint || existing?.windowFingerprint,
    somCandidateId: plan.action_plan.som.selectedCandidateId ?? existing?.somCandidateId,
    successCount,
    failCount,
    createdAt: existing?.createdAt ?? now,
    updatedAt: now,
    lastSuccessAt: input.sent ? now : existing?.lastSuccessAt,
    avgLatencyMs
  };
  if (existingIndex >= 0)
    memory.records[existingIndex] = nextRecord;
  else
    memory.records.unshift(nextRecord);
  memory.records = memory.records.sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, 800);
  writeActionMemory(projectDir, memory);
  promoteSlowBrainReplaySkill(projectDir, {
    intent,
    screenState,
    actionPlan: plan,
    latencyMs,
    sent: input.sent
  });
  const metrics = readMetrics(projectDir);
  metrics.updatedAt = now;
  metrics.totalRuns += 1;
  if (input.sent)
    metrics.successfulRuns += 1;
  const vlmCallsUsed = Math.max(0, Math.min(2, Math.floor(Number(input.vlmCallsUsed ?? 0) || 0)));
  metrics.vlmCalls += vlmCallsUsed;
  if (intent.risk === "HIGH") {
    metrics.highRiskRuns += 1;
    if (input.highRiskMisfire)
      metrics.highRiskMisfireRuns += 1;
  }
  if (plan.action_plan.routeLevel === "L2_OCR" || plan.action_plan.routeLevel === "L3_SOM_VLM") {
    metrics.somRuns += 1;
    if (input.somSucceeded)
      metrics.somSuccessRuns += 1;
  }
  if (plan.action_plan.memoryHit) {
    metrics.reuseRuns += 1;
    metrics.reuseLatencyMs = pushLatency(metrics.reuseLatencyMs, latencyMs);
  } else {
    metrics.firstRuns += 1;
    metrics.firstLatencyMs = pushLatency(metrics.firstLatencyMs, latencyMs);
  }
  writeMetrics(projectDir, metrics);
}
function readDesktopAutomationKpi(projectDir) {
  const metrics = readMetrics(projectDir);
  const totalRuns = metrics.totalRuns > 0 ? metrics.totalRuns : 1;
  const somRuns = metrics.somRuns > 0 ? metrics.somRuns : 1;
  const highRiskRuns = metrics.highRiskRuns > 0 ? metrics.highRiskRuns : 1;
  const snapshot = {
    totalRuns: metrics.totalRuns,
    successfulRuns: metrics.successfulRuns,
    vlmCallRatio: Number((metrics.vlmCalls / totalRuns).toFixed(4)),
    somPathHitRate: Number((metrics.somSuccessRuns / somRuns).toFixed(4)),
    reuseTaskP95Ms: p95(metrics.reuseLatencyMs),
    firstTaskP95Ms: p95(metrics.firstLatencyMs),
    highRiskMisfireRate: Number((metrics.highRiskMisfireRuns / highRiskRuns).toFixed(4)),
    reuseRuns: metrics.reuseRuns,
    firstRuns: metrics.firstRuns
  };
  return {
    ...snapshot,
    acceptance: evaluateDesktopAutomationAcceptance(metrics, snapshot)
  };
}

// src/channel/outbound/shared.ts
function safeValueFromSignal(signal, key) {
  const matched = new RegExp(`${key}=([^|]*)`).exec(signal)?.[1];
  if (matched == null)
    return;
  const text = matched.trim();
  return text.length > 0 ? text : undefined;
}
function deriveDesktopFailureDetail(input) {
  return safeValueFromSignal(input.signal, "error") ?? (input.stderr.trim() || undefined) ?? (input.stdout.trim() || undefined) ?? (input.timedOut ? "timeout" : `exit_${input.exitCode}`);
}
function buildEvidenceDir(projectDir, channel) {
  const root = getMiyaVisionTempDir(projectDir, channel);
  fs15.mkdirSync(root, { recursive: true });
  return root;
}
function parseJsonFromEnv(raw) {
  const text = String(raw ?? "").trim();
  if (!text)
    return;
  try {
    return JSON.parse(text);
  } catch {
    return;
  }
}
async function sendDesktopOutbound(input) {
  const destination = input.destination.trim();
  const text = (input.text ?? "").trim();
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = createHash4("sha256").update(`${text}||${mediaPath}`).digest("hex");
  const traceID = `desktop_${randomUUID6()}`;
  const evidenceDir = buildEvidenceDir(input.projectDir, input.channel);
  if (process.platform !== "win32") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_windows_only",
      automationPath: "sendkeys",
      simulationStatus: "not_available",
      simulationRiskHints: ["platform_not_supported"],
      receiptStatus: "uncertain",
      failureStep: "preflight.platform",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (process.env.MIYA_UI_AUTOMATION_ENABLED !== "1") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_disabled:set MIYA_UI_AUTOMATION_ENABLED=1",
      automationPath: "sendkeys",
      simulationStatus: "not_available",
      simulationRiskHints: ["desktop_ui_disabled"],
      receiptStatus: "uncertain",
      failureStep: "preflight.runtime_switch",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (!destination || !text && !mediaPath) {
    return Promise.resolve({
      sent: false,
      message: "invalid_desktop_send_args",
      automationPath: "sendkeys",
      simulationStatus: "not_available",
      simulationRiskHints: ["invalid_arguments"],
      receiptStatus: "uncertain",
      failureStep: "preflight.args",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  const rawDisplayWidth = Number(process.env.MIYA_DESKTOP_DISPLAY_WIDTH ?? 1920);
  const rawDisplayHeight = Number(process.env.MIYA_DESKTOP_DISPLAY_HEIGHT ?? 1080);
  const displayWidth = Number.isFinite(rawDisplayWidth) ? Math.max(640, Math.min(16384, Math.floor(rawDisplayWidth))) : 1920;
  const displayHeight = Number.isFinite(rawDisplayHeight) ? Math.max(480, Math.min(16384, Math.floor(rawDisplayHeight))) : 1080;
  const ocrText = String(process.env.MIYA_DESKTOP_OCR_TEXT ?? "").trim();
  const ocrBoxes = parseJsonFromEnv(process.env.MIYA_DESKTOP_OCR_BOXES_JSON);
  const somCandidates = parseJsonFromEnv(process.env.MIYA_DESKTOP_SOM_CANDIDATES_JSON);
  const actionPlan = buildDesktopActionPlan({
    projectDir: input.projectDir,
    intent: {
      kind: "desktop_outbound_send",
      channel: input.channel,
      appName: input.appName,
      destination,
      payloadHash,
      hasText: text.length > 0,
      hasMedia: mediaPath.length > 0,
      risk: input.riskLevel ?? "LOW"
    },
    screenState: {
      windowFingerprint: undefined,
      captureMethod: "unknown",
      display: {
        width: displayWidth,
        height: displayHeight
      },
      uiaAvailable: process.env.MIYA_DESKTOP_UIA_FIRST !== "0",
      ocrAvailable: String(process.env.MIYA_VISION_LOCAL_CMD ?? "").trim().length > 0 || String(process.env.MIYA_QWEN3VL_CMD ?? "").trim().length > 0 || String(process.env.MIYA_VISION_OCR_ENDPOINT ?? "").trim().length > 0 || ocrText.length > 0 || Array.isArray(ocrBoxes) && ocrBoxes.length > 0,
      ocrText: ocrText || undefined,
      ocrBoxes,
      somCandidates
    }
  });
  const actionPlanJson = JSON.stringify(actionPlan);
  const actionPlanB64 = Buffer.from(actionPlanJson, "utf-8").toString("base64");
  const script = `
$ErrorActionPreference = 'Stop'
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
try { Add-Type -AssemblyName UIAutomationClient | Out-Null } catch {}
Add-Type @"
using System;
using System.Runtime.InteropServices;
using System.Text;
public static class MiyaInputProbe {
  [StructLayout(LayoutKind.Sequential)]
  public struct POINT { public int X; public int Y; }
  [DllImport("user32.dll")] public static extern bool GetCursorPos(out POINT point);
  [DllImport("user32.dll")] public static extern short GetAsyncKeyState(int vKey);
}
public static class MiyaWinApi {
  [DllImport("user32.dll")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
  [DllImport("user32.dll")] public static extern bool SetForegroundWindow(IntPtr hWnd);
  [DllImport("user32.dll")] public static extern bool BringWindowToTop(IntPtr hWnd);
  [DllImport("user32.dll")] public static extern IntPtr GetForegroundWindow();
  [DllImport("user32.dll")] public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
  [DllImport("kernel32.dll")] public static extern uint GetCurrentThreadId();
  [DllImport("user32.dll")] public static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);
  [DllImport("user32.dll", CharSet = CharSet.Unicode)] public static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);
  [DllImport("user32.dll", CharSet = CharSet.Unicode)] public static extern int GetClassName(IntPtr hWnd, StringBuilder lpClassName, int nMaxCount);
}
public static class MiyaHumanInput {
  [StructLayout(LayoutKind.Sequential)]
  public struct INPUT {
    public uint type;
    public InputUnion U;
  }

  [StructLayout(LayoutKind.Explicit)]
  public struct InputUnion {
    [FieldOffset(0)]
    public MOUSEINPUT mi;
    [FieldOffset(0)]
    public KEYBDINPUT ki;
  }

  [StructLayout(LayoutKind.Sequential)]
  public struct MOUSEINPUT {
    public int dx;
    public int dy;
    public uint mouseData;
    public uint dwFlags;
    public uint time;
    public IntPtr dwExtraInfo;
  }

  [StructLayout(LayoutKind.Sequential)]
  public struct KEYBDINPUT {
    public ushort wVk;
    public ushort wScan;
    public uint dwFlags;
    public uint time;
    public IntPtr dwExtraInfo;
  }

  [DllImport("user32.dll", SetLastError = true)]
  public static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

  [DllImport("user32.dll", SetLastError = true)]
  public static extern bool SetCursorPos(int X, int Y);

  public const uint INPUT_MOUSE = 0;
  public const uint INPUT_KEYBOARD = 1;
  public const uint KEYEVENTF_KEYUP = 0x0002;
  public const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
  public const uint MOUSEEVENTF_LEFTUP = 0x0004;

  public static void KeyTap(ushort vk) {
    INPUT[] inputs = new INPUT[2];
    inputs[0].type = INPUT_KEYBOARD;
    inputs[0].U.ki.wVk = vk;
    inputs[0].U.ki.dwFlags = 0;
    inputs[1].type = INPUT_KEYBOARD;
    inputs[1].U.ki.wVk = vk;
    inputs[1].U.ki.dwFlags = KEYEVENTF_KEYUP;
    SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
  }

  public static void KeyChord(ushort modifier, ushort key) {
    INPUT[] inputs = new INPUT[4];
    inputs[0].type = INPUT_KEYBOARD;
    inputs[0].U.ki.wVk = modifier;
    inputs[1].type = INPUT_KEYBOARD;
    inputs[1].U.ki.wVk = key;
    inputs[2].type = INPUT_KEYBOARD;
    inputs[2].U.ki.wVk = key;
    inputs[2].U.ki.dwFlags = KEYEVENTF_KEYUP;
    inputs[3].type = INPUT_KEYBOARD;
    inputs[3].U.ki.wVk = modifier;
    inputs[3].U.ki.dwFlags = KEYEVENTF_KEYUP;
    SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
  }

  public static void LeftClick() {
    INPUT[] inputs = new INPUT[2];
    inputs[0].type = INPUT_MOUSE;
    inputs[0].U.mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
    inputs[1].type = INPUT_MOUSE;
    inputs[1].U.mi.dwFlags = MOUSEEVENTF_LEFTUP;
    SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
  }

  public static void Move(int x, int y) {
    SetCursorPos(x, y);
  }
}
"@

$destination = $env:MIYA_DESTINATION
$payload = $env:MIYA_MESSAGE
$mediaPath = $env:MIYA_MEDIA_PATH
$appName = $env:MIYA_APP_NAME
$payloadHash = $env:MIYA_PAYLOAD_HASH
$traceId = $env:MIYA_TRACE_ID
$evidenceDir = $env:MIYA_EVIDENCE_DIR
$actionPlanB64 = $env:MIYA_ACTION_PLAN_B64
$actionPlanRaw = $env:MIYA_ACTION_PLAN_JSON
$shell = New-Object -ComObject WScript.Shell

$step = "bootstrap"
$precheck = "unavailable"
$postcheck = "unavailable"
$receipt = "uncertain"
$recipientCheck = "uncertain"
$preShot = ""
$postShot = ""
$windowFingerprint = ""
$automationPath = "sendkeys"
$uiaPath = "none"
$simulation = "not_available"
$targetHwndText = ""
$foregroundBeforeText = ""
$foregroundAfterText = ""
$fallbackReasons = New-Object System.Collections.Generic.List[string]
$riskHints = New-Object System.Collections.Generic.List[string]
$routeLevel = "L1_UIA"
$somSelectionSource = "none"
$somSelectedCandidate = ""
$vlmCallsUsed = 0
$sendInputEnabled = ($env:MIYA_DESKTOP_SENDINPUT_ENABLED -ne '0')
$actionPlan = $null
try {
  $actionPlanPayload = ""
  if ($actionPlanB64) {
    $actionPlanPayload = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($actionPlanB64))
  } else {
    $actionPlanPayload = [string]$actionPlanRaw
  }
  if ($actionPlanPayload) {
    $actionPlan = $actionPlanPayload | ConvertFrom-Json
    if ($actionPlan -and $actionPlan.action_plan) {
      $routeRaw = [string]$actionPlan.action_plan.routeLevel
      if ($routeRaw -in @('L0_ACTION_MEMORY','L1_UIA','L2_OCR','L3_SOM_VLM')) {
        $routeLevel = $routeRaw
      }
      $som = $actionPlan.action_plan.som
      if ($som) {
        $sourceRaw = [string]$som.selectionSource
        if ($sourceRaw -in @('memory','heuristic','vlm','none')) {
          $somSelectionSource = $sourceRaw
        }
        if ($som.selectedCandidateId) {
          $somSelectedCandidate = [string][int]$som.selectedCandidateId
        }
        if ($som.vlmCallsPlanned -ne $null) {
          $planned = [int]$som.vlmCallsPlanned
          $vlmCallsUsed = [Math]::Max(0, [Math]::Min(2, $planned))
        }
      }
    }
  }
} catch {
  $riskHints.Add("action_plan_parse_failed")
}

function Safe-Token {
  param([string]$Value)
  if (-not $Value) { return "" }
  return $Value.Replace('|', '/').Replace([char]13, ' ').Replace([char]10, ' ').Trim()
}

function Get-Sha256Hex {
  param([string]$Value)
  if (-not $Value) { return "" }
  $sha = [System.Security.Cryptography.SHA256]::Create()
  try {
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($Value)
    $hash = $sha.ComputeHash($bytes)
    return ([BitConverter]::ToString($hash) -replace '-', '').ToLowerInvariant()
  } finally {
    $sha.Dispose()
  }
}

function Format-Hwnd {
  param([IntPtr]$Hwnd)
  if ($Hwnd -eq [IntPtr]::Zero) { return "0x0" }
  return ('0x{0:X}' -f [UInt64]$Hwnd.ToInt64())
}

function Save-Screenshot {
  param([string]$TargetPath)
  try {
    $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
    $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
    $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
    $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)
    $bitmap.Save($TargetPath, [System.Drawing.Imaging.ImageFormat]::Png)
    $graphics.Dispose()
    $bitmap.Dispose()
  } catch {}
}

function Get-CursorPoint {
  $point = New-Object MiyaInputProbe+POINT
  [void][MiyaInputProbe]::GetCursorPos([ref]$point)
  return @{ X = [int]$point.X; Y = [int]$point.Y }
}

function Test-KeyboardActivity {
  $keys = @(0x08,0x09,0x0D,0x10,0x11,0x12,0x1B,0x20,0x25,0x26,0x27,0x28,0x2E,0x5B,0x5C)
  foreach ($vk in $keys) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  for ($vk = 0x30; $vk -le 0x5A; $vk++) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  return $false
}

function Wait-UserInputIdle {
  param([int]$TimeoutMs = 1200, [int]$StableMs = 350, [int]$SampleMs = 60)
  $deadline = (Get-Date).AddMilliseconds($TimeoutMs)
  $idleSince = Get-Date
  $last = Get-CursorPoint
  while ((Get-Date) -lt $deadline) {
    Start-Sleep -Milliseconds $SampleMs
    $curr = Get-CursorPoint
    $moved = ([Math]::Abs($curr.X - $last.X) + [Math]::Abs($curr.Y - $last.Y)) -gt 2
    $typing = Test-KeyboardActivity
    if ($moved -or $typing) {
      $idleSince = Get-Date
      $last = $curr
      continue
    }
    if (((Get-Date) - $idleSince).TotalMilliseconds -ge $StableMs) {
      return $curr
    }
    $last = $curr
  }
  throw "input_mutex_timeout:user_active"
}

function Assert-NoUserInterference {
  param($LockPoint)
  $curr = Get-CursorPoint
  $moved = ([Math]::Abs($curr.X - $LockPoint.X) + [Math]::Abs($curr.Y - $LockPoint.Y)) -gt 6
  if ($moved -or (Test-KeyboardActivity)) {
    throw "input_mutex_timeout:user_interference"
  }
}

function Start-JitterSleep {
  param([int]$MinMs = 18, [int]$MaxMs = 52)
  $min = [Math]::Max(1, $MinMs)
  $max = [Math]::Max($min + 1, $MaxMs)
  Start-Sleep -Milliseconds (Get-Random -Minimum $min -Maximum $max)
}

function Invoke-HumanKeyTap {
  param([int]$Vk, [string]$Fallback)
  if ($sendInputEnabled) {
    [MiyaHumanInput]::KeyTap([uint16]$Vk)
    Start-JitterSleep
    return
  }
  [System.Windows.Forms.SendKeys]::SendWait($Fallback)
}

function Invoke-HumanPaste {
  if ($sendInputEnabled) {
    [MiyaHumanInput]::KeyChord([uint16]0x11, [uint16]0x56)
    Start-JitterSleep -MinMs 24 -MaxMs 76
    return
  }
  [System.Windows.Forms.SendKeys]::SendWait('^v')
}

function Invoke-HumanEnter {
  Invoke-HumanKeyTap -Vk 0x0D -Fallback '{ENTER}'
}

function Invoke-HumanLeftClick {
  [MiyaHumanInput]::LeftClick()
  Start-JitterSleep -MinMs 18 -MaxMs 60
}

function Move-HumanMouseBezier {
  param([int]$TargetX, [int]$TargetY, [int]$DurationMs = 260)
  $start = Get-CursorPoint
  $steps = [Math]::Max(10, [Math]::Min(36, [int]($DurationMs / 14)))
  $dx = $TargetX - $start.X
  $dy = $TargetY - $start.Y
  $ctrl1x = $start.X + [int]($dx * 0.25) + (Get-Random -Minimum -26 -Maximum 27)
  $ctrl1y = $start.Y + [int]($dy * 0.15) + (Get-Random -Minimum -22 -Maximum 23)
  $ctrl2x = $start.X + [int]($dx * 0.75) + (Get-Random -Minimum -26 -Maximum 27)
  $ctrl2y = $start.Y + [int]($dy * 0.85) + (Get-Random -Minimum -22 -Maximum 23)
  for ($i = 1; $i -le $steps; $i++) {
    $t = [double]$i / [double]$steps
    $u = 1.0 - $t
    $x = [int]([Math]::Round(($u*$u*$u*$start.X) + (3*$u*$u*$t*$ctrl1x) + (3*$u*$t*$t*$ctrl2x) + ($t*$t*$t*$TargetX)))
    $y = [int]([Math]::Round(($u*$u*$u*$start.Y) + (3*$u*$u*$t*$ctrl1y) + (3*$u*$t*$t*$ctrl2y) + ($t*$t*$t*$TargetY)))
    $jx = $x + (Get-Random -Minimum -1 -Maximum 2)
    $jy = $y + (Get-Random -Minimum -1 -Maximum 2)
    [MiyaHumanInput]::Move($jx, $jy)
    Start-JitterSleep -MinMs 6 -MaxMs 18
  }
}

function Get-PixelFingerprint {
  param([int]$X, [int]$Y)
  try {
    $w = 16
    $h = 16
    $bitmap = New-Object System.Drawing.Bitmap $w, $h
    $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
    $graphics.CopyFromScreen([Math]::Max(0, $X - 8), [Math]::Max(0, $Y - 8), 0, 0, [System.Drawing.Size]::new($w, $h))
    $sum = 0L
    for ($yy = 0; $yy -lt $h; $yy += 2) {
      for ($xx = 0; $xx -lt $w; $xx += 2) {
        $c = $bitmap.GetPixel($xx, $yy)
        $sum += [int]$c.R + [int]$c.G + [int]$c.B
      }
    }
    $graphics.Dispose()
    $bitmap.Dispose()
    return [string]$sum
  } catch {
    return ""
  }
}

function Resolve-SomCandidatePoint {
  param($Som, [int]$DisplayWidth, [int]$DisplayHeight)
  if (-not $Som) { return $null }
  $candidateId = $Som.selectedCandidateId
  if (-not $candidateId) { return $null }
  $candidate = $Som.candidates | Where-Object { $_.id -eq $candidateId } | Select-Object -First 1
  if (-not $candidate) { return $null }
  $coarseRow = if ($candidate.coarse -and $candidate.coarse.row -ne $null) { [int]$candidate.coarse.row } else { 4 }
  $coarseCol = if ($candidate.coarse -and $candidate.coarse.col -ne $null) { [int]$candidate.coarse.col } else { 4 }
  $cellW = [Math]::Max(1, [int]($DisplayWidth / 10))
  $cellH = [Math]::Max(1, [int]($DisplayHeight / 10))
  $coarseX = [Math]::Min($DisplayWidth - 1, [Math]::Max(0, $coarseCol * $cellW + [int]($cellW / 2)))
  $coarseY = [Math]::Min($DisplayHeight - 1, [Math]::Max(0, $coarseRow * $cellH + [int]($cellH / 2)))
  $roiX = if ($candidate.roi -and $candidate.roi.x -ne $null) { [int]$candidate.roi.x } else { $coarseCol * $cellW }
  $roiY = if ($candidate.roi -and $candidate.roi.y -ne $null) { [int]$candidate.roi.y } else { $coarseRow * $cellH }
  $roiW = if ($candidate.roi -and $candidate.roi.width -ne $null) { [int]$candidate.roi.width } else { $cellW }
  $roiH = if ($candidate.roi -and $candidate.roi.height -ne $null) { [int]$candidate.roi.height } else { $cellH }
  $fineX = [Math]::Min($DisplayWidth - 1, [Math]::Max(0, $roiX + [int]($roiW / 2) + (Get-Random -Minimum -3 -Maximum 4)))
  $fineY = [Math]::Min($DisplayHeight - 1, [Math]::Max(0, $roiY + [int]($roiH / 2) + (Get-Random -Minimum -3 -Maximum 4)))
  return @{
    id = [int]$candidateId
    coarseX = [int]$coarseX
    coarseY = [int]$coarseY
    fineX = [int]$fineX
    fineY = [int]$fineY
  }
}

function Invoke-SomCandidateActivation {
  param($Som, [int]$DisplayWidth, [int]$DisplayHeight, [int]$ExpectedPid)
  $point = Resolve-SomCandidatePoint -Som $Som -DisplayWidth $DisplayWidth -DisplayHeight $DisplayHeight
  if (-not $point) { return $false }
  $beforeFingerprint = Get-PixelFingerprint -X $point.fineX -Y $point.fineY
  Move-HumanMouseBezier -TargetX $point.coarseX -TargetY $point.coarseY -DurationMs 190
  Move-HumanMouseBezier -TargetX $point.fineX -TargetY $point.fineY -DurationMs 180
  Invoke-HumanLeftClick
  $afterFingerprint = Get-PixelFingerprint -X $point.fineX -Y $point.fineY
  if ($beforeFingerprint -and $afterFingerprint -and $beforeFingerprint -eq $afterFingerprint) {
    $riskHints.Add("som_pixel_fingerprint_static")
  }
  try {
    $el = [System.Windows.Automation.AutomationElement]::FromPoint([System.Windows.Point]::new([double]$point.fineX, [double]$point.fineY))
    if (-not $el -or ($ExpectedPid -gt 0 -and $el.Current.ProcessId -ne $ExpectedPid)) {
      $riskHints.Add("som_uia_hit_test_failed")
    }
  } catch {
    $riskHints.Add("som_uia_hit_test_unavailable")
  }
  $somSelectedCandidate = [string]$point.id
  return $true
}

function Get-WindowTitle {
  param([IntPtr]$Hwnd)
  if ($Hwnd -eq [IntPtr]::Zero) { return "" }
  $sb = New-Object System.Text.StringBuilder 1024
  [void][MiyaWinApi]::GetWindowText($Hwnd, $sb, $sb.Capacity)
  return Safe-Token($sb.ToString())
}

function Get-WindowClass {
  param([IntPtr]$Hwnd)
  if ($Hwnd -eq [IntPtr]::Zero) { return "" }
  $sb = New-Object System.Text.StringBuilder 512
  [void][MiyaWinApi]::GetClassName($Hwnd, $sb, $sb.Capacity)
  return Safe-Token($sb.ToString())
}

function Get-WindowProcessId {
  param([IntPtr]$Hwnd)
  $pid = [uint32]0
  [void][MiyaWinApi]::GetWindowThreadProcessId($Hwnd, [ref]$pid)
  return [int]$pid
}

function Build-WindowFingerprint {
  param([IntPtr]$Hwnd)
  if ($Hwnd -eq [IntPtr]::Zero) { return "" }
  $pid = Get-WindowProcessId -Hwnd $Hwnd
  $titleHash = (Get-Sha256Hex (Get-WindowTitle -Hwnd $Hwnd))
  if ($titleHash.Length -gt 12) { $titleHash = $titleHash.Substring(0, 12) }
  $classHash = (Get-Sha256Hex (Get-WindowClass -Hwnd $Hwnd))
  if ($classHash.Length -gt 12) { $classHash = $classHash.Substring(0, 12) }
  return ("pid=" + $pid + ";hwnd=" + (Format-Hwnd -Hwnd $Hwnd) + ";class=" + $classHash + ";title=" + $titleHash)
}

function Resolve-TargetWindow {
  param([string]$AppName, [string]$Destination)
  $windows = @(Get-Process -Name $AppName -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowHandle -and $_.MainWindowHandle -ne 0 })
  if ($windows.Count -eq 0) {
    Start-Process -FilePath $AppName | Out-Null
    Start-Sleep -Milliseconds 1200
    $windows = @(Get-Process -Name $AppName -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowHandle -and $_.MainWindowHandle -ne 0 })
  }
  if ($windows.Count -eq 0) { return $null }
  $selected = $null
  if ($Destination) {
    $selected = $windows | Where-Object { $_.MainWindowTitle -like ("*" + $Destination + "*") } | Select-Object -First 1
  }
  if (-not $selected) {
    $selected = $windows | Select-Object -First 1
  }
  if (-not $selected) { return $null }
  $hwnd = [IntPtr]$selected.MainWindowHandle
  return @{
    processId = [int]$selected.Id
    hwnd = $hwnd
    title = Safe-Token([string]$selected.MainWindowTitle)
    fingerprint = Build-WindowFingerprint -Hwnd $hwnd
  }
}

function Focus-WindowWinApi {
  param([IntPtr]$TargetHwnd, [string]$Destination, [string]$AppName)
  $before = [MiyaWinApi]::GetForegroundWindow()
  $targetPid = [uint32]0
  $targetThread = [MiyaWinApi]::GetWindowThreadProcessId($TargetHwnd, [ref]$targetPid)
  $selfThread = [MiyaWinApi]::GetCurrentThreadId()
  $fgPid = [uint32]0
  $fgThread = if ($before -ne [IntPtr]::Zero) { [MiyaWinApi]::GetWindowThreadProcessId($before, [ref]$fgPid) } else { [uint32]0 }
  $attachedSelf = $false
  $attachedForeground = $false
  [void][MiyaWinApi]::ShowWindow($TargetHwnd, 9)
  try {
    if ($targetThread -ne 0 -and $targetThread -ne $selfThread) {
      $attachedSelf = [MiyaWinApi]::AttachThreadInput($selfThread, $targetThread, $true)
    }
    if ($targetThread -ne 0 -and $fgThread -ne 0 -and $fgThread -ne $targetThread) {
      $attachedForeground = [MiyaWinApi]::AttachThreadInput($fgThread, $targetThread, $true)
    }
    [void][MiyaWinApi]::SetForegroundWindow($TargetHwnd)
    [void][MiyaWinApi]::BringWindowToTop($TargetHwnd)
    Start-Sleep -Milliseconds 120
  } finally {
    if ($attachedForeground) {
      [void][MiyaWinApi]::AttachThreadInput($fgThread, $targetThread, $false)
    }
    if ($attachedSelf) {
      [void][MiyaWinApi]::AttachThreadInput($selfThread, $targetThread, $false)
    }
  }
  $fallbackReason = ""
  $after = [MiyaWinApi]::GetForegroundWindow()
  if ($after -ne $TargetHwnd) {
    $fallbackReason = "winapi_foreground_mismatch"
    $activated = $false
    if ($Destination) {
      $activated = $shell.AppActivate($Destination)
    }
    if (-not $activated) {
      $activated = $shell.AppActivate($AppName)
      if (-not $activated) {
        $fallbackReason = "winapi_and_appactivate_failed"
      } else {
        $fallbackReason = "winapi_fallback_appactivate_app"
      }
    } else {
      $fallbackReason = "winapi_fallback_appactivate_destination"
    }
    Start-Sleep -Milliseconds 120
    $after = [MiyaWinApi]::GetForegroundWindow()
  }
  return @{
    ok = ($after -eq $TargetHwnd)
    before = $before
    after = $after
    fallbackReason = $fallbackReason
  }
}

function Assert-TargetStable {
  param(
    [string]$AppName,
    [string]$Destination,
    [IntPtr]$ExpectedHwnd,
    [string]$ExpectedFingerprint,
    [string]$Phase
  )
  $resolved = Resolve-TargetWindow -AppName $AppName -Destination $Destination
  if (-not $resolved) {
    throw ("window_not_found:" + $Phase)
  }
  if ($resolved.hwnd -ne $ExpectedHwnd) {
    throw ("hwnd_changed:" + $Phase)
  }
  if ($ExpectedFingerprint -and $resolved.fingerprint -ne $ExpectedFingerprint) {
    throw ("hwnd_fingerprint_mismatch:" + $Phase)
  }
  return $resolved
}

function Try-SendTextViaUia {
  param(
    [string]$Value,
    [int]$ExpectedProcessId,
    [IntPtr]$ExpectedHwnd
  )
  try {
    if ($ExpectedHwnd -ne [IntPtr]::Zero -and [MiyaWinApi]::GetForegroundWindow() -ne $ExpectedHwnd) {
      return $false
    }
    $focused = [System.Windows.Automation.AutomationElement]::FocusedElement
    if (-not $focused) { return $false }
    if ($ExpectedProcessId -gt 0 -and $focused.Current.ProcessId -ne $ExpectedProcessId) {
      return $false
    }
    $valuePattern = $focused.GetCurrentPattern([System.Windows.Automation.ValuePattern]::Pattern)
    if (-not $valuePattern) { return $false }
    if ($focused.Current.IsEnabled -ne $true) { return $false }
    $valuePattern.SetValue($Value)
    Start-Sleep -Milliseconds 120
    Invoke-HumanEnter
    return $true
  } catch {
    return $false
  }
}

try {
  if (-not (Test-Path -LiteralPath $evidenceDir)) {
    New-Item -ItemType Directory -Path $evidenceDir -Force | Out-Null
  }
  $step = "bootstrap.process"
  $lockPoint = Wait-UserInputIdle

  $target = Resolve-TargetWindow -AppName $appName -Destination $destination
  if (-not $target) {
    throw ("window_not_found:" + $destination)
  }
  $targetHwnd = $target.hwnd
  $targetHwndText = Format-Hwnd -Hwnd $targetHwnd
  $windowFingerprint = $target.fingerprint

  $step = "precheck.focus_winapi"
  $focus = Focus-WindowWinApi -TargetHwnd $targetHwnd -Destination $destination -AppName $appName
  $foregroundBeforeText = Format-Hwnd -Hwnd $focus.before
  $foregroundAfterText = Format-Hwnd -Hwnd $focus.after
  if ($focus.fallbackReason) { $fallbackReasons.Add($focus.fallbackReason) }
  if (-not $focus.ok) {
    throw "window_focus_verify_failed"
  }
  $precheck = "window_activated"
  Assert-NoUserInterference -LockPoint $lockPoint
  $target = Assert-TargetStable -AppName $appName -Destination $destination -ExpectedHwnd $targetHwnd -ExpectedFingerprint $windowFingerprint -Phase "before_send"
  if ($target.title -like ("*" + $destination + "*")) {
    $recipientCheck = "matched"
  }

  $step = "precheck.capture"
  $preShot = Join-Path $evidenceDir ($traceId + "_pre.png")
  Save-Screenshot -TargetPath $preShot

  if ($env:MIYA_DESKTOP_UIA_FIRST -eq '0') {
    $riskHints.Add("uia_disabled_by_config")
  } else {
    try {
      $null = [System.Windows.Automation.AutomationElement]::FocusedElement
      $simulation = "captured"
    } catch {
      $simulation = "not_available"
      $riskHints.Add("uia_runtime_unavailable")
    }
  }

  if ($routeLevel -in @('L2_OCR','L3_SOM_VLM')) {
    $step = "locate.som"
    if ($actionPlan -and $actionPlan.action_plan -and $actionPlan.action_plan.som) {
      $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
      $somActivated = Invoke-SomCandidateActivation -Som $actionPlan.action_plan.som -DisplayWidth $bounds.Width -DisplayHeight $bounds.Height -ExpectedPid $target.processId
      if (-not $somActivated) {
        throw "som_candidate_unresolved"
      }
    } else {
      if ($routeLevel -eq 'L2_OCR') {
        $riskHints.Add("ocr_locator_missing_candidate")
      } else {
        throw "som_plan_missing"
      }
    }
  }

  if ($mediaPath) {
    Assert-NoUserInterference -LockPoint $lockPoint
    [void](Assert-TargetStable -AppName $appName -Destination $destination -ExpectedHwnd $targetHwnd -ExpectedFingerprint $windowFingerprint -Phase "media_prepare")
    $step = "send.media_prepare"
    if (-not (Test-Path -LiteralPath $mediaPath)) {
      throw ("media_not_found:" + $mediaPath)
    }
    $list = New-Object System.Collections.Specialized.StringCollection
    $list.Add($mediaPath) | Out-Null
    $data = New-Object System.Windows.Forms.DataObject
    $data.SetFileDropList($list)
    [System.Windows.Forms.Clipboard]::SetDataObject($data, $true)
    Start-Sleep -Milliseconds 220
    Invoke-HumanPaste
    $step = "send.media_commit"
    Start-Sleep -Milliseconds 220
    Invoke-HumanEnter
    Start-Sleep -Milliseconds 220
    if ($automationPath -eq "uia") { $automationPath = "mixed" } else { $automationPath = "sendkeys" }
    if ($env:MIYA_DESKTOP_UIA_FIRST -ne '0') { $riskHints.Add("media_sendkeys_path") }
  }

  if ($payload) {
    Assert-NoUserInterference -LockPoint $lockPoint
    [void](Assert-TargetStable -AppName $appName -Destination $destination -ExpectedHwnd $targetHwnd -ExpectedFingerprint $windowFingerprint -Phase "text_prepare")
    $sentViaUia = $false
    if ($env:MIYA_DESKTOP_UIA_FIRST -ne '0') {
      $step = "send.text_prepare.uia"
      $sentViaUia = Try-SendTextViaUia -Value $payload -ExpectedProcessId $target.processId -ExpectedHwnd $targetHwnd
      if ($sentViaUia) {
        if ($automationPath -eq "sendkeys") { $automationPath = "uia" } else { $automationPath = "mixed" }
        $uiaPath = "valuepattern"
        $step = "send.text_commit.uia"
      } else {
        $fallbackReasons.Add("uia_valuepattern_unavailable")
      }
    }
    if (-not $sentViaUia) {
      $step = "send.text_prepare.clipboard"
      Set-Clipboard -Value $payload
      Start-Sleep -Milliseconds 180
      Invoke-HumanPaste
      $step = "send.text_commit.clipboard"
      Start-Sleep -Milliseconds 120
      Invoke-HumanEnter
      if ($automationPath -eq "uia") { $automationPath = "mixed" } else { $automationPath = "sendkeys" }
      $uiaPath = "clipboard_sendkeys"
    }
  }

  $step = "postcheck.verify_window"
  $foregroundNow = [MiyaWinApi]::GetForegroundWindow()
  if ($foregroundNow -ne $targetHwnd) {
    throw "foreground_drift_after_send"
  }
  $targetAfter = Assert-TargetStable -AppName $appName -Destination $destination -ExpectedHwnd $targetHwnd -ExpectedFingerprint $windowFingerprint -Phase "after_send"
  $windowFingerprint = $targetAfter.fingerprint
  $postcheck = "window_active_after_send"
  $receipt = "confirmed"
  $step = "postcheck.capture"
  $postShot = Join-Path $evidenceDir ($traceId + "_post.png")
  Save-Screenshot -TargetPath $postShot

  $fallbackReason = if ($fallbackReasons.Count -gt 0) { ($fallbackReasons -join ',') } else { "none" }
  $windowFpToken = Safe-Token -Value $windowFingerprint
  $fallbackToken = Safe-Token -Value $fallbackReason
  $preShotToken = Safe-Token -Value $preShot
  $postShotToken = Safe-Token -Value $postShot
  $somCandidateToken = Safe-Token -Value $somSelectedCandidate
  $riskToken = Safe-Token -Value ($riskHints -join ',')
  Write-Output ("desktop_send_ok|step=" + $step + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFpToken + "|target_hwnd=" + $targetHwndText + "|foreground_before=" + $foregroundBeforeText + "|foreground_after=" + $foregroundAfterText + "|uia_path=" + $uiaPath + "|fallback_reason=" + $fallbackToken + "|pre_shot=" + $preShotToken + "|post_shot=" + $postShotToken + "|payload=" + $payloadHash + "|automation=" + $automationPath + "|simulation=" + $simulation + "|route_level=" + $routeLevel + "|som_source=" + $somSelectionSource + "|som_candidate=" + $somCandidateToken + "|vlm_calls=" + ([string]$vlmCallsUsed) + "|risk=" + $riskToken)
  exit 0
} catch {
  $err = Safe-Token($_.Exception.Message)
  $fallbackReason = if ($fallbackReasons.Count -gt 0) { ($fallbackReasons -join ',') } else { "none" }
  $windowFpToken = Safe-Token -Value $windowFingerprint
  $targetHwndToken = Safe-Token -Value $targetHwndText
  $foregroundBeforeToken = Safe-Token -Value $foregroundBeforeText
  $foregroundAfterToken = Safe-Token -Value $foregroundAfterText
  $uiaPathToken = Safe-Token -Value $uiaPath
  $fallbackToken = Safe-Token -Value $fallbackReason
  $preShotToken = Safe-Token -Value $preShot
  $postShotToken = Safe-Token -Value $postShot
  $somCandidateToken = Safe-Token -Value $somSelectedCandidate
  $riskToken = Safe-Token -Value ($riskHints -join ',')
  Write-Output ("desktop_send_fail|step=" + $step + "|error=" + $err + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFpToken + "|target_hwnd=" + $targetHwndToken + "|foreground_before=" + $foregroundBeforeToken + "|foreground_after=" + $foregroundAfterToken + "|uia_path=" + $uiaPathToken + "|fallback_reason=" + $fallbackToken + "|pre_shot=" + $preShotToken + "|post_shot=" + $postShotToken + "|payload=" + $payloadHash + "|automation=" + $automationPath + "|simulation=" + $simulation + "|route_level=" + $routeLevel + "|som_source=" + $somSelectionSource + "|som_candidate=" + $somCandidateToken + "|vlm_calls=" + ([string]$vlmCallsUsed) + "|risk=" + $riskToken)
  exit 2
}
`.trim();
  const startedAt = Date.now();
  const proc = Bun.spawn([
    "powershell",
    "-NoProfile",
    "-NonInteractive",
    "-ExecutionPolicy",
    "Bypass",
    "-Command",
    script
  ], {
    env: {
      ...process.env,
      MIYA_DESTINATION: destination,
      MIYA_MESSAGE: text,
      MIYA_MEDIA_PATH: mediaPath,
      MIYA_APP_NAME: input.appName,
      MIYA_PAYLOAD_HASH: payloadHash,
      MIYA_TRACE_ID: traceID,
      MIYA_EVIDENCE_DIR: evidenceDir,
      MIYA_ACTION_PLAN_JSON: actionPlanJson,
      MIYA_ACTION_PLAN_B64: actionPlanB64
    },
    windowsHide: true,
    stdio: ["ignore", "pipe", "pipe"]
  });
  let timedOut = false;
  const timeout = setTimeout(() => {
    timedOut = true;
    try {
      proc.kill("SIGTERM");
    } catch {}
  }, 15000);
  const exitCode = await proc.exited;
  clearTimeout(timeout);
  const stdout = (await new Response(proc.stdout).text()).trim();
  const stderr = (await new Response(proc.stderr).text()).trim();
  const signal = stdout || stderr;
  const precheck = safeValueFromSignal(signal, "pre") ?? "failed";
  const postcheck = safeValueFromSignal(signal, "post") ?? "failed";
  const receipt = safeValueFromSignal(signal, "receipt") === "confirmed" ? "confirmed" : "uncertain";
  const failureStep = safeValueFromSignal(signal, "step") ?? "send.unknown";
  const windowFingerprint = safeValueFromSignal(signal, "window_fp");
  const targetHwnd = safeValueFromSignal(signal, "target_hwnd");
  const foregroundBefore = safeValueFromSignal(signal, "foreground_before");
  const foregroundAfter = safeValueFromSignal(signal, "foreground_after");
  const uiaPathRaw = safeValueFromSignal(signal, "uia_path");
  const uiaPath = uiaPathRaw === "valuepattern" || uiaPathRaw === "clipboard_sendkeys" || uiaPathRaw === "none" ? uiaPathRaw : undefined;
  const fallbackReason = safeValueFromSignal(signal, "fallback_reason");
  const recipientTextCheckRaw = safeValueFromSignal(signal, "recipient");
  const recipientTextCheck = recipientTextCheckRaw === "matched" || recipientTextCheckRaw === "mismatch" ? recipientTextCheckRaw : "uncertain";
  const preSendScreenshotPath = safeValueFromSignal(signal, "pre_shot");
  const postSendScreenshotPath = safeValueFromSignal(signal, "post_shot");
  const payloadFromSignal = safeValueFromSignal(signal, "payload") ?? payloadHash;
  const automationRaw = safeValueFromSignal(signal, "automation");
  const automationPath = automationRaw === "uia" || automationRaw === "mixed" || automationRaw === "sendkeys" ? automationRaw : "sendkeys";
  const simulationRaw = safeValueFromSignal(signal, "simulation");
  const simulationStatus = simulationRaw === "captured" ? "captured" : "not_available";
  const simulationRiskHints = (safeValueFromSignal(signal, "risk") ?? "").split(",").map((item) => item.trim()).filter(Boolean);
  const routeLevelRaw = safeValueFromSignal(signal, "route_level");
  const routeLevel = routeLevelRaw === "L0_ACTION_MEMORY" || routeLevelRaw === "L1_UIA" || routeLevelRaw === "L2_OCR" || routeLevelRaw === "L3_SOM_VLM" ? routeLevelRaw : actionPlan.action_plan.routeLevel;
  const somSelectionSourceRaw = safeValueFromSignal(signal, "som_source");
  const somSelectionSource = somSelectionSourceRaw === "memory" || somSelectionSourceRaw === "heuristic" || somSelectionSourceRaw === "vlm" || somSelectionSourceRaw === "none" ? somSelectionSourceRaw : actionPlan.action_plan.som.selectionSource;
  const somSelectedCandidateRaw = Number(safeValueFromSignal(signal, "som_candidate") ?? Number.NaN);
  const somSelectedCandidateId = Number.isFinite(somSelectedCandidateRaw) ? Math.max(1, Math.floor(somSelectedCandidateRaw)) : actionPlan.action_plan.som.selectedCandidateId;
  const vlmCallsRaw = Number(safeValueFromSignal(signal, "vlm_calls") ?? Number.NaN);
  const vlmCallsUsed = Number.isFinite(vlmCallsRaw) ? Math.max(0, Math.min(2, Math.floor(vlmCallsRaw))) : Math.max(0, Math.min(2, actionPlan.action_plan.som.vlmCallsPlanned ?? 0));
  const latencyMs = Math.max(1, Date.now() - startedAt);
  if (fallbackReason && fallbackReason !== "none") {
    simulationRiskHints.push(`focus_fallback:${fallbackReason}`);
  }
  const writeOutcomeAndReadKpi = (sent) => {
    try {
      recordDesktopActionOutcome(input.projectDir, {
        intent: actionPlan.intent,
        screenState: {
          ...actionPlan.screen_state,
          windowFingerprint: windowFingerprint ?? actionPlan.screen_state.windowFingerprint
        },
        actionPlan,
        sent,
        latencyMs,
        vlmCallsUsed,
        somSucceeded: routeLevel === "L2_OCR" || routeLevel === "L3_SOM_VLM" ? sent : false,
        highRiskMisfire: (input.riskLevel ?? "LOW") === "HIGH" && sent && recipientTextCheck === "mismatch"
      });
      return readDesktopAutomationKpi(input.projectDir);
    } catch {
      return;
    }
  };
  if (exitCode === 0 && stdout.includes("desktop_send_ok") && !timedOut) {
    const kpiSnapshot2 = writeOutcomeAndReadKpi(true);
    return {
      sent: true,
      message: `${input.channel}_desktop_sent`,
      automationPath,
      uiaPath,
      targetHwnd,
      foregroundBefore,
      foregroundAfter,
      fallbackReason,
      simulationStatus,
      simulationRiskHints,
      visualPrecheck: precheck,
      visualPostcheck: postcheck,
      receiptStatus: receipt,
      payloadHash: payloadFromSignal,
      windowFingerprint,
      recipientTextCheck,
      preSendScreenshotPath,
      postSendScreenshotPath,
      failureStep,
      routeLevel,
      actionPlan,
      somSelectionSource,
      somSelectedCandidateId,
      vlmCallsUsed,
      actionPlanMemoryHit: actionPlan.action_plan.memoryHit,
      latencyMs,
      kpiSnapshot: kpiSnapshot2
    };
  }
  const detail = deriveDesktopFailureDetail({
    signal,
    stdout,
    stderr,
    timedOut,
    exitCode
  });
  const kpiSnapshot = writeOutcomeAndReadKpi(false);
  return {
    sent: false,
    message: `${input.channel}_desktop_send_failed:${detail}`,
    automationPath,
    uiaPath,
    targetHwnd,
    foregroundBefore,
    foregroundAfter,
    fallbackReason,
    simulationStatus,
    simulationRiskHints,
    visualPrecheck: precheck,
    visualPostcheck: postcheck,
    receiptStatus: receipt,
    failureStep,
    payloadHash: payloadFromSignal,
    windowFingerprint,
    recipientTextCheck,
    preSendScreenshotPath,
    postSendScreenshotPath,
    routeLevel,
    actionPlan,
    somSelectionSource,
    somSelectedCandidateId,
    vlmCallsUsed,
    actionPlanMemoryHit: actionPlan.action_plan.memoryHit,
    latencyMs,
    kpiSnapshot
  };
}

// src/channel/outbound/qq.ts
async function sendQqDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "QQ",
    channel: "qq",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath,
    riskLevel: input.riskLevel
  });
}

// src/channel/outbound/wechat.ts
async function sendWechatDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "WeChat",
    channel: "wechat",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath,
    riskLevel: input.riskLevel
  });
}

// src/multimodal/vision.ts
import { spawnSync as spawnSync3 } from "node:child_process";
import * as fs17 from "node:fs";
import * as path19 from "node:path";

// src/media/store.ts
import { randomUUID as randomUUID7 } from "node:crypto";
import * as fs16 from "node:fs";
import * as path18 from "node:path";
var DEFAULT_TTL_HOURS = 24;
function nowIso11() {
  return new Date().toISOString();
}
function mediaDir(projectDir) {
  return path18.join(getMiyaRuntimeDir(projectDir), "media");
}
function mediaIndexFile(projectDir) {
  return path18.join(mediaDir(projectDir), "index.json");
}
function ensureDir7(dirPath) {
  fs16.mkdirSync(dirPath, { recursive: true });
}
function decodeMetadata(projectDir, metadata) {
  if (!metadata || typeof metadata !== "object")
    return metadata;
  if (typeof metadata.secure === "string") {
    try {
      const plain = decryptSensitiveValue(projectDir, metadata.secure);
      const parsed = JSON.parse(plain);
      return parsed;
    } catch {
      return metadata;
    }
  }
  return metadata;
}
function readStore3(projectDir) {
  const file3 = mediaIndexFile(projectDir);
  if (!fs16.existsSync(file3)) {
    return { items: {} };
  }
  try {
    const parsed = JSON.parse(fs16.readFileSync(file3, "utf-8"));
    const items = {};
    for (const [id, item] of Object.entries(parsed.items ?? {})) {
      items[id] = {
        ...item,
        source: decryptSensitiveValue(projectDir, String(item.source ?? "")),
        fileName: decryptSensitiveValue(projectDir, String(item.fileName ?? "")),
        localPath: typeof item.localPath === "string" ? decryptSensitiveValue(projectDir, item.localPath) : item.localPath,
        metadata: decodeMetadata(projectDir, item.metadata)
      };
    }
    return { items };
  } catch {
    return { items: {} };
  }
}
function writeStore(projectDir, store) {
  ensureDir7(mediaDir(projectDir));
  const encrypted = { items: {} };
  for (const [id, item] of Object.entries(store.items)) {
    encrypted.items[id] = {
      ...item,
      source: encryptSensitiveValue(projectDir, item.source),
      fileName: encryptSensitiveValue(projectDir, item.fileName),
      localPath: item.localPath ? encryptSensitiveValue(projectDir, item.localPath) : item.localPath,
      metadata: item.metadata ? {
        secure: encryptSensitiveValue(projectDir, JSON.stringify(item.metadata))
      } : item.metadata
    };
  }
  fs16.writeFileSync(mediaIndexFile(projectDir), `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function buildExpiration(ttlHours) {
  const expires = new Date(Date.now() + ttlHours * 3600 * 1000);
  return expires.toISOString();
}
function ingestMedia(projectDir, input) {
  const ttlHours = Math.max(1, input.ttlHours ?? DEFAULT_TTL_HOURS);
  const store = readStore3(projectDir);
  const id = `media_${randomUUID7()}`;
  let localPath;
  if (input.contentBase64) {
    const dir = mediaDir(projectDir);
    ensureDir7(dir);
    const ext = path18.extname(input.fileName) || ".bin";
    const filePath3 = path18.join(dir, `${id}${ext}`);
    fs16.writeFileSync(filePath3, Buffer.from(input.contentBase64, "base64"));
    localPath = filePath3;
  }
  const item = {
    id,
    source: input.source,
    kind: input.kind,
    mimeType: input.mimeType,
    fileName: input.fileName,
    localPath,
    sizeBytes: input.sizeBytes,
    createdAt: nowIso11(),
    expiresAt: buildExpiration(ttlHours),
    metadata: input.metadata
  };
  store.items[id] = item;
  writeStore(projectDir, store);
  return item;
}
function getMediaItem(projectDir, mediaID) {
  const store = readStore3(projectDir);
  return store.items[mediaID] ?? null;
}
function patchMediaMetadata(projectDir, mediaID, patch) {
  const store = readStore3(projectDir);
  const current = store.items[mediaID];
  if (!current)
    return null;
  const next = {
    ...current,
    metadata: {
      ...current.metadata ?? {},
      ...patch
    }
  };
  store.items[mediaID] = next;
  writeStore(projectDir, store);
  return next;
}
function listMediaItems(projectDir, limit = 100) {
  const store = readStore3(projectDir);
  return Object.values(store.items).sort((a, b) => Date.parse(b.createdAt) - Date.parse(a.createdAt)).slice(0, Math.max(1, limit));
}
function runMediaGc(projectDir) {
  const store = readStore3(projectDir);
  const now = Date.now();
  let removed = 0;
  for (const [id, item] of Object.entries(store.items)) {
    const expired = Date.parse(item.expiresAt) <= now;
    if (!expired)
      continue;
    if (item.localPath && fs16.existsSync(item.localPath)) {
      try {
        fs16.unlinkSync(item.localPath);
      } catch {}
    }
    delete store.items[id];
    removed += 1;
  }
  writeStore(projectDir, store);
  return {
    removed,
    kept: Object.keys(store.items).length
  };
}

// src/multimodal/vision.ts
async function commandExists(command) {
  const probe = process.platform === "win32" ? ["where", command] : ["which", command];
  const proc = Bun.spawn(probe, { stdout: "pipe", stderr: "pipe" });
  let timedOut = false;
  const timer = setTimeout(() => {
    timedOut = true;
    try {
      proc.kill();
    } catch {}
  }, 3000);
  const code = await proc.exited;
  clearTimeout(timer);
  return !timedOut && code === 0;
}
async function runTesseractOcr(imagePath) {
  if (!await commandExists("tesseract"))
    return "";
  const args = process.platform === "win32" ? ["tesseract", imagePath, "stdout", "--psm", "6"] : ["tesseract", imagePath, "stdout", "--psm", "6"];
  const proc = Bun.spawn(args, { stdout: "pipe", stderr: "pipe" });
  let timedOut = false;
  const timer = setTimeout(() => {
    timedOut = true;
    try {
      proc.kill();
    } catch {}
  }, 8000);
  const code = await proc.exited;
  clearTimeout(timer);
  if (timedOut || code !== 0)
    return "";
  return (await new Response(proc.stdout).text()).trim();
}
async function runRemoteVisionInference(imagePath, question) {
  const endpoint = process.env.MIYA_VISION_OCR_ENDPOINT?.trim();
  if (!endpoint)
    return { text: "" };
  if (!fs17.existsSync(imagePath))
    return { text: "" };
  const image = fs17.readFileSync(imagePath);
  const mimeType = imagePath.endsWith(".png") ? "image/png" : imagePath.endsWith(".jpg") || imagePath.endsWith(".jpeg") ? "image/jpeg" : "application/octet-stream";
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        imageBase64: image.toString("base64"),
        mimeType,
        question: question ?? ""
      })
    });
    if (!response.ok)
      return { text: "" };
    const payload = await response.json();
    const text = String(payload.text ?? payload.ocr_text ?? "").trim();
    return {
      text,
      summary: payload.summary ? String(payload.summary) : undefined,
      boxes: Array.isArray(payload.boxes) ? payload.boxes : undefined
    };
  } catch {
    return { text: "" };
  }
}
function parseCommandSpec2(raw) {
  const input = raw.trim();
  if (!input)
    return null;
  const tokens = [];
  let current = "";
  let quote = null;
  for (let i = 0;i < input.length; i += 1) {
    const ch = input[i] ?? "";
    if ((ch === '"' || ch === "'") && (!quote || quote === ch)) {
      quote = quote ? null : ch;
      continue;
    }
    if (!quote && /\s/.test(ch)) {
      if (current)
        tokens.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current)
    tokens.push(current);
  if (tokens.length === 0)
    return null;
  return {
    command: tokens[0],
    args: tokens.slice(1)
  };
}
function resolveLocalVisionCommand(projectDir) {
  const explicit = process.env.MIYA_VISION_LOCAL_CMD?.trim();
  if (explicit) {
    const parsed = parseCommandSpec2(explicit);
    if (parsed)
      return { ...parsed, shell: false };
    return { command: explicit, args: [], shell: true };
  }
  const scriptPath = path19.join(projectDir, "miya-src", "python", "infer_qwen3_vl.py");
  if (!fs17.existsSync(scriptPath))
    return null;
  const backendCmd = String(process.env.MIYA_QWEN3VL_CMD ?? "").trim();
  const pythonOverride = String(process.env.MIYA_VISION_PYTHON ?? "").trim();
  const venvPython = venvPythonPath(projectDir);
  const python = pythonOverride || (fs17.existsSync(venvPython) ? venvPython : process.platform === "win32" ? "python" : "python3");
  const args = [
    scriptPath,
    "--model-dir",
    getMiyaQwen3VlModelDir(projectDir),
    "--mode",
    "vision_ocr"
  ];
  if (backendCmd) {
    args.push("--backend-cmd", backendCmd);
  }
  return {
    command: python,
    args,
    shell: false
  };
}
function runLocalVisionInference(projectDir, imagePath, question) {
  const commandSpec = resolveLocalVisionCommand(projectDir);
  if (!commandSpec)
    return { text: "" };
  if (!fs17.existsSync(imagePath))
    return { text: "" };
  const timeoutMsRaw = Number(process.env.MIYA_VISION_LOCAL_TIMEOUT_MS ?? 6000);
  const timeoutMs = Number.isFinite(timeoutMsRaw) ? Math.max(800, Math.min(30000, Math.floor(timeoutMsRaw))) : 6000;
  const image = fs17.readFileSync(imagePath);
  const mimeType = imagePath.endsWith(".png") ? "image/png" : imagePath.endsWith(".jpg") || imagePath.endsWith(".jpeg") ? "image/jpeg" : "application/octet-stream";
  const payload = JSON.stringify({
    imageBase64: image.toString("base64"),
    mimeType,
    imagePath,
    question: question ?? "",
    mode: "vision_ocr"
  });
  try {
    const result = spawnSync3(commandSpec.command, commandSpec.args, {
      input: payload,
      timeout: timeoutMs,
      encoding: "utf-8",
      shell: commandSpec.shell,
      windowsHide: true,
      stdio: ["pipe", "pipe", "pipe"]
    });
    if (result.error || result.status !== 0 || result.signal)
      return { text: "" };
    const parsed = JSON.parse(String(result.stdout ?? "").trim());
    const text = String(parsed.text ?? parsed.ocr_text ?? "").trim();
    return {
      text,
      summary: parsed.summary ? String(parsed.summary) : undefined,
      boxes: Array.isArray(parsed.boxes) ? parsed.boxes : undefined
    };
  } catch {
    return { text: "" };
  }
}
async function readTextFromImage(imagePath, question, projectDir = process.cwd()) {
  const local = runLocalVisionInference(projectDir, imagePath, question);
  if (local.text) {
    return {
      source: "remote_vlm",
      text: local.text,
      summary: local.summary,
      boxes: local.boxes
    };
  }
  const remote = await runRemoteVisionInference(imagePath, question);
  if (remote.text) {
    return {
      source: "remote_vlm",
      text: remote.text,
      summary: remote.summary,
      boxes: remote.boxes
    };
  }
  const tesseractText = await runTesseractOcr(imagePath);
  if (tesseractText) {
    return {
      source: "tesseract",
      text: tesseractText
    };
  }
  return {
    source: "none",
    text: ""
  };
}
var CAPTURE_PRIORITY = [
  "wgc_hwnd",
  "print_window",
  "dxgi_duplication",
  "uia_only"
];
function normalizeCaptureMethod(input) {
  const raw = String(input ?? "").trim().toLowerCase();
  if (!raw)
    return null;
  if (raw === "wgc" || raw === "wgc_hwnd")
    return "wgc_hwnd";
  if (raw === "printwindow" || raw === "print_window")
    return "print_window";
  if (raw === "dxgi" || raw === "dxgi_duplication")
    return "dxgi_duplication";
  if (raw === "uia" || raw === "uia_only")
    return "uia_only";
  if (raw === "unknown")
    return "unknown";
  return null;
}
function parseCaptureMethods(input) {
  const raw = String(input ?? "").trim();
  if (!raw)
    return [...CAPTURE_PRIORITY];
  const methods = raw.split(",").map((item) => normalizeCaptureMethod(item)).filter((item) => Boolean(item) && item !== "unknown");
  if (methods.length === 0)
    return [...CAPTURE_PRIORITY];
  return [...new Set(methods)];
}
function inferCaptureProbeLimitations(input) {
  const signal = `${input.visualPrecheck ?? ""}|${input.visualPostcheck ?? ""}`.toLowerCase();
  const result = [];
  if (!signal.trim())
    return result;
  if (signal.includes("black"))
    result.push("capture_probe_black_screen");
  if (signal.includes("timeout"))
    result.push("capture_probe_timeout");
  if (signal.includes("error") || signal.includes("failed"))
    result.push("capture_probe_error");
  if (signal.includes("occluded"))
    result.push("capture_probe_occluded");
  return [...new Set(result)];
}
function compactOcrText(text) {
  return (text || "").replace(/\s+/g, "").toLowerCase();
}
function parseDesktopOcrSignals(ocrText, expectedRecipient) {
  const normalized = (ocrText || "").replace(/\s+/g, " ").trim();
  const recipient = expectedRecipient.trim();
  const lowered = normalized.toLowerCase();
  const compactNormalized = compactOcrText(normalized);
  const compactRecipient = compactOcrText(recipient);
  const recipientDetected = recipient && (normalized.includes(recipient) || lowered.includes(recipient.toLowerCase()) || compactRecipient.length > 0 && compactNormalized.includes(compactRecipient)) ? recipient : "";
  const sentHints = [
    "",
    "",
    "sent",
    "delivered",
    "",
    ""
  ];
  const failHints = ["", "failed", "", "retry", "", ""];
  const hasSent = sentHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const hasFail = failHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const sendStatusDetected = hasFail ? "failed" : hasSent ? "sent" : "uncertain";
  let recipientMatch = "uncertain";
  if (recipientDetected) {
    recipientMatch = "matched";
  } else if (recipient && normalized.length > 0) {
    recipientMatch = "mismatch";
  }
  return {
    recipientDetected,
    recipientMatch,
    sendStatusDetected
  };
}
async function analyzeDesktopOutboundEvidence(input) {
  const capture = resolveCaptureCapability(input);
  const candidates = [
    input.postSendScreenshotPath,
    input.preSendScreenshotPath
  ].filter((item) => typeof item === "string" && fs17.existsSync(item));
  if (candidates.length === 0) {
    const recipientMatch = input.recipientTextCheck ?? "uncertain";
    const sendStatusDetected = input.receiptStatus === "confirmed" ? "sent" : "uncertain";
    return {
      recipientMatch,
      sendStatusDetected,
      ocrSource: "none",
      ocrPreview: "",
      uiStyleMismatch: true,
      retries: 0,
      capture: {
        method: capture.method,
        confidence: capture.confidence,
        limitations: mergeCaptureLimitations(capture.limitations, {
          uiStyleMismatch: true,
          recipientMatch,
          sendStatusDetected
        })
      }
    };
  }
  const isLowConfidenceText = (text) => {
    const trimmed = (text || "").replace(/\s+/g, "");
    if (trimmed.length < 8)
      return true;
    const meaningful = trimmed.replace(/[a-zA-Z0-9\u4e00-\u9fa5]/g, "");
    const noiseRatio = meaningful.length / Math.max(1, trimmed.length);
    return noiseRatio > 0.6;
  };
  let inferred = await readTextFromImage(candidates[0], "");
  let signals = parseDesktopOcrSignals(inferred.text, input.destination);
  let retries = 0;
  let uiStyleMismatch = inferred.source === "none" || signals.recipientMatch !== "matched" && isLowConfidenceText(inferred.text);
  if (candidates.length > 1 && (signals.recipientMatch === "mismatch" || uiStyleMismatch)) {
    const retryInferred = await readTextFromImage(candidates[1], "DPI");
    const retrySignals = parseDesktopOcrSignals(retryInferred.text, input.destination);
    retries = 1;
    const retryBetter = retrySignals.recipientMatch === "matched" || retrySignals.sendStatusDetected !== "uncertain" && signals.sendStatusDetected === "uncertain" || !isLowConfidenceText(retryInferred.text) && isLowConfidenceText(inferred.text);
    if (retryBetter) {
      inferred = retryInferred;
      signals = retrySignals;
    }
    uiStyleMismatch = (inferred.source === "none" || isLowConfidenceText(inferred.text)) && signals.recipientMatch !== "matched";
  }
  const mergedRecipient = signals.recipientMatch === "mismatch" && input.recipientTextCheck === "matched" ? "matched" : signals.recipientMatch === "uncertain" ? input.recipientTextCheck ?? "uncertain" : signals.recipientMatch;
  const mergedStatus = signals.sendStatusDetected === "uncertain" ? input.receiptStatus === "confirmed" ? "sent" : "uncertain" : signals.sendStatusDetected;
  const stableRecipient = uiStyleMismatch && mergedRecipient === "mismatch" ? "uncertain" : mergedRecipient;
  const confidence = estimateEvidenceConfidence({
    ocrSource: inferred.source,
    uiStyleMismatch,
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    retries
  });
  const mergedConfidence = Number(Math.min(confidence, capture.confidence).toFixed(2));
  if (mergedConfidence < 0.45) {
    uiStyleMismatch = true;
  }
  return {
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    ocrSource: inferred.source,
    ocrPreview: inferred.text.slice(0, 300),
    uiStyleMismatch,
    retries,
    capture: {
      method: capture.method,
      confidence: mergedConfidence,
      limitations: mergeCaptureLimitations(capture.limitations, {
        uiStyleMismatch,
        recipientMatch: stableRecipient,
        sendStatusDetected: mergedStatus
      })
    }
  };
}
function resolveCaptureCapability(input) {
  const hasScreenshots = typeof input.preSendScreenshotPath === "string" && input.preSendScreenshotPath.length > 0 && fs17.existsSync(input.preSendScreenshotPath) || typeof input.postSendScreenshotPath === "string" && input.postSendScreenshotPath.length > 0 && fs17.existsSync(input.postSendScreenshotPath);
  const supported = parseCaptureMethods(process.env.MIYA_CAPTURE_CAPABILITIES);
  const preferred = CAPTURE_PRIORITY.find((item) => supported.includes(item));
  const requested = normalizeCaptureMethod(process.env.MIYA_CAPTURE_METHOD);
  let method = "unknown";
  if (hasScreenshots) {
    if (requested && supported.includes(requested)) {
      method = requested;
    } else if (preferred) {
      method = preferred;
    } else {
      method = "unknown";
    }
  } else {
    method = supported.includes("uia_only") ? "uia_only" : "unknown";
  }
  const limitations = [];
  limitations.push(...inferCaptureProbeLimitations(input));
  if (!hasScreenshots) {
    limitations.push("no_desktop_screenshot");
  }
  if (requested && requested !== "unknown" && !supported.includes(requested)) {
    limitations.push(`capture_method_not_supported:${requested}`);
  }
  if (hasScreenshots && preferred && method !== "unknown" && method !== preferred) {
    limitations.push(`capture_fallback:${preferred}->${method}`);
  }
  if (!hasScreenshots && preferred && preferred !== "uia_only") {
    limitations.push(`capture_tree_exhausted:${preferred}`);
  }
  if (method === "unknown")
    limitations.push("capture_method_unspecified");
  if (method === "uia_only")
    limitations.push("pixel_evidence_unavailable");
  const baseByMethod = {
    wgc_hwnd: 0.92,
    print_window: 0.84,
    dxgi_duplication: 0.76,
    uia_only: 0.4,
    unknown: 0.24
  };
  let confidence = baseByMethod[method];
  if (!hasScreenshots) {
    confidence = Math.min(confidence, method === "uia_only" ? 0.34 : 0.24);
  }
  if (limitations.includes("capture_probe_black_screen")) {
    confidence = Math.min(confidence, 0.28);
  }
  if (limitations.includes("capture_probe_timeout")) {
    confidence = Math.min(confidence, 0.3);
  }
  if (limitations.includes("capture_probe_error")) {
    confidence = Math.min(confidence, 0.3);
  }
  return {
    method,
    confidence: Number(confidence.toFixed(2)),
    limitations
  };
}
function estimateEvidenceConfidence(input) {
  let score = input.ocrSource === "remote_vlm" ? 0.86 : input.ocrSource === "tesseract" ? 0.72 : 0.35;
  if (input.uiStyleMismatch)
    score -= 0.32;
  if (input.recipientMatch === "matched")
    score += 0.08;
  if (input.sendStatusDetected === "sent" || input.sendStatusDetected === "failed")
    score += 0.04;
  if (input.retries > 0)
    score -= 0.05;
  if (score < 0)
    return 0;
  if (score > 1)
    return 1;
  return Number(score.toFixed(2));
}
function mergeCaptureLimitations(base, input) {
  const result = [...base];
  if (input.uiStyleMismatch)
    result.push("ui_style_mismatch");
  if (input.recipientMatch === "uncertain")
    result.push("recipient_unverified");
  if (input.sendStatusDetected === "uncertain")
    result.push("delivery_unverified");
  return [...new Set(result)];
}

// src/policy/semantic-tags.ts
var SEMANTIC_TAGS = [
  "window_not_found",
  "window_occluded",
  "recipient_mismatch",
  "input_mutex_timeout",
  "receipt_uncertain",
  "privilege_barrier",
  "ui_style_mismatch"
];
function isSemanticTag(value) {
  return typeof value === "string" && SEMANTIC_TAGS.includes(value);
}
function normalizeSemanticTags(value) {
  if (!Array.isArray(value))
    return [];
  return value.map((item) => String(item)).filter((item) => isSemanticTag(item));
}
function assertSemanticTags(value) {
  if (!Array.isArray(value))
    return;
  for (const item of value) {
    if (!isSemanticTag(item)) {
      throw new Error(`invalid_semantic_tag:${String(item)}`);
    }
  }
}

// src/channels/policy.ts
var OUTBOUND_ALLOWLIST_CHANNELS = new Set(["qq", "wechat"]);
function getChannelDirection(channel) {
  return OUTBOUND_ALLOWLIST_CHANNELS.has(channel) ? "OUTBOUND_ALLOWLIST" : "INBOUND_ONLY";
}
function canChannelSend(channel) {
  return getChannelDirection(channel) === "OUTBOUND_ALLOWLIST";
}
function assertChannelCanSend(channel) {
  if (canChannelSend(channel))
    return;
  throw new Error(`channel_send_blocked:${channel}:INBOUND_ONLY channels are receive-only`);
}

// src/channels/service.ts
function parseEnvList(input) {
  if (!input)
    return [];
  return input.split(",").map((value) => value.trim()).filter(Boolean);
}
function outboundAuditFile(projectDir) {
  return path20.join(getMiyaRuntimeDir(projectDir), "channels-outbound.jsonl");
}
function appendOutboundAudit(projectDir, row) {
  const file3 = outboundAuditFile(projectDir);
  fs18.mkdirSync(path20.dirname(file3), { recursive: true });
  fs18.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
function semanticTagsForOutboundMessage(message) {
  if (message.includes("target_not_in_allowlist"))
    return ["recipient_mismatch"];
  if (message.includes("recipient_text_mismatch"))
    return ["recipient_mismatch"];
  if (message.includes("arch_advisor_denied"))
    return ["privilege_barrier"];
  if (message.includes("input_mutex_timeout"))
    return ["input_mutex_timeout"];
  if (message.includes("receipt_uncertain"))
    return ["receipt_uncertain"];
  if (message.includes("blocked_by_privilege") || message.includes("privilege")) {
    return ["privilege_barrier"];
  }
  if (message.includes("window_not_found"))
    return ["window_not_found"];
  if (message.includes("window_occluded"))
    return ["window_occluded"];
  if (message.includes("ui_style_mismatch"))
    return ["ui_style_mismatch"];
  return [];
}
function parsePositiveIntEnv(name, fallback) {
  const raw = process.env[name];
  if (!raw)
    return fallback;
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0)
    return fallback;
  return Math.floor(parsed);
}
var INPUT_MUTEX_TIMEOUT_MS = parsePositiveIntEnv("MIYA_INPUT_MUTEX_TIMEOUT_MS", 20000);
var INPUT_MUTEX_STRIKE_LIMIT = 3;
var INPUT_MUTEX_COOLDOWN_MS = 15 * 60 * 1000;
var inputMutexOwner = null;
var inputMutexQueue = [];
function acquireInputMutex(sessionID, timeoutMs = INPUT_MUTEX_TIMEOUT_MS) {
  return new Promise((resolve3, reject) => {
    let released = false;
    const makeLease = () => ({
      release: () => {
        if (released)
          return;
        released = true;
        if (inputMutexOwner === sessionID) {
          inputMutexOwner = null;
        }
        while (inputMutexQueue.length > 0 && !inputMutexOwner) {
          const next = inputMutexQueue.shift();
          if (!next)
            break;
          if (!next.active)
            continue;
          next.grant();
        }
      }
    });
    const pending = {
      sessionID,
      active: true,
      grant: () => {}
    };
    const timer = setTimeout(() => {
      pending.active = false;
      const idx = inputMutexQueue.indexOf(pending);
      if (idx >= 0)
        inputMutexQueue.splice(idx, 1);
      reject(new Error("input_mutex_timeout"));
    }, timeoutMs);
    const grant = () => {
      if (!pending.active)
        return;
      pending.active = false;
      clearTimeout(timer);
      inputMutexOwner = sessionID;
      resolve3(makeLease());
    };
    pending.grant = grant;
    if (!inputMutexOwner) {
      grant();
      return;
    }
    inputMutexQueue.push(pending);
  });
}
function buildSemanticSummary(row) {
  if (row.sent) {
    return {
      conclusion: "Outbound send completed with verifiable desktop evidence.",
      keyAssertion: `recipient_check=${row.recipientTextCheck ?? "uncertain"}, send_status=${row.sendStatusCheck ?? "uncertain"}`,
      recovery: "No recovery needed."
    };
  }
  if (row.message.includes("arch_advisor_denied")) {
    return {
      conclusion: "Outbound send blocked by Arch Advisor approval gate.",
      keyAssertion: "Arch Advisor approval flag was false, so outbound flow was denied before desktop execution.",
      recovery: "Re-issue approval ticket via Arch Advisor and retry only after policy checks pass."
    };
  }
  if (row.message.includes("input_mutex_timeout")) {
    return {
      conclusion: "Outbound send blocked by input mutex timeout.",
      keyAssertion: "Desktop control was denied because user input mutex could not be acquired in time.",
      recovery: "Wait for user idle state and retry with renewed approval tickets."
    };
  }
  if (row.message.includes("ui_style_mismatch")) {
    return {
      conclusion: "Outbound send degraded due to unstable UI/OCR style mismatch.",
      keyAssertion: "Visual confirmation confidence was too low after retry, so send was treated as failed.",
      recovery: "Adjust DPI/theme/window state, then retry with refreshed evidence."
    };
  }
  return {
    conclusion: row.sent ? "Outbound send completed." : "Outbound send blocked or uncertain.",
    keyAssertion: `message=${row.message}`,
    recovery: row.sent ? "No recovery needed." : "Review desktop evidence and retry only after policy/approval checks pass."
  };
}
function buildEvidenceBundle(row) {
  if (row.channel !== "qq" && row.channel !== "wechat")
    return;
  const screenshots = [
    row.preSendScreenshotPath,
    row.postSendScreenshotPath
  ].filter((item) => typeof item === "string" && item.length > 0);
  const ticketTraceIds = [
    row.ticketSummary?.outboundSendTraceId,
    row.ticketSummary?.desktopControlTraceId
  ].filter((item) => typeof item === "string" && item.length > 0);
  return {
    kind: "desktop_outbound",
    version: "v5",
    destination: row.destination,
    payloadHash: row.payloadHash,
    ticketTraceIds: ticketTraceIds.length > 0 ? ticketTraceIds : undefined,
    screenshots,
    checks: {
      recipientTextCheck: row.recipientTextCheck,
      sendStatusCheck: row.sendStatusCheck,
      receiptStatus: row.receiptStatus
    },
    diagnostics: {
      windowFingerprint: row.windowFingerprint,
      failureStep: row.failureStep,
      targetHwnd: row.targetHwnd,
      foregroundBefore: row.foregroundBefore,
      foregroundAfter: row.foregroundAfter,
      uiaPath: row.uiaPath,
      fallbackReason: row.fallbackReason,
      routeLevel: row.routeLevel,
      somSelectionSource: row.somSelectionSource,
      somSelectedCandidateId: typeof row.somSelectedCandidateId === "number" ? String(row.somSelectedCandidateId) : undefined,
      vlmCallsUsed: typeof row.vlmCallsUsed === "number" ? String(row.vlmCallsUsed) : undefined,
      ocrSource: row.ocrSource,
      ocrPreview: row.ocrPreview
    },
    meta: {
      captureMethod: row.captureMethod ?? "unknown",
      confidence: Number.isFinite(row.evidenceConfidence) ? Number(row.evidenceConfidence) : 0,
      limitations: row.evidenceLimitations ?? [],
      policyHash: row.policyHash
    },
    simulation: row.simulationStatus === "captured" || screenshots.length > 0 ? {
      status: "captured",
      clickTargets: [],
      riskHints: row.simulationRiskHints
    } : {
      status: "not_available",
      reason: row.simulationRiskHints && row.simulationRiskHints.length > 0 ? row.simulationRiskHints.join(",") : "desktop_screenshots_missing",
      riskHints: row.simulationRiskHints
    }
  };
}
function listOutboundAudit(projectDir, limit = 50) {
  const file3 = outboundAuditFile(projectDir);
  if (!fs18.existsSync(file3))
    return [];
  const rows = fs18.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}
function normalizeBlockedReason(row) {
  if (row.reason)
    return row.reason;
  const msg = String(row.message ?? "").trim();
  if (!msg)
    return "unknown";
  if (msg.includes(":"))
    return msg.split(":")[0];
  return msg.slice(0, 64);
}
function summarizeChannelGovernance(projectDir, limit = 400) {
  const rows = listOutboundAudit(projectDir, Math.max(20, Math.min(5000, limit)));
  const stateMap = new Map(listChannelStates(projectDir).map((state) => [state.name, state]));
  const blockedRows = rows.filter((row) => !row.sent);
  const inboundOnlyViolationAttempts = rows.filter((row) => !canChannelSend(row.channel)).length;
  const inboundOnlyInvariantMaintained = !rows.some((row) => row.sent && !canChannelSend(row.channel));
  const blockedReasonCount = new Map;
  for (const row of blockedRows) {
    const key = normalizeBlockedReason(row);
    blockedReasonCount.set(key, (blockedReasonCount.get(key) ?? 0) + 1);
  }
  const channelBreakdown = [...new Set(rows.map((row) => row.channel))].map((channel) => {
    const subset = rows.filter((row) => row.channel === channel);
    return {
      channel,
      attempts: subset.length,
      sent: subset.filter((row) => row.sent).length,
      blocked: subset.filter((row) => !row.sent).length,
      outboundAllowed: canChannelSend(channel)
    };
  }).sort((a, b) => b.attempts - a.attempts);
  return {
    generatedAt: new Date().toISOString(),
    windowRows: rows.length,
    outboundSent: rows.filter((row) => row.sent).length,
    outboundBlocked: blockedRows.length,
    inboundOnlyViolationAttempts,
    inboundOnlyInvariantMaintained,
    highRiskBlocked: blockedRows.filter((row) => row.riskLevel === "HIGH").length,
    topBlockedReasons: [...blockedReasonCount.entries()].sort((a, b) => b[1] - a[1]).slice(0, 8).map(([reason, count]) => ({ reason, count })),
    channelBreakdown: channelBreakdown.length > 0 ? channelBreakdown : [...stateMap.keys()].map((channel) => ({
      channel,
      attempts: 0,
      sent: 0,
      blocked: 0,
      outboundAllowed: canChannelSend(channel)
    }))
  };
}

class ChannelRuntime {
  projectDir;
  callbacks;
  sendQqDesktopMessageImpl;
  sendWechatDesktopMessageImpl;
  analyzeDesktopOutboundEvidenceImpl;
  telegramPolling = false;
  telegramOffset = 0;
  slackSocketModeRunning = false;
  slackSocket;
  slackReconnectTimer;
  outboundThrottle = new Map;
  outboundPayloadHistory = new Map;
  inputMutexStrike = new Map;
  inputMutexCooldownUntil = new Map;
  sendFingerprintHistory = new Map;
  constructor(projectDir, callbacks, deps = {}) {
    this.projectDir = projectDir;
    this.callbacks = callbacks;
    this.sendQqDesktopMessageImpl = deps.sendQqDesktopMessage ?? sendQqDesktopMessage;
    this.sendWechatDesktopMessageImpl = deps.sendWechatDesktopMessage ?? sendWechatDesktopMessage;
    this.analyzeDesktopOutboundEvidenceImpl = deps.analyzeDesktopOutboundEvidence ?? analyzeDesktopOutboundEvidence;
  }
  listChannels() {
    return listChannelStates(this.projectDir);
  }
  listPairs(status) {
    return listPairRequests(this.projectDir, status);
  }
  approvePair(pairID) {
    return resolvePairRequest(this.projectDir, pairID, "approved");
  }
  rejectPair(pairID) {
    return resolvePairRequest(this.projectDir, pairID, "rejected");
  }
  markChannelEnabled(channel, enabled) {
    upsertChannelState(this.projectDir, channel, {
      enabled,
      connected: enabled
    });
  }
  async start() {
    upsertChannelState(this.projectDir, "webchat", {
      enabled: true,
      connected: true
    });
    await this.startTelegramPolling();
    this.syncPassiveChannelStates();
    await this.startSlackSocketMode();
  }
  syncPassiveChannelStates() {
    upsertChannelState(this.projectDir, "qq", {
      enabled: false,
      connected: false,
      lastError: "QQ outbound requires desktop UI automation runtime"
    });
    upsertChannelState(this.projectDir, "wechat", {
      enabled: false,
      connected: false,
      lastError: "WeChat outbound requires desktop UI automation runtime"
    });
    const hasSlack = !!process.env.MIYA_SLACK_BOT_TOKEN;
    upsertChannelState(this.projectDir, "slack", {
      enabled: hasSlack,
      connected: hasSlack,
      lastError: hasSlack ? undefined : "Missing MIYA_SLACK_BOT_TOKEN"
    });
    const hasDiscord = !!process.env.MIYA_DISCORD_BOT_TOKEN;
    upsertChannelState(this.projectDir, "discord", {
      enabled: hasDiscord,
      connected: hasDiscord,
      lastError: hasDiscord ? undefined : "Missing MIYA_DISCORD_BOT_TOKEN"
    });
    const hasWhatsApp = !!process.env.MIYA_WHATSAPP_TOKEN && !!process.env.MIYA_WHATSAPP_PHONE_NUMBER_ID;
    upsertChannelState(this.projectDir, "whatsapp", {
      enabled: hasWhatsApp,
      connected: hasWhatsApp,
      lastError: hasWhatsApp ? undefined : "Missing MIYA_WHATSAPP_TOKEN or MIYA_WHATSAPP_PHONE_NUMBER_ID"
    });
    const hasGoogleChat = !!process.env.MIYA_GOOGLE_CHAT_WEBHOOK_URL;
    upsertChannelState(this.projectDir, "google_chat", {
      enabled: hasGoogleChat,
      connected: hasGoogleChat,
      lastError: hasGoogleChat ? undefined : "Missing MIYA_GOOGLE_CHAT_WEBHOOK_URL"
    });
    const hasSignal = !!process.env.MIYA_SIGNAL_REST_URL;
    upsertChannelState(this.projectDir, "signal", {
      enabled: hasSignal,
      connected: hasSignal,
      lastError: hasSignal ? undefined : "Missing MIYA_SIGNAL_REST_URL"
    });
    const hasIMessage = !!process.env.MIYA_BLUEBUBBLES_URL;
    upsertChannelState(this.projectDir, "imessage", {
      enabled: hasIMessage,
      connected: hasIMessage,
      lastError: hasIMessage ? undefined : "Missing MIYA_BLUEBUBBLES_URL"
    });
    const hasTeams = !!process.env.MIYA_TEAMS_WEBHOOK_URL;
    upsertChannelState(this.projectDir, "teams", {
      enabled: hasTeams,
      connected: hasTeams,
      lastError: hasTeams ? undefined : "Missing MIYA_TEAMS_WEBHOOK_URL"
    });
  }
  async startSlackSocketMode() {
    const appToken = process.env.MIYA_SLACK_APP_TOKEN;
    const botToken = process.env.MIYA_SLACK_BOT_TOKEN;
    if (!appToken || !botToken || this.slackSocketModeRunning)
      return;
    this.slackSocketModeRunning = true;
    const connect = async () => {
      if (!this.slackSocketModeRunning)
        return;
      try {
        const openRes = await fetch("https://slack.com/api/apps.connections.open", {
          method: "POST",
          headers: {
            authorization: `Bearer ${appToken}`,
            "content-type": "application/json"
          },
          body: "{}"
        });
        const openBody = await openRes.json();
        if (!openBody.ok || !openBody.url) {
          throw new Error(openBody.error ?? "slack_socket_open_failed");
        }
        const socket = new WebSocket(openBody.url);
        this.slackSocket = socket;
        socket.onopen = () => {
          upsertChannelState(this.projectDir, "slack", {
            enabled: true,
            connected: true,
            lastError: undefined
          });
        };
        socket.onmessage = (event) => {
          this.handleSlackSocketMessage(String(event.data));
        };
        socket.onerror = () => {
          upsertChannelState(this.projectDir, "slack", {
            connected: false,
            lastError: "slack_socket_error"
          });
        };
        socket.onclose = () => {
          if (!this.slackSocketModeRunning)
            return;
          upsertChannelState(this.projectDir, "slack", {
            connected: false,
            lastError: "slack_socket_closed"
          });
          this.scheduleSlackReconnect(connect);
        };
      } catch (error92) {
        upsertChannelState(this.projectDir, "slack", {
          connected: false,
          lastError: error92 instanceof Error ? error92.message : String(error92)
        });
        this.scheduleSlackReconnect(connect);
      }
    };
    await connect();
  }
  scheduleSlackReconnect(connect) {
    if (!this.slackSocketModeRunning)
      return;
    if (this.slackReconnectTimer)
      clearTimeout(this.slackReconnectTimer);
    this.slackReconnectTimer = setTimeout(() => {
      connect();
    }, 3000);
  }
  async handleSlackSocketMessage(messageText) {
    if (!messageText.trim())
      return;
    const payload = JSON.parse(messageText);
    if (payload.envelope_id && this.slackSocket?.readyState === WebSocket.OPEN) {
      this.slackSocket.send(JSON.stringify({ envelope_id: payload.envelope_id }));
    }
    if (payload.type !== "events_api")
      return;
    const event = payload.payload?.event;
    if (!event)
      return;
    if (event.type !== "message")
      return;
    if (!event.user || !event.text || !event.channel)
      return;
    if (event.bot_id)
      return;
    await this.handleInbound({
      channel: "slack",
      senderID: event.user,
      displayName: event.user,
      conversationID: event.channel,
      text: event.text,
      raw: payload
    });
  }
  async startTelegramPolling() {
    const token = process.env.MIYA_TELEGRAM_BOT_TOKEN;
    if (!token) {
      upsertChannelState(this.projectDir, "telegram", {
        enabled: false,
        connected: false,
        lastError: "Missing MIYA_TELEGRAM_BOT_TOKEN"
      });
      return;
    }
    if (this.telegramPolling)
      return;
    this.telegramPolling = true;
    upsertChannelState(this.projectDir, "telegram", {
      enabled: true,
      connected: true,
      lastError: undefined
    });
    const poll = async () => {
      if (!this.telegramPolling)
        return;
      try {
        const url3 = `https://api.telegram.org/bot${token}/getUpdates?timeout=20&offset=${this.telegramOffset}`;
        const response = await fetch(url3);
        const body = await response.json();
        if (!body.ok) {
          throw new Error(body.description ?? "telegram_get_updates_failed");
        }
        for (const update of body.result ?? []) {
          this.telegramOffset = Math.max(this.telegramOffset, Number(update.update_id) + 1);
          const message = update.message;
          if (!message?.text || !message.chat?.id || !message.from?.id) {
            continue;
          }
          await this.handleInbound({
            channel: "telegram",
            senderID: String(message.from.id),
            displayName: message.from.username ?? message.from.first_name ?? String(message.from.id),
            conversationID: String(message.chat.id),
            text: message.text,
            raw: update
          });
        }
        upsertChannelState(this.projectDir, "telegram", {
          connected: true,
          lastError: undefined
        });
      } catch (error92) {
        upsertChannelState(this.projectDir, "telegram", {
          connected: false,
          lastError: error92 instanceof Error ? error92.message : String(error92)
        });
      } finally {
        if (this.telegramPolling) {
          setTimeout(() => {
            poll();
          }, 500);
        }
      }
    };
    poll();
  }
  stop() {
    this.telegramPolling = false;
    this.slackSocketModeRunning = false;
    if (this.slackReconnectTimer) {
      clearTimeout(this.slackReconnectTimer);
      this.slackReconnectTimer = undefined;
    }
    if (this.slackSocket) {
      try {
        this.slackSocket.close();
      } catch {}
      this.slackSocket = undefined;
    }
  }
  async handleInbound(message) {
    const allowByEnv = parseEnvList(process.env.MIYA_ALLOWED_SENDERS);
    const isAllowed = allowByEnv.length > 0 ? allowByEnv.includes(message.senderID) : isSenderAllowed(this.projectDir, message.channel, message.senderID);
    if (!isAllowed) {
      const pair = ensurePairRequest(this.projectDir, {
        channel: message.channel,
        senderID: message.senderID,
        displayName: message.displayName,
        messagePreview: message.text.slice(0, 120)
      });
      await this.callbacks.onPairRequested(pair);
      await this.sendPairingMessage(message.channel, message.conversationID);
      return;
    }
    await this.callbacks.onInbound(message);
  }
  recordOutboundAttempt(row) {
    const semanticTags = normalizeSemanticTags(row.semanticTags ?? semanticTagsForOutboundMessage(row.message));
    assertSemanticTags(semanticTags);
    const payload = {
      id: row.id ?? `out_${randomUUID8()}`,
      at: row.at ?? new Date().toISOString(),
      channel: row.channel,
      destination: row.destination,
      textPreview: row.textPreview,
      sent: row.sent,
      message: row.message,
      mediaPath: row.mediaPath,
      reason: row.reason,
      riskLevel: row.riskLevel,
      archAdvisorApproved: row.archAdvisorApproved,
      targetInAllowlist: row.targetInAllowlist,
      contactTier: row.contactTier,
      intent: row.intent,
      containsSensitive: row.containsSensitive,
      policyHash: row.policyHash,
      sendFingerprint: row.sendFingerprint,
      ticketSummary: row.ticketSummary,
      visualPrecheck: row.visualPrecheck,
      visualPostcheck: row.visualPostcheck,
      automationPath: row.automationPath,
      uiaPath: row.uiaPath,
      targetHwnd: row.targetHwnd,
      foregroundBefore: row.foregroundBefore,
      foregroundAfter: row.foregroundAfter,
      fallbackReason: row.fallbackReason,
      simulationStatus: row.simulationStatus,
      simulationRiskHints: row.simulationRiskHints,
      receiptStatus: row.receiptStatus,
      payloadHash: row.payloadHash,
      windowFingerprint: row.windowFingerprint,
      recipientTextCheck: row.recipientTextCheck,
      sendStatusCheck: row.sendStatusCheck,
      preSendScreenshotPath: row.preSendScreenshotPath,
      postSendScreenshotPath: row.postSendScreenshotPath,
      failureStep: row.failureStep,
      routeLevel: row.routeLevel,
      somSelectionSource: row.somSelectionSource,
      somSelectedCandidateId: row.somSelectedCandidateId,
      vlmCallsUsed: row.vlmCallsUsed,
      actionPlanMemoryHit: row.actionPlanMemoryHit,
      automationLatencyMs: row.automationLatencyMs,
      automationKpi: row.automationKpi,
      ocrSource: row.ocrSource,
      ocrPreview: row.ocrPreview,
      captureMethod: row.captureMethod,
      evidenceConfidence: row.evidenceConfidence,
      evidenceLimitations: row.evidenceLimitations,
      evidenceBundle: buildEvidenceBundle(row),
      semanticSummary: buildSemanticSummary(row),
      semanticTags
    };
    appendOutboundAudit(this.projectDir, payload);
    return payload;
  }
  checkThrottle(channel, destination) {
    const now = Date.now();
    const key = `${channel}:${destination}`;
    const policy = readPolicy(this.projectDir);
    const windowMs = Math.max(1000, Number(policy.outbound.burstWindowMs || 60000));
    const minIntervalMs = Math.max(500, Number(policy.outbound.minIntervalMs || 4000));
    const burstLimit = Math.max(1, Number(policy.outbound.burstLimit || 3));
    const list = (this.outboundThrottle.get(key) ?? []).filter((ts) => now - ts <= windowMs);
    if (list.length > 0 && now - list[list.length - 1] < minIntervalMs) {
      this.outboundThrottle.set(key, list);
      return `throttled:min_interval_${minIntervalMs}ms`;
    }
    if (list.length >= burstLimit) {
      this.outboundThrottle.set(key, list);
      return `throttled:burst_limit_${burstLimit}_per_${windowMs}ms`;
    }
    list.push(now);
    this.outboundThrottle.set(key, list);
    return null;
  }
  checkDuplicatePayload(channel, destination, text) {
    const now = Date.now();
    const policy = readPolicy(this.projectDir);
    const duplicateWindowMs = Math.max(1000, Number(policy.outbound.duplicateWindowMs || 60000));
    const key = `${channel}:${destination}`;
    const payloadHash = createHash5("sha256").update(text).digest("hex").slice(0, 24);
    const recent = (this.outboundPayloadHistory.get(key) ?? []).filter((item) => now - item.at <= duplicateWindowMs);
    const duplicated = recent.some((item) => item.hash === payloadHash);
    if (!duplicated) {
      recent.push({ at: now, hash: payloadHash });
      this.outboundPayloadHistory.set(key, recent);
      return null;
    }
    this.outboundPayloadHistory.set(key, recent);
    return `duplicate_payload_within_${duplicateWindowMs}ms`;
  }
  isDesktopChannel(channel) {
    return channel === "qq" || channel === "wechat";
  }
  inMutexCooldown(sessionID) {
    const until = this.inputMutexCooldownUntil.get(sessionID) ?? 0;
    return until > Date.now();
  }
  markMutexTimeout(sessionID) {
    const strikes = (this.inputMutexStrike.get(sessionID) ?? 0) + 1;
    this.inputMutexStrike.set(sessionID, strikes);
    if (strikes >= INPUT_MUTEX_STRIKE_LIMIT) {
      this.inputMutexCooldownUntil.set(sessionID, Date.now() + INPUT_MUTEX_COOLDOWN_MS);
      this.inputMutexStrike.set(sessionID, 0);
    }
  }
  clearMutexStrike(sessionID) {
    this.inputMutexStrike.set(sessionID, 0);
  }
  checkSendFingerprint(sendFingerprint) {
    const now = Date.now();
    const windowMs = 60000;
    for (const [fingerprint, ts] of this.sendFingerprintHistory.entries()) {
      if (now - ts > windowMs) {
        this.sendFingerprintHistory.delete(fingerprint);
      }
    }
    if (this.sendFingerprintHistory.has(sendFingerprint)) {
      return "duplicate_send_fingerprint";
    }
    this.sendFingerprintHistory.set(sendFingerprint, now);
    return null;
  }
  normalizeDesktopRuntimeError(error92) {
    const raw = error92 instanceof Error ? error92.message : typeof error92 === "string" ? error92 : "unknown";
    return raw.trim().toLowerCase().replace(/[^a-z0-9:_-]+/g, "_").slice(0, 120) || "unknown";
  }
  recordDesktopRuntimeFailure(input) {
    const detail = this.normalizeDesktopRuntimeError(input.error);
    const audit = this.recordOutboundAttempt({
      channel: input.channel,
      destination: input.destination,
      textPreview: input.textPreview,
      sent: false,
      message: `outbound_degraded:desktop_runtime_exception:${detail}`,
      reason: "desktop_send_failed",
      archAdvisorApproved: input.archAdvisorApproved,
      targetInAllowlist: input.targetInAllowlist,
      contactTier: input.contactTier,
      intent: input.intent,
      containsSensitive: input.containsSensitive,
      riskLevel: input.riskLevel,
      policyHash: input.policyHash,
      sendFingerprint: input.sendFingerprint,
      ticketSummary: input.ticketSummary,
      payloadHash: input.payloadHash,
      failureStep: "desktop.runtime"
    });
    return { sent: false, message: audit.message, auditID: audit.id };
  }
  async sendMessage(input) {
    const text = (input.text ?? "").trim();
    const mediaPath = (input.mediaPath ?? "").trim();
    const payloadHash = (input.payloadHash ?? createHash5("sha256").update(`${text}||${mediaPath}`).digest("hex")).trim();
    if (!text && !mediaPath) {
      return { sent: false, message: "invalid_outbound_payload_empty" };
    }
    try {
      assertChannelCanSend(input.channel);
    } catch (error92) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: error92 instanceof Error ? error92.message : String(error92),
        reason: "channel_blocked",
        payloadHash
      });
      return {
        sent: false,
        message: audit.message,
        auditID: audit.id
      };
    }
    const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
    const riskLevel = input.outboundCheck?.riskLevel ?? "HIGH";
    const intent = input.outboundCheck?.intent ?? "initiate";
    const containsSensitive = Boolean(input.outboundCheck?.containsSensitive);
    const policyHash = input.outboundCheck?.policyHash;
    const sessionID = (input.sessionID ?? "main").trim() || "main";
    const ticketSummary = input.approvalTickets && input.approvalTickets.outboundSend && input.approvalTickets.desktopControl ? {
      outboundSendTraceId: input.approvalTickets.outboundSend.traceID,
      desktopControlTraceId: input.approvalTickets.desktopControl.traceID,
      expiresAt: Date.parse(input.approvalTickets.outboundSend.expiresAt) < Date.parse(input.approvalTickets.desktopControl.expiresAt) ? input.approvalTickets.outboundSend.expiresAt : input.approvalTickets.desktopControl.expiresAt
    } : undefined;
    if (!archAdvisorApproved) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: "outbound_blocked:arch_advisor_denied",
        reason: "arch_advisor_denied",
        archAdvisorApproved,
        riskLevel,
        intent,
        containsSensitive,
        policyHash,
        payloadHash
      });
      return { sent: false, message: audit.message, auditID: audit.id };
    }
    const targetInAllowlist = input.outboundCheck?.bypassAllowlist === true ? true : isSenderAllowed(this.projectDir, input.channel, input.destination);
    if (!targetInAllowlist) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: `outbound_blocked:target_not_in_allowlist:${input.channel}`,
        reason: "allowlist_denied",
        archAdvisorApproved,
        targetInAllowlist,
        riskLevel,
        intent,
        containsSensitive,
        policyHash,
        payloadHash
      });
      return { sent: false, message: audit.message, auditID: audit.id };
    }
    const tier = input.outboundCheck?.bypassAllowlist === true ? "owner" : getContactTier(this.projectDir, input.channel, input.destination);
    if (tier === "friend") {
      if (intent !== "reply") {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_blocked:friend_tier_can_only_reply",
          reason: "allowlist_denied",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
      if (containsSensitive) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_blocked:friend_tier_sensitive_content_denied",
          reason: "allowlist_denied",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.outboundCheck?.bypassThrottle !== true) {
      const throttle = this.checkThrottle(input.channel, input.destination);
      if (throttle) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${throttle}`,
          reason: "throttled",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.outboundCheck?.bypassDuplicateGuard !== true) {
      const duplicate = this.checkDuplicatePayload(input.channel, input.destination, `${text}||${mediaPath}`);
      if (duplicate) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${duplicate}`,
          reason: "duplicate_payload",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.sendFingerprint) {
      const fingerprintDup = this.checkSendFingerprint(input.sendFingerprint);
      if (fingerprintDup) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${fingerprintDup}`,
          reason: "duplicate_payload",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    let mutexLease = null;
    if (this.isDesktopChannel(input.channel)) {
      if (this.inMutexCooldown(sessionID)) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_degraded:input_mutex_cooldown:draft_only",
          reason: "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
      try {
        mutexLease = await acquireInputMutex(sessionID, INPUT_MUTEX_TIMEOUT_MS);
      } catch {
        this.markMutexTimeout(sessionID);
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_degraded:input_mutex_timeout:draft_only",
          reason: "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.channel === "qq" || input.channel === "wechat") {
      try {
        if (input.channel === "qq") {
          const result2 = await this.sendQqDesktopMessageImpl({
            projectDir: this.projectDir,
            destination: input.destination,
            text,
            mediaPath,
            riskLevel
          });
          const visionCheck2 = await this.analyzeDesktopOutboundEvidenceImpl({
            destination: input.destination,
            preSendScreenshotPath: result2.preSendScreenshotPath,
            postSendScreenshotPath: result2.postSendScreenshotPath,
            visualPrecheck: result2.visualPrecheck,
            visualPostcheck: result2.visualPostcheck,
            receiptStatus: result2.receiptStatus,
            recipientTextCheck: result2.recipientTextCheck
          });
          if (visionCheck2.recipientMatch === "mismatch") {
            result2.sent = false;
            result2.message = "outbound_blocked:recipient_text_mismatch";
          }
          if (visionCheck2.sendStatusDetected === "failed") {
            result2.sent = false;
            result2.message = "outbound_blocked:receipt_uncertain";
          }
          if (visionCheck2.uiStyleMismatch) {
            result2.sent = false;
            result2.message = "outbound_degraded:ui_style_mismatch:draft_only";
          }
          if (result2.sent && result2.receiptStatus !== "confirmed") {
            result2.sent = false;
            result2.message = "outbound_blocked:receipt_uncertain";
          }
          const audit2 = this.recordOutboundAttempt({
            channel: "qq",
            destination: input.destination,
            textPreview: text.slice(0, 200),
            sent: result2.sent,
            message: result2.message,
            mediaPath: mediaPath || undefined,
            reason: result2.sent ? "sent" : "desktop_send_failed",
            archAdvisorApproved,
            targetInAllowlist,
            contactTier: tier,
            intent,
            containsSensitive,
            riskLevel,
            policyHash,
            sendFingerprint: input.sendFingerprint,
            ticketSummary,
            payloadHash: result2.payloadHash ?? payloadHash,
            windowFingerprint: result2.windowFingerprint,
            recipientTextCheck: visionCheck2.recipientMatch === "matched" || visionCheck2.recipientMatch === "mismatch" ? visionCheck2.recipientMatch : result2.recipientTextCheck,
            sendStatusCheck: visionCheck2.sendStatusDetected,
            preSendScreenshotPath: result2.preSendScreenshotPath,
            postSendScreenshotPath: result2.postSendScreenshotPath,
            failureStep: result2.failureStep,
            ocrSource: visionCheck2.ocrSource,
            ocrPreview: visionCheck2.ocrPreview,
            captureMethod: visionCheck2.capture.method,
            evidenceConfidence: visionCheck2.capture.confidence,
            evidenceLimitations: visionCheck2.capture.limitations,
            automationPath: result2.automationPath,
            uiaPath: result2.uiaPath,
            targetHwnd: result2.targetHwnd,
            foregroundBefore: result2.foregroundBefore,
            foregroundAfter: result2.foregroundAfter,
            fallbackReason: result2.fallbackReason,
            simulationStatus: result2.simulationStatus,
            simulationRiskHints: result2.simulationRiskHints,
            visualPrecheck: result2.visualPrecheck,
            visualPostcheck: result2.visualPostcheck,
            receiptStatus: result2.receiptStatus,
            routeLevel: result2.routeLevel,
            somSelectionSource: result2.somSelectionSource,
            somSelectedCandidateId: result2.somSelectedCandidateId,
            vlmCallsUsed: result2.vlmCallsUsed,
            actionPlanMemoryHit: result2.actionPlanMemoryHit,
            automationLatencyMs: result2.latencyMs,
            automationKpi: result2.kpiSnapshot
          });
          if (result2.sent) {
            this.clearMutexStrike(sessionID);
          }
          if (!audit2.evidenceBundle || !audit2.semanticSummary) {
            return {
              sent: false,
              message: "outbound_blocked:missing_evidence_bundle",
              auditID: audit2.id
            };
          }
          return { ...result2, auditID: audit2.id };
        }
        const result = await this.sendWechatDesktopMessageImpl({
          projectDir: this.projectDir,
          destination: input.destination,
          text,
          mediaPath,
          riskLevel
        });
        const visionCheck = await this.analyzeDesktopOutboundEvidenceImpl({
          destination: input.destination,
          preSendScreenshotPath: result.preSendScreenshotPath,
          postSendScreenshotPath: result.postSendScreenshotPath,
          visualPrecheck: result.visualPrecheck,
          visualPostcheck: result.visualPostcheck,
          receiptStatus: result.receiptStatus,
          recipientTextCheck: result.recipientTextCheck
        });
        if (visionCheck.recipientMatch === "mismatch") {
          result.sent = false;
          result.message = "outbound_blocked:recipient_text_mismatch";
        }
        if (visionCheck.sendStatusDetected === "failed") {
          result.sent = false;
          result.message = "outbound_blocked:receipt_uncertain";
        }
        if (visionCheck.uiStyleMismatch) {
          result.sent = false;
          result.message = "outbound_degraded:ui_style_mismatch:draft_only";
        }
        if (result.sent && result.receiptStatus !== "confirmed") {
          result.sent = false;
          result.message = "outbound_blocked:receipt_uncertain";
        }
        const audit = this.recordOutboundAttempt({
          channel: "wechat",
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: result.sent,
          message: result.message,
          mediaPath: mediaPath || undefined,
          reason: result.sent ? "sent" : "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash: result.payloadHash ?? payloadHash,
          windowFingerprint: result.windowFingerprint,
          recipientTextCheck: visionCheck.recipientMatch === "matched" || visionCheck.recipientMatch === "mismatch" ? visionCheck.recipientMatch : result.recipientTextCheck,
          sendStatusCheck: visionCheck.sendStatusDetected,
          preSendScreenshotPath: result.preSendScreenshotPath,
          postSendScreenshotPath: result.postSendScreenshotPath,
          failureStep: result.failureStep,
          ocrSource: visionCheck.ocrSource,
          ocrPreview: visionCheck.ocrPreview,
          captureMethod: visionCheck.capture.method,
          evidenceConfidence: visionCheck.capture.confidence,
          evidenceLimitations: visionCheck.capture.limitations,
          automationPath: result.automationPath,
          uiaPath: result.uiaPath,
          targetHwnd: result.targetHwnd,
          foregroundBefore: result.foregroundBefore,
          foregroundAfter: result.foregroundAfter,
          fallbackReason: result.fallbackReason,
          simulationStatus: result.simulationStatus,
          simulationRiskHints: result.simulationRiskHints,
          visualPrecheck: result.visualPrecheck,
          visualPostcheck: result.visualPostcheck,
          receiptStatus: result.receiptStatus,
          routeLevel: result.routeLevel,
          somSelectionSource: result.somSelectionSource,
          somSelectedCandidateId: result.somSelectedCandidateId,
          vlmCallsUsed: result.vlmCallsUsed,
          actionPlanMemoryHit: result.actionPlanMemoryHit,
          automationLatencyMs: result.latencyMs,
          automationKpi: result.kpiSnapshot
        });
        if (result.sent) {
          this.clearMutexStrike(sessionID);
        }
        if (!audit.evidenceBundle || !audit.semanticSummary) {
          return {
            sent: false,
            message: "outbound_blocked:missing_evidence_bundle",
            auditID: audit.id
          };
        }
        return { ...result, auditID: audit.id };
      } catch (error92) {
        return this.recordDesktopRuntimeFailure({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash,
          error: error92
        });
      } finally {
        mutexLease?.release();
      }
    }
    mutexLease?.release();
    return {
      sent: false,
      message: `channel_send_blocked:${input.channel}:INBOUND_ONLY channels are receive-only`
    };
  }
  async sendPairingMessage(channel, destination) {
    if (channel !== "qq" && channel !== "wechat") {
      return;
    }
    const pairingText = "Miya security: your account is not paired yet. Ask admin to approve pairing in Miya control panel.";
    await this.sendMessage({
      channel,
      destination,
      text: pairingText,
      outboundCheck: {
        archAdvisorApproved: true,
        riskLevel: "LOW",
        bypassAllowlist: true,
        bypassThrottle: true,
        bypassDuplicateGuard: true
      }
    });
  }
}
// src/gateway/mode-observability.ts
import * as fs19 from "node:fs";
import * as path21 from "node:path";
function nowIso12() {
  return new Date().toISOString();
}
function storePath(projectDir) {
  return path21.join(getMiyaRuntimeDir(projectDir), "mode-observability.json");
}
function defaultStore2() {
  return {
    version: 1,
    totals: {
      turns: 0,
      modeSwitches: 0,
      misclassificationRollbacks: 0,
      autonomousAttempts: 0,
      autonomousCompletions: 0,
      negativeFeedbackTurns: 0
    },
    lastMode: undefined,
    lastTurnID: undefined,
    updatedAt: nowIso12()
  };
}
function readStore4(projectDir) {
  const file3 = storePath(projectDir);
  if (!fs19.existsSync(file3))
    return defaultStore2();
  try {
    const parsed = JSON.parse(fs19.readFileSync(file3, "utf-8"));
    return {
      ...defaultStore2(),
      ...parsed,
      totals: {
        ...defaultStore2().totals,
        ...parsed.totals ?? {}
      }
    };
  } catch {
    return defaultStore2();
  }
}
function writeStore2(projectDir, store) {
  fs19.mkdirSync(path21.dirname(storePath(projectDir)), { recursive: true });
  fs19.writeFileSync(storePath(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
  return store;
}
function safeRate(numerator, denominator) {
  if (denominator <= 0)
    return 0;
  return Number((numerator / denominator).toFixed(4));
}
function readModeObservability(projectDir) {
  const store = readStore4(projectDir);
  const turns = Math.max(0, store.totals.turns);
  const modeSwitchFrequency = safeRate(store.totals.modeSwitches, Math.max(1, turns - 1));
  const misclassificationRollbackRate = safeRate(store.totals.misclassificationRollbacks, Math.max(1, turns));
  const autonomousTaskCompletionRate = safeRate(store.totals.autonomousCompletions, Math.max(1, store.totals.autonomousAttempts));
  const userNegativeFeedbackRate = safeRate(store.totals.negativeFeedbackTurns, Math.max(1, turns));
  return {
    totals: store.totals,
    metrics: {
      modeSwitchFrequency,
      misclassificationRollbackRate,
      autonomousTaskCompletionRate,
      userNegativeFeedbackRate
    },
    lastMode: store.lastMode,
    lastTurnID: store.lastTurnID,
    updatedAt: store.updatedAt
  };
}
function recordModeObservability(projectDir, input) {
  const store = readStore4(projectDir);
  const next = {
    ...store,
    totals: { ...store.totals },
    updatedAt: nowIso12(),
    lastTurnID: input.turnID
  };
  next.totals.turns += 1;
  if (store.lastMode && store.lastMode !== input.finalMode) {
    next.totals.modeSwitches += 1;
  }
  if (input.rollback)
    next.totals.misclassificationRollbacks += 1;
  if (input.autonomousAttempt)
    next.totals.autonomousAttempts += 1;
  if (input.autonomousSuccess)
    next.totals.autonomousCompletions += 1;
  if (input.negativeFeedback)
    next.totals.negativeFeedbackTurns += 1;
  next.lastMode = input.finalMode;
  writeStore2(projectDir, next);
  return readModeObservability(projectDir);
}
function detectNegativeFeedbackText(text) {
  return /(|||||||wrong|bad|stop|not good|hate)/i.test(String(text ?? "").trim());
}

// src/learning/skill-drafts.ts
import { createHash as createHash6, randomUUID as randomUUID9 } from "node:crypto";
import * as fs20 from "node:fs";
import * as path22 from "node:path";
function nowIso13() {
  return new Date().toISOString();
}
function filePath3(projectDir) {
  return path22.join(getMiyaRuntimeDir(projectDir), "learning-skill-drafts.json");
}
function normalizeText(text) {
  return String(text ?? "").replace(/\s+/g, " ").trim();
}
function tokenize(text) {
  return Array.from(new Set(normalizeText(text).toLowerCase().split(/[^a-z0-9_\-\u4e00-\u9fff]+/i).map((item) => item.trim()).filter((item) => item.length >= 2)));
}
function hashText(text) {
  return createHash6("sha256").update(text).digest("hex").slice(0, 16);
}
function ensureDir8(projectDir) {
  fs20.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp3(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeDraft(raw) {
  const now = nowIso13();
  return {
    id: String(raw.id ?? `draft_${randomUUID9()}`),
    source: raw.source === "reflect" ? "reflect" : "ralph",
    status: raw.status === "accepted" || raw.status === "rejected" || raw.status === "recommended" || raw.status === "draft" ? raw.status : "draft",
    title: normalizeText(String(raw.title ?? "")),
    problemPattern: normalizeText(String(raw.problemPattern ?? "")),
    solutionPattern: normalizeText(String(raw.solutionPattern ?? "")),
    commands: Array.isArray(raw.commands) ? raw.commands.map(String).map(normalizeText).filter(Boolean) : [],
    tags: Array.isArray(raw.tags) ? raw.tags.map(String).map((item) => item.trim().toLowerCase()).filter(Boolean) : [],
    confidence: clamp3(Number(raw.confidence ?? 0.5), 0.1, 0.99),
    uses: clamp3(Number(raw.uses ?? 0), 0, 1e6),
    hits: clamp3(Number(raw.hits ?? 0), 0, 1e6),
    misses: clamp3(Number(raw.misses ?? 0), 0, 1e6),
    createdAt: raw.createdAt ? String(raw.createdAt) : now,
    updatedAt: raw.updatedAt ? String(raw.updatedAt) : now
  };
}
function readStore5(projectDir) {
  const file3 = filePath3(projectDir);
  if (!fs20.existsSync(file3))
    return { drafts: [] };
  try {
    const parsed = JSON.parse(fs20.readFileSync(file3, "utf-8"));
    const drafts = Array.isArray(parsed?.drafts) ? parsed.drafts.map((item) => normalizeDraft(item)) : [];
    return { drafts };
  } catch {
    return { drafts: [] };
  }
}
function writeStore3(projectDir, store) {
  ensureDir8(projectDir);
  fs20.writeFileSync(filePath3(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function findSimilarDraftIndex(drafts, candidate) {
  const signature = hashText(`${candidate.source}|${candidate.problemPattern}|${candidate.solutionPattern}|${candidate.commands.join("|")}`);
  return drafts.findIndex((item) => {
    const current = hashText(`${item.source}|${item.problemPattern}|${item.solutionPattern}|${item.commands.join("|")}`);
    return current === signature;
  });
}
function upsertDraft(projectDir, draft) {
  const store = readStore5(projectDir);
  const index = findSimilarDraftIndex(store.drafts, draft);
  if (index >= 0) {
    const current = store.drafts[index];
    const merged = normalizeDraft({
      ...current,
      ...draft,
      id: current.id,
      createdAt: current.createdAt,
      confidence: current.confidence * 0.7 + draft.confidence * 0.3,
      status: current.status === "accepted" || current.status === "rejected" ? current.status : draft.status,
      tags: Array.from(new Set([...current.tags, ...draft.tags])).slice(0, 12),
      updatedAt: nowIso13()
    });
    store.drafts[index] = merged;
    writeStore3(projectDir, store);
    return merged;
  }
  const next = normalizeDraft(draft);
  store.drafts = [next, ...store.drafts].slice(0, 500);
  writeStore3(projectDir, store);
  return next;
}
function draftScoreForQuery(draft, query) {
  const queryTokens = tokenize(query);
  if (queryTokens.length === 0)
    return 0;
  const targetTokens = new Set(tokenize(`${draft.title} ${draft.problemPattern} ${draft.solutionPattern} ${draft.tags.join(" ")}`));
  let overlap = 0;
  for (const token of queryTokens) {
    if (targetTokens.has(token))
      overlap += 1;
  }
  const overlapScore = overlap / queryTokens.length;
  const quality = draft.confidence;
  const statusBoost = draft.status === "accepted" ? 0.12 : draft.status === "recommended" ? 0.06 : 0;
  return clamp3(overlapScore * 0.75 + quality * 0.25 + statusBoost, 0, 1);
}
function matchDrafts(projectDir, query, threshold, limit) {
  const store = readStore5(projectDir);
  return store.drafts.filter((draft) => draft.status !== "rejected").map((draft) => ({ draft, score: draftScoreForQuery(draft, query) })).filter((item) => item.score >= threshold).sort((a, b) => b.score - a.score).slice(0, Math.max(1, limit));
}
function listSkillDrafts(projectDir, input) {
  const limit = Math.max(1, Math.min(200, Math.floor(Number(input?.limit ?? 50))));
  const store = readStore5(projectDir);
  return store.drafts.filter((draft) => input?.status ? draft.status === input.status : true).slice(0, limit);
}
function setSkillDraftStatus(projectDir, draftID, status, usage) {
  const store = readStore5(projectDir);
  const index = store.drafts.findIndex((item) => item.id === draftID);
  if (index < 0)
    return null;
  const current = store.drafts[index];
  const next = normalizeDraft({
    ...current,
    status: status ?? current.status,
    uses: usage ? current.uses + 1 : current.uses,
    hits: usage ? current.hits + (usage.hit ? 1 : 0) : current.hits,
    misses: usage ? current.misses + (usage.hit ? 0 : 1) : current.misses,
    updatedAt: nowIso13()
  });
  store.drafts[index] = next;
  writeStore3(projectDir, store);
  return next;
}
function getLearningStats(projectDir) {
  const drafts = readStore5(projectDir).drafts;
  const byStatus = {
    draft: 0,
    recommended: 0,
    accepted: 0,
    rejected: 0
  };
  let totalUses = 0;
  let totalHits = 0;
  for (const draft of drafts) {
    byStatus[draft.status] += 1;
    totalUses += draft.uses;
    totalHits += draft.hits;
  }
  return {
    total: drafts.length,
    byStatus,
    totalUses,
    hitRate: totalUses > 0 ? Number((totalHits / totalUses).toFixed(4)) : 0
  };
}
function buildLearningInjection(projectDir, query, input) {
  const threshold = clamp3(Number(input?.threshold ?? 0.64), 0.3, 0.98);
  const limit = Math.max(1, Math.min(3, Math.floor(Number(input?.limit ?? 2))));
  const matches = matchDrafts(projectDir, query, threshold, limit);
  if (matches.length === 0)
    return { snippet: undefined, matchedDraftIDs: [] };
  const lines = [
    "[MIYA_LEARNING_DRAFT_REUSE]",
    "Matched historical patterns (use as guidance, then verify):"
  ];
  for (const item of matches) {
    lines.push(`- draft=${item.draft.id} score=${item.score.toFixed(2)} title=${item.draft.title}`);
    lines.push(`  pattern=${item.draft.problemPattern}`);
    lines.push(`  fix=${item.draft.solutionPattern}`);
    if (item.draft.commands.length > 0) {
      lines.push(`  commands=${item.draft.commands.join(" ; ")}`);
    }
  }
  return {
    snippet: lines.join(`
`),
    matchedDraftIDs: matches.map((item) => item.draft.id)
  };
}
function createSkillDraftsFromReflect(projectDir, input) {
  const memories = Array.isArray(input.createdMemories) ? input.createdMemories : [];
  if (memories.length === 0)
    return [];
  const preferenceMemories = memories.filter((item) => item.memoryKind === "UserPreference").slice(0, 6);
  if (preferenceMemories.length === 0)
    return [];
  const pattern = preferenceMemories.map((item) => item.text).join(" | ");
  const draft = upsertDraft(projectDir, {
    id: `draft_${randomUUID9()}`,
    source: "reflect",
    status: "draft",
    title: "Reflect ",
    problemPattern: "",
    solutionPattern: `${pattern}`,
    commands: [],
    tags: ["reflect", "preference"],
    confidence: 0.62,
    uses: 0,
    hits: 0,
    misses: 0,
    createdAt: nowIso13(),
    updatedAt: nowIso13()
  });
  return [draft];
}
// src/companion/memory-vector.ts
import { randomUUID as randomUUID10 } from "node:crypto";
import * as fs23 from "node:fs";
import * as path25 from "node:path";

// src/companion/memory-embedding.ts
import { createHash as createHash7 } from "node:crypto";
import * as fs21 from "node:fs";
import * as path23 from "node:path";
var DEFAULT_CONFIG2 = {
  kind: "local-hash",
  dims: 64,
  timeoutMs: 2500,
  fallbackKind: "local-hash"
};
var PROVIDERS = [
  {
    kind: "local-hash",
    description: "Deterministic hash embedding, low-cost and offline.",
    supportsRemote: false
  },
  {
    kind: "local-ngram",
    description: "Character ngram hashing optimized for mixed CJK/English.",
    supportsRemote: false
  },
  {
    kind: "remote-http",
    description: "HTTP embedding endpoint with local fallback.",
    supportsRemote: true
  }
];
function configPath(projectDir) {
  return path23.join(getMiyaRuntimeDir(projectDir), "memory", "embedding-provider.json");
}
function ensureDir9(projectDir) {
  fs21.mkdirSync(path23.dirname(configPath(projectDir)), { recursive: true });
}
function normalizeText2(text) {
  return String(text ?? "").trim().replace(/\s+/g, " ");
}
function toNumber(value, fallback, min, max) {
  const next = Number(value);
  if (!Number.isFinite(next))
    return fallback;
  return Math.max(min, Math.min(max, Math.floor(next)));
}
function normalizeHeaders(input) {
  if (!input || typeof input !== "object" || Array.isArray(input))
    return;
  const out = {};
  for (const [key, value] of Object.entries(input)) {
    const k = String(key).trim();
    const v = String(value ?? "").trim();
    if (!k || !v)
      continue;
    out[k] = v;
  }
  return Object.keys(out).length > 0 ? out : undefined;
}
function normalizeConfig2(raw) {
  const kind = raw?.kind === "local-hash" || raw?.kind === "local-ngram" || raw?.kind === "remote-http" ? raw.kind : DEFAULT_CONFIG2.kind;
  const fallbackKind = raw?.fallbackKind === "local-ngram" ? "local-ngram" : "local-hash";
  return {
    kind,
    dims: toNumber(raw?.dims, DEFAULT_CONFIG2.dims, 16, 2048),
    url: typeof raw?.url === "string" ? raw.url.trim() || undefined : undefined,
    model: typeof raw?.model === "string" ? raw.model.trim() || undefined : undefined,
    timeoutMs: toNumber(raw?.timeoutMs, DEFAULT_CONFIG2.timeoutMs ?? 2500, 500, 20000),
    headers: normalizeHeaders(raw?.headers),
    fallbackKind
  };
}
function listEmbeddingProviders() {
  return PROVIDERS;
}
function readEmbeddingProviderConfig(projectDir) {
  const file3 = configPath(projectDir);
  if (!fs21.existsSync(file3))
    return DEFAULT_CONFIG2;
  try {
    const parsed = JSON.parse(fs21.readFileSync(file3, "utf-8"));
    return normalizeConfig2(parsed);
  } catch {
    return DEFAULT_CONFIG2;
  }
}
function writeEmbeddingProviderConfig(projectDir, patch) {
  const current = readEmbeddingProviderConfig(projectDir);
  const next = normalizeConfig2({
    ...current,
    ...patch,
    headers: patch.headers ?? current.headers
  });
  ensureDir9(projectDir);
  fs21.writeFileSync(configPath(projectDir), `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function baseTokenize(text) {
  return normalizeText2(text).toLowerCase().split(/[^\p{L}\p{N}]+/u).map((item) => item.trim()).filter(Boolean);
}
function localHashEmbedding(text, dims) {
  const vec = new Array(dims).fill(0);
  const parts = baseTokenize(text);
  if (parts.length === 0)
    return vec;
  for (const part of parts) {
    const hash3 = createHash7("sha256").update(part).digest();
    for (let i = 0;i < 8; i += 1) {
      const idx = hash3[i] % dims;
      vec[idx] += 1 + hash3[i + 8] % 3;
    }
  }
  const norm = Math.sqrt(vec.reduce((sum, value) => sum + value * value, 0));
  if (norm <= 0)
    return vec;
  return vec.map((value) => value / norm);
}
function charNgrams(input) {
  const text = normalizeText2(input).toLowerCase();
  if (text.length < 2)
    return text ? [text] : [];
  const chars = Array.from(text.replace(/\s+/g, ""));
  const out = [];
  for (let i = 0;i < chars.length; i += 1) {
    out.push(chars.slice(i, i + 2).join(""));
    if (i + 3 <= chars.length)
      out.push(chars.slice(i, i + 3).join(""));
  }
  return out.filter((item) => item.length >= 2);
}
function localNgramEmbedding(text, dims) {
  const vec = new Array(dims).fill(0);
  const grams = charNgrams(text);
  if (grams.length === 0)
    return localHashEmbedding(text, dims);
  for (const gram of grams) {
    const hash3 = createHash7("sha256").update(gram).digest();
    const idxA = hash3[0] % dims;
    const idxB = hash3[1] % dims;
    vec[idxA] += 1.2;
    vec[idxB] += 0.8;
  }
  const norm = Math.sqrt(vec.reduce((sum, value) => sum + value * value, 0));
  if (norm <= 0)
    return vec;
  return vec.map((value) => value / norm);
}
function fallbackEmbedding(text, dims, fallbackKind) {
  return fallbackKind === "local-ngram" ? localNgramEmbedding(text, dims) : localHashEmbedding(text, dims);
}
function extractEmbeddingPayload(raw) {
  if (!raw || typeof raw !== "object")
    return null;
  const obj = raw;
  const direct = obj.embedding;
  if (Array.isArray(direct)) {
    return direct.map((item) => Number(item)).filter((item) => Number.isFinite(item));
  }
  if (Array.isArray(obj.data) && obj.data.length > 0) {
    const first = obj.data[0];
    if (first && Array.isArray(first.embedding)) {
      return first.embedding.map((item) => Number(item)).filter((item) => Number.isFinite(item));
    }
  }
  return null;
}
function remoteHttpEmbedding(text, config3) {
  if (!config3.url || typeof Bun === "undefined")
    return null;
  try {
    const args = [
      "-sS",
      "--max-time",
      String(Math.ceil((config3.timeoutMs ?? 2500) / 1000)),
      "-H",
      "Content-Type: application/json"
    ];
    if (config3.headers) {
      for (const [key, value] of Object.entries(config3.headers)) {
        args.push("-H", `${key}: ${value}`);
      }
    }
    const payload = {
      input: [text],
      model: config3.model,
      dimensions: config3.dims
    };
    args.push("-X", "POST", "--data", JSON.stringify(payload), config3.url);
    const proc = Bun.spawnSync(["curl", ...args], {
      stdout: "pipe",
      stderr: "pipe",
      timeout: config3.timeoutMs
    });
    if (proc.exitCode !== 0)
      return null;
    const body = Buffer.from(proc.stdout).toString("utf-8").trim();
    if (!body)
      return null;
    const parsed = JSON.parse(body);
    const values = extractEmbeddingPayload(parsed);
    if (!values || values.length === 0)
      return null;
    const dims = Math.max(8, config3.dims);
    if (values.length === dims)
      return values;
    if (values.length > dims)
      return values.slice(0, dims);
    return [...values, ...new Array(dims - values.length).fill(0)];
  } catch {
    return null;
  }
}
function embedTextWithProvider(projectDir, text) {
  const config3 = readEmbeddingProviderConfig(projectDir);
  const dims = Math.max(16, config3.dims);
  if (config3.kind === "local-hash") {
    return {
      embedding: localHashEmbedding(text, dims),
      provider: "local-hash",
      dims
    };
  }
  if (config3.kind === "local-ngram") {
    return {
      embedding: localNgramEmbedding(text, dims),
      provider: "local-ngram",
      dims
    };
  }
  const remote = remoteHttpEmbedding(text, config3);
  if (remote && remote.length > 0) {
    return {
      embedding: remote,
      provider: `remote-http:${config3.model ?? "default"}`,
      dims
    };
  }
  const fallbackKind = config3.fallbackKind ?? "local-hash";
  return {
    embedding: fallbackEmbedding(text, dims, fallbackKind),
    provider: `remote-http:fallback:${fallbackKind}`,
    dims
  };
}

// src/companion/memory-sqlite.ts
import * as fs22 from "node:fs";
import * as path24 from "node:path";

// src/companion/sqlite-runtime.ts
import { createRequire as createRequire2 } from "node:module";
var cachedBackend;
function resolveBunBackend(require2) {
  try {
    const mod = require2("bun:sqlite");
    const BunDatabase = mod?.Database;
    if (typeof BunDatabase !== "function")
      return null;
    return {
      open(file3) {
        const db = new BunDatabase(file3);
        return {
          exec(sql) {
            db.exec(sql);
          },
          query(sql) {
            const statement = db.query(sql);
            return {
              run: (...args) => statement.run(...args),
              get: (...args) => statement.get(...args),
              all: (...args) => statement.all(...args)
            };
          },
          transaction(callback) {
            return db.transaction(callback);
          },
          close() {
            db.close();
          }
        };
      }
    };
  } catch {
    return null;
  }
}
function resolveNodeBackend(require2) {
  try {
    const mod = require2("node:sqlite");
    const DatabaseSync = mod?.DatabaseSync;
    if (typeof DatabaseSync !== "function")
      return null;
    return {
      open(file3) {
        const db = new DatabaseSync(file3);
        return {
          exec(sql) {
            db.exec(sql);
          },
          query(sql) {
            return {
              run: (...args) => db.prepare(sql).run(...args),
              get: (...args) => db.prepare(sql).get(...args),
              all: (...args) => db.prepare(sql).all(...args)
            };
          },
          transaction(callback) {
            return () => {
              db.exec("BEGIN IMMEDIATE");
              try {
                callback();
                db.exec("COMMIT");
              } catch (error92) {
                try {
                  db.exec("ROLLBACK");
                } catch {}
                throw error92;
              }
            };
          },
          close() {
            db.close();
          }
        };
      }
    };
  } catch {
    return null;
  }
}
function resolveBackend() {
  if (cachedBackend !== undefined)
    return cachedBackend;
  const require2 = createRequire2(import.meta.url);
  cachedBackend = resolveBunBackend(require2) ?? resolveNodeBackend(require2);
  return cachedBackend;
}
function openSqliteDatabase(file3) {
  const backend = resolveBackend();
  if (!backend)
    return null;
  try {
    return backend.open(file3);
  } catch {
    return null;
  }
}

// src/companion/memory-sqlite.ts
function memoryDir(projectDir) {
  return path24.join(getMiyaRuntimeDir(projectDir), "memory");
}
function sqlitePath(projectDir) {
  return path24.join(memoryDir(projectDir), "memories.sqlite");
}
function openDatabase(projectDir) {
  fs22.mkdirSync(memoryDir(projectDir), { recursive: true });
  const db = openSqliteDatabase(sqlitePath(projectDir));
  if (!db)
    return null;
  db.exec(`
    CREATE TABLE IF NOT EXISTS memories (
      id TEXT PRIMARY KEY,
      subject TEXT NOT NULL,
      predicate TEXT NOT NULL,
      object TEXT NOT NULL,
      memory_kind TEXT DEFAULT 'Fact',
      semantic_layer TEXT DEFAULT 'episodic',
      learning_stage TEXT DEFAULT 'candidate',
      domain TEXT DEFAULT 'relationship',
      inferred_domain TEXT,
      source_type TEXT DEFAULT 'manual',
      status TEXT DEFAULT 'pending',
      embedding_provider TEXT DEFAULT 'local-hash',
      confidence REAL DEFAULT 0.5,
      source_message_id TEXT,
      conflict_flag INTEGER DEFAULT 0,
      is_archived INTEGER DEFAULT 0,
      access_count INTEGER DEFAULT 0,
      created_at TEXT NOT NULL,
      last_accessed_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memories_vss (
      memory_id TEXT PRIMARY KEY,
      object_embedding TEXT NOT NULL,
      FOREIGN KEY(memory_id) REFERENCES memories(id) ON DELETE CASCADE
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS long_term_graph (
      memory_id TEXT PRIMARY KEY,
      subject TEXT NOT NULL,
      predicate TEXT NOT NULL,
      object TEXT NOT NULL,
      memory_kind TEXT NOT NULL,
      semantic_layer TEXT DEFAULT 'episodic',
      domain TEXT DEFAULT 'relationship',
      confidence REAL DEFAULT 0.5,
      source_message_id TEXT,
      updated_at TEXT NOT NULL,
      FOREIGN KEY(memory_id) REFERENCES memories(id) ON DELETE CASCADE
    );
  `);
  const alterStatements = [
    `ALTER TABLE memories ADD COLUMN memory_kind TEXT DEFAULT 'Fact'`,
    `ALTER TABLE memories ADD COLUMN semantic_layer TEXT DEFAULT 'episodic'`,
    `ALTER TABLE memories ADD COLUMN learning_stage TEXT DEFAULT 'candidate'`,
    `ALTER TABLE memories ADD COLUMN domain TEXT DEFAULT 'relationship'`,
    `ALTER TABLE memories ADD COLUMN inferred_domain TEXT`,
    `ALTER TABLE memories ADD COLUMN source_type TEXT DEFAULT 'manual'`,
    `ALTER TABLE memories ADD COLUMN status TEXT DEFAULT 'pending'`,
    `ALTER TABLE memories ADD COLUMN embedding_provider TEXT DEFAULT 'local-hash'`,
    `ALTER TABLE long_term_graph ADD COLUMN semantic_layer TEXT DEFAULT 'episodic'`,
    `ALTER TABLE long_term_graph ADD COLUMN domain TEXT DEFAULT 'relationship'`
  ];
  for (const sql of alterStatements) {
    try {
      db.exec(sql);
    } catch {}
  }
  return db;
}
function parseTriplet(text) {
  const parts = text.trim().split(/\s+/);
  if (parts.length >= 3) {
    return {
      subject: parts[0] ?? "User",
      predicate: parts[1] ?? "knows",
      object: parts.slice(2).join(" ")
    };
  }
  return {
    subject: "User",
    predicate: "fact",
    object: text.trim()
  };
}
function syncCompanionMemoriesToSqlite(projectDir, items) {
  let db = null;
  try {
    db = openDatabase(projectDir);
    if (!db)
      return;
    const upsertMemory = db.query(`
      INSERT INTO memories (
        id, subject, predicate, object, memory_kind, semantic_layer, learning_stage,
        domain, inferred_domain, source_type, status, embedding_provider, confidence,
        source_message_id, conflict_flag, is_archived, access_count, created_at, last_accessed_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(id) DO UPDATE SET
        subject=excluded.subject,
        predicate=excluded.predicate,
        object=excluded.object,
        memory_kind=excluded.memory_kind,
        semantic_layer=excluded.semantic_layer,
        learning_stage=excluded.learning_stage,
        domain=excluded.domain,
        inferred_domain=excluded.inferred_domain,
        source_type=excluded.source_type,
        status=excluded.status,
        embedding_provider=excluded.embedding_provider,
        confidence=excluded.confidence,
        source_message_id=excluded.source_message_id,
        conflict_flag=excluded.conflict_flag,
        is_archived=excluded.is_archived,
        access_count=excluded.access_count,
        created_at=excluded.created_at,
        last_accessed_at=excluded.last_accessed_at
    `);
    const upsertVss = db.query(`
      INSERT INTO memories_vss (memory_id, object_embedding)
      VALUES (?, ?)
      ON CONFLICT(memory_id) DO UPDATE SET
        object_embedding=excluded.object_embedding
    `);
    const upsertLongTermGraph = db.query(`
      INSERT INTO long_term_graph (
        memory_id, subject, predicate, object, memory_kind, semantic_layer,
        domain, confidence, source_message_id, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(memory_id) DO UPDATE SET
        subject=excluded.subject,
        predicate=excluded.predicate,
        object=excluded.object,
        memory_kind=excluded.memory_kind,
        semantic_layer=excluded.semantic_layer,
        domain=excluded.domain,
        confidence=excluded.confidence,
        source_message_id=excluded.source_message_id,
        updated_at=excluded.updated_at
    `);
    const tx = db.transaction(() => {
      for (const item of items) {
        const triplet = parseTriplet(item.text);
        upsertMemory.run(item.id, triplet.subject, triplet.predicate, triplet.object, item.memoryKind ?? "Fact", item.semanticLayer, item.learningStage, item.domain, item.inferredDomain ?? null, item.sourceType ?? "manual", item.status, item.embeddingProvider ?? "local-hash", item.confidence, item.sourceMessageID ?? null, item.conflictWizardID ? 1 : 0, item.isArchived ? 1 : 0, item.accessCount, item.createdAt, item.lastAccessedAt);
        upsertVss.run(item.id, JSON.stringify(item.embedding));
        upsertLongTermGraph.run(item.id, triplet.subject, triplet.predicate, triplet.object, item.memoryKind ?? "Fact", item.semanticLayer, item.domain, item.confidence, item.sourceMessageID ?? null, item.updatedAt);
      }
    });
    tx();
  } catch {} finally {
    try {
      db?.close();
    } catch {}
  }
}
function getCompanionMemorySqliteStats(projectDir) {
  let db = null;
  const dbPath = sqlitePath(projectDir);
  try {
    db = openDatabase(projectDir);
    if (!db) {
      return {
        sqlitePath: dbPath,
        memoryCount: 0,
        vectorCount: 0,
        graphCount: 0,
        byLearningStage: {}
      };
    }
    const memoryCount = Number(db.query("SELECT COUNT(1) AS c FROM memories").get()?.c ?? 0);
    const vectorCount = Number(db.query("SELECT COUNT(1) AS c FROM memories_vss").get()?.c ?? 0);
    const graphCount = Number(db.query("SELECT COUNT(1) AS c FROM long_term_graph").get()?.c ?? 0);
    const stageRows = db.query("SELECT learning_stage AS stage, COUNT(1) AS c FROM memories GROUP BY learning_stage").all();
    const byLearningStage = {};
    for (const row of stageRows) {
      const stage = String(row.stage ?? "unknown");
      byLearningStage[stage] = Number(row.c ?? 0);
    }
    return {
      sqlitePath: dbPath,
      memoryCount,
      vectorCount,
      graphCount,
      byLearningStage
    };
  } finally {
    try {
      db?.close();
    } catch {}
  }
}

// src/companion/memory-vector.ts
function nowIso14() {
  return new Date().toISOString();
}
function filePath4(projectDir) {
  return path25.join(getMiyaRuntimeDir(projectDir), "companion-memory-vectors.json");
}
function correctionFilePath(projectDir) {
  return path25.join(getMiyaRuntimeDir(projectDir), "companion-memory-corrections.json");
}
function ensureDir10(projectDir) {
  fs23.mkdirSync(path25.dirname(filePath4(projectDir)), { recursive: true });
}
function normalizeText3(text) {
  return text.trim().replace(/\s+/g, " ");
}
function normalizeSemanticLayer(value, fallback) {
  if (value === "episodic" || value === "semantic" || value === "preference" || value === "tool_trace") {
    return value;
  }
  return fallback;
}
function normalizeLearningStage(value, fallback) {
  if (value === "ephemeral" || value === "candidate" || value === "persistent") {
    return value;
  }
  return fallback;
}
var WORK_DOMAIN_HINT = /(bug|fix|error|code|commit|branch|build|deploy|api|test|typescript|python|sql|||||||||)/i;
function inferSemanticLayerByText(text, kind, sourceType) {
  if (kind === "UserPreference")
    return "preference";
  if (sourceType === "reflect" && /(trace|stack|command|tool|shell|stderr|stdout||)/i.test(text)) {
    return "tool_trace";
  }
  if (kind === "Insight")
    return "semantic";
  if (/(|||prefer|avoid||)/i.test(text))
    return "preference";
  if (/(||||tends to|usually|always|often)/i.test(text))
    return "semantic";
  if (/(trace|stack|command|tool|shell|stderr|stdout|||)/i.test(text)) {
    return "tool_trace";
  }
  return "episodic";
}
function inferLearningStageByStatus(status) {
  if (status === "active")
    return "persistent";
  if (status === "pending")
    return "candidate";
  return "candidate";
}
function inferMemoryDomain(text) {
  return WORK_DOMAIN_HINT.test(text) ? "work" : "relationship";
}
function tokenize2(text) {
  return normalizeText3(text).toLowerCase().split(/[^\p{L}\p{N}]+/u).map((item) => item.trim()).filter(Boolean).slice(0, 80);
}
function cosine(a, b) {
  if (a.length !== b.length || a.length === 0)
    return 0;
  let sum = 0;
  for (let i = 0;i < a.length; i += 1)
    sum += a[i] * b[i];
  return sum;
}
function lexicalSimilarity(queryTokens, docTokens, docFreq, corpusSize) {
  if (queryTokens.length === 0 || docTokens.length === 0 || corpusSize <= 0)
    return 0;
  const tf = new Map;
  for (const token of docTokens) {
    tf.set(token, (tf.get(token) ?? 0) + 1);
  }
  let score = 0;
  for (const token of queryTokens) {
    const termFreq = (tf.get(token) ?? 0) / docTokens.length;
    if (termFreq <= 0)
      continue;
    const df = docFreq.get(token) ?? 0;
    const idf = Math.log((corpusSize + 1) / (df + 1)) + 1;
    score += termFreq * idf;
  }
  return score;
}
function buildDocFreq(tokensList) {
  const freq = new Map;
  for (const tokens of tokensList) {
    const uniq = new Set(tokens);
    for (const token of uniq) {
      freq.set(token, (freq.get(token) ?? 0) + 1);
    }
  }
  return freq;
}
function extractConflictKey(text) {
  const negative = text.match(/(?:|||)\s*([^!?]+)/);
  if (negative?.[1])
    return { key: normalizeText3(negative[1]), polarity: "negative" };
  const positive = text.match(/(?:|||)\s*([^!?]+)/);
  if (positive?.[1])
    return { key: normalizeText3(positive[1]), polarity: "positive" };
  return { polarity: "neutral" };
}
function readStore6(projectDir) {
  const file3 = filePath4(projectDir);
  if (!fs23.existsSync(file3))
    return { version: 2, items: [] };
  try {
    const parsed = JSON.parse(fs23.readFileSync(file3, "utf-8"));
    return {
      version: 2,
      items: Array.isArray(parsed.items) ? parsed.items.map((item) => {
        const status = item.status === "active" || item.status === "pending" || item.status === "superseded" ? item.status : "active";
        const memoryKind = item.memoryKind === "Fact" || item.memoryKind === "Insight" || item.memoryKind === "UserPreference" ? item.memoryKind : undefined;
        const sourceType = item.sourceType === "manual" || item.sourceType === "conversation" || item.sourceType === "reflect" || item.sourceType === "direct_correction" ? item.sourceType : "manual";
        const text = typeof item.text === "string" ? item.text : "";
        return {
          ...item,
          confidence: typeof item.confidence === "number" && Number.isFinite(item.confidence) ? Math.max(0, Math.min(1, item.confidence)) : 0.7,
          tier: item.tier === "L1" || item.tier === "L2" || item.tier === "L3" ? item.tier : "L2",
          sourceMessageID: typeof item.sourceMessageID === "string" && item.sourceMessageID.trim() ? item.sourceMessageID : undefined,
          sourceType,
          memoryKind,
          semanticLayer: normalizeSemanticLayer(item.semanticLayer, inferSemanticLayerByText(text, memoryKind, sourceType)),
          learningStage: normalizeLearningStage(item.learningStage, inferLearningStageByStatus(status)),
          domain: item.domain === "work" || item.domain === "relationship" ? item.domain : "relationship",
          inferredDomain: item.inferredDomain === "work" || item.inferredDomain === "relationship" ? item.inferredDomain : undefined,
          crossDomainWrite: item.crossDomainWrite && typeof item.crossDomainWrite === "object" && (item.crossDomainWrite.from === "work" || item.crossDomainWrite.from === "relationship") && (item.crossDomainWrite.to === "work" || item.crossDomainWrite.to === "relationship") ? {
            from: item.crossDomainWrite.from,
            to: item.crossDomainWrite.to,
            requiresApproval: item.crossDomainWrite.requiresApproval !== false,
            evidence: Array.isArray(item.crossDomainWrite.evidence) ? item.crossDomainWrite.evidence.map((entry2) => String(entry2)).slice(0, 20) : [],
            approvedAt: typeof item.crossDomainWrite.approvedAt === "string" ? item.crossDomainWrite.approvedAt : undefined
          } : undefined,
          status,
          accessCount: typeof item.accessCount === "number" && Number.isFinite(item.accessCount) ? Math.max(0, Math.floor(item.accessCount)) : 0,
          embeddingProvider: typeof item.embeddingProvider === "string" && item.embeddingProvider.trim() ? item.embeddingProvider : "local-hash",
          isArchived: typeof item.isArchived === "boolean" ? item.isArchived : false
        };
      }) : []
    };
  } catch {
    return { version: 2, items: [] };
  }
}
function readCorrectionStore(projectDir) {
  const file3 = correctionFilePath(projectDir);
  if (!fs23.existsSync(file3))
    return { version: 1, items: [] };
  try {
    const parsed = JSON.parse(fs23.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      items: Array.isArray(parsed.items) ? parsed.items : []
    };
  } catch {
    return { version: 1, items: [] };
  }
}
function writeCorrectionStore(projectDir, store) {
  ensureDir10(projectDir);
  fs23.writeFileSync(correctionFilePath(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
  return store;
}
function writeStore4(projectDir, store) {
  ensureDir10(projectDir);
  fs23.writeFileSync(filePath4(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
  syncCompanionMemoriesToSqlite(projectDir, store.items);
  return store;
}
function toDays(deltaMs) {
  return Math.max(0, deltaMs / (24 * 3600 * 1000));
}
function safeDateMs(input) {
  const value = Date.parse(input);
  return Number.isFinite(value) ? value : 0;
}
function memoryAgeDays(item, nowMs) {
  return toDays(nowMs - safeDateMs(item.updatedAt));
}
function memoryIdleDays(item, nowMs) {
  return toDays(nowMs - safeDateMs(item.lastAccessedAt || item.updatedAt));
}
function normalizeDriftThresholds(options) {
  return {
    staleDays: typeof options?.staleDays === "number" && options.staleDays > 0 ? Math.min(365, options.staleDays) : 45,
    lowAccessCount: typeof options?.lowAccessCount === "number" && options.lowAccessCount >= 0 ? Math.min(20, Math.floor(options.lowAccessCount)) : 1,
    minScore: typeof options?.minScore === "number" && Number.isFinite(options.minScore) ? Math.max(0.01, Math.min(0.9, options.minScore)) : 0.12,
    minConfidence: typeof options?.minConfidence === "number" && Number.isFinite(options.minConfidence) ? Math.max(0.05, Math.min(0.95, options.minConfidence)) : 0.45,
    pendingTimeoutDays: typeof options?.pendingTimeoutDays === "number" && options.pendingTimeoutDays > 0 ? Math.min(180, options.pendingTimeoutDays) : 21,
    crossDomainPendingDays: typeof options?.crossDomainPendingDays === "number" && options.crossDomainPendingDays > 0 ? Math.min(90, options.crossDomainPendingDays) : 7
  };
}
function signalPriority(signal) {
  const severityWeight = signal.severity === "high" ? 3 : signal.severity === "medium" ? 2 : 1;
  return severityWeight * 1e4 + Math.round(signal.ageDays * 10);
}
function conflictStrength(item, nowMs) {
  const agePenalty = Math.exp(-(Math.log(2) / 30) * memoryIdleDays(item, nowMs));
  const accessWeight = Math.min(1, item.accessCount / 8);
  return item.confidence * 0.55 + item.score * 0.25 + agePenalty * 0.15 + accessWeight * 0.05;
}
function decayCompanionMemoryVectors(projectDir, halfLifeDays = 30) {
  const store = readStore6(projectDir);
  const safeHalfLife = Math.max(1, halfLifeDays);
  const lambda = Math.log(2) / safeHalfLife;
  const nowMs = Date.now();
  let updated = 0;
  for (const item of store.items) {
    if (item.status !== "active")
      continue;
    const ageDays = Math.max(0, (nowMs - Date.parse(item.updatedAt)) / (24 * 3600 * 1000));
    const nextScore = Math.max(0.05, item.score * Math.exp(-lambda * ageDays));
    if (Math.abs(nextScore - item.score) > 0.0001) {
      item.score = Number(nextScore.toFixed(4));
      if (item.score < 0.08) {
        item.isArchived = true;
      }
      item.updatedAt = nowIso14();
      updated += 1;
    }
  }
  writeStore4(projectDir, store);
  return { updated, items: store.items };
}
function auditCompanionMemoryDrift(projectDir, options) {
  const store = readStore6(projectDir);
  const nowMs = Date.now();
  const thresholds = normalizeDriftThresholds(options);
  const limit = typeof options?.limit === "number" && options.limit > 0 ? Math.min(1000, Math.floor(options.limit)) : 200;
  const pushSignal = (list, signal) => {
    list.push(signal);
  };
  const items = [];
  for (const item of store.items) {
    if (item.status === "superseded")
      continue;
    const ageDays = memoryAgeDays(item, nowMs);
    const idleDays = memoryIdleDays(item, nowMs);
    if (item.status === "active" && !item.isArchived) {
      const staleCandidate = ageDays >= thresholds.staleDays && idleDays >= Math.max(1, thresholds.staleDays / 2) && item.accessCount <= thresholds.lowAccessCount && item.score <= Math.max(0.25, thresholds.minScore + 0.05);
      if (staleCandidate) {
        pushSignal(items, {
          memoryID: item.id,
          reason: "stale_low_access",
          severity: "medium",
          recommendedAction: "archive",
          ageDays: Number(ageDays.toFixed(2)),
          idleDays: Number(idleDays.toFixed(2)),
          domain: item.domain,
          status: item.status,
          score: item.score,
          confidence: item.confidence,
          detail: `stale>${thresholds.staleDays}d and low access<=${thresholds.lowAccessCount}`
        });
      }
      const confidenceCollapse = item.confidence < thresholds.minConfidence && item.score < thresholds.minScore && ageDays >= Math.max(3, thresholds.pendingTimeoutDays / 2);
      if (confidenceCollapse) {
        pushSignal(items, {
          memoryID: item.id,
          reason: "confidence_collapse",
          severity: "high",
          recommendedAction: "archive",
          ageDays: Number(ageDays.toFixed(2)),
          idleDays: Number(idleDays.toFixed(2)),
          domain: item.domain,
          status: item.status,
          score: item.score,
          confidence: item.confidence,
          detail: `confidence<${thresholds.minConfidence} and score<${thresholds.minScore}`
        });
      }
    }
    if (item.status === "pending") {
      const isCrossDomainPending = Boolean(item.crossDomainWrite?.requiresApproval);
      const timeoutDays = isCrossDomainPending ? thresholds.crossDomainPendingDays : thresholds.pendingTimeoutDays;
      if (ageDays >= timeoutDays) {
        pushSignal(items, {
          memoryID: item.id,
          reason: isCrossDomainPending ? "cross_domain_pending_timeout" : "pending_timeout",
          severity: isCrossDomainPending ? "high" : "low",
          recommendedAction: "supersede",
          ageDays: Number(ageDays.toFixed(2)),
          idleDays: Number(idleDays.toFixed(2)),
          domain: item.domain,
          status: item.status,
          score: item.score,
          confidence: item.confidence,
          detail: isCrossDomainPending ? `cross-domain pending timeout>${thresholds.crossDomainPendingDays}d` : `pending timeout>${thresholds.pendingTimeoutDays}d`
        });
      }
    }
  }
  const conflictGroups = new Map;
  for (const item of store.items) {
    if (item.status !== "active" || item.isArchived || !item.conflictKey)
      continue;
    const polarity = extractConflictKey(item.text).polarity;
    if (polarity === "neutral")
      continue;
    const key = `${item.domain}|${item.conflictKey}`;
    const group = conflictGroups.get(key) ?? [];
    group.push(item);
    conflictGroups.set(key, group);
  }
  for (const [key, group] of conflictGroups.entries()) {
    if (group.length < 2)
      continue;
    const hasPositive = group.some((item) => extractConflictKey(item.text).polarity === "positive");
    const hasNegative = group.some((item) => extractConflictKey(item.text).polarity === "negative");
    if (!hasPositive || !hasNegative)
      continue;
    const sorted = [...group].sort((a, b) => conflictStrength(b, nowMs) - conflictStrength(a, nowMs));
    const winner = sorted[0];
    if (!winner)
      continue;
    for (const item of sorted.slice(1)) {
      pushSignal(items, {
        memoryID: item.id,
        reason: "conflict_parallel_active",
        severity: "high",
        recommendedAction: "supersede",
        ageDays: Number(memoryAgeDays(item, nowMs).toFixed(2)),
        idleDays: Number(memoryIdleDays(item, nowMs).toFixed(2)),
        domain: item.domain,
        status: item.status,
        score: item.score,
        confidence: item.confidence,
        detail: `conflict group ${key} winner=${winner.id}`,
        relatedMemoryID: winner.id
      });
    }
  }
  const dedupe = new Map;
  for (const item of items) {
    const existing = dedupe.get(item.memoryID);
    if (!existing || signalPriority(item) > signalPriority(existing)) {
      dedupe.set(item.memoryID, item);
    }
  }
  const ranked = [...dedupe.values()].sort((a, b) => signalPriority(b) - signalPriority(a)).slice(0, limit);
  const rankedByReason = {
    stale_low_access: 0,
    confidence_collapse: 0,
    pending_timeout: 0,
    cross_domain_pending_timeout: 0,
    conflict_parallel_active: 0
  };
  const rankedBySeverity = {
    low: 0,
    medium: 0,
    high: 0
  };
  for (const item of ranked) {
    rankedByReason[item.reason] += 1;
    rankedBySeverity[item.severity] += 1;
  }
  return {
    generatedAt: nowIso14(),
    scanned: store.items.length,
    actionableCount: ranked.length,
    thresholds,
    byReason: rankedByReason,
    bySeverity: rankedBySeverity,
    items: ranked
  };
}
function recycleCompanionMemoryDrift(projectDir, options) {
  const report = auditCompanionMemoryDrift(projectDir, {
    ...options,
    limit: typeof options?.limit === "number" ? options.limit : 1000
  });
  const dryRun = options?.dryRun === true;
  const maxActions = typeof options?.maxActions === "number" && options.maxActions > 0 ? Math.min(500, Math.floor(options.maxActions)) : 80;
  if (dryRun || report.items.length === 0) {
    return {
      dryRun,
      applied: 0,
      archivedIDs: [],
      superseded: [],
      remainingActionable: report.actionableCount,
      report
    };
  }
  const store = readStore6(projectDir);
  const index = new Map(store.items.map((item) => [item.id, item]));
  const now = nowIso14();
  const archivedIDs = [];
  const superseded = [];
  let applied = 0;
  for (const signal of report.items) {
    if (applied >= maxActions)
      break;
    const target = index.get(signal.memoryID);
    if (!target || target.status === "superseded")
      continue;
    if (signal.recommendedAction === "archive") {
      if (target.status !== "active" || target.isArchived)
        continue;
      target.isArchived = true;
      target.updatedAt = now;
      archivedIDs.push(target.id);
      applied += 1;
      continue;
    }
    if (signal.recommendedAction === "supersede") {
      const supersededBy = signal.relatedMemoryID && index.has(signal.relatedMemoryID) ? signal.relatedMemoryID : "system:drift-recycler";
      target.status = "superseded";
      target.learningStage = "candidate";
      target.supersededBy = supersededBy;
      target.updatedAt = now;
      superseded.push({
        memoryID: target.id,
        supersededBy,
        reason: signal.reason
      });
      applied += 1;
    }
  }
  if (applied > 0) {
    writeStore4(projectDir, store);
  }
  return {
    dryRun: false,
    applied,
    archivedIDs,
    superseded,
    remainingActionable: Math.max(0, report.actionableCount - applied),
    report
  };
}
function upsertCompanionMemoryVector(projectDir, input) {
  const text = normalizeText3(input.text);
  if (!text)
    throw new Error("invalid_memory_text");
  decayCompanionMemoryVectors(projectDir);
  const store = readStore6(projectDir);
  const embedded = embedTextWithProvider(projectDir, text);
  const embedding = embedded.embedding;
  const now = nowIso14();
  const inferredDomain = inferMemoryDomain(text);
  const requestedDomain = input.domain ?? inferredDomain;
  const crossDomain = requestedDomain !== inferredDomain;
  const crossDomainEvidence = Array.isArray(input.evidence) ? input.evidence.map((item) => normalizeText3(String(item))).filter(Boolean).slice(0, 20) : [];
  const near = store.items.filter((item) => item.status === "active" && item.domain === requestedDomain).map((item) => ({
    item,
    sim: cosine(item.embedding, embedding)
  })).sort((a, b) => b.sim - a.sim)[0];
  if (near && near.sim >= 0.95) {
    near.item.score = Math.min(1.5, near.item.score + 0.15);
    near.item.accessCount += 1;
    near.item.isArchived = false;
    near.item.lastAccessedAt = now;
    near.item.updatedAt = now;
    writeStore4(projectDir, store);
    return near.item;
  }
  const preference = extractConflictKey(text);
  const confidenceInput = typeof input.confidence === "number" && Number.isFinite(input.confidence) ? input.confidence : input.tier === "L1" ? 1 : input.tier === "L3" ? 0.4 : 0.7;
  const confidence = Math.max(0, Math.min(1, confidenceInput));
  const sourceType = input.sourceType ?? "manual";
  const memoryKind = input.memoryKind;
  const defaultStatus = crossDomain ? "pending" : input.activate ? "active" : "pending";
  const semanticLayer = normalizeSemanticLayer(input.semanticLayer, inferSemanticLayerByText(text, memoryKind, sourceType));
  const created = {
    id: `mem_${randomUUID10()}`,
    text,
    domain: requestedDomain,
    inferredDomain,
    crossDomainWrite: crossDomain ? {
      from: inferredDomain,
      to: requestedDomain,
      requiresApproval: true,
      evidence: crossDomainEvidence
    } : undefined,
    source: input.source?.trim() || "manual",
    embeddingProvider: embedded.provider,
    embedding,
    score: 1,
    confidence,
    tier: input.tier ?? (confidence >= 0.95 ? "L1" : confidence >= 0.6 ? "L2" : "L3"),
    sourceMessageID: input.sourceMessageID,
    sourceType,
    memoryKind,
    semanticLayer,
    learningStage: normalizeLearningStage(input.learningStage, inferLearningStageByStatus(defaultStatus)),
    status: defaultStatus,
    conflictKey: preference.key,
    accessCount: 0,
    isArchived: false,
    createdAt: now,
    updatedAt: now,
    lastAccessedAt: now
  };
  if (preference.key && preference.polarity !== "neutral") {
    const conflicting = [];
    for (const item of store.items) {
      if (item.status === "superseded")
        continue;
      const other = extractConflictKey(item.text);
      if (!other.key || other.key !== preference.key || other.polarity === "neutral")
        continue;
      if (other.polarity !== preference.polarity) {
        conflicting.push(item);
      }
    }
    if (conflicting.length > 0) {
      const lambda = Math.log(2) / 30;
      const newScore = created.confidence;
      const scored = conflicting.map((item) => {
        const ageDays = Math.max(0, (Date.now() - Date.parse(item.lastAccessedAt)) / (24 * 3600 * 1000));
        const score = item.confidence * Math.exp(-lambda * ageDays);
        return { item, score };
      });
      const strongestOld = scored.sort((a, b) => b.score - a.score)[0];
      const threshold = 0.1;
      const forceOverride = created.sourceType === "direct_correction";
      const shouldOverwrite = forceOverride || (strongestOld ? newScore > strongestOld.score + threshold : false);
      if (shouldOverwrite && !crossDomain) {
        created.status = "active";
        created.learningStage = "persistent";
        for (const other of conflicting) {
          other.status = "superseded";
          other.supersededBy = created.id;
          other.updatedAt = now;
        }
      } else {
        const correctionStore = readCorrectionStore(projectDir);
        const wizard = {
          id: `mcw_${randomUUID10()}`,
          conflictKey: preference.key,
          candidateMemoryID: created.id,
          existingMemoryIDs: conflicting.map((item) => item.id),
          status: "pending",
          createdAt: now,
          updatedAt: now
        };
        correctionStore.items = [wizard, ...correctionStore.items].slice(0, 1000);
        writeCorrectionStore(projectDir, correctionStore);
        created.conflictWizardID = wizard.id;
        created.status = "pending";
        created.learningStage = "candidate";
      }
    }
  }
  store.items = [created, ...store.items].slice(0, 1000);
  writeStore4(projectDir, store);
  return created;
}
function searchCompanionMemoryVectors(projectDir, query, limit = 5, options) {
  const q = normalizeText3(query);
  if (!q)
    return [];
  const embeddedQuery = embedTextWithProvider(projectDir, q);
  const qEmb = embeddedQuery.embedding;
  const qTokens = tokenize2(q);
  const store = readStore6(projectDir);
  const nowMs = Date.now();
  const recencyHalfLifeDays = Math.max(1, options?.recencyHalfLifeDays ?? 30);
  const alpha = options?.alpha ?? 0.6;
  const beta = options?.beta ?? 0.2;
  const gamma = options?.gamma ?? 0.2;
  const threshold = Math.max(0, options?.threshold ?? 0.15);
  const semanticWeight = Math.max(0, options?.semanticWeight ?? 0.7);
  const lexicalWeight = Math.max(0, options?.lexicalWeight ?? 0.3);
  const combinedWeightBase = Math.max(0.001, semanticWeight + lexicalWeight);
  const domainAllow = new Set;
  if (options?.domain === "work" || options?.domain === "relationship") {
    domainAllow.add(options.domain);
  }
  if (Array.isArray(options?.domains)) {
    for (const item of options.domains) {
      if (item === "work" || item === "relationship")
        domainAllow.add(item);
    }
  }
  const semanticLayerAllow = new Set;
  if (Array.isArray(options?.semanticLayers)) {
    for (const layer of options.semanticLayers) {
      if (layer === "episodic" || layer === "semantic" || layer === "preference" || layer === "tool_trace") {
        semanticLayerAllow.add(layer);
      }
    }
  }
  const learningStageAllow = new Set;
  if (Array.isArray(options?.learningStages)) {
    for (const stage of options.learningStages) {
      if (stage === "ephemeral" || stage === "candidate" || stage === "persistent") {
        learningStageAllow.add(stage);
      }
    }
  }
  const importanceFromTier = (tier) => tier === "L1" ? 1 : tier === "L2" ? 0.7 : 0.4;
  const recency = (at) => {
    const deltaDays = Math.max(0, (nowMs - Date.parse(at)) / (24 * 3600 * 1000));
    const lambda = Math.log(2) / recencyHalfLifeDays;
    return Math.exp(-lambda * deltaDays);
  };
  const candidates = store.items.filter((item) => {
    if (item.status !== "active" || item.isArchived)
      return false;
    if (domainAllow.size > 0 && !domainAllow.has(item.domain))
      return false;
    if (semanticLayerAllow.size > 0 && !semanticLayerAllow.has(item.semanticLayer))
      return false;
    if (learningStageAllow.size > 0 && !learningStageAllow.has(item.learningStage))
      return false;
    return true;
  });
  const tokenizedDocs = candidates.map((item) => tokenize2(item.text));
  const docFreq = buildDocFreq(tokenizedDocs);
  const results = candidates.map((item, index) => {
    const semanticSimilarity = cosine(item.embedding, qEmb);
    const lexicalRaw = lexicalSimilarity(qTokens, tokenizedDocs[index] ?? [], docFreq, Math.max(1, candidates.length));
    const lexicalSimilarityNorm = Math.max(0, Math.min(1, lexicalRaw / 3));
    const similarity = (semanticSimilarity * semanticWeight + lexicalSimilarityNorm * lexicalWeight) / combinedWeightBase;
    const importance = importanceFromTier(item.tier) * item.score * item.confidence;
    const rankScore = alpha * similarity + beta * recency(item.lastAccessedAt) + gamma * importance;
    return {
      ...item,
      similarity,
      semanticSimilarity,
      lexicalSimilarity: lexicalSimilarityNorm,
      channels: {
        semantic: semanticSimilarity,
        lexical: lexicalSimilarityNorm
      },
      rankScore
    };
  }).filter((item) => item.rankScore >= threshold).sort((a, b) => b.rankScore - a.rankScore).slice(0, Math.max(1, limit));
  for (const item of results) {
    const target = store.items.find((existing) => existing.id === item.id);
    if (!target)
      continue;
    target.accessCount += 1;
    target.lastAccessedAt = nowIso14();
  }
  writeStore4(projectDir, store);
  return results;
}
function listCompanionMemoryVectors(projectDir, domain3) {
  return readStore6(projectDir).items.filter((item) => !domain3 || item.domain === domain3);
}
function listPendingCompanionMemoryVectors(projectDir, domain3) {
  return readStore6(projectDir).items.filter((item) => item.status === "pending" && (!domain3 || item.domain === domain3));
}
function listCompanionMemoryCorrections(projectDir) {
  return readCorrectionStore(projectDir).items;
}
function mergePendingMemoryConflicts(projectDir, input) {
  const store = readStore6(projectDir);
  const maxSupersede = Math.max(1, Math.min(200, Math.floor(input?.maxSupersede ?? 40)));
  const now = nowIso14();
  const groups = new Map;
  for (const item of store.items) {
    if (item.status !== "pending")
      continue;
    const conflict = extractConflictKey(item.text);
    if (!item.conflictKey || conflict.polarity === "neutral")
      continue;
    const key = `${item.domain}|${item.conflictKey}|${conflict.polarity}`;
    const group = groups.get(key) ?? [];
    group.push(item);
    groups.set(key, group);
  }
  let merged = 0;
  const winners = [];
  for (const [, group] of groups.entries()) {
    if (group.length <= 1)
      continue;
    const sorted = [...group].sort((a, b) => {
      if (b.confidence !== a.confidence)
        return b.confidence - a.confidence;
      return Date.parse(b.updatedAt) - Date.parse(a.updatedAt);
    });
    const winner = sorted[0];
    if (!winner)
      continue;
    winners.push(winner.id);
    for (const item of sorted.slice(1)) {
      if (merged >= maxSupersede)
        break;
      item.status = "superseded";
      item.supersededBy = winner.id;
      item.updatedAt = now;
      merged += 1;
    }
    if (merged >= maxSupersede)
      break;
  }
  if (merged > 0)
    writeStore4(projectDir, store);
  return { merged, winners };
}
function confirmCompanionMemoryVector(projectDir, input) {
  const store = readStore6(projectDir);
  const target = store.items.find((item) => item.id === input.memoryID);
  if (!target)
    return null;
  const now = nowIso14();
  if (!input.confirm) {
    target.status = "superseded";
    target.learningStage = "candidate";
    target.updatedAt = now;
  } else {
    if (target.crossDomainWrite?.requiresApproval) {
      const evidence = Array.isArray(input.evidence) ? input.evidence.map((item) => normalizeText3(String(item))).filter(Boolean) : [];
      if (evidence.length === 0) {
        throw new Error("cross_domain_evidence_required");
      }
      target.crossDomainWrite = {
        ...target.crossDomainWrite,
        requiresApproval: false,
        evidence: Array.from(new Set([...target.crossDomainWrite.evidence, ...evidence])).slice(0, 30),
        approvedAt: now
      };
    }
    target.status = "active";
    target.learningStage = "persistent";
    target.updatedAt = now;
    target.lastAccessedAt = now;
    if (input.supersedeConflicts && target.conflictKey) {
      for (const item of store.items) {
        if (item.id === target.id || item.status === "superseded")
          continue;
        if (item.conflictKey === target.conflictKey) {
          const sourcePolarity = extractConflictKey(target.text).polarity;
          const itemPolarity = extractConflictKey(item.text).polarity;
          if (sourcePolarity !== "neutral" && itemPolarity !== "neutral" && sourcePolarity !== itemPolarity) {
            item.status = "superseded";
            item.supersededBy = target.id;
            item.updatedAt = now;
          }
        }
      }
    }
  }
  writeStore4(projectDir, store);
  if (target.conflictWizardID) {
    const corrections = readCorrectionStore(projectDir);
    corrections.items = corrections.items.map((item) => item.id === target.conflictWizardID ? {
      ...item,
      status: input.confirm ? "resolved" : "rejected",
      updatedAt: now
    } : item);
    writeCorrectionStore(projectDir, corrections);
  }
  return target;
}
function getCompanionMemoryVector(projectDir, memoryID) {
  return readStore6(projectDir).items.find((item) => item.id === memoryID) ?? null;
}
function updateCompanionMemoryVector(projectDir, input) {
  const store = readStore6(projectDir);
  const target = store.items.find((item) => item.id === input.memoryID);
  if (!target)
    return null;
  const text = normalizeText3(input.text);
  if (!text)
    throw new Error("invalid_memory_text");
  const embedded = embedTextWithProvider(projectDir, text);
  const now = nowIso14();
  target.text = text;
  target.embedding = embedded.embedding;
  target.embeddingProvider = embedded.provider;
  target.confidence = Number(Math.max(0.35, Math.min(0.98, target.confidence + 0.02)).toFixed(3));
  target.score = Number(Math.max(0.2, target.score).toFixed(3));
  target.conflictKey = extractConflictKey(text).key;
  if (input.domain === "work" || input.domain === "relationship") {
    target.domain = input.domain;
  }
  if (input.memoryKind === "Fact" || input.memoryKind === "Insight" || input.memoryKind === "UserPreference") {
    target.memoryKind = input.memoryKind;
  }
  target.updatedAt = now;
  target.lastAccessedAt = now;
  writeStore4(projectDir, store);
  return target;
}
function archiveCompanionMemoryVector(projectDir, input) {
  const store = readStore6(projectDir);
  const target = store.items.find((item) => item.id === input.memoryID);
  if (!target)
    return null;
  target.isArchived = input.archived;
  target.updatedAt = nowIso14();
  writeStore4(projectDir, store);
  return target;
}

// src/companion/learning-metrics.ts
function nowIso15() {
  return new Date().toISOString();
}
function clampRate(value, min, max) {
  if (!Number.isFinite(value))
    return min;
  return Math.max(min, Math.min(max, value));
}
function safeRate2(numerator, denominator) {
  if (denominator <= 0)
    return 0;
  return Number((numerator / denominator).toFixed(4));
}
function resolveTargets(input) {
  const misclassificationEnv = Number(process.env.MIYA_MODE_MISCLASSIFICATION_MAX_RATE ?? "");
  const correctionEnv = Number(process.env.MIYA_CORRECTION_CONVERGENCE_MIN_RATE ?? "");
  const memoryHitEnv = Number(process.env.MIYA_MEMORY_HIT_MIN_RATE ?? "");
  const maxModeMisclassificationRate = clampRate(Number.isFinite(input?.maxModeMisclassificationRate) ? Number(input?.maxModeMisclassificationRate) : Number.isFinite(misclassificationEnv) ? misclassificationEnv : 0.08, 0.01, 1);
  const minCorrectionConvergenceRate = clampRate(Number.isFinite(input?.minCorrectionConvergenceRate) ? Number(input?.minCorrectionConvergenceRate) : Number.isFinite(correctionEnv) ? correctionEnv : 0.65, 0.01, 1);
  const minMemoryHitRate = clampRate(Number.isFinite(input?.minMemoryHitRate) ? Number(input?.minMemoryHitRate) : Number.isFinite(memoryHitEnv) ? memoryHitEnv : 0.55, 0.01, 1);
  return {
    maxModeMisclassificationRate,
    minCorrectionConvergenceRate,
    minMemoryHitRate
  };
}
function readCompanionLearningMetrics(projectDir, input) {
  const memories = listCompanionMemoryVectors(projectDir);
  const corrections = listCompanionMemoryCorrections(projectDir);
  const mode = readModeObservability(projectDir);
  const drafts = getLearningStats(projectDir);
  const activeMemories = memories.filter((item) => item.status === "active" && !item.isArchived);
  const pendingMemories = memories.filter((item) => item.status === "pending");
  const preferenceMemories = activeMemories.filter((item) => item.semanticLayer === "preference");
  const correctionResolved = corrections.filter((item) => item.status === "resolved").length;
  const correctionRejected = corrections.filter((item) => item.status === "rejected").length;
  const correctionPending = corrections.filter((item) => item.status === "pending").length;
  const correctionConvergenceRate = safeRate2(correctionResolved, correctionResolved + correctionRejected);
  const memoryHitRate = safeRate2(activeMemories.filter((item) => item.accessCount > 0).length, activeMemories.length);
  const modeMisclassificationRate = clampRate(mode.metrics.misclassificationRollbackRate, 0, 1);
  const negativeFeedbackRate = clampRate(mode.metrics.userNegativeFeedbackRate, 0, 1);
  const targets = resolveTargets(input);
  const checks5 = {
    modeMisclassificationRate: modeMisclassificationRate <= targets.maxModeMisclassificationRate,
    correctionConvergenceRate: correctionConvergenceRate >= targets.minCorrectionConvergenceRate,
    memoryHitRate: memoryHitRate >= targets.minMemoryHitRate,
    pass: false
  };
  checks5.pass = checks5.modeMisclassificationRate && checks5.correctionConvergenceRate && checks5.memoryHitRate;
  return {
    generatedAt: nowIso15(),
    totals: {
      memories: memories.length,
      activeMemories: activeMemories.length,
      pendingMemories: pendingMemories.length,
      preferenceMemories: preferenceMemories.length,
      corrections: corrections.length,
      correctionsResolved: correctionResolved,
      correctionsRejected: correctionRejected,
      correctionsPending: correctionPending
    },
    rates: {
      modeMisclassificationRate,
      correctionConvergenceRate,
      memoryHitRate,
      negativeFeedbackRate
    },
    learningDrafts: drafts,
    targets,
    checks: checks5
  };
}

// src/companion/memory-graph.ts
import * as fs24 from "node:fs";
import * as path26 from "node:path";
function memoryDir2(projectDir) {
  return path26.join(getMiyaRuntimeDir(projectDir), "memory");
}
function sqlitePath2(projectDir) {
  return path26.join(memoryDir2(projectDir), "memories.sqlite");
}
function openGraphDb(projectDir) {
  fs24.mkdirSync(memoryDir2(projectDir), { recursive: true });
  const db = openSqliteDatabase(sqlitePath2(projectDir));
  if (!db)
    return null;
  db.exec(`
    CREATE TABLE IF NOT EXISTS long_term_graph (
      memory_id TEXT PRIMARY KEY,
      subject TEXT NOT NULL,
      predicate TEXT NOT NULL,
      object TEXT NOT NULL,
      memory_kind TEXT NOT NULL,
      semantic_layer TEXT DEFAULT 'episodic',
      domain TEXT DEFAULT 'relationship',
      confidence REAL DEFAULT 0.5,
      source_message_id TEXT,
      updated_at TEXT NOT NULL
    );
  `);
  try {
    db.exec(`ALTER TABLE long_term_graph ADD COLUMN semantic_layer TEXT DEFAULT 'episodic'`);
  } catch {}
  try {
    db.exec(`ALTER TABLE long_term_graph ADD COLUMN domain TEXT DEFAULT 'relationship'`);
  } catch {}
  return db;
}
function tokenize3(query) {
  return query.toLowerCase().split(/[^\p{L}\p{N}]+/u).map((item) => item.trim()).filter(Boolean).slice(0, 12);
}
function overlapScore(tokens, text) {
  if (tokens.length === 0)
    return 0;
  const lower = text.toLowerCase();
  let matched = 0;
  for (const token of tokens) {
    if (lower.includes(token))
      matched += 1;
  }
  return matched / tokens.length;
}
function searchCompanionMemoryGraph(projectDir, query, limit = 8, options) {
  const text = String(query ?? "").trim();
  if (!text)
    return [];
  const safeLimit = Math.max(1, Math.min(50, Math.floor(limit)));
  const minConfidence = typeof options?.minConfidence === "number" ? Math.max(0, Math.min(1, options.minConfidence)) : 0;
  let db = null;
  try {
    db = openGraphDb(projectDir);
    if (!db)
      return [];
    const like = `%${text.replace(/[%_]/g, "")}%`;
    const layer = typeof options?.semanticLayer === "string" ? options.semanticLayer.trim() : "";
    const domain3 = typeof options?.domain === "string" ? options.domain.trim() : "";
    const rows = db.query(`
          SELECT
            memory_id AS memoryID,
            subject,
            predicate,
            object,
            memory_kind AS memoryKind,
            semantic_layer AS semanticLayer,
            domain,
            confidence,
            source_message_id AS sourceMessageID,
            updated_at AS updatedAt
          FROM long_term_graph
          WHERE
            confidence >= ?1
            AND (?2 = '' OR semantic_layer = ?2)
            AND (?3 = '' OR domain = ?3)
            AND (
              subject LIKE ?4
              OR predicate LIKE ?4
              OR object LIKE ?4
            )
          ORDER BY confidence DESC, updated_at DESC
          LIMIT ?5
        `).all(minConfidence, layer, domain3, like, safeLimit * 4);
    const tokens = tokenize3(text);
    return rows.map((row) => {
      const confidence = Number(row.confidence ?? 0.5);
      const lexical = overlapScore(tokens, `${row.subject} ${row.predicate} ${row.object}`);
      const score = Number((0.55 * lexical + 0.45 * confidence).toFixed(4));
      return {
        ...row,
        semanticLayer: String(row.semanticLayer ?? "episodic"),
        domain: String(row.domain ?? "relationship"),
        confidence,
        score
      };
    }).sort((a, b) => b.score - a.score).slice(0, safeLimit);
  } finally {
    try {
      db?.close();
    } catch {}
  }
}
function listCompanionMemoryGraphNeighbors(projectDir, entity, limit = 12) {
  const text = String(entity ?? "").trim();
  if (!text)
    return [];
  const safeLimit = Math.max(1, Math.min(80, Math.floor(limit)));
  let db = null;
  try {
    db = openGraphDb(projectDir);
    if (!db)
      return [];
    const like = `%${text.replace(/[%_]/g, "")}%`;
    const rows = db.query(`
          SELECT
            memory_id AS memoryID,
            subject,
            predicate,
            object,
            memory_kind AS memoryKind,
            semantic_layer AS semanticLayer,
            domain,
            confidence,
            source_message_id AS sourceMessageID,
            updated_at AS updatedAt
          FROM long_term_graph
          WHERE subject LIKE ?1 OR object LIKE ?1
          ORDER BY confidence DESC, updated_at DESC
          LIMIT ?2
        `).all(like, safeLimit);
    return rows.map((row) => ({
      ...row,
      semanticLayer: String(row.semanticLayer ?? "episodic"),
      domain: String(row.domain ?? "relationship"),
      confidence: Number(row.confidence ?? 0.5),
      score: Number(row.confidence ?? 0.5)
    }));
  } finally {
    try {
      db?.close();
    } catch {}
  }
}
function getCompanionMemoryGraphStats(projectDir) {
  let db = null;
  try {
    db = openGraphDb(projectDir);
    if (!db) {
      return {
        sqlitePath: sqlitePath2(projectDir),
        edgeCount: 0,
        avgConfidence: 0,
        byLayer: {}
      };
    }
    const row = db.query(`
          SELECT
            COUNT(1) AS edgeCount,
            AVG(confidence) AS avgConfidence,
            MAX(updated_at) AS updatedAt
          FROM long_term_graph
        `).get();
    const layerRows = db.query(`
          SELECT semantic_layer AS layer, COUNT(1) AS c
          FROM long_term_graph
          GROUP BY semantic_layer
        `).all();
    const byLayer = {};
    for (const item of layerRows) {
      byLayer[String(item.layer ?? "unknown")] = Number(item.c ?? 0);
    }
    return {
      sqlitePath: sqlitePath2(projectDir),
      edgeCount: Number(row?.edgeCount ?? 0),
      avgConfidence: Number(Number(row?.avgConfidence ?? 0).toFixed(4)),
      byLayer,
      updatedAt: row?.updatedAt
    };
  } finally {
    try {
      db?.close();
    } catch {}
  }
}

// src/companion/memory-recall-benchmark.ts
import * as fs25 from "node:fs";
import * as os from "node:os";
import * as path27 from "node:path";
var __dirname = "G:\\pythonG\\py\\yun\\.opencode\\miya-src\\src\\companion";
var DEFAULT_DATASET_PATH = path27.join(__dirname, "benchmarks", "recall-default.json");
function normalizeDataset(raw) {
  return {
    name: typeof raw.name === "string" && raw.name.trim() ? raw.name.trim() : "memory-recall-default",
    fixtures: Array.isArray(raw.fixtures) ? raw.fixtures.map((item) => ({
      id: typeof item.id === "string" ? item.id.trim() || undefined : undefined,
      text: String(item.text ?? "").trim(),
      domain: item.domain === "work" || item.domain === "relationship" ? item.domain : undefined,
      semanticLayer: item.semanticLayer === "episodic" || item.semanticLayer === "semantic" || item.semanticLayer === "preference" || item.semanticLayer === "tool_trace" ? item.semanticLayer : undefined
    })).filter((item) => item.text.length > 0) : [],
    cases: Array.isArray(raw.cases) ? raw.cases.map((item, index) => ({
      id: typeof item.id === "string" && item.id.trim() ? item.id.trim() : `case_${index + 1}`,
      query: String(item.query ?? "").trim(),
      expected: Array.isArray(item.expected) ? item.expected.map((entry2) => String(entry2).trim()).filter(Boolean) : [],
      domain: item.domain === "work" || item.domain === "relationship" ? item.domain : undefined,
      semanticLayers: Array.isArray(item.semanticLayers) ? item.semanticLayers.filter((entry2) => entry2 === "episodic" || entry2 === "semantic" || entry2 === "preference" || entry2 === "tool_trace") : undefined,
      k: typeof item.k === "number" && Number.isFinite(item.k) ? Math.max(1, Math.min(20, Math.floor(item.k))) : undefined
    })).filter((item) => item.query.length > 0 && item.expected.length > 0) : []
  };
}
function loadMemoryRecallDataset(datasetPath) {
  const file3 = datasetPath && datasetPath.trim() ? datasetPath : DEFAULT_DATASET_PATH;
  if (!fs25.existsSync(file3)) {
    throw new Error(`dataset_not_found:${file3}`);
  }
  const raw = JSON.parse(fs25.readFileSync(file3, "utf-8"));
  return normalizeDataset(raw);
}
function isCaseHit(expected, retrieved) {
  const expectedLower = expected.map((item) => item.toLowerCase());
  for (const row of retrieved) {
    const lower = row.toLowerCase();
    if (expectedLower.some((item) => lower.includes(item)))
      return true;
  }
  return false;
}
function runMemoryRecallBenchmark(input) {
  const dataset = input?.dataset ?? loadMemoryRecallDataset(input?.datasetPath);
  const workdir = fs25.mkdtempSync(path27.join(os.tmpdir(), "miya-memory-benchmark-"));
  const fixtureIDMap = new Map;
  for (const fixture of dataset.fixtures) {
    const created = upsertCompanionMemoryVector(workdir, {
      text: fixture.text,
      source: "benchmark",
      activate: true,
      domain: fixture.domain,
      semanticLayer: fixture.semanticLayer,
      learningStage: "persistent"
    });
    if (fixture.id)
      fixtureIDMap.set(fixture.id, created.id);
  }
  const ks = Array.isArray(input?.kValues) && input.kValues.length > 0 ? input.kValues.map((value) => Math.max(1, Math.min(20, Math.floor(value)))) : [1, 3, 5, 8];
  const perK = {};
  for (const k of ks)
    perK[k] = { hit: 0, total: 0 };
  const caseResults = [];
  for (const item of dataset.cases) {
    const expected = item.expected.map((entry2) => fixtureIDMap.get(entry2) ?? entry2);
    const maxK = Math.max(item.k ?? 0, ...ks);
    const hits = searchCompanionMemoryVectors(workdir, item.query, maxK, {
      threshold: 0,
      domain: item.domain,
      semanticLayers: item.semanticLayers
    });
    const retrievedRows = hits.map((row) => `${row.id} ${row.text}`);
    for (const k of ks) {
      const topk = retrievedRows.slice(0, k);
      perK[k].total += 1;
      if (isCaseHit(expected, topk))
        perK[k].hit += 1;
    }
    const caseK = item.k ?? 5;
    const retrievedCase = retrievedRows.slice(0, caseK);
    caseResults.push({
      id: item.id ?? `case_${caseResults.length + 1}`,
      query: item.query,
      k: caseK,
      expected,
      retrieved: retrievedCase,
      hit: isCaseHit(expected, retrievedCase)
    });
  }
  const recallAtK = {};
  for (const [k, score] of Object.entries(perK)) {
    recallAtK[`recall@${k}`] = score.total > 0 ? Number((score.hit / score.total).toFixed(4)) : 0;
  }
  return {
    dataset: dataset.name,
    cases: dataset.cases.length,
    recallAtK,
    caseResults
  };
}

// src/companion/memory-reflect.ts
import { createHash as createHash8, randomUUID as randomUUID11 } from "node:crypto";
import * as fs26 from "node:fs";
import * as path28 from "node:path";
function nowIso16() {
  return new Date().toISOString();
}
function memoryDir3(projectDir) {
  return path28.join(getMiyaRuntimeDir(projectDir), "memory");
}
function shortTermLogPath(projectDir) {
  return path28.join(memoryDir3(projectDir), "short-term-history.jsonl");
}
function archiveLogPath(projectDir) {
  return path28.join(memoryDir3(projectDir), "archived-history.jsonl");
}
function reflectJobPath(projectDir) {
  return path28.join(memoryDir3(projectDir), "reflect-jobs.jsonl");
}
function reflectStatePath(projectDir) {
  return path28.join(memoryDir3(projectDir), "reflect-state.json");
}
function ensureDir11(projectDir) {
  fs26.mkdirSync(memoryDir3(projectDir), { recursive: true });
}
function normalizeText4(input) {
  return input.trim().replace(/\s+/g, " ");
}
function hashMessage(input) {
  return createHash8("sha256").update(`${input.sender}
${input.at}
${normalizeText4(input.text)}`).digest("hex");
}
function parseJsonlRows(file3) {
  if (!fs26.existsSync(file3))
    return [];
  const rows = [];
  const raw = fs26.readFileSync(file3, "utf-8");
  for (const line of raw.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed)
      continue;
    try {
      rows.push(JSON.parse(trimmed));
    } catch {}
  }
  return rows;
}
function writeJsonlRows(file3, rows) {
  const body = rows.map((row) => JSON.stringify(row)).join(`
`);
  fs26.writeFileSync(file3, body ? `${body}
` : "", "utf-8");
}
function readReflectState(projectDir) {
  const file3 = reflectStatePath(projectDir);
  if (!fs26.existsSync(file3))
    return {};
  try {
    const parsed = JSON.parse(fs26.readFileSync(file3, "utf-8"));
    return parsed ?? {};
  } catch {
    return {};
  }
}
function writeReflectState(projectDir, patch) {
  ensureDir11(projectDir);
  const file3 = reflectStatePath(projectDir);
  const next = {
    ...readReflectState(projectDir),
    ...patch
  };
  fs26.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function extractTriplets(log) {
  if (log.sender === "system")
    return [];
  const text = normalizeText4(log.text);
  if (!text)
    return [];
  const triplets = [];
  const add = (kind, subject, predicate, object3, confidence, tier, semanticLayer) => {
    const value = normalizeText4(object3);
    if (!value)
      return;
    triplets.push({
      kind,
      subject,
      predicate,
      object: value,
      semanticLayer,
      confidence,
      tier,
      sourceLogID: log.id
    });
  };
  const likes = text.match(/(?:)?([^!?.]+)/);
  if (likes?.[1])
    add("UserPreference", "User", "likes", likes[1], 0.86, "L2", "preference");
  const dislikes = text.match(/(?:|)?([^!?.]+)/);
  if (dislikes?.[1])
    add("UserPreference", "User", "dislikes", dislikes[1], 0.86, "L2", "preference");
  const prefers = text.match(/(?:||)?(?:|||)\s*([^!?.]+)/);
  if (prefers?.[1])
    add("UserPreference", "User", "prefers", prefers[1], 0.9, "L2", "preference");
  const avoids = text.match(/(?:||)\s*([^!?.]+)/);
  if (avoids?.[1])
    add("UserPreference", "User", "avoids", avoids[1], 0.88, "L2", "preference");
  const needs = text.match(/(?:||)([^!?.]+)/);
  if (needs?.[1])
    add("Fact", "User", "requires", needs[1], 0.7, "L2", "episodic");
  const blocks = text.match(/(?:||)([^!?.]+)(?:|||)/);
  if (blocks?.[1])
    add("Insight", "User", "is_blocking", `${blocks[1]}`, 0.75, "L2", "semantic");
  const anxiety = text.match(/(?:||||)([^!?.]*)/);
  if (anxiety)
    add("Insight", "User", "emotion_signal", ` ${anxiety[0]}`.trim(), 0.72, "L3", "semantic");
  const project = text.match(/(?:||repo|)\s*[:]?\s*([^!?.]+)/i);
  if (project?.[1])
    add("Fact", "User", "project", project[1], 0.68, "L2", "semantic");
  const apiRef = text.match(/(?:API||doc|docs?)\s*[:]?\s*([^!?.]+)/i);
  if (apiRef?.[1])
    add("Fact", "User", "api_reference", apiRef[1], 0.64, "L3", "semantic");
  const toolTrace = text.match(/(?:||run|bash|shell||traceback|stack\\s*trace|stderr|stdout)([^!?.]{0,120})/i);
  if (toolTrace) {
    add("Fact", log.sender === "assistant" ? "Miya" : "User", "tool_trace", toolTrace[0], 0.78, "L2", "tool_trace");
  }
  if (triplets.length === 0 && text.length <= 120) {
    add("Fact", log.sender === "assistant" ? "Miya" : "User", "stated", text, 0.55, "L3", "episodic");
  }
  return triplets;
}
function tripletText(triplet) {
  return `${triplet.subject} ${triplet.predicate} ${triplet.object}`;
}
function appendShortTermMemoryLog(projectDir, input) {
  const text = normalizeText4(input.text);
  if (!text)
    return null;
  const at = input.at ?? nowIso16();
  const messageHash = input.messageID || hashMessage({ text, sender: input.sender, at });
  ensureDir11(projectDir);
  const file3 = shortTermLogPath(projectDir);
  const rows = parseJsonlRows(file3);
  if (rows.some((row2) => row2.messageHash === messageHash))
    return null;
  const row = {
    id: `st_${randomUUID11()}`,
    sessionID: input.sessionID?.trim() || "main",
    sender: input.sender,
    text,
    at,
    messageHash
  };
  rows.push(row);
  writeJsonlRows(file3, rows);
  writeReflectState(projectDir, { lastLogAt: at });
  return row;
}
function getMemoryReflectStatus(projectDir) {
  const rows = parseJsonlRows(shortTermLogPath(projectDir));
  const pendingLogs = rows.filter((row) => !row.processedAt).length;
  const state = readReflectState(projectDir);
  return {
    pendingLogs,
    lastLogAt: state.lastLogAt,
    lastReflectAt: state.lastReflectAt
  };
}
function reflectCompanionMemory(projectDir, input) {
  ensureDir11(projectDir);
  const state = readReflectState(projectDir);
  const now = nowIso16();
  if (input?.idempotencyKey && state.lastReflectIdempotencyKey === input.idempotencyKey) {
    if (state.lastReflectResult)
      return state.lastReflectResult;
  }
  const cooldownMinutes = Math.max(0, input?.cooldownMinutes ?? 0);
  if (cooldownMinutes > 0 && state.lastReflectAt) {
    const deltaMs = Date.now() - Date.parse(state.lastReflectAt);
    if (Number.isFinite(deltaMs) && deltaMs < cooldownMinutes * 60 * 1000) {
      const blocked = {
        jobID: `reflect_${randomUUID11()}`,
        processedLogs: 0,
        generatedTriplets: 0,
        generatedFacts: 0,
        generatedInsights: 0,
        generatedPreferences: 0,
        createdMemories: [],
        archivedLogs: 0
      };
      writeReflectState(projectDir, {
        lastReflectReason: `cooldown_blocked_${cooldownMinutes}m`
      });
      return blocked;
    }
  }
  const rows = parseJsonlRows(shortTermLogPath(projectDir));
  const pending = rows.filter((row) => !row.processedAt);
  const minLogs = Math.max(1, input?.minLogs ?? 1);
  if (!input?.force && pending.length < minLogs) {
    return {
      jobID: `reflect_${randomUUID11()}`,
      processedLogs: 0,
      generatedTriplets: 0,
      generatedFacts: 0,
      generatedInsights: 0,
      generatedPreferences: 0,
      createdMemories: [],
      archivedLogs: 0
    };
  }
  const maxLogs = Math.max(1, input?.maxLogs ?? 50);
  const picked = pending.slice(0, maxLogs);
  const triplets = picked.flatMap((row) => extractTriplets(row));
  const maxWritesCandidate = typeof input?.maxWrites === "number" ? input.maxWrites : triplets.length;
  const maxWrites = Math.max(1, maxWritesCandidate);
  const writableTriplets = triplets.slice(0, maxWrites);
  const generatedFacts = triplets.filter((item) => item.kind === "Fact").length;
  const generatedInsights = triplets.filter((item) => item.kind === "Insight").length;
  const generatedPreferences = triplets.filter((item) => item.kind === "UserPreference").length;
  const createdMemories = writableTriplets.map((triplet) => upsertCompanionMemoryVector(projectDir, {
    text: tripletText(triplet),
    source: "reflect",
    activate: false,
    confidence: triplet.confidence,
    tier: triplet.tier,
    sourceMessageID: triplet.sourceLogID,
    sourceType: "reflect",
    memoryKind: triplet.kind,
    semanticLayer: triplet.semanticLayer,
    learningStage: "candidate"
  }));
  if (input?.mergeConflicts !== false) {
    mergePendingMemoryConflicts(projectDir, {
      maxSupersede: Math.max(1, Math.min(80, Math.floor(maxWrites / 2) || 1))
    });
  }
  const processedAt = nowIso16();
  const pickedIdSet = new Set(picked.map((row) => row.id));
  const nextRows = rows.filter((row) => !pickedIdSet.has(row.id));
  writeJsonlRows(shortTermLogPath(projectDir), nextRows);
  const archived = parseJsonlRows(archiveLogPath(projectDir));
  const moved = picked.map((row) => ({ ...row, processedAt }));
  writeJsonlRows(archiveLogPath(projectDir), [...archived, ...moved]);
  const result = {
    jobID: `reflect_${randomUUID11()}`,
    processedLogs: picked.length,
    generatedTriplets: triplets.length,
    generatedFacts,
    generatedInsights,
    generatedPreferences,
    createdMemories,
    archivedLogs: moved.length
  };
  createSkillDraftsFromReflect(projectDir, {
    createdMemories
  });
  fs26.appendFileSync(reflectJobPath(projectDir), `${JSON.stringify({ ...result, at: processedAt })}
`, "utf-8");
  writeReflectState(projectDir, {
    lastReflectAt: now,
    lastReflectIdempotencyKey: input?.idempotencyKey,
    lastReflectResult: result,
    lastReflectReason: "ok"
  });
  return result;
}

// src/companion/memory-reflect-worker.ts
import { randomUUID as randomUUID12 } from "node:crypto";
import * as fs28 from "node:fs";
import * as path30 from "node:path";

// src/strategy/experiments.ts
import { createHash as createHash9 } from "node:crypto";
import * as fs27 from "node:fs";
import * as path29 from "node:path";
var DEFAULT_CONFIG3 = {
  routing: {
    enabled: false,
    rolloutPercent: 0
  },
  memory_write: {
    enabled: false,
    rolloutPercent: 0
  },
  approval_threshold: {
    enabled: false,
    rolloutPercent: 0
  }
};
function configFile(projectDir) {
  return path29.join(getMiyaRuntimeDir(projectDir), "strategy-experiments.json");
}
function observationFile(projectDir) {
  return path29.join(getMiyaRuntimeDir(projectDir), "strategy-observations.jsonl");
}
function clamp4(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function nowIso17() {
  return new Date().toISOString();
}
function normalizeRule(input, fallback) {
  const obj = input && typeof input === "object" ? input : {};
  return {
    enabled: obj.enabled === true,
    rolloutPercent: clamp4(Number(obj.rolloutPercent ?? fallback.rolloutPercent), 0, 100)
  };
}
function readConfig2(projectDir) {
  const file3 = configFile(projectDir);
  if (!fs27.existsSync(file3))
    return { ...DEFAULT_CONFIG3 };
  try {
    const parsed = JSON.parse(fs27.readFileSync(file3, "utf-8"));
    return {
      routing: normalizeRule(parsed.routing, DEFAULT_CONFIG3.routing),
      memory_write: normalizeRule(parsed.memory_write, DEFAULT_CONFIG3.memory_write),
      approval_threshold: normalizeRule(parsed.approval_threshold, DEFAULT_CONFIG3.approval_threshold)
    };
  } catch {
    return { ...DEFAULT_CONFIG3 };
  }
}
function readStrategyExperimentConfig(projectDir) {
  return readConfig2(projectDir);
}
function writeStrategyExperimentConfig(projectDir, patch) {
  const current = readConfig2(projectDir);
  const next = {
    routing: patch.routing !== undefined ? normalizeRule(patch.routing, current.routing) : current.routing,
    memory_write: patch.memory_write !== undefined ? normalizeRule(patch.memory_write, current.memory_write) : current.memory_write,
    approval_threshold: patch.approval_threshold !== undefined ? normalizeRule(patch.approval_threshold, current.approval_threshold) : current.approval_threshold
  };
  const file3 = configFile(projectDir);
  fs27.mkdirSync(path29.dirname(file3), { recursive: true });
  fs27.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function bucket(subjectID, experiment) {
  const digest = createHash9("sha256").update(`${subjectID}|${experiment}`).digest("hex").slice(0, 8);
  return Number.parseInt(digest, 16) % 100;
}
function resolveStrategyVariant(projectDir, experiment, subjectID) {
  const config3 = readConfig2(projectDir);
  const rule = config3[experiment];
  if (!rule.enabled || rule.rolloutPercent <= 0)
    return "disabled";
  return bucket(subjectID, experiment) < rule.rolloutPercent ? "treatment" : "control";
}
function recordStrategyObservation(projectDir, input) {
  const file3 = observationFile(projectDir);
  fs27.mkdirSync(path29.dirname(file3), { recursive: true });
  const row = {
    at: input.at ?? nowIso17(),
    experiment: input.experiment,
    variant: input.variant,
    subjectID: input.subjectID,
    success: input.success,
    costUsd: typeof input.costUsd === "number" && Number.isFinite(input.costUsd) ? Math.max(0, input.costUsd) : undefined,
    riskScore: typeof input.riskScore === "number" && Number.isFinite(input.riskScore) ? clamp4(input.riskScore, 0, 1) : undefined,
    latencyMs: typeof input.latencyMs === "number" && Number.isFinite(input.latencyMs) ? Math.max(0, Math.floor(input.latencyMs)) : undefined,
    metadata: input.metadata && typeof input.metadata === "object" ? input.metadata : undefined
  };
  fs27.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
  return row;
}
function readObservations(projectDir, limit = 2000) {
  const file3 = observationFile(projectDir);
  if (!fs27.existsSync(file3))
    return [];
  const rows = [];
  const lines = fs27.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean);
  for (const line of lines.slice(-Math.max(1, Math.min(20000, limit)))) {
    try {
      rows.push(JSON.parse(line));
    } catch {}
  }
  return rows;
}
function summarizeStrategyObservations(projectDir, limit = 2000) {
  const rows = readObservations(projectDir, limit);
  const base = {
    disabled: { total: 0, successRate: 0, avgCostUsd: 0, avgRisk: 0 },
    control: { total: 0, successRate: 0, avgCostUsd: 0, avgRisk: 0 },
    treatment: { total: 0, successRate: 0, avgCostUsd: 0, avgRisk: 0 }
  };
  const summary = {
    routing: { total: 0, byVariant: structuredClone(base) },
    memory_write: { total: 0, byVariant: structuredClone(base) },
    approval_threshold: { total: 0, byVariant: structuredClone(base) }
  };
  for (const row of rows) {
    const target = summary[row.experiment];
    target.total += 1;
    const bucket2 = target.byVariant[row.variant];
    bucket2.total += 1;
    bucket2.successRate += row.success ? 1 : 0;
    bucket2.avgCostUsd += Number(row.costUsd ?? 0);
    bucket2.avgRisk += Number(row.riskScore ?? 0);
  }
  for (const experiment of Object.keys(summary)) {
    for (const variant of [
      "disabled",
      "control",
      "treatment"
    ]) {
      const bucket2 = summary[experiment].byVariant[variant];
      if (bucket2.total === 0)
        continue;
      bucket2.successRate = Number((bucket2.successRate / bucket2.total).toFixed(4));
      bucket2.avgCostUsd = Number((bucket2.avgCostUsd / bucket2.total).toFixed(6));
      bucket2.avgRisk = Number((bucket2.avgRisk / bucket2.total).toFixed(4));
    }
  }
  return summary;
}
function replayStrategyOffline(projectDir, input) {
  const limit = Math.max(1, Math.min(20000, Math.floor(input?.limit ?? 5000)));
  return {
    config: readConfig2(projectDir),
    summary: summarizeStrategyObservations(projectDir, limit)
  };
}
// src/companion/memory-reflect-worker.ts
function nowIso18() {
  return new Date().toISOString();
}
function queueFile(projectDir) {
  return path30.join(getMiyaRuntimeDir(projectDir), "memory", "reflect-queue.json");
}
function readStore7(projectDir) {
  const file3 = queueFile(projectDir);
  if (!fs28.existsSync(file3))
    return { version: 1, jobs: [] };
  try {
    const parsed = JSON.parse(fs28.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      jobs: Array.isArray(parsed.jobs) ? parsed.jobs : []
    };
  } catch {
    return { version: 1, jobs: [] };
  }
}
function writeStore5(projectDir, store) {
  const file3 = queueFile(projectDir);
  fs28.mkdirSync(path30.dirname(file3), { recursive: true });
  const next = {
    version: 1,
    jobs: store.jobs.slice(0, 200)
  };
  fs28.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function enqueueReflectWorkerJob(projectDir, request) {
  const store = readStore7(projectDir);
  const duplicate = store.jobs.find((job2) => job2.status === "queued" && job2.request.reason === request.reason);
  if (duplicate)
    return duplicate;
  const now = nowIso18();
  const job = {
    id: `mrw_${randomUUID12()}`,
    status: "queued",
    request: {
      reason: request.reason,
      force: request.force === true,
      minLogs: typeof request.minLogs === "number" && request.minLogs > 0 ? Number(request.minLogs) : undefined,
      maxLogs: typeof request.maxLogs === "number" && request.maxLogs > 0 ? Number(request.maxLogs) : undefined,
      maxWrites: typeof request.maxWrites === "number" && request.maxWrites > 0 ? Number(request.maxWrites) : undefined,
      cooldownMinutes: typeof request.cooldownMinutes === "number" && request.cooldownMinutes >= 0 ? Number(request.cooldownMinutes) : undefined
    },
    createdAt: now,
    updatedAt: now
  };
  store.jobs = [job, ...store.jobs].slice(0, 200);
  writeStore5(projectDir, store);
  return job;
}
function listReflectWorkerJobs(projectDir, limit = 30) {
  const store = readStore7(projectDir);
  return store.jobs.slice(0, Math.max(1, Math.min(200, limit)));
}
function scheduleAutoReflectJob(projectDir, input) {
  const idleMinutes = Math.max(1, input?.idleMinutes ?? 5);
  const minPendingLogs = Math.max(1, input?.minPendingLogs ?? 1);
  const cooldownMinutes = Math.max(1, input?.cooldownMinutes ?? 3);
  const status = getMemoryReflectStatus(projectDir);
  if (status.pendingLogs < minPendingLogs)
    return null;
  if (!status.lastLogAt)
    return null;
  const nowMs = Date.now();
  const idleMs = nowMs - Date.parse(status.lastLogAt);
  if (!Number.isFinite(idleMs) || idleMs < idleMinutes * 60 * 1000)
    return null;
  if (status.lastReflectAt) {
    const cooldownMs = nowMs - Date.parse(status.lastReflectAt);
    if (Number.isFinite(cooldownMs) && cooldownMs < cooldownMinutes * 60 * 1000)
      return null;
  }
  return enqueueReflectWorkerJob(projectDir, {
    reason: "auto_idle",
    force: true,
    minLogs: minPendingLogs,
    maxLogs: input?.maxLogs ?? 120,
    maxWrites: input?.maxWrites ?? 40,
    cooldownMinutes
  });
}
function runReflectWorkerTick(projectDir, input) {
  const maxJobs = Math.max(1, Math.min(5, Math.floor(input?.maxJobs ?? 1)));
  const writeBudget = Math.max(1, Math.min(200, Math.floor(input?.writeBudget ?? 40)));
  const mergeBudget = Math.max(1, Math.min(200, Math.floor(input?.mergeBudget ?? 40)));
  const store = readStore7(projectDir);
  const jobs = store.jobs;
  const toRun = jobs.filter((job) => job.status === "queued").slice(0, maxJobs);
  let completed = 0;
  let failed = 0;
  for (const job of toRun) {
    job.status = "running";
    job.startedAt = nowIso18();
    job.updatedAt = job.startedAt;
    writeStore5(projectDir, store);
    try {
      const result = reflectCompanionMemory(projectDir, {
        force: job.request.force,
        minLogs: job.request.minLogs,
        maxLogs: job.request.maxLogs,
        maxWrites: Math.min(writeBudget, job.request.maxWrites ?? writeBudget),
        cooldownMinutes: job.request.cooldownMinutes,
        idempotencyKey: job.id,
        mergeConflicts: true
      });
      const merged = mergePendingMemoryConflicts(projectDir, {
        maxSupersede: mergeBudget
      });
      job.status = "completed";
      job.finishedAt = nowIso18();
      job.updatedAt = job.finishedAt;
      job.mergedConflicts = merged.merged;
      job.result = {
        jobID: result.jobID,
        processedLogs: result.processedLogs,
        generatedTriplets: result.generatedTriplets,
        generatedFacts: result.generatedFacts,
        generatedInsights: result.generatedInsights,
        generatedPreferences: result.generatedPreferences,
        archivedLogs: result.archivedLogs
      };
      recordStrategyObservation(projectDir, {
        experiment: "memory_write",
        variant: resolveStrategyVariant(projectDir, "memory_write", job.id),
        subjectID: job.id,
        success: result.processedLogs > 0 || result.generatedTriplets > 0,
        riskScore: merged.merged > 0 ? 0.25 : 0.1,
        metadata: {
          reason: job.request.reason,
          processedLogs: result.processedLogs,
          generatedTriplets: result.generatedTriplets,
          mergedConflicts: merged.merged
        }
      });
      completed += 1;
    } catch (error92) {
      job.status = "failed";
      job.finishedAt = nowIso18();
      job.updatedAt = job.finishedAt;
      job.error = error92 instanceof Error ? error92.message : String(error92);
      recordStrategyObservation(projectDir, {
        experiment: "memory_write",
        variant: resolveStrategyVariant(projectDir, "memory_write", job.id),
        subjectID: job.id,
        success: false,
        riskScore: 0.8,
        metadata: {
          reason: job.request.reason,
          error: job.error
        }
      });
      failed += 1;
    }
    writeStore5(projectDir, store);
  }
  return {
    processed: toRun.length,
    completed,
    failed,
    jobs: toRun
  };
}

// src/companion/persona-world.ts
import { randomUUID as randomUUID13 } from "node:crypto";
import * as fs29 from "node:fs";
import * as path31 from "node:path";
function nowIso19() {
  return new Date().toISOString();
}
function filePath5(projectDir) {
  return path31.join(getMiyaRuntimeDir(projectDir), "companion-persona-world.json");
}
function defaultStore3() {
  const now = nowIso19();
  return {
    version: 1,
    personas: [
      {
        id: "persona_default",
        name: "Default Companion",
        persona: "calm, supportive, and proactive",
        style: "warm and concise",
        relationship: "companion",
        risk: "low",
        createdAt: now,
        updatedAt: now
      }
    ],
    worlds: [
      {
        id: "world_default",
        name: "Default Workspace",
        summary: "Generic software delivery context with safety-first collaboration.",
        rules: ["No irreversible action without explicit approval."],
        tags: ["software", "productivity"],
        risk: "low",
        createdAt: now,
        updatedAt: now
      }
    ],
    bindings: {}
  };
}
function readStore8(projectDir) {
  const file3 = filePath5(projectDir);
  if (!fs29.existsSync(file3))
    return defaultStore3();
  try {
    const parsed = JSON.parse(fs29.readFileSync(file3, "utf-8"));
    const base = defaultStore3();
    return {
      version: 1,
      personas: Array.isArray(parsed.personas) ? parsed.personas : base.personas,
      worlds: Array.isArray(parsed.worlds) ? parsed.worlds : base.worlds,
      bindings: parsed.bindings && typeof parsed.bindings === "object" ? parsed.bindings : {}
    };
  } catch {
    return defaultStore3();
  }
}
function writeStore6(projectDir, store) {
  const file3 = filePath5(projectDir);
  fs29.mkdirSync(path31.dirname(file3), { recursive: true });
  fs29.writeFileSync(file3, `${JSON.stringify(store, null, 2)}
`, "utf-8");
  return store;
}
function normalizeRisk(risk) {
  if (risk === "high" || risk === "medium" || risk === "low")
    return risk;
  return "low";
}
function listPersonaPresets(projectDir) {
  return readStore8(projectDir).personas;
}
function listWorldPresets(projectDir) {
  return readStore8(projectDir).worlds;
}
function upsertPersonaPreset(projectDir, input) {
  const store = readStore8(projectDir);
  const now = nowIso19();
  const id = input.id?.trim() || `persona_${randomUUID13()}`;
  const current = store.personas.find((item) => item.id === id);
  const next = {
    id,
    name: input.name.trim(),
    persona: input.persona.trim(),
    style: input.style.trim(),
    relationship: input.relationship.trim(),
    risk: normalizeRisk(input.risk),
    createdAt: current?.createdAt ?? now,
    updatedAt: now
  };
  store.personas = [
    next,
    ...store.personas.filter((item) => item.id !== id)
  ].slice(0, 120);
  writeStore6(projectDir, store);
  return next;
}
function upsertWorldPreset(projectDir, input) {
  const store = readStore8(projectDir);
  const now = nowIso19();
  const id = input.id?.trim() || `world_${randomUUID13()}`;
  const current = store.worlds.find((item) => item.id === id);
  const next = {
    id,
    name: input.name.trim(),
    summary: input.summary.trim(),
    rules: Array.isArray(input.rules) ? input.rules.map((item) => String(item).trim()).filter(Boolean) : [],
    tags: Array.isArray(input.tags) ? input.tags.map((item) => String(item).trim()).filter(Boolean) : [],
    risk: normalizeRisk(input.risk),
    createdAt: current?.createdAt ?? now,
    updatedAt: now
  };
  store.worlds = [next, ...store.worlds.filter((item) => item.id !== id)].slice(0, 120);
  writeStore6(projectDir, store);
  return next;
}
function bindSessionPersonaWorld(projectDir, input) {
  const store = readStore8(projectDir);
  const sessionID = input.sessionID.trim() || "main";
  const binding = {
    sessionID,
    personaPresetID: input.personaPresetID?.trim() || undefined,
    worldPresetID: input.worldPresetID?.trim() || undefined,
    updatedAt: nowIso19()
  };
  store.bindings[sessionID] = binding;
  writeStore6(projectDir, store);
  return binding;
}
function resolveSessionPersonaWorld(projectDir, sessionID) {
  const store = readStore8(projectDir);
  const binding = store.bindings[sessionID] ?? {
    sessionID,
    personaPresetID: "persona_default",
    worldPresetID: "world_default",
    updatedAt: nowIso19()
  };
  const persona = store.personas.find((item) => item.id === binding.personaPresetID);
  const world = store.worlds.find((item) => item.id === binding.worldPresetID);
  const risk = persona?.risk === "high" || world?.risk === "high" ? "high" : persona?.risk === "medium" || world?.risk === "medium" ? "medium" : "low";
  return {
    binding,
    persona,
    world,
    risk
  };
}
function buildPersonaWorldPrompt(projectDir, sessionID) {
  const resolved = resolveSessionPersonaWorld(projectDir, sessionID);
  const blocks = [];
  if (resolved.persona) {
    blocks.push([
      `[MIYA_PERSONA id=${resolved.persona.id} risk=${resolved.persona.risk}]`,
      `name=${resolved.persona.name}`,
      `persona=${resolved.persona.persona}`,
      `style=${resolved.persona.style}`,
      `relationship=${resolved.persona.relationship}`
    ].join(`
`));
  }
  if (resolved.world) {
    blocks.push([
      `[MIYA_WORLD id=${resolved.world.id} risk=${resolved.world.risk}]`,
      `name=${resolved.world.name}`,
      `summary=${resolved.world.summary}`,
      resolved.world.rules.length > 0 ? `rules:
${resolved.world.rules.map((item) => `- ${item}`).join(`
`)}` : ""
    ].filter(Boolean).join(`
`));
  }
  blocks.push(`[MIYA_PERSONA_WORLD_RISK] ${resolved.risk}`);
  return blocks.join(`

`);
}

// src/companion/store.ts
import { randomUUID as randomUUID14 } from "node:crypto";
import * as fs30 from "node:fs";
import * as path32 from "node:path";
function nowIso20() {
  return new Date().toISOString();
}
function filePath6(projectDir) {
  return path32.join(getMiyaRuntimeDir(projectDir), "companion.json");
}
function ensureDir12(file3) {
  fs30.mkdirSync(path32.dirname(file3), { recursive: true });
}
function defaultProfile() {
  return {
    enabled: false,
    onboardingCompleted: false,
    name: "Miya",
    persona: "calm, supportive, and proactive",
    relationship: "companion",
    style: "warm and concise",
    memoryFacts: [],
    assets: [],
    updatedAt: nowIso20()
  };
}
function readCompanionProfile(projectDir) {
  const file3 = filePath6(projectDir);
  if (!fs30.existsSync(file3))
    return defaultProfile();
  try {
    const parsed = JSON.parse(fs30.readFileSync(file3, "utf-8"));
    return {
      ...defaultProfile(),
      ...parsed,
      memoryFacts: Array.isArray(parsed.memoryFacts) ? parsed.memoryFacts : [],
      assets: Array.isArray(parsed.assets) ? parsed.assets : [],
      updatedAt: parsed.updatedAt ?? nowIso20()
    };
  } catch {
    return defaultProfile();
  }
}
function writeCompanionProfile(projectDir, profile) {
  const file3 = filePath6(projectDir);
  ensureDir12(file3);
  const next = {
    ...profile,
    updatedAt: nowIso20()
  };
  fs30.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function patchCompanionProfile(projectDir, patch) {
  const current = readCompanionProfile(projectDir);
  return writeCompanionProfile(projectDir, {
    ...current,
    ...patch
  });
}
function addCompanionAsset(projectDir, input) {
  const current = readCompanionProfile(projectDir);
  const asset = {
    id: `asset_${randomUUID14()}`,
    type: input.type,
    pathOrUrl: input.pathOrUrl,
    label: input.label,
    createdAt: nowIso20()
  };
  return writeCompanionProfile(projectDir, {
    ...current,
    assets: [asset, ...current.assets].slice(0, 200)
  });
}
function resetCompanionProfile(projectDir) {
  return writeCompanionProfile(projectDir, defaultProfile());
}
function syncCompanionProfileMemoryFacts(projectDir) {
  const current = readCompanionProfile(projectDir);
  const memoryFacts = listCompanionMemoryVectors(projectDir, "relationship").filter((item) => item.status === "active").map((item) => item.text).slice(0, 300);
  return writeCompanionProfile(projectDir, {
    ...current,
    memoryFacts
  });
}

// src/companion/wizard.ts
import { createHash as createHash10, randomUUID as randomUUID15 } from "node:crypto";
import * as fs31 from "node:fs";
import * as path33 from "node:path";
function nowIso21() {
  return new Date().toISOString();
}
function normalizeSessionId(sessionId) {
  const normalized = sessionId.trim().replace(/[^a-zA-Z0-9_-]+/g, "_");
  return normalized || "main";
}
function profilesRoot(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "profiles", "companion");
}
function sessionRoot(projectDir, sessionId) {
  return path33.join(profilesRoot(projectDir), "sessions", normalizeSessionId(sessionId));
}
function currentProfileDir(projectDir, sessionId) {
  return path33.join(sessionRoot(projectDir, sessionId), "current");
}
function wizardFilePath(projectDir, sessionId) {
  return path33.join(currentProfileDir(projectDir, sessionId), "wizard-state.json");
}
function metadataPath(projectDir, sessionId) {
  return path33.join(currentProfileDir(projectDir, sessionId), "metadata.json");
}
function ensureProfileLayout(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  fs31.mkdirSync(path33.join(current, "photos"), { recursive: true });
  fs31.mkdirSync(path33.join(current, "embeddings"), { recursive: true });
  fs31.mkdirSync(path33.join(current, "lora"), { recursive: true });
  fs31.mkdirSync(path33.join(current, "voice"), { recursive: true });
  fs31.mkdirSync(path33.join(sessionRoot(projectDir, sessionId), "history"), {
    recursive: true
  });
}
function safeReadJson2(filePath7) {
  if (!fs31.existsSync(filePath7))
    return null;
  try {
    return JSON.parse(fs31.readFileSync(filePath7, "utf-8"));
  } catch {
    return null;
  }
}
function safeWriteJson2(filePath7, value) {
  fs31.mkdirSync(path33.dirname(filePath7), { recursive: true });
  fs31.writeFileSync(filePath7, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function checksumFile(filePath7) {
  try {
    const data = fs31.readFileSync(filePath7);
    return `sha256:${createHash10("sha256").update(data).digest("hex")}`;
  } catch {
    return "sha256:unknown";
  }
}
function extensionForMime(mimeType, fallback = ".bin") {
  if (mimeType.includes("png"))
    return ".png";
  if (mimeType.includes("jpeg") || mimeType.includes("jpg"))
    return ".jpg";
  if (mimeType.includes("webp"))
    return ".webp";
  if (mimeType.includes("wav"))
    return ".wav";
  if (mimeType.includes("mpeg") || mimeType.includes("mp3"))
    return ".mp3";
  if (mimeType.includes("ogg"))
    return ".ogg";
  return fallback;
}
function defaultMetadata(sessionId) {
  const now = nowIso21();
  return {
    profileId: `companion-${now.replace(/[:.]/g, "-")}`,
    createdAt: now,
    updatedAt: now,
    version: "v1",
    assets: {
      photos: {
        count: 0,
        paths: [],
        checksums: []
      },
      voice: {
        hasSample: false,
        duration: 0,
        modelType: "gpt_sovits_v2"
      },
      persona: {
        sourceText: "",
        generatedPrompt: ""
      }
    },
    trainingStatus: {
      image: "pending",
      voice: "pending"
    },
    sessionBinding: {
      opencodeSessionId: sessionId,
      daemonSessionId: `daemon-${sessionId}`
    }
  };
}
function defaultState3(sessionId) {
  const now = nowIso21();
  return {
    sessionId: `wizard:companion:${normalizeSessionId(sessionId)}`,
    boundSessionId: sessionId || "main",
    state: "idle",
    startedAt: now,
    updatedAt: now,
    assets: {
      photos: [],
      voiceSample: "",
      personalityText: ""
    },
    trainingJobs: {},
    jobs: []
  };
}
function writeMetadata(projectDir, sessionId, metadata) {
  const next = { ...metadata, updatedAt: nowIso21() };
  safeWriteJson2(metadataPath(projectDir, sessionId), next);
  return next;
}
function readMetadata(projectDir, sessionId) {
  ensureProfileLayout(projectDir, sessionId);
  const existing = safeReadJson2(metadataPath(projectDir, sessionId));
  if (existing)
    return existing;
  const created = defaultMetadata(sessionId);
  writeMetadata(projectDir, sessionId, created);
  return created;
}
function writeState2(projectDir, sessionId, state) {
  ensureProfileLayout(projectDir, sessionId);
  const next = { ...state, updatedAt: nowIso21() };
  safeWriteJson2(wizardFilePath(projectDir, sessionId), next);
  return next;
}
function moveCurrentToHistory(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  if (!fs31.existsSync(current))
    return;
  const historyDir = path33.join(sessionRoot(projectDir, sessionId), "history", new Date().toISOString().replace(/[:.]/g, "-"));
  fs31.mkdirSync(path33.dirname(historyDir), { recursive: true });
  fs31.cpSync(current, historyDir, { recursive: true });
  fs31.rmSync(current, { recursive: true, force: true });
}
function listSessionDirs(projectDir) {
  const root = path33.join(profilesRoot(projectDir), "sessions");
  if (!fs31.existsSync(root))
    return [];
  try {
    return fs31.readdirSync(root, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => entry2.name);
  } catch {
    return [];
  }
}
function sessionHasWizardFile(projectDir, sessionDirName) {
  const file3 = path33.join(profilesRoot(projectDir), "sessions", sessionDirName, "current", "wizard-state.json");
  return fs31.existsSync(file3);
}
function stateHasAssets(state) {
  return state.assets.photos.length > 0 || Boolean(state.assets.voiceSample) || Boolean(state.assets.personalityText);
}
function findSessionByJobId(projectDir, jobID) {
  for (const sid of listCompanionWizardSessions(projectDir)) {
    const state = readCompanionWizardState(projectDir, sid);
    if (state.jobs.some((job) => job.id === jobID))
      return sid;
  }
  return null;
}
function resolveSessionForWrite(projectDir, requestedSessionId) {
  if (requestedSessionId && requestedSessionId.trim()) {
    return normalizeSessionId(requestedSessionId);
  }
  const sessions = listCompanionWizardSessions(projectDir);
  if (sessions.length === 0)
    return "main";
  const active = sessions.filter((sid) => {
    const state = readCompanionWizardState(projectDir, sid);
    return state.state !== "idle" || stateHasAssets(state) || state.jobs.length > 0;
  });
  if (active.length === 1)
    return active[0];
  if (active.includes("main"))
    return "main";
  return active[0] ?? sessions[0] ?? "main";
}
function listCompanionWizardSessions(projectDir) {
  return listSessionDirs(projectDir).filter((name) => sessionHasWizardFile(projectDir, name)).map((name) => name || "main");
}
function readCompanionWizardState(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  const existing = safeReadJson2(wizardFilePath(projectDir, effectiveSessionId));
  if (existing)
    return existing;
  const created = defaultState3(effectiveSessionId);
  return writeState2(projectDir, effectiveSessionId, created);
}
function isCompanionWizardEmpty(projectDir, sessionId = "main") {
  const state = readCompanionWizardState(projectDir, sessionId);
  if (stateHasAssets(state))
    return false;
  if (state.jobs.length > 0)
    return false;
  return state.state === "idle";
}
function startCompanionWizard(projectDir, input) {
  const sessionId = normalizeSessionId(input?.sessionId ?? "main");
  ensureProfileLayout(projectDir, sessionId);
  if (input?.forceReset) {
    moveCurrentToHistory(projectDir, sessionId);
    ensureProfileLayout(projectDir, sessionId);
  }
  const existing = readCompanionWizardState(projectDir, sessionId);
  if (!input?.forceReset && (stateHasAssets(existing) || existing.state !== "idle")) {
    return existing;
  }
  const state = writeState2(projectDir, sessionId, {
    ...defaultState3(sessionId),
    state: "awaiting_photos",
    startedAt: nowIso21()
  });
  writeMetadata(projectDir, sessionId, defaultMetadata(sessionId));
  return state;
}
function resetCompanionWizard(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  moveCurrentToHistory(projectDir, effectiveSessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  writeMetadata(projectDir, effectiveSessionId, defaultMetadata(effectiveSessionId));
  return writeState2(projectDir, effectiveSessionId, {
    ...defaultState3(effectiveSessionId),
    state: "idle"
  });
}
function copyMediaToProfile(projectDir, mediaIDs, targetDir) {
  const output = [];
  fs31.mkdirSync(targetDir, { recursive: true });
  for (const mediaID of mediaIDs) {
    const item = getMediaItem(projectDir, mediaID);
    if (!item?.localPath || !fs31.existsSync(item.localPath)) {
      throw new Error(`media_asset_not_found:${mediaID}`);
    }
    const ext = path33.extname(item.fileName) || extensionForMime(item.mimeType);
    const fileName = `${String(output.length + 1).padStart(2, "0")}_original${ext}`;
    const filePath7 = path33.join(targetDir, fileName);
    fs31.copyFileSync(item.localPath, filePath7);
    output.push(filePath7);
  }
  return output;
}
function enqueueJob(state, input) {
  const job = {
    id: `wjob_${randomUUID15()}`,
    type: input.type,
    status: "queued",
    progress: 0,
    estimatedTime: input.estimatedTime,
    fallbackStrategy: input.fallbackStrategy,
    createdAt: nowIso21(),
    updatedAt: nowIso21(),
    attempts: 0
  };
  return {
    ...state,
    jobs: [...state.jobs, job],
    trainingJobs: {
      ...state.trainingJobs,
      imageJobId: input.type === "training.image" ? job.id : state.trainingJobs.imageJobId,
      voiceJobId: input.type === "training.voice" ? job.id : state.trainingJobs.voiceJobId
    }
  };
}
function submitWizardPhotos(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_photos") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  if (input.mediaIDs.length < 1 || input.mediaIDs.length > 5) {
    throw new Error("wizard_photo_count_invalid:must_be_1_to_5");
  }
  const photosDir = path33.join(currentProfileDir(projectDir, sessionId), "photos");
  fs31.rmSync(photosDir, { recursive: true, force: true });
  const copied = copyMediaToProfile(projectDir, input.mediaIDs, photosDir);
  if (copied.length < 1 || copied.length > 5 || copied.length !== input.mediaIDs.length) {
    throw new Error("wizard_photo_copy_invalid:must_be_1_to_5");
  }
  const withJob = enqueueJob({
    ...current,
    state: "training_image",
    assets: {
      ...current.assets,
      photos: copied
    }
  }, {
    type: "training.image",
    estimatedTime: "5-10",
    fallbackStrategy: "embedding"
  });
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      photos: {
        count: copied.length,
        paths: copied.map((item) => path33.relative(currentProfileDir(projectDir, sessionId), item)),
        checksums: copied.map((item) => checksumFile(item))
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      image: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.imageJobId);
  if (!job)
    throw new Error("image_job_not_created");
  return { state: written, job };
}
function submitWizardVoice(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_voice") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const voiceDir = path33.join(currentProfileDir(projectDir, sessionId), "voice");
  fs31.mkdirSync(voiceDir, { recursive: true });
  const copied = copyMediaToProfile(projectDir, [input.mediaID], voiceDir);
  if (copied.length !== 1)
    throw new Error("voice_asset_not_found");
  const voicePath = path33.join(voiceDir, "original_sample.wav");
  fs31.copyFileSync(copied[0], voicePath);
  const withJob = enqueueJob({
    ...current,
    state: "training_voice",
    assets: {
      ...current.assets,
      voiceSample: voicePath
    }
  }, {
    type: "training.voice",
    estimatedTime: "3-8",
    fallbackStrategy: "embedding"
  });
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      voice: {
        hasSample: true,
        duration: 0,
        modelType: "gpt_sovits_v2"
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      voice: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.voiceJobId);
  if (!job)
    throw new Error("voice_job_not_created");
  return { state: written, job };
}
function submitWizardPersonality(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_personality") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const text = input.personalityText.trim();
  if (!text)
    throw new Error("invalid_personality_text");
  const personaPath = path33.join(currentProfileDir(projectDir, sessionId), "persona.json");
  const persona = {
    sourceText: text,
    generatedPrompt: `system: ${text}`,
    updatedAt: nowIso21()
  };
  safeWriteJson2(personaPath, persona);
  const next = writeState2(projectDir, sessionId, {
    ...current,
    state: "completed",
    assets: {
      ...current.assets,
      personalityText: text
    }
  });
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      persona: {
        sourceText: text,
        generatedPrompt: persona.generatedPrompt
      }
    }
  });
  return next;
}
function pickQueuedTrainingJob(projectDir, sessionId) {
  const targetSessions = sessionId ? [normalizeSessionId(sessionId)] : listCompanionWizardSessions(projectDir);
  for (const sid of targetSessions) {
    const state = readCompanionWizardState(projectDir, sid);
    if (state.jobs.some((item) => item.status === "training"))
      continue;
    const queued = state.jobs.find((item) => item.status === "queued");
    if (queued)
      return { sessionId: sid, job: queued };
  }
  return null;
}
function markTrainingJobRunning(projectDir, jobID, sessionId = "main") {
  const sid = normalizeSessionId(sessionId);
  const resolvedSession = sessionId === "main" ? findSessionByJobId(projectDir, jobID) ?? sid : sid;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    jobs: current.jobs.map((job2) => job2.id === jobID ? {
      ...job2,
      status: "training",
      progress: Math.max(5, job2.progress),
      attempts: job2.attempts + 1,
      updatedAt: nowIso21()
    } : job2)
  });
  const job = updated.jobs.find((item) => item.id === jobID);
  if (!job)
    return updated;
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, image: "training" }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, voice: "training" }
    });
  }
  return updated;
}
function requeueTrainingJob(projectDir, input) {
  const sid = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sid);
  return writeState2(projectDir, sid, {
    ...current,
    jobs: current.jobs.map((job) => job.id === input.jobID ? {
      ...job,
      status: "queued",
      progress: Math.max(10, job.progress),
      checkpointPath: input.checkpointPath,
      message: input.message,
      updatedAt: nowIso21()
    } : job)
  });
}
function markTrainingJobFinished(projectDir, input) {
  const sid = normalizeSessionId(input.sessionId ?? "main");
  const resolvedSession = input.sessionId == null ? findSessionByJobId(projectDir, input.jobID) ?? sid : sid;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const job = current.jobs.find((item) => item.id === input.jobID);
  if (!job)
    return current;
  const nextState = job.type === "training.image" ? input.status === "failed" || input.status === "canceled" ? "training_image" : "awaiting_voice" : input.status === "failed" || input.status === "canceled" ? "training_voice" : "awaiting_personality";
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    state: nextState,
    jobs: current.jobs.map((item) => item.id === input.jobID ? {
      ...item,
      status: input.status,
      message: input.message,
      progress: input.status === "failed" ? item.progress : 100,
      currentTier: input.tier,
      checkpointPath: input.checkpointPath ?? item.checkpointPath,
      updatedAt: nowIso21()
    } : item)
  });
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        image: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        voice: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  }
  return updated;
}
function cancelCompanionWizardTraining(projectDir, sessionId = "main") {
  const sid = resolveSessionForWrite(projectDir, sessionId);
  const current = readCompanionWizardState(projectDir, sid);
  let hasCanceled = false;
  const nextJobs = current.jobs.map((job) => {
    if (job.status !== "queued" && job.status !== "training")
      return job;
    hasCanceled = true;
    return {
      ...job,
      status: "canceled",
      message: "/",
      updatedAt: nowIso21()
    };
  });
  if (!hasCanceled)
    return current;
  const nextState = current.assets.voiceSample ? "awaiting_personality" : current.assets.photos.length > 0 ? "awaiting_voice" : "awaiting_photos";
  return writeState2(projectDir, sid, {
    ...current,
    state: nextState,
    jobs: nextJobs
  });
}
function getCompanionProfileCurrentDir(projectDir, sessionId = "main") {
  const sid = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, sid);
  return currentProfileDir(projectDir, sid);
}
function getWizardJobById(projectDir, jobID) {
  for (const sid of listCompanionWizardSessions(projectDir)) {
    const state = readCompanionWizardState(projectDir, sid);
    const match = state.jobs.find((job) => job.id === jobID);
    if (match)
      return { ...match, sessionId: sid };
  }
  return null;
}
function wizardChecklist(state) {
  return [
    state.assets.photos.length > 0 ? "visual:done" : "visual:pending",
    state.assets.voiceSample ? "voice:done" : "voice:pending",
    state.assets.personalityText ? "persona:done" : "persona:pending"
  ];
}
// src/compat/ecosystem-bridge-registry.ts
var AUDIT_FIELDS = [
  "source",
  "version",
  "policyHash",
  "capabilityID",
  "timestamp",
  "operator",
  "result"
];
var DEFAULT_ROLLBACK = {
  strategy: "disable_entry",
  steps: [
    "disable ecosystem entry in registry",
    "re-run smoke regression suite",
    "restore previous pinned version"
  ]
};
var ECOSYSTEM_BRIDGE_ENTRIES = [
  {
    id: "opensouls",
    name: "OpenSouls",
    repository: "https://github.com/opensouls/opensouls.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["memory_write"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["memory", "agent-runtime"]
  },
  {
    id: "letta",
    name: "Letta",
    repository: "https://github.com/letta-ai/letta.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["memory_write"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["memory", "agent"]
  },
  {
    id: "openhands",
    name: "OpenHands",
    repository: "https://github.com/OpenHands/OpenHands.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["local_build", "fs_write"],
      requiredDomains: ["local_build", "fs_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["autonomy", "coding-agent"]
  },
  {
    id: "open-llm-vtuber",
    name: "Open-LLM-VTuber",
    repository: "https://github.com/Open-LLM-VTuber/Open-LLM-VTuber.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["voice_output", "media_generation"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["companion", "voice", "avatar"]
  },
  {
    id: "mem0",
    name: "Mem0",
    repository: "https://github.com/mem0ai/mem0.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["memory_write"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["memory", "retrieval"]
  },
  {
    id: "sillytavern",
    name: "SillyTavern",
    repository: "https://github.com/SillyTavern/SillyTavern.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["memory_write", "voice_output"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["companion", "persona"]
  },
  {
    id: "openclaw",
    name: "OpenClaw",
    repository: "https://github.com/openclaw/openclaw.git",
    integrationMode: "adapter",
    versionPolicy: { pinRequired: true, updateCadence: "scheduled" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["channel_send", "desktop_control"],
      requiredDomains: ["outbound_send", "desktop_control"]
    },
    rollbackPlan: {
      strategy: "rollback_adapter",
      steps: [
        "disable openclaw adapter routes",
        "switch to direct gateway methods",
        "restore previous adapter pin"
      ]
    },
    auditFields: AUDIT_FIELDS,
    tags: ["skills", "ecosystem", "adapter"]
  },
  {
    id: "oh-my-claudecode",
    name: "oh-my-claudecode",
    repository: "https://github.com/Yeachan-Heo/oh-my-claudecode.git",
    integrationMode: "skill-pack",
    versionPolicy: { pinRequired: true, updateCadence: "scheduled" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["local_build"],
      requiredDomains: ["local_build"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["workflow", "autonomy"]
  },
  {
    id: "clawra",
    name: "Clawra",
    repository: "https://github.com/SumeLabs/clawra.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["memory_write", "voice_output"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["persona", "companion"]
  },
  {
    id: "openclaw-girl-agent",
    name: "OpenClaw AI Girlfriend by Clawra",
    repository: "https://github.com/openclaw-girl-agent/openclaw-ai-girlfriend-by-clawra.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["memory_write", "voice_output"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["companion", "persona"]
  },
  {
    id: "oh-my-opencode",
    name: "oh-my-opencode",
    repository: "https://github.com/code-yeongyu/oh-my-opencode.git",
    integrationMode: "skill-pack",
    versionPolicy: { pinRequired: true, updateCadence: "scheduled" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["local_build", "fs_write"],
      requiredDomains: ["local_build", "fs_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["workflow", "autonomy"]
  },
  {
    id: "memos",
    name: "MemOS",
    repository: "https://github.com/MemTensor/MemOS.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["memory_write"],
      requiredDomains: ["memory_write"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["memory", "knowledge"]
  },
  {
    id: "oh-my-opencode-slim",
    name: "oh-my-opencode-slim",
    repository: "https://github.com/alvinunreal/oh-my-opencode-slim.git",
    integrationMode: "skill-pack",
    versionPolicy: { pinRequired: true, updateCadence: "scheduled" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["local_build"],
      requiredDomains: ["local_build"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["workflow", "slim"]
  },
  {
    id: "zeroclaw",
    name: "ZeroClaw",
    repository: "https://github.com/zeroclaw-labs/zeroclaw.git",
    integrationMode: "reference",
    versionPolicy: { pinRequired: true, updateCadence: "manual" },
    compatibilityMatrix: {
      minMiyaVersion: "0.7.0",
      minOpenCodeVersion: "1.1.56",
      platforms: ["windows", "linux", "macos"]
    },
    permissionMetadata: {
      sideEffects: ["local_build", "desktop_control"],
      requiredDomains: ["local_build", "desktop_control"]
    },
    rollbackPlan: DEFAULT_ROLLBACK,
    auditFields: AUDIT_FIELDS,
    tags: ["agent-runtime", "automation"]
  }
];
var ECOSYSTEM_BRIDGE_REGISTRY = [
  ...ECOSYSTEM_BRIDGE_ENTRIES
].sort((a, b) => a.id.localeCompare(b.id));
function listEcosystemBridgeRegistry() {
  return ECOSYSTEM_BRIDGE_REGISTRY.map((entry2) => ({
    ...entry2,
    versionPolicy: { ...entry2.versionPolicy },
    compatibilityMatrix: {
      ...entry2.compatibilityMatrix,
      platforms: [...entry2.compatibilityMatrix.platforms]
    },
    permissionMetadata: {
      ...entry2.permissionMetadata,
      sideEffects: [...entry2.permissionMetadata.sideEffects],
      requiredDomains: [...entry2.permissionMetadata.requiredDomains]
    },
    rollbackPlan: {
      ...entry2.rollbackPlan,
      steps: [...entry2.rollbackPlan.steps]
    },
    auditFields: [...entry2.auditFields],
    tags: [...entry2.tags]
  }));
}
function getEcosystemBridgeEntry(id) {
  const normalized = String(id ?? "").trim().toLowerCase();
  if (!normalized)
    return null;
  const hit = ECOSYSTEM_BRIDGE_REGISTRY.find((entry2) => entry2.id === normalized);
  if (!hit)
    return null;
  return listEcosystemBridgeRegistry().find((entry2) => entry2.id === normalized) ?? null;
}
// src/compat/gateway-v2.ts
function toV2Alias(method) {
  return method.startsWith("v2.") ? method : `v2.${method}`;
}
function registerGatewayV2Aliases(methods) {
  const targets = methods.list().filter((method) => method.trim().length > 0).filter((method) => !method.startsWith("v2."));
  const aliases = [];
  let created = 0;
  let skipped = 0;
  for (const target of targets) {
    const alias = toV2Alias(target);
    const ok = methods.registerAlias(alias, target);
    if (!ok) {
      skipped += 1;
      continue;
    }
    aliases.push({ alias, target });
    created += 1;
  }
  return {
    scanned: targets.length,
    created,
    skipped,
    aliases
  };
}
// src/config/agent-model-persistence.ts
import * as fs32 from "node:fs";
import * as path34 from "node:path";

// src/config/constants.ts
var AGENT_ALIASES = {
  orchestrator: "1-task-manager",
  explorer: "2-code-search",
  librarian: "3-docs-helper",
  oracle: "4-architecture-advisor",
  fixer: "5-code-fixer",
  designer: "6-ui-designer",
  "code-simplicity-reviewer": "7-code-simplicity-reviewer",
  "7-code-simplicity-reviewer": "7-code-simplicity-reviewer",
  simplicity_reviewer: "7-code-simplicity-reviewer",
  explore: "2-code-search",
  "frontend-ui-ux-engineer": "6-ui-designer",
  "4-code-fixer": "5-code-fixer",
  "5-ui-designer": "6-ui-designer",
  "6-architecture-advisor": "4-architecture-advisor"
};
var SUBAGENT_NAMES = [
  "2-code-search",
  "3-docs-helper",
  "4-architecture-advisor",
  "5-code-fixer",
  "6-ui-designer"
];
var ORCHESTRATOR_NAME = "1-task-manager";
var CODE_SIMPLICITY_REVIEWER_NAME = "7-code-simplicity-reviewer";
var ALL_AGENT_NAMES = [
  ORCHESTRATOR_NAME,
  ...SUBAGENT_NAMES,
  CODE_SIMPLICITY_REVIEWER_NAME
];
var DEFAULT_TIMEOUT_MS = 2 * 60 * 1000;
var MAX_POLL_TIME_MS = 5 * 60 * 1000;

// src/config/agent-model-persistence.ts
var KNOWN_AGENT_NAMES = new Set(ALL_AGENT_NAMES);
var AGENT_RUNTIME_VERSION = 1;
var STATE_SYNC_STAMP_BY_DIR = new Map;
function isObject3(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function filePath7(projectDir) {
  return path34.join(getMiyaRuntimeDir(projectDir), "agent-runtime.json");
}
function legacyFilePath(projectDir) {
  return path34.join(getMiyaRuntimeDir(projectDir), "agent-models.json");
}
function normalizeAgentName(name) {
  const trimmed = name.trim();
  if (!trimmed)
    return null;
  const canonical = AGENT_ALIASES[trimmed] ?? trimmed;
  return KNOWN_AGENT_NAMES.has(canonical) ? canonical : null;
}
function normalizeModelRef(value) {
  if (typeof value === "string") {
    const text = value.trim();
    const slash = text.indexOf("/");
    if (slash <= 0 || slash >= text.length - 1) {
      return null;
    }
    return text;
  }
  if (isObject3(value)) {
    const providerID = String(value.providerID ?? "").trim();
    let modelID = String(value.modelID ?? "").trim();
    if (!providerID || !modelID)
      return null;
    if (modelID.toLowerCase().startsWith(`${providerID.toLowerCase()}/`)) {
      modelID = modelID.slice(providerID.length + 1);
    }
    if (providerID.toLowerCase() === "openrouter") {
      const parts = modelID.split("/").filter(Boolean);
      if (parts.length > 2) {
        modelID = parts.slice(-2).join("/");
      }
    }
    return `${providerID}/${modelID}`;
  }
  return null;
}
function normalizeModelWithProvider(modelRaw, providerRaw) {
  const model = normalizeModelRef(modelRaw) ?? undefined;
  const providerID = normalizeProviderID(providerRaw);
  if (!model) {
    return {
      model: undefined,
      providerID
    };
  }
  const parts = model.split("/").filter(Boolean);
  if (parts.length === 0) {
    return {
      model: undefined,
      providerID
    };
  }
  if (!providerID) {
    return {
      model,
      providerID: normalizeProviderID(parts[0])
    };
  }
  if (parts[0] === providerID) {
    if (providerID === "openrouter" && parts.length > 3) {
      const compact = `openrouter/${parts.slice(-2).join("/")}`;
      return { model: compact, providerID };
    }
    return { model, providerID };
  }
  if (providerID === "openrouter") {
    const compact = `openrouter/${parts.slice(-2).join("/")}`;
    return { model: compact, providerID };
  }
  const modelProvider = normalizeProviderID(parts[0]);
  return {
    model,
    providerID: modelProvider ?? providerID
  };
}
function parsePersistedModel(value) {
  return normalizeModelRef(value) ?? (isObject3(value) ? normalizeModelRef(value.model) : null);
}
function normalizeProviderID(value) {
  const text = String(value ?? "").trim();
  return text || undefined;
}
function normalizeStringValue(value) {
  const text = String(value ?? "").trim();
  return text || undefined;
}
function normalizeOptions(value) {
  if (!isObject3(value))
    return;
  return JSON.parse(JSON.stringify(value));
}
function normalizeAgentRuntimeEntry(value) {
  if (!isObject3(value))
    return null;
  const { model, providerID: normalizedProviderID } = normalizeModelWithProvider(value.model ?? value, value.providerID);
  const variant = normalizeStringValue(value.variant);
  const providerID = normalizedProviderID;
  const options = normalizeOptions(value.options ?? value.providerOptions);
  const apiKey = normalizeStringValue(value.apiKey);
  const baseURL = normalizeStringValue(value.baseURL);
  if (!model && !variant && !providerID && !options && !apiKey && !baseURL) {
    return null;
  }
  return {
    model: model ?? undefined,
    variant,
    providerID,
    options,
    apiKey,
    baseURL,
    updatedAt: normalizeStringValue(value.updatedAt) ?? new Date().toISOString()
  };
}
function readLegacyModels(projectDir) {
  const file3 = legacyFilePath(projectDir);
  if (!fs32.existsSync(file3))
    return {};
  try {
    const raw = fs32.readFileSync(file3, "utf-8");
    const parsed = JSON.parse(raw);
    if (!isObject3(parsed.agents))
      return {};
    const result = {};
    for (const [rawAgentName, rawModel] of Object.entries(parsed.agents)) {
      const agentName = normalizeAgentName(rawAgentName);
      const model = parsePersistedModel(rawModel);
      if (!agentName || !model)
        continue;
      result[agentName] = model;
    }
    return result;
  } catch {
    return {};
  }
}
function normalizeRuntimeState(projectDir, parsed) {
  if (!parsed || !isObject3(parsed.agents)) {
    const legacy = readLegacyModels(projectDir);
    const agentsFromLegacy = {};
    for (const [agentName, model] of Object.entries(legacy)) {
      agentsFromLegacy[agentName] = {
        model,
        providerID: model.split("/")[0],
        updatedAt: new Date().toISOString()
      };
    }
    return {
      version: AGENT_RUNTIME_VERSION,
      revision: 0,
      updatedAt: new Date().toISOString(),
      agents: agentsFromLegacy
    };
  }
  const agents = {};
  for (const [rawAgentName, rawEntry] of Object.entries(parsed.agents)) {
    const agentName = normalizeAgentName(rawAgentName);
    if (!agentName)
      continue;
    const entry2 = normalizeAgentRuntimeEntry(rawEntry);
    if (!entry2)
      continue;
    agents[agentName] = entry2;
  }
  const activeAgentId = normalizeAgentName(String(parsed.activeAgentId ?? "")) ?? undefined;
  return {
    version: AGENT_RUNTIME_VERSION,
    revision: Number(parsed.revision ?? 0) || 0,
    updatedAt: normalizeStringValue(parsed.updatedAt) ?? new Date().toISOString(),
    activeAgentId,
    agents
  };
}
function readRuntimeState(projectDir) {
  const file3 = filePath7(projectDir);
  if (!fs32.existsSync(file3)) {
    const migrated = normalizeRuntimeState(projectDir, null);
    if (Object.keys(migrated.agents).length > 0 || fs32.existsSync(legacyFilePath(projectDir))) {
      const runtimeToWrite = {
        ...migrated,
        revision: migrated.revision > 0 ? migrated.revision : 1,
        updatedAt: new Date().toISOString()
      };
      writeRuntimeStateAtomic(projectDir, runtimeToWrite);
      return runtimeToWrite;
    }
    return migrated;
  }
  try {
    const raw = fs32.readFileSync(file3, "utf-8");
    const parsed = JSON.parse(raw);
    return normalizeRuntimeState(projectDir, parsed);
  } catch {
    return normalizeRuntimeState(projectDir, null);
  }
}
function writeRuntimeStateAtomic(projectDir, runtime) {
  const file3 = filePath7(projectDir);
  fs32.mkdirSync(path34.dirname(file3), { recursive: true });
  const orderedAgents = Object.fromEntries(Object.keys(runtime.agents).sort((a, b) => a.localeCompare(b)).map((key) => [key, runtime.agents[key]]));
  const payload = {
    version: AGENT_RUNTIME_VERSION,
    revision: runtime.revision,
    updatedAt: runtime.updatedAt,
    activeAgentId: runtime.activeAgentId,
    agents: orderedAgents
  };
  const tmp = `${file3}.tmp.${process.pid}.${Date.now()}`;
  fs32.writeFileSync(tmp, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
  fs32.renameSync(tmp, file3);
}
function readPersistedAgentRuntime(projectDir) {
  const runtime = readRuntimeState(projectDir);
  return {
    activeAgentId: runtime.activeAgentId,
    revision: runtime.revision,
    agents: runtime.agents
  };
}

// src/config/provider-override-audit.ts
import * as fs33 from "node:fs";
import * as path35 from "node:path";
function providerOverrideAuditFile(projectDir) {
  return path35.join(getMiyaRuntimeDir(projectDir), "audit", "provider-overrides.jsonl");
}
function listProviderOverrideAudits(projectDir, limit = 50) {
  const file3 = providerOverrideAuditFile(projectDir);
  if (!fs33.existsSync(file3))
    return [];
  const safeLimit = Math.max(1, Math.min(500, Math.floor(limit)));
  const lines = fs33.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean);
  return lines.slice(-safeLimit).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => item !== null).reverse();
}

// src/context/pipeline.ts
var DEFAULT_MODE_SAFE_WORK_CONFIDENCE = 0.5;
function clamp5(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function applyModeSafeWorkFallback(modeKernel, minConfidence = DEFAULT_MODE_SAFE_WORK_CONFIDENCE) {
  const threshold = clamp5(Number(minConfidence), 0, 1);
  const lowConfidenceSafeFallback = modeKernel.confidence < threshold;
  if (!lowConfidenceSafeFallback) {
    return {
      modeKernel,
      lowConfidenceSafeFallback: false
    };
  }
  return {
    modeKernel: {
      ...modeKernel,
      mode: "work",
      why: modeKernel.why.includes("low_confidence_safe_work_fallback") ? modeKernel.why : [...modeKernel.why, "low_confidence_safe_work_fallback"]
    },
    lowConfidenceSafeFallback: true
  };
}
function shouldInjectPersonaWorldPrompt(input) {
  if (input.executeWork && input.mode === "work")
    return false;
  return true;
}

// src/daemon/psyche/bandit.ts
import * as fs34 from "node:fs";
var DEFAULT_FAST_BRAIN = { buckets: {} };
var MAX_BUCKETS = 1200;
function nowIso22() {
  return new Date().toISOString();
}
function safeReadJson3(filePath8, fallback) {
  if (!fs34.existsSync(filePath8))
    return fallback;
  try {
    return JSON.parse(fs34.readFileSync(filePath8, "utf-8"));
  } catch {
    return fallback;
  }
}
function fastBrainBucket(input) {
  const normalizedIntent = input.intent.trim().toLowerCase() || "unknown_intent";
  const channel = (input.channel || "none").trim().toLowerCase() || "none";
  return [
    `state=${input.state}`,
    `intent=${normalizedIntent}`,
    `urgency=${input.urgency}`,
    `channel=${channel}`,
    `user=${input.userInitiated ? "1" : "0"}`
  ].join("|");
}
function readFastBrainScore(fastBrainPath, input) {
  const store = safeReadJson3(fastBrainPath, DEFAULT_FAST_BRAIN);
  const key = fastBrainBucket(input);
  const stats = store.buckets[key];
  if (!stats)
    return 0.5;
  const alpha = Number.isFinite(stats.alpha) ? stats.alpha : 1;
  const beta = Number.isFinite(stats.beta) ? stats.beta : 1;
  const total = alpha + beta;
  if (!Number.isFinite(total) || total <= 0)
    return 0.5;
  return Math.max(0, Math.min(1, alpha / total));
}
function touchFastBrain(fastBrainPath, input) {
  const store = safeReadJson3(fastBrainPath, DEFAULT_FAST_BRAIN);
  const key = fastBrainBucket(input);
  const current = store.buckets[key] ?? {
    alpha: 1,
    beta: 1,
    updatedAt: nowIso22()
  };
  if (input.approved) {
    current.alpha += 1;
  } else {
    current.beta += 1;
  }
  current.updatedAt = nowIso22();
  store.buckets[key] = current;
  trimOldBuckets(store);
  fs34.writeFileSync(fastBrainPath, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function adjustFastBrain(fastBrainPath, key, alphaDelta, betaDelta) {
  const store = safeReadJson3(fastBrainPath, DEFAULT_FAST_BRAIN);
  const current = store.buckets[key] ?? {
    alpha: 1,
    beta: 1,
    updatedAt: nowIso22()
  };
  const alpha = Number.isFinite(current.alpha) ? current.alpha : 1;
  const beta = Number.isFinite(current.beta) ? current.beta : 1;
  current.alpha = Math.max(1, alpha + Math.max(0, alphaDelta));
  current.beta = Math.max(1, beta + Math.max(0, betaDelta));
  current.updatedAt = nowIso22();
  store.buckets[key] = current;
  trimOldBuckets(store);
  fs34.writeFileSync(fastBrainPath, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function trimOldBuckets(store) {
  const keys = Object.keys(store.buckets);
  if (keys.length <= MAX_BUCKETS)
    return;
  keys.sort((a, b) => Date.parse(store.buckets[a].updatedAt) - Date.parse(store.buckets[b].updatedAt)).slice(0, keys.length - MAX_BUCKETS).forEach((keyToDelete) => {
    delete store.buckets[keyToDelete];
  });
}
// src/daemon/psyche/consult.ts
import { randomUUID as randomUUID16 } from "node:crypto";
import * as fs41 from "node:fs";
import * as path39 from "node:path";

// src/daemon/psyche/logger.ts
import * as fs35 from "node:fs";
function nowUnixSec() {
  return Math.floor(Date.now() / 1000);
}
function appendJsonl(path36, payload) {
  fs35.appendFileSync(path36, `${JSON.stringify(payload)}
`, "utf-8");
}
function appendPsycheObservation(trainingDataLogPath, input) {
  appendJsonl(trainingDataLogPath, {
    t: nowUnixSec(),
    type: "observation",
    obs: {
      at: input.at,
      state: input.state,
      intent: input.intent,
      urgency: input.urgency,
      channel: input.channel ?? "none",
      userInitiated: input.userInitiated,
      confidence: input.confidence,
      decision: input.decision,
      shouldProbeScreen: input.shouldProbeScreen,
      reasons: input.reasons,
      signals: input.signals ?? {},
      approvalMode: input.approvalMode,
      fixability: input.fixability,
      trust: input.trust
    }
  });
}
function appendPsycheOutcome(trainingDataLogPath, input) {
  appendJsonl(trainingDataLogPath, {
    t: nowUnixSec(),
    type: "action_outcome",
    action: {
      at: input.at,
      consultAuditID: input.consultAuditID,
      state: input.state,
      intent: input.intent,
      urgency: input.urgency,
      channel: input.channel ?? "none",
      userInitiated: input.userInitiated,
      delivered: input.delivered,
      blockedReason: input.blockedReason ?? "",
      explicitFeedback: input.explicitFeedback,
      userReplyWithinSec: input.userReplyWithinSec,
      userInitiatedWithinSec: input.userInitiatedWithinSec,
      score: Number(input.score.toFixed(3)),
      reward: input.reward
    }
  });
}

// src/daemon/psyche/probe-budget.ts
import * as fs36 from "node:fs";
function readState(filePath8, fallbackCapacity) {
  if (!fs36.existsSync(filePath8)) {
    return { tokens: fallbackCapacity, updatedAtMs: Date.now() };
  }
  try {
    const parsed = JSON.parse(fs36.readFileSync(filePath8, "utf-8"));
    const tokens = Number(parsed.tokens);
    const updatedAtMs = Number(parsed.updatedAtMs);
    return {
      tokens: Number.isFinite(tokens) ? tokens : fallbackCapacity,
      updatedAtMs: Number.isFinite(updatedAtMs) ? updatedAtMs : Date.now()
    };
  } catch {
    return { tokens: fallbackCapacity, updatedAtMs: Date.now() };
  }
}
function writeState3(filePath8, state) {
  fs36.writeFileSync(filePath8, `${JSON.stringify(state, null, 2)}
`, "utf-8");
}
function consumeProbeBudget(filePath8, config3, nowMs = Date.now()) {
  const capacity = Math.max(1, Math.floor(config3.capacity));
  const refillPerSec = Math.max(0.0001, config3.refillPerSec);
  const current = readState(filePath8, capacity);
  const elapsedSec = Math.max(0, (nowMs - current.updatedAtMs) / 1000);
  const refilled = Math.min(capacity, current.tokens + elapsedSec * refillPerSec);
  const allowed = refilled >= 1;
  const nextTokens = allowed ? refilled - 1 : refilled;
  writeState3(filePath8, { tokens: nextTokens, updatedAtMs: nowMs });
  return { allowed, remainingTokens: Number(nextTokens.toFixed(3)) };
}

// src/daemon/psyche/probe-worker/capture.ts
import { spawnSync as spawnSync4 } from "node:child_process";
function parseMethodList() {
  const raw = String(process.env.MIYA_CAPTURE_PROBE_METHODS ?? "dxgi_duplication,wgc_hwnd,print_window").trim().toLowerCase();
  const parsed = raw.split(",").map((item) => item.trim()).filter(Boolean).map((item) => item === "dxgi" || item === "dxgi_duplication" || item === "wgc_hwnd" || item === "print_window" ? item === "dxgi" ? "dxgi_duplication" : item : null).filter((item) => Boolean(item));
  if (parsed.length === 0)
    return ["dxgi_duplication", "wgc_hwnd", "print_window"];
  return [...new Set(parsed)];
}
function parseJson(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}
function runCaptureHelper(input) {
  const command = String(input.command ?? "").trim();
  if (!command) {
    return {
      ok: false,
      method: input.method,
      limitations: [input.missingCode],
      error: input.missingCode
    };
  }
  const result = spawnSync4(command, [], {
    timeout: Math.max(500, input.timeoutMs),
    encoding: "utf-8",
    shell: true,
    windowsHide: true,
    stdio: ["ignore", "pipe", "pipe"]
  });
  if (result.error) {
    return {
      ok: false,
      method: input.method,
      limitations: [input.execFailedCode],
      error: result.error.message || input.execFailedCode
    };
  }
  if (result.status !== 0) {
    return {
      ok: false,
      method: input.method,
      limitations: [input.nonZeroCode],
      error: String(result.stderr || `exit_${result.status}`).trim()
    };
  }
  const parsed = parseJson(String(result.stdout ?? "").trim());
  if (!parsed) {
    return {
      ok: false,
      method: input.method,
      limitations: [input.invalidJsonCode],
      error: input.invalidJsonCode
    };
  }
  const limitations = Array.isArray(parsed.limitations) ? parsed.limitations.map((item) => String(item ?? "").trim()).filter(Boolean) : [];
  return {
    ok: parsed.ok === true && typeof parsed.imageBase64 === "string" && parsed.imageBase64.length > 0,
    method: input.method,
    imageBase64: typeof parsed.imageBase64 === "string" ? parsed.imageBase64 : undefined,
    blackFrame: parsed.blackFrame === true,
    limitations,
    error: typeof parsed.error === "string" ? parsed.error : undefined
  };
}
function runDxgiHelper(timeoutMs) {
  if (process.platform !== "win32") {
    return {
      ok: false,
      method: "dxgi_duplication",
      limitations: ["platform_not_windows"],
      error: "platform_not_windows"
    };
  }
  const helper = runCaptureHelper({
    method: "dxgi_duplication",
    command: String(process.env.MIYA_DXGI_CAPTURE_HELPER_CMD ?? ""),
    missingCode: "dxgi_helper_missing",
    execFailedCode: "dxgi_helper_exec_failed",
    nonZeroCode: "dxgi_helper_nonzero_exit",
    invalidJsonCode: "dxgi_helper_invalid_json",
    timeoutMs
  });
  if (helper.ok)
    return helper;
  const ffmpeg = runDxgiFfmpegFallback(timeoutMs);
  if (!ffmpeg.ok) {
    return {
      ...helper,
      limitations: [
        ...new Set([...helper.limitations, ...ffmpeg.limitations])
      ].slice(0, 24),
      error: helper.error || ffmpeg.error
    };
  }
  return {
    ...ffmpeg,
    limitations: [
      ...new Set([
        ...helper.limitations,
        ...ffmpeg.limitations,
        "dxgi_helper_fallback"
      ])
    ].slice(0, 24)
  };
}
function runDxgiFfmpegFallback(timeoutMs) {
  const command = String(process.env.MIYA_DXGI_CAPTURE_FFMPEG_CMD ?? "ffmpeg").trim();
  if (!command) {
    return {
      ok: false,
      method: "dxgi_duplication",
      limitations: ["dxgi_ffmpeg_missing"],
      error: "dxgi_ffmpeg_missing"
    };
  }
  const argsRaw = String(process.env.MIYA_DXGI_CAPTURE_FFMPEG_ARGS ?? "").trim();
  const args = argsRaw.length > 0 ? argsRaw.split(/\s+/).filter(Boolean) : [
    "-hide_banner",
    "-loglevel",
    "error",
    "-f",
    "ddagrab",
    "-framerate",
    "1",
    "-frames:v",
    "1",
    "-i",
    "desktop",
    "-vf",
    "scale=224:224",
    "-f",
    "image2pipe",
    "-vcodec",
    "png",
    "-"
  ];
  const run = spawnSync4(command, args, {
    timeout: Math.max(500, timeoutMs),
    encoding: "buffer",
    windowsHide: true,
    stdio: ["ignore", "pipe", "pipe"]
  });
  if (run.error) {
    return {
      ok: false,
      method: "dxgi_duplication",
      limitations: ["dxgi_ffmpeg_exec_failed"],
      error: run.error.message || "dxgi_ffmpeg_exec_failed"
    };
  }
  if (run.signal) {
    return {
      ok: false,
      method: "dxgi_duplication",
      timedOut: true,
      limitations: ["dxgi_ffmpeg_timeout"],
      error: String(run.signal)
    };
  }
  if (run.status !== 0) {
    return {
      ok: false,
      method: "dxgi_duplication",
      limitations: ["dxgi_ffmpeg_nonzero_exit"],
      error: Buffer.from(run.stderr ?? "").toString("utf-8").trim() || `exit_${run.status}`
    };
  }
  const imageBuffer = Buffer.isBuffer(run.stdout) ? run.stdout : Buffer.from(run.stdout ?? "");
  if (!imageBuffer || imageBuffer.length === 0) {
    return {
      ok: false,
      method: "dxgi_duplication",
      limitations: ["dxgi_ffmpeg_empty_frame"],
      error: "dxgi_ffmpeg_empty_frame"
    };
  }
  return {
    ok: true,
    method: "dxgi_duplication",
    imageBase64: imageBuffer.toString("base64"),
    blackFrame: false,
    limitations: ["dxgi_ffmpeg_fallback"]
  };
}
function runWgcHelper(timeoutMs) {
  return runCaptureHelper({
    method: "wgc_hwnd",
    command: String(process.env.MIYA_WGC_CAPTURE_HELPER_CMD ?? ""),
    missingCode: "wgc_helper_missing",
    execFailedCode: "wgc_helper_exec_failed",
    nonZeroCode: "wgc_helper_nonzero_exit",
    invalidJsonCode: "wgc_helper_invalid_json",
    timeoutMs
  });
}
function runPrintWindowCapture(timeoutMs) {
  if (process.platform !== "win32") {
    return {
      ok: false,
      method: "print_window",
      limitations: ["platform_not_windows"],
      error: "platform_not_windows"
    };
  }
  const script = `
Add-Type -AssemblyName System.Drawing
Add-Type @"
using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;
public static class MiyaPrintWindowProbe {
  [StructLayout(LayoutKind.Sequential)]
  public struct RECT { public int Left; public int Top; public int Right; public int Bottom; }
  [DllImport("user32.dll")] public static extern IntPtr GetForegroundWindow();
  [DllImport("user32.dll")] public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
  [DllImport("user32.dll")] public static extern bool PrintWindow(IntPtr hwnd, IntPtr hdcBlt, int nFlags);
  [DllImport("user32.dll")] public static extern bool IsWindowVisible(IntPtr hWnd);
  public static string CaptureForeground() {
    IntPtr hwnd = GetForegroundWindow();
    if (hwnd == IntPtr.Zero) return "{\\"ok\\":false,\\"error\\":\\"no_foreground_window\\",\\"limitations\\":[\\"capture_probe_error:no_foreground_window\\"]}";
    if (!IsWindowVisible(hwnd)) return "{\\"ok\\":false,\\"error\\":\\"window_not_visible\\",\\"limitations\\":[\\"capture_probe_occluded\\"]}";
    RECT rect;
    if (!GetWindowRect(hwnd, out rect)) return "{\\"ok\\":false,\\"error\\":\\"window_rect_failed\\",\\"limitations\\":[\\"capture_probe_error:window_rect\\"]}";
    int width = Math.Max(1, rect.Right - rect.Left);
    int height = Math.Max(1, rect.Bottom - rect.Top);
    using (var bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb)) {
      using (var g = Graphics.FromImage(bmp)) {
        IntPtr hdc = g.GetHdc();
        bool ok = false;
        try {
          ok = PrintWindow(hwnd, hdc, 0);
        } finally {
          g.ReleaseHdc(hdc);
        }
        if (!ok) {
          return "{\\"ok\\":false,\\"error\\":\\"print_window_failed\\",\\"limitations\\":[\\"capture_probe_error:print_window\\"]}";
        }
      }
      using (var small = new Bitmap(224, 224, PixelFormat.Format24bppRgb))
      using (var gs = Graphics.FromImage(small))
      using (var ms = new MemoryStream()) {
        gs.InterpolationMode = InterpolationMode.HighQualityBicubic;
        gs.DrawImage(bmp, 0, 0, 224, 224);
        long total = 0;
        int step = 8;
        int count = 0;
        for (int y = 0; y < small.Height; y += step) {
          for (int x = 0; x < small.Width; x += step) {
            Color c = small.GetPixel(x, y);
            total += (c.R + c.G + c.B);
            count += 1;
          }
        }
        double avg = count > 0 ? (double)total / (count * 3.0) : 0;
        bool black = avg < 6.0;
        small.Save(ms, ImageFormat.Png);
        string payload = Convert.ToBase64String(ms.ToArray());
        string json = "{\\"ok\\":true,\\"blackFrame\\":" + (black ? "true" : "false") + ",\\"imageBase64\\":\\"" + payload + "\\",\\"limitations\\":[]}";
        return json;
      }
    }
  }
}
"@
[MiyaPrintWindowProbe]::CaptureForeground()
`.trim();
  const run = spawnSync4("powershell.exe", [
    "-NoProfile",
    "-NonInteractive",
    "-ExecutionPolicy",
    "Bypass",
    "-Command",
    script
  ], {
    timeout: Math.max(500, timeoutMs),
    encoding: "utf-8",
    windowsHide: true
  });
  if (run.error) {
    return {
      ok: false,
      method: "print_window",
      limitations: ["capture_probe_error:spawn"],
      error: run.error.message || "spawn_failed"
    };
  }
  if (run.signal) {
    return {
      ok: false,
      method: "print_window",
      timedOut: true,
      limitations: ["capture_probe_timeout"],
      error: String(run.signal)
    };
  }
  const parsed = parseJson(String(run.stdout ?? "").trim());
  if (!parsed) {
    return {
      ok: false,
      method: "print_window",
      limitations: ["capture_probe_error:invalid_json"],
      error: String(run.stderr ?? "invalid_json").trim()
    };
  }
  const limitations = Array.isArray(parsed.limitations) ? parsed.limitations.map((item) => String(item ?? "").trim()).filter(Boolean) : [];
  return {
    ok: parsed.ok === true && typeof parsed.imageBase64 === "string" && parsed.imageBase64.length > 0,
    method: "print_window",
    imageBase64: typeof parsed.imageBase64 === "string" ? parsed.imageBase64 : undefined,
    blackFrame: parsed.blackFrame === true,
    limitations,
    error: typeof parsed.error === "string" ? parsed.error : undefined
  };
}
function captureFrameForScreenProbe(timeoutMs = 2000) {
  const methods = parseMethodList();
  const limitations = [];
  for (const method of methods) {
    const result = method === "dxgi_duplication" ? runDxgiHelper(timeoutMs) : method === "wgc_hwnd" ? runWgcHelper(timeoutMs) : runPrintWindowCapture(timeoutMs);
    limitations.push(...result.limitations);
    if (result.ok) {
      return {
        ...result,
        limitations: [...new Set([...limitations, ...result.limitations])]
      };
    }
  }
  return {
    ok: false,
    limitations: [...new Set(limitations)].slice(0, 24),
    error: "capture_tree_exhausted"
  };
}

// src/daemon/psyche/probe-worker/vlm.ts
import { spawnSync as spawnSync5 } from "node:child_process";
import * as fs37 from "node:fs";
import * as path36 from "node:path";
function parseCommandSpec3(raw) {
  const input = raw.trim();
  if (!input)
    return null;
  const tokens = [];
  let current = "";
  let quote = null;
  for (let i = 0;i < input.length; i += 1) {
    const ch = input[i] ?? "";
    if ((ch === '"' || ch === "'") && (!quote || quote === ch)) {
      quote = quote ? null : ch;
      continue;
    }
    if (!quote && /\s/.test(ch)) {
      if (current)
        tokens.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current)
    tokens.push(current);
  if (tokens.length === 0)
    return null;
  return { command: tokens[0], args: tokens.slice(1) };
}
function parseLocalCommand() {
  const dedicated = String(process.env.MIYA_SCREEN_PROBE_LOCAL_VLM_CMD ?? "").trim();
  if (dedicated) {
    const parsed = parseCommandSpec3(dedicated);
    if (!parsed)
      return null;
    return { ...parsed, shell: false };
  }
  const shared = String(process.env.MIYA_VISION_LOCAL_CMD ?? "").trim();
  if (shared) {
    const parsed = parseCommandSpec3(shared);
    if (parsed)
      return { ...parsed, shell: false };
    return { command: shared, args: [], shell: true };
  }
  const projectDir = process.cwd();
  const scriptPath = path36.join(projectDir, "miya-src", "python", "infer_qwen3_vl.py");
  if (!fs37.existsSync(scriptPath))
    return null;
  const backendCmd = String(process.env.MIYA_QWEN3VL_CMD ?? "").trim();
  const modelRoot = path36.basename(projectDir).toLowerCase() === ".opencode" ? path36.join(projectDir, "miya", "model") : path36.join(projectDir, ".opencode", "miya", "model");
  const modelDir = String(process.env.MIYA_QWEN3VL_MODEL_DIR ?? "").trim() || path36.join(modelRoot, "shi jue", "Qwen3VL-4B-Instruct-Q4_K_M");
  const python = String(process.env.MIYA_VISION_PYTHON ?? "").trim() || "python";
  const args = [scriptPath, "--mode", "screen_probe", "--model-dir", modelDir];
  if (backendCmd)
    args.push("--backend-cmd", backendCmd);
  return {
    command: python,
    args,
    shell: false
  };
}
function parseJson2(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}
function normalizeTags(tags) {
  if (!Array.isArray(tags))
    return [];
  return [
    ...new Set(tags.map((item) => String(item ?? "").trim()).filter(Boolean))
  ].map((item) => item.toLowerCase()).slice(0, 12);
}
function inferSignalsFromTags(tags, appHint) {
  const normalizedHint = String(appHint ?? "").trim().toLowerCase();
  const inferred = {};
  if (tags.some((item) => item.includes("playing_game") || item.includes("game"))) {
    inferred.foreground = "game";
    inferred.gamepadActive = true;
  } else if (tags.some((item) => item.includes("watching_video") || item.includes("media") || item.includes("player"))) {
    inferred.foreground = "player";
    inferred.audioActive = true;
    inferred.fullscreen = true;
  } else if (tags.some((item) => item.includes("coding") || item.includes("terminal"))) {
    inferred.foreground = normalizedHint.includes("terminal") ? "terminal" : "ide";
  }
  if (normalizedHint.includes("player"))
    inferred.foreground = "player";
  if (normalizedHint.includes("game"))
    inferred.foreground = "game";
  return inferred;
}
function runScreenProbeVlm(input) {
  const commandSpec = parseLocalCommand();
  if (!commandSpec) {
    return {
      ok: false,
      sceneTags: [],
      confidence: 0,
      limitations: ["local_vlm_command_missing"],
      inferredSignals: {},
      error: "local_vlm_command_missing"
    };
  }
  const payload = JSON.stringify({
    imageBase64: input.imageBase64,
    question: input.question,
    mode: "screen_probe"
  });
  const run = spawnSync5(commandSpec.command, commandSpec.args, {
    input: payload,
    timeout: Math.max(600, input.timeoutMs),
    encoding: "utf-8",
    shell: commandSpec.shell,
    windowsHide: true,
    stdio: ["pipe", "pipe", "pipe"]
  });
  if (run.error) {
    return {
      ok: false,
      sceneTags: [],
      confidence: 0,
      limitations: ["local_vlm_exec_failed"],
      inferredSignals: {},
      error: run.error.message || "local_vlm_exec_failed"
    };
  }
  if (run.signal) {
    return {
      ok: false,
      sceneTags: [],
      confidence: 0,
      limitations: ["local_vlm_timeout"],
      inferredSignals: {},
      error: String(run.signal)
    };
  }
  if (run.status !== 0) {
    return {
      ok: false,
      sceneTags: [],
      confidence: 0,
      limitations: ["local_vlm_nonzero_exit"],
      inferredSignals: {},
      error: String(run.stderr ?? `exit_${run.status}`).trim()
    };
  }
  const parsed = parseJson2(String(run.stdout ?? "").trim());
  if (!parsed) {
    return {
      ok: false,
      sceneTags: [],
      confidence: 0,
      limitations: ["local_vlm_invalid_json"],
      inferredSignals: {},
      error: "local_vlm_invalid_json"
    };
  }
  const sceneTags = normalizeTags(parsed.sceneTags);
  const confidenceRaw = Number(parsed.confidence ?? Number.NaN);
  const confidence = Number.isFinite(confidenceRaw) ? Math.max(0, Math.min(1, Number(confidenceRaw.toFixed(3)))) : sceneTags.length > 0 ? 0.6 : 0.35;
  const limitations = [
    ...normalizeTags(parsed.captureLimitations),
    ...normalizeTags(parsed.redFlags).map((item) => `red_flag:${item}`)
  ];
  return {
    ok: true,
    sceneTags,
    confidence,
    limitations,
    inferredSignals: inferSignalsFromTags(sceneTags, parsed.appHint)
  };
}

// src/daemon/psyche/screen-probe.ts
function uniqueStrings(values) {
  return [
    ...new Set(values.map((item) => String(item ?? "").trim()).filter(Boolean))
  ].slice(0, 24);
}
function runScreenProbe(input) {
  const timeoutMs = Math.max(800, Math.min(6000, Math.floor(input.timeoutMs ?? 2800)));
  const capture = captureFrameForScreenProbe(timeoutMs);
  const captureLimitations = uniqueStrings(capture.limitations);
  if (!capture.ok) {
    const timedOut = capture.timedOut === true || captureLimitations.includes("capture_probe_timeout");
    return {
      status: timedOut ? "timeout" : "error",
      method: capture.method,
      captureLimitations: uniqueStrings([
        ...captureLimitations,
        timedOut ? "capture_probe_timeout" : "capture_probe_error"
      ]),
      sceneTags: [],
      confidence: 0,
      inferredSignals: {}
    };
  }
  if (capture.blackFrame) {
    return {
      status: "black",
      method: capture.method,
      captureLimitations: uniqueStrings([
        ...captureLimitations,
        "capture_probe_black_screen"
      ]),
      sceneTags: [],
      confidence: 0.25,
      inferredSignals: {}
    };
  }
  const imageBase64 = String(capture.imageBase64 ?? "").trim();
  if (!imageBase64) {
    return {
      status: "error",
      method: capture.method,
      captureLimitations: uniqueStrings([
        ...captureLimitations,
        "capture_probe_error:no_frame_data"
      ]),
      sceneTags: [],
      confidence: 0,
      inferredSignals: {}
    };
  }
  const vlm = runScreenProbeVlm({
    imageBase64,
    question: `Analyze current desktop scene for intent=${input.intent}; output scene tags only.`,
    timeoutMs: timeoutMs - 300
  });
  if (!vlm.ok) {
    return {
      status: "ok",
      method: capture.method,
      captureLimitations: uniqueStrings([
        ...captureLimitations,
        ...vlm.limitations
      ]),
      sceneTags: [],
      confidence: 0.4,
      inferredSignals: {}
    };
  }
  return {
    status: "ok",
    method: capture.method,
    captureLimitations: uniqueStrings([
      ...captureLimitations,
      ...vlm.limitations
    ]),
    sceneTags: vlm.sceneTags,
    confidence: vlm.confidence,
    inferredSignals: vlm.inferredSignals
  };
}

// src/daemon/psyche/sensors/windows-shell.ts
import { spawnSync as spawnSync6 } from "node:child_process";
function normalizeStdout(stdout) {
  if (typeof stdout !== "string")
    return "";
  return stdout.trim();
}
function runWindowsPowerShellJson(script, timeoutMs) {
  if (process.platform !== "win32") {
    return { ok: false, error: "platform_not_windows" };
  }
  const command = String(script ?? "").trim();
  if (!command)
    return { ok: false, error: "empty_script" };
  try {
    const child = spawnSync6("powershell.exe", [
      "-NoProfile",
      "-NonInteractive",
      "-ExecutionPolicy",
      "Bypass",
      "-Command",
      command
    ], {
      timeout: Math.max(300, timeoutMs),
      encoding: "utf-8",
      windowsHide: true
    });
    if (child.error) {
      return {
        ok: false,
        error: child.error.message || "spawn_failed"
      };
    }
    if (child.status !== 0) {
      return {
        ok: false,
        error: normalizeStdout(child.stderr) || `exit_${child.status}`
      };
    }
    const text = normalizeStdout(child.stdout);
    if (!text)
      return { ok: false, error: "empty_stdout" };
    try {
      return {
        ok: true,
        value: JSON.parse(text)
      };
    } catch {
      return { ok: false, error: "json_parse_failed" };
    }
  } catch (error92) {
    return {
      ok: false,
      error: error92 instanceof Error ? error92.message : String(error92)
    };
  }
}

// src/daemon/psyche/sensors/audio.ts
function sampleAudioSignal() {
  const script = `
try {
  Add-Type -AssemblyName System.Runtime.WindowsRuntime
  $null = [Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager, Windows.Media.Control, ContentType=WindowsRuntime]
  $manager = [Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager]::RequestAsync().GetAwaiter().GetResult()
  $sessions = $manager.GetSessions()
  $activeCount = 0
  foreach ($session in $sessions) {
    try {
      $playback = $session.GetPlaybackInfo()
      if ($playback -and $playback.PlaybackStatus -eq [Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackStatus]::Playing) {
        $activeCount += 1
      }
    } catch {}
  }
  @{
    audioSessionCount = $activeCount
    audioSessionActive = ($activeCount -gt 0)
  } | ConvertTo-Json -Compress
} catch {
  @{
    audioSessionCount = 0
    audioSessionActive = $false
    error = "media_session_unavailable"
  } | ConvertTo-Json -Compress
}
`.trim();
  const shell = runWindowsPowerShellJson(script, 1200);
  if (!shell.ok || !shell.value) {
    return {
      signals: {},
      limitations: [`audio_probe_failed:${shell.error ?? "unknown"}`]
    };
  }
  const sessionCountRaw = Number(shell.value.audioSessionCount ?? Number.NaN);
  const audioSessionCount = Number.isFinite(sessionCountRaw) ? Math.max(0, Math.floor(sessionCountRaw)) : 0;
  return {
    signals: {
      audioSessionCount,
      audioSessionActive: Boolean(shell.value.audioSessionActive) || audioSessionCount > 0,
      audioActive: Boolean(shell.value.audioSessionActive) || audioSessionCount > 0
    },
    limitations: typeof shell.value.error === "string" && shell.value.error.trim().length > 0 ? [shell.value.error.trim()] : []
  };
}

// src/daemon/psyche/sensors/foreground.ts
var lastWindowKey = "";
var switchEventsMs = [];
function normalizeForegroundCategory(processName, title) {
  const processText = processName.toLowerCase();
  const titleText = title.toLowerCase();
  const text = `${processText} ${titleText}`;
  if (["code", "cursor", "webstorm", "pycharm", "idea64", "devenv"].some((item) => processText.includes(item))) {
    return "ide";
  }
  if (["cmd", "powershell", "pwsh", "windowsterminal", "bash", "wt"].some((item) => processText.includes(item))) {
    return "terminal";
  }
  if (["qq", "wechat", "telegram", "discord", "slack", "teams"].some((item) => processText.includes(item))) {
    return "chat";
  }
  if ([
    "steam",
    "epicgameslauncher",
    "riotclientservices",
    "battle.net",
    "game"
  ].some((item) => text.includes(item))) {
    return "game";
  }
  if ([
    "vlc",
    "potplayer",
    "mpv",
    "movies",
    "media player",
    "netflix",
    "youtube"
  ].some((item) => text.includes(item))) {
    return "player";
  }
  if (["chrome", "msedge", "firefox", "opera", "brave", "safari"].some((item) => processText.includes(item))) {
    return "browser";
  }
  if (!processText && !titleText)
    return "unknown";
  return "other";
}
function calculateSwitchRate(windowKey, nowMs) {
  if (windowKey && windowKey !== lastWindowKey) {
    switchEventsMs.push(nowMs);
    lastWindowKey = windowKey;
  }
  while (switchEventsMs.length > 0 && nowMs - switchEventsMs[0] > 60000) {
    switchEventsMs.shift();
  }
  return switchEventsMs.length;
}
function sampleForegroundSignal(nowMs = Date.now()) {
  const script = `
Add-Type -AssemblyName System.Windows.Forms
Add-Type @"
using System;
using System.Runtime.InteropServices;
using System.Text;
public static class MiyaForegroundProbe {
  [StructLayout(LayoutKind.Sequential)]
  public struct RECT { public int Left; public int Top; public int Right; public int Bottom; }
  [DllImport("user32.dll")] public static extern IntPtr GetForegroundWindow();
  [DllImport("user32.dll")] public static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int maxCount);
  [DllImport("user32.dll")] public static extern bool GetWindowRect(IntPtr hWnd, out RECT rect);
  [DllImport("user32.dll")] public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);
}
"@
$hwnd = [MiyaForegroundProbe]::GetForegroundWindow()
if ($hwnd -eq [IntPtr]::Zero) {
  @{ process=''; title=''; fullscreen=$false } | ConvertTo-Json -Compress
  exit 0
}
$pid = 0
[void][MiyaForegroundProbe]::GetWindowThreadProcessId($hwnd, [ref]$pid)
$titleBuilder = New-Object System.Text.StringBuilder 4096
[void][MiyaForegroundProbe]::GetWindowText($hwnd, $titleBuilder, $titleBuilder.Capacity)
$title = $titleBuilder.ToString()
$processName = ''
try {
  $processName = (Get-Process -Id $pid -ErrorAction Stop).ProcessName
} catch {}
$isFullscreen = $false
try {
  $rect = New-Object MiyaForegroundProbe+RECT
  if ([MiyaForegroundProbe]::GetWindowRect($hwnd, [ref]$rect)) {
    $w = [Math]::Abs($rect.Right - $rect.Left)
    $h = [Math]::Abs($rect.Bottom - $rect.Top)
    $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
    if ($w -ge ($bounds.Width - 6) -and $h -ge ($bounds.Height - 6)) {
      $isFullscreen = $true
    }
  }
} catch {}
@{ process=$processName; title=$title; fullscreen=$isFullscreen } | ConvertTo-Json -Compress
`.trim();
  const shell = runWindowsPowerShellJson(script, 900);
  if (!shell.ok || !shell.value) {
    return {
      signals: {
        foreground: "unknown"
      },
      limitations: [`foreground_probe_failed:${shell.error ?? "unknown"}`]
    };
  }
  const processName = String(shell.value.process ?? "").trim();
  const title = String(shell.value.title ?? "").trim();
  const category = normalizeForegroundCategory(processName, title);
  const windowKey = `${processName.toLowerCase()}|${title.toLowerCase()}`;
  const windowSwitchPerMin = calculateSwitchRate(windowKey, nowMs);
  return {
    signals: {
      foreground: category,
      foregroundTitle: title,
      fullscreen: Boolean(shell.value.fullscreen),
      windowSwitchPerMin
    },
    limitations: []
  };
}

// src/daemon/psyche/sensors/gamepad.ts
function sampleGamepadSignal() {
  const script = `
Add-Type @"
using System;
using System.Runtime.InteropServices;
public static class MiyaXInputProbe {
  [StructLayout(LayoutKind.Sequential)]
  public struct XINPUT_GAMEPAD {
    public ushort wButtons;
    public byte bLeftTrigger;
    public byte bRightTrigger;
    public short sThumbLX;
    public short sThumbLY;
    public short sThumbRX;
    public short sThumbRY;
  }
  [StructLayout(LayoutKind.Sequential)]
  public struct XINPUT_STATE {
    public uint dwPacketNumber;
    public XINPUT_GAMEPAD Gamepad;
  }
  [DllImport("xinput1_4.dll", EntryPoint="XInputGetState")]
  public static extern uint XInputGetState14(uint dwUserIndex, out XINPUT_STATE pState);
  [DllImport("xinput9_1_0.dll", EntryPoint="XInputGetState")]
  public static extern uint XInputGetState910(uint dwUserIndex, out XINPUT_STATE pState);
}
"@
$active = $false
$probeErr = ''
for ($i = 0; $i -lt 4; $i++) {
  $state = New-Object MiyaXInputProbe+XINPUT_STATE
  $ret = 1167
  try { $ret = [MiyaXInputProbe]::XInputGetState14([uint32]$i, [ref]$state) } catch {}
  if ($ret -ne 0) {
    try { $ret = [MiyaXInputProbe]::XInputGetState910([uint32]$i, [ref]$state) } catch {}
  }
  if ($ret -eq 0) {
    if (
      $state.Gamepad.wButtons -ne 0 -or
      $state.Gamepad.bLeftTrigger -gt 10 -or
      $state.Gamepad.bRightTrigger -gt 10 -or
      [Math]::Abs($state.Gamepad.sThumbLX) -gt 4000 -or
      [Math]::Abs($state.Gamepad.sThumbLY) -gt 4000 -or
      [Math]::Abs($state.Gamepad.sThumbRX) -gt 4000 -or
      [Math]::Abs($state.Gamepad.sThumbRY) -gt 4000
    ) {
      $active = $true
      break
    }
  } elseif ($ret -ne 1167) {
    $probeErr = "xinput_code_" + $ret
  }
}
@{
  xinputActive = $active
  gamepadActive = $active
  error = $probeErr
} | ConvertTo-Json -Compress
`.trim();
  const shell = runWindowsPowerShellJson(script, 900);
  if (!shell.ok || !shell.value) {
    return {
      signals: {},
      limitations: [`gamepad_probe_failed:${shell.error ?? "unknown"}`]
    };
  }
  return {
    signals: {
      xinputActive: Boolean(shell.value.xinputActive),
      gamepadActive: Boolean(shell.value.gamepadActive)
    },
    limitations: typeof shell.value.error === "string" && shell.value.error.trim().length > 0 ? [shell.value.error.trim()] : []
  };
}

// src/daemon/psyche/sensors/input.ts
var inputEventsMs = [];
var previousIdleSec;
function updateApm(input, nowMs) {
  const idle = Number.isFinite(input.idleSec) ? Number(input.idleSec) : undefined;
  if (input.rawInputActive) {
    inputEventsMs.push(nowMs);
  }
  if (idle !== undefined && previousIdleSec !== undefined && idle + 0.2 < previousIdleSec) {
    inputEventsMs.push(nowMs);
  }
  previousIdleSec = idle;
  while (inputEventsMs.length > 0 && nowMs - inputEventsMs[0] > 60000) {
    inputEventsMs.shift();
  }
  return inputEventsMs.length;
}
function sampleInputSignal(nowMs = Date.now()) {
  const script = `
Add-Type @"
using System;
using System.Runtime.InteropServices;
public static class MiyaInputSignal {
  [StructLayout(LayoutKind.Sequential)]
  public struct LASTINPUTINFO {
    public uint cbSize;
    public uint dwTime;
  }
  [DllImport("user32.dll")] public static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);
  [DllImport("kernel32.dll")] public static extern ulong GetTickCount64();
  [DllImport("user32.dll")] public static extern short GetAsyncKeyState(int vKey);
}
"@
$idleSec = 0.0
try {
  $lii = New-Object MiyaInputSignal+LASTINPUTINFO
  $lii.cbSize = [System.Runtime.InteropServices.Marshal]::SizeOf([type]'MiyaInputSignal+LASTINPUTINFO')
  if ([MiyaInputSignal]::GetLastInputInfo([ref]$lii)) {
    $tick = [double][MiyaInputSignal]::GetTickCount64()
    $delta = [Math]::Max(0, $tick - [double]$lii.dwTime)
    $idleSec = [Math]::Round($delta / 1000.0, 3)
  }
} catch {}
$active = $false
$keys = @(0x01,0x02,0x08,0x09,0x0D,0x10,0x11,0x12,0x1B,0x20,0x25,0x26,0x27,0x28)
foreach ($vk in $keys) {
  if (([MiyaInputSignal]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) {
    $active = $true
    break
  }
}
@{
  idleSec = $idleSec
  rawInputActive = $active
} | ConvertTo-Json -Compress
`.trim();
  const shell = runWindowsPowerShellJson(script, 900);
  if (!shell.ok || !shell.value) {
    return {
      signals: {},
      limitations: [`input_probe_failed:${shell.error ?? "unknown"}`]
    };
  }
  const idleSec = Number(shell.value.idleSec ?? Number.NaN);
  const rawInputActive = Boolean(shell.value.rawInputActive);
  const apm = updateApm({
    idleSec: Number.isFinite(idleSec) ? idleSec : undefined,
    rawInputActive
  }, nowMs);
  return {
    signals: {
      idleSec: Number.isFinite(idleSec) ? Number(idleSec.toFixed(2)) : undefined,
      rawInputActive,
      apm
    },
    limitations: []
  };
}

// src/daemon/psyche/sensors/index.ts
function nowIso23() {
  return new Date().toISOString();
}
function mergeCaptureLimitations2(parts) {
  const merged = parts.flat().map((item) => String(item ?? "").trim()).filter(Boolean);
  return [...new Set(merged)].slice(0, 24);
}
function collectNativeSentinelSignals() {
  const input = sampleInputSignal();
  const foreground = sampleForegroundSignal();
  const audio = sampleAudioSignal();
  const gamepad = sampleGamepadSignal();
  return {
    sampledAt: nowIso23(),
    signals: {
      ...input.signals,
      ...foreground.signals,
      ...audio.signals,
      ...gamepad.signals
    },
    captureLimitations: mergeCaptureLimitations2([
      input.limitations,
      foreground.limitations,
      audio.limitations,
      gamepad.limitations
    ])
  };
}

// src/daemon/psyche/slow-brain.ts
import { createHash as createHash11 } from "node:crypto";
import * as fs39 from "node:fs";
import * as path38 from "node:path";

// src/daemon/psyche/training-summary.ts
import * as fs38 from "node:fs";
import * as path37 from "node:path";
function nowIso24() {
  return new Date().toISOString();
}
function trainingFile(projectDir) {
  return path37.join(getMiyaRuntimeDir(projectDir), "daemon", "psyche", "training-data.jsonl");
}
function safeParse5(line) {
  try {
    return JSON.parse(line);
  } catch {
    return null;
  }
}
function readPsycheTrainingSummary(projectDir, limit = 400) {
  const file3 = trainingFile(projectDir);
  if (!fs38.existsSync(file3)) {
    return {
      windowRows: 0,
      observations: 0,
      outcomes: 0,
      decisions: { allow: 0, defer: 0, deny: 0 },
      outcomesSummary: {
        positive: 0,
        negative: 0,
        avgScore: 0,
        positiveRate: 0
      },
      resonance: {
        safeHoldDefers: 0,
        probeRequested: 0,
        falseIdleRiskSignals: 0,
        drmCaptureBlockedSignals: 0
      },
      generatedAt: nowIso24()
    };
  }
  const rows = fs38.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).slice(-Math.max(20, Math.min(5000, limit))).map((line) => safeParse5(line)).filter((row) => Boolean(row));
  let observations = 0;
  let outcomes = 0;
  const decisions = { allow: 0, defer: 0, deny: 0 };
  let positive = 0;
  let negative = 0;
  let scoreTotal = 0;
  let scoreCount = 0;
  let safeHoldDefers = 0;
  let probeRequested = 0;
  let falseIdleRiskSignals = 0;
  let drmCaptureBlockedSignals = 0;
  for (const row of rows) {
    if (row.type === "observation") {
      observations += 1;
      if (row.obs?.decision === "allow")
        decisions.allow += 1;
      else if (row.obs?.decision === "deny")
        decisions.deny += 1;
      else if (row.obs?.decision === "defer")
        decisions.defer += 1;
      if (row.obs?.shouldProbeScreen)
        probeRequested += 1;
      const reasons = Array.isArray(row.obs?.reasons) ? row.obs?.reasons.map((item) => String(item)) : [];
      if (reasons.some((item) => item.includes("shadow_mode_safe_hold") || item.includes("safe_hold"))) {
        safeHoldDefers += 1;
      }
      if (reasons.some((item) => item.includes("input_signal_conflict") || item.includes("idle_with_media_signal_needs_probe") || item.includes("probe_failed_with_media_signals"))) {
        falseIdleRiskSignals += 1;
      }
      if (reasons.some((item) => item.includes("screen_probe_capture_protected") || item.includes("capture_limitations_present"))) {
        drmCaptureBlockedSignals += 1;
      }
      continue;
    }
    if (row.type === "action_outcome") {
      outcomes += 1;
      if (row.action?.reward === "positive")
        positive += 1;
      if (row.action?.reward === "negative")
        negative += 1;
      if (Number.isFinite(row.action?.score)) {
        scoreTotal += Number(row.action?.score);
        scoreCount += 1;
      }
      if (String(row.action?.blockedReason ?? "").includes("safe_hold")) {
        safeHoldDefers += 1;
      }
    }
  }
  const positiveRate = outcomes > 0 ? Number((positive / outcomes).toFixed(4)) : 0;
  const avgScore = scoreCount > 0 ? Number((scoreTotal / scoreCount).toFixed(4)) : 0;
  return {
    windowRows: rows.length,
    observations,
    outcomes,
    decisions,
    outcomesSummary: {
      positive,
      negative,
      avgScore,
      positiveRate
    },
    resonance: {
      safeHoldDefers,
      probeRequested,
      falseIdleRiskSignals,
      drmCaptureBlockedSignals
    },
    generatedAt: nowIso24()
  };
}

// src/daemon/psyche/slow-brain.ts
function nowIso25() {
  return new Date().toISOString();
}
function clamp6(input, min, max) {
  if (!Number.isFinite(input))
    return min;
  return Math.max(min, Math.min(max, Number(input.toFixed(4))));
}
function slowBrainFile(projectDir) {
  return path38.join(getMiyaRuntimeDir(projectDir), "daemon", "psyche", "slow-brain.json");
}
function defaultParameters() {
  return {
    consumeAllowThreshold: 0.6,
    awayAllowThreshold: 0.35,
    deferRetryBaseSec: 120,
    confidenceBoost: 0.55
  };
}
function defaultPolicy2() {
  return {
    versionID: "sb_default",
    createdAt: nowIso25(),
    source: {
      windowRows: 0,
      outcomes: 0
    },
    metrics: {
      positiveRate: 0,
      avgScore: 0,
      safeHoldDefers: 0,
      falseIdleRiskSignals: 0,
      drmCaptureBlockedSignals: 0
    },
    parameters: defaultParameters()
  };
}
function normalizePolicy(raw) {
  if (!raw || typeof raw !== "object" || Array.isArray(raw))
    return null;
  const row = raw;
  const versionID = String(row.versionID ?? "").trim();
  if (!versionID)
    return null;
  const createdAt = typeof row.createdAt === "string" ? row.createdAt : nowIso25();
  const sourceRaw = row.source && typeof row.source === "object" && !Array.isArray(row.source) ? row.source : {};
  const metricsRaw = row.metrics && typeof row.metrics === "object" && !Array.isArray(row.metrics) ? row.metrics : {};
  const paramsRaw = row.parameters && typeof row.parameters === "object" && !Array.isArray(row.parameters) ? row.parameters : {};
  const source = {
    windowRows: Math.max(0, Number(sourceRaw.windowRows ?? 0) || 0),
    outcomes: Math.max(0, Number(sourceRaw.outcomes ?? 0) || 0)
  };
  const metrics = {
    positiveRate: clamp6(Number(metricsRaw.positiveRate ?? 0), 0, 1),
    avgScore: clamp6(Number(metricsRaw.avgScore ?? 0), -1, 1),
    safeHoldDefers: Math.max(0, Number(metricsRaw.safeHoldDefers ?? 0) || 0),
    falseIdleRiskSignals: Math.max(0, Number(metricsRaw.falseIdleRiskSignals ?? 0) || 0),
    drmCaptureBlockedSignals: Math.max(0, Number(metricsRaw.drmCaptureBlockedSignals ?? 0) || 0)
  };
  const defaults = defaultParameters();
  const parameters = {
    consumeAllowThreshold: clamp6(Number(paramsRaw.consumeAllowThreshold ?? defaults.consumeAllowThreshold), 0.3, 0.9),
    awayAllowThreshold: clamp6(Number(paramsRaw.awayAllowThreshold ?? defaults.awayAllowThreshold), 0.15, 0.8),
    deferRetryBaseSec: Math.max(15, Math.min(900, Math.floor(Number(paramsRaw.deferRetryBaseSec ?? defaults.deferRetryBaseSec) || 0))),
    confidenceBoost: clamp6(Number(paramsRaw.confidenceBoost ?? defaults.confidenceBoost), 0.2, 0.95)
  };
  return {
    versionID,
    createdAt,
    source,
    metrics,
    parameters
  };
}
function normalizeState2(raw) {
  if (!raw || typeof raw !== "object" || Array.isArray(raw)) {
    return {
      versions: [],
      status: "idle",
      updatedAt: nowIso25()
    };
  }
  const row = raw;
  const versions3 = Array.isArray(row.versions) ? row.versions.map(normalizePolicy).filter((item) => Boolean(item)) : [];
  return {
    activeVersionID: typeof row.activeVersionID === "string" && row.activeVersionID.trim().length > 0 ? row.activeVersionID.trim() : undefined,
    versions: versions3,
    status: row.status === "trained" || row.status === "rolled_back" || row.status === "skipped" || row.status === "idle" ? row.status : "idle",
    updatedAt: typeof row.updatedAt === "string" ? row.updatedAt : nowIso25(),
    lastRetrainAt: typeof row.lastRetrainAt === "string" ? row.lastRetrainAt : undefined,
    lastRollbackAt: typeof row.lastRollbackAt === "string" ? row.lastRollbackAt : undefined,
    lastSkipReason: typeof row.lastSkipReason === "string" ? row.lastSkipReason : undefined
  };
}
function writeState4(projectDir, state) {
  const file3 = slowBrainFile(projectDir);
  fs39.mkdirSync(path38.dirname(file3), { recursive: true });
  fs39.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
}
function summarizeToPolicy(summary) {
  const positiveRate = clamp6(summary.outcomesSummary.positiveRate, 0, 1);
  const avgScore = clamp6(summary.outcomesSummary.avgScore, -1, 1);
  const safeHoldPressure = clamp6(summary.resonance.safeHoldDefers / Math.max(1, summary.observations), 0, 1);
  const falseIdlePressure = clamp6(summary.resonance.falseIdleRiskSignals / Math.max(1, summary.observations), 0, 1);
  const drmPressure = clamp6(summary.resonance.drmCaptureBlockedSignals / Math.max(1, summary.observations), 0, 1);
  const consumeAllowThreshold = clamp6(0.52 + (0.5 - positiveRate) * 0.25 + falseIdlePressure * 0.18 + drmPressure * 0.1, 0.35, 0.88);
  const awayAllowThreshold = clamp6(0.28 + (0.5 - positiveRate) * 0.2 + falseIdlePressure * 0.08, 0.18, 0.72);
  const deferRetryBaseSec = Math.max(30, Math.min(900, Math.floor(90 + summary.resonance.safeHoldDefers * 3 + falseIdlePressure * 120)));
  const confidenceBoost = clamp6(0.5 + positiveRate * 0.3 - falseIdlePressure * 0.15 - drmPressure * 0.08 + avgScore * 0.1, 0.2, 0.92);
  const digest = createHash11("sha1").update(JSON.stringify({
    windowRows: summary.windowRows,
    outcomes: summary.outcomes,
    positiveRate,
    avgScore,
    safeHoldPressure,
    falseIdlePressure,
    drmPressure
  })).digest("hex").slice(0, 10);
  return {
    versionID: `sb_${Date.now().toString(36)}_${digest}`,
    createdAt: nowIso25(),
    source: {
      windowRows: summary.windowRows,
      outcomes: summary.outcomes
    },
    metrics: {
      positiveRate,
      avgScore,
      safeHoldDefers: summary.resonance.safeHoldDefers,
      falseIdleRiskSignals: summary.resonance.falseIdleRiskSignals,
      drmCaptureBlockedSignals: summary.resonance.drmCaptureBlockedSignals
    },
    parameters: {
      consumeAllowThreshold,
      awayAllowThreshold,
      deferRetryBaseSec,
      confidenceBoost
    }
  };
}
function readSlowBrainState(projectDir) {
  const file3 = slowBrainFile(projectDir);
  if (!fs39.existsSync(file3)) {
    const state = {
      versions: [],
      status: "idle",
      updatedAt: nowIso25()
    };
    writeState4(projectDir, state);
    return state;
  }
  try {
    const parsed = JSON.parse(fs39.readFileSync(file3, "utf-8"));
    const state = normalizeState2(parsed);
    writeState4(projectDir, state);
    return state;
  } catch {
    const state = {
      versions: [],
      status: "idle",
      updatedAt: nowIso25()
    };
    writeState4(projectDir, state);
    return state;
  }
}
function getActiveSlowBrainPolicy(projectDir) {
  const state = readSlowBrainState(projectDir);
  if (state.activeVersionID) {
    const active = state.versions.find((item) => item.versionID === state.activeVersionID);
    if (active)
      return active;
  }
  if (state.versions.length > 0)
    return state.versions[state.versions.length - 1];
  return defaultPolicy2();
}
function retrainSlowBrainPolicy(projectDir, options) {
  const minOutcomes = Math.max(1, Math.floor(options?.minOutcomes ?? 20));
  const summary = options?.summary ?? readPsycheTrainingSummary(projectDir, options?.trainingWindow ?? 600);
  const state = readSlowBrainState(projectDir);
  if (!options?.force && summary.outcomes < minOutcomes) {
    const skipped = {
      ...state,
      status: "skipped",
      updatedAt: nowIso25(),
      lastSkipReason: "insufficient_outcomes"
    };
    writeState4(projectDir, skipped);
    return {
      ok: false,
      reason: "skipped_insufficient_outcomes",
      state: skipped
    };
  }
  const policy = summarizeToPolicy(summary);
  const versions3 = [...state.versions, policy].slice(-12);
  const next = {
    ...state,
    activeVersionID: policy.versionID,
    versions: versions3,
    status: "trained",
    updatedAt: nowIso25(),
    lastRetrainAt: nowIso25(),
    lastSkipReason: undefined
  };
  writeState4(projectDir, next);
  return {
    ok: true,
    reason: "trained",
    policy,
    state: next
  };
}
function rollbackSlowBrainPolicy(projectDir, targetVersionID) {
  const state = readSlowBrainState(projectDir);
  if (state.versions.length <= 1 && !targetVersionID) {
    return {
      ok: false,
      reason: "rollback_history_insufficient",
      state
    };
  }
  const currentID = state.activeVersionID;
  const target = targetVersionID ? state.versions.find((item) => item.versionID === targetVersionID) : [...state.versions].reverse().find((item) => item.versionID !== currentID);
  if (!target) {
    return {
      ok: false,
      reason: targetVersionID ? "rollback_target_not_found" : "rollback_history_insufficient",
      state
    };
  }
  if (currentID && currentID === target.versionID) {
    return {
      ok: false,
      reason: "rollback_already_active",
      state
    };
  }
  const next = {
    ...state,
    activeVersionID: target.versionID,
    status: "rolled_back",
    updatedAt: nowIso25(),
    lastRollbackAt: nowIso25()
  };
  writeState4(projectDir, next);
  return {
    ok: true,
    reason: "rolled_back",
    state: next
  };
}

// src/daemon/psyche/state-machine.ts
function asFinite(value) {
  if (typeof value !== "number")
    return;
  if (!Number.isFinite(value))
    return;
  return value;
}
function toConfidence(raw) {
  if (!Number.isFinite(raw))
    return 0;
  return Math.max(0, Math.min(1, Number(raw.toFixed(2))));
}
function hasKeyword(text, keywords) {
  const normalized = text.toLowerCase();
  return keywords.some((keyword) => normalized.includes(keyword));
}
function inferSentinelState(input) {
  const signals = input ?? {};
  const idleSec = asFinite(signals.idleSec);
  const foreground = signals.foreground ?? "unknown";
  const foregroundTitle = String(signals.foregroundTitle ?? "").trim().toLowerCase();
  const fullscreen = Boolean(signals.fullscreen);
  const audioSessionCount = asFinite(signals.audioSessionCount) ?? 0;
  const audioActive = Boolean(signals.audioActive || signals.audioSessionActive || audioSessionCount > 0);
  const gamepadActive = Boolean(signals.gamepadActive || signals.xinputActive);
  const rawInputActive = Boolean(signals.rawInputActive);
  const switchRate = asFinite(signals.windowSwitchPerMin) ?? 0;
  const apm = asFinite(signals.apm) ?? 0;
  const captureLimitations = Array.isArray(signals.captureLimitations) ? signals.captureLimitations.map((item) => String(item || "").trim().toLowerCase()).filter((item) => item.length > 0) : [];
  const screenProbe = signals.screenProbe ?? "not_run";
  const reasons = [];
  let shouldProbeScreen = false;
  const looksLikeProtectedCapture = captureLimitations.some((item) => ["drm", "hdcp", "protected", "pmp", "copyright"].some((flag) => item.includes(flag)));
  const inputSignalConflict = (idleSec ?? 0) >= 120 && (rawInputActive || switchRate >= 10) || (foreground === "game" || foreground === "player") && !audioActive && (idleSec ?? 0) >= 120 && switchRate >= 8;
  const probeFailed = screenProbe === "black" || screenProbe === "error" || screenProbe === "timeout";
  if (probeFailed) {
    reasons.push(`screen_probe_${screenProbe}`);
    if (looksLikeProtectedCapture || screenProbe === "black") {
      reasons.push("screen_probe_capture_protected");
    }
    reasons.push(audioActive || fullscreen ? "probe_failed_with_media_signals" : "probe_failed_fallback_unknown");
    return {
      state: "UNKNOWN",
      confidence: toConfidence(audioActive || fullscreen ? 0.46 : 0.41),
      reasons,
      shouldProbeScreen: false
    };
  }
  if (inputSignalConflict) {
    shouldProbeScreen = fullscreen || audioActive || foreground === "game" || foreground === "player";
    reasons.push("input_signal_conflict");
    return {
      state: "UNKNOWN",
      confidence: toConfidence(0.44),
      reasons,
      shouldProbeScreen
    };
  }
  if (foreground === "game" && !gamepadActive && (idleSec ?? 0) >= 240 && !audioActive) {
    shouldProbeScreen = true;
    reasons.push("foreground_game_without_input_needs_probe");
    return {
      state: "UNKNOWN",
      confidence: toConfidence(0.48),
      reasons,
      shouldProbeScreen
    };
  }
  if (gamepadActive || foreground === "game") {
    reasons.push(gamepadActive ? "gamepad_active" : "foreground_game");
    if (rawInputActive)
      reasons.push("raw_input_active");
    return {
      state: "PLAY",
      confidence: toConfidence(gamepadActive ? 0.95 : 0.86),
      reasons,
      shouldProbeScreen: false
    };
  }
  if ((fullscreen || foreground === "player") && audioActive && (idleSec ?? 0) >= 30) {
    reasons.push(fullscreen ? "fullscreen_with_audio" : "player_with_audio");
    return {
      state: "CONSUME",
      confidence: toConfidence(0.88),
      reasons,
      shouldProbeScreen: false
    };
  }
  if ((foreground === "ide" || foreground === "terminal" || foreground === "browser" && apm >= 60) && (idleSec ?? 0) < 210 && !fullscreen) {
    reasons.push(`foreground_${foreground}`);
    if (switchRate >= 8) {
      reasons.push("window_switch_high");
    }
    if (hasKeyword(foregroundTitle, [
      "debug",
      "breakpoint",
      "exception",
      "attach"
    ])) {
      reasons.push("semantic_focus_stress");
    } else if (hasKeyword(foregroundTitle, ["build", "compile", "ci", "test"])) {
      reasons.push("semantic_focus_build");
    } else if (hasKeyword(foregroundTitle, ["readme", "docs", "notion", "wiki"])) {
      reasons.push("semantic_focus_doc");
    }
    return {
      state: "FOCUS",
      confidence: toConfidence(switchRate >= 8 ? 0.9 : 0.82),
      reasons,
      shouldProbeScreen: false
    };
  }
  if (idleSec !== undefined && idleSec >= 360 && !audioActive && !fullscreen && !gamepadActive && !rawInputActive && switchRate <= 1) {
    reasons.push("long_idle_without_media_or_gamepad");
    return {
      state: "AWAY",
      confidence: toConfidence(0.84),
      reasons,
      shouldProbeScreen: false
    };
  }
  if ((idleSec ?? 0) >= 90 && (audioActive || fullscreen || foreground === "player")) {
    shouldProbeScreen = true;
    reasons.push("idle_with_media_signal_needs_probe");
  }
  if (looksLikeProtectedCapture) {
    reasons.push("capture_limitations_present");
  }
  if (signals.stateTransition) {
    reasons.push(`state_transition_${String(signals.stateTransition).toLowerCase()}`);
  }
  reasons.push(`foreground_${foreground}`);
  return {
    state: "UNKNOWN",
    confidence: toConfidence(0.5),
    reasons,
    shouldProbeScreen
  };
}

// src/daemon/psyche/trust.ts
import * as fs40 from "node:fs";
var DEFAULT_SCORE = 50;
var MIN_SCORE = 0;
var MAX_SCORE = 100;
var MAX_WINDOW = 10;
function nowIso26() {
  return new Date().toISOString();
}
function clampScore(value) {
  return Math.max(MIN_SCORE, Math.min(MAX_SCORE, Math.floor(value)));
}
function entityKey(kind, value) {
  return `${kind}:${value.trim().toLowerCase()}`;
}
function shiftWindow(value) {
  const normalized = Math.max(0, Math.floor(value));
  if (normalized < MAX_WINDOW)
    return normalized;
  return MAX_WINDOW - 1;
}
function readStore9(filePath8) {
  if (!fs40.existsSync(filePath8))
    return { entities: {} };
  try {
    const parsed = JSON.parse(fs40.readFileSync(filePath8, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.entities)
      return { entities: {} };
    return parsed;
  } catch {
    return { entities: {} };
  }
}
function writeStore7(filePath8, store) {
  fs40.writeFileSync(filePath8, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function seedScore() {
  return {
    score: DEFAULT_SCORE,
    approvedCount10: 0,
    deniedCount10: 0,
    usefulCount10: 0,
    uselessCount10: 0,
    lastDecisionAt: nowIso26(),
    autoBlacklisted: false
  };
}
function getTrustScore(filePath8, input) {
  const value = String(input.value ?? "").trim();
  if (!value)
    return DEFAULT_SCORE;
  const store = readStore9(filePath8);
  return store.entities[entityKey(input.kind, value)]?.score ?? DEFAULT_SCORE;
}
function updateTrustScore(filePath8, input) {
  const value = String(input.value ?? "").trim();
  if (!value)
    return seedScore();
  const store = readStore9(filePath8);
  const key = entityKey(input.kind, value);
  const current = store.entities[key] ?? seedScore();
  const confidence = Number.isFinite(input.confidence) ? Number(input.confidence) : 1;
  let score = current.score;
  if (input.highRiskRollback) {
    score = 20;
  } else if (input.approved) {
    score += 5;
  } else {
    score -= 8;
  }
  if (confidence < 0.5)
    score -= 10;
  const nextApproved = input.approved ? shiftWindow(current.approvedCount10) + 1 : shiftWindow(current.approvedCount10);
  const nextDenied = input.approved ? shiftWindow(current.deniedCount10) : shiftWindow(current.deniedCount10) + 1;
  const useful = input.approved ? shiftWindow(current.usefulCount10) + 1 : shiftWindow(current.usefulCount10);
  const useless = input.approved ? shiftWindow(current.uselessCount10) : shiftWindow(current.uselessCount10) + 1;
  const autoBlacklisted = useful < useless;
  const next = {
    score: clampScore(score),
    approvedCount10: Math.min(MAX_WINDOW, nextApproved),
    deniedCount10: Math.min(MAX_WINDOW, nextDenied),
    usefulCount10: Math.min(MAX_WINDOW, useful),
    uselessCount10: Math.min(MAX_WINDOW, useless),
    lastDecisionAt: nowIso26(),
    autoBlacklisted
  };
  store.entities[key] = next;
  writeStore7(filePath8, store);
  return next;
}
function trustTierFromScore(score) {
  if (score >= 90)
    return "high";
  if (score >= 50)
    return "medium";
  return "low";
}

// src/daemon/psyche/consult.ts
var DEFAULT_BUDGETS = {
  FOCUS: { maxActions: 1, windowSec: 3600 },
  CONSUME: { maxActions: 1, windowSec: 2400 },
  PLAY: { maxActions: 0, windowSec: 3600 },
  AWAY: { maxActions: 2, windowSec: 3600 },
  UNKNOWN: { maxActions: 0, windowSec: 1800 }
};
var defaultRandomSource = {
  next: () => Math.random()
};
function nowIso27() {
  return new Date().toISOString();
}
function clamp7(value, min, max) {
  if (!Number.isFinite(value))
    return min;
  return Math.max(min, Math.min(max, Number(value.toFixed(4))));
}
function asUrgency(value) {
  return value === "low" || value === "high" || value === "critical" ? value : "medium";
}

class PsycheConsultService {
  projectDir;
  fastBrainPath;
  consultLogPath;
  budgetPath;
  probeBudgetPath;
  trainingDataLogPath;
  trustPath;
  lifecyclePath;
  epsilon;
  shadowModeDays;
  random;
  delayedPenaltyApplied = new Set;
  nativeSignalsProvider;
  screenProbeProvider;
  constructor(projectDir, options) {
    this.projectDir = projectDir;
    const psycheDir = path39.join(getMiyaRuntimeDir(projectDir), "daemon", "psyche");
    fs41.mkdirSync(psycheDir, { recursive: true });
    this.fastBrainPath = path39.join(psycheDir, "fast-brain.json");
    this.consultLogPath = path39.join(psycheDir, "consult.jsonl");
    this.budgetPath = path39.join(psycheDir, "interruption-budget.json");
    this.probeBudgetPath = path39.join(psycheDir, "probe-budget.json");
    this.trainingDataLogPath = path39.join(psycheDir, "training-data.jsonl");
    this.trustPath = path39.join(psycheDir, "trust-score.json");
    this.lifecyclePath = path39.join(psycheDir, "lifecycle.json");
    this.epsilon = Math.max(0, Math.min(0.1, options?.epsilon ?? this.resolveEpsilonFromEnv()));
    this.shadowModeDays = this.resolveShadowModeDays(options?.shadowModeDays);
    this.random = options?.random ?? defaultRandomSource;
    this.nativeSignalsProvider = options?.nativeSignalsProvider ?? (() => collectNativeSentinelSignals());
    this.screenProbeProvider = options?.screenProbeProvider ?? ((probeInput) => runScreenProbe(probeInput));
    this.ensureLifecycleState();
  }
  consult(input) {
    const intent = String(input.intent ?? "").trim() || "unknown_intent";
    const urgency = asUrgency(input.urgency);
    const userInitiated = input.userInitiated !== false;
    const nativeSample = this.safeReadNativeSignals();
    const incomingSignals = input.signals ?? {};
    const allowSignalOverride = input.allowSignalOverride === true;
    let sampledSignals = allowSignalOverride ? {
      ...incomingSignals
    } : {
      ...incomingSignals,
      ...nativeSample.signals
    };
    let captureLimitations = this.normalizeCaptureLimitations([
      ...Array.isArray(input.captureLimitations) ? input.captureLimitations : [],
      ...Array.isArray(incomingSignals.captureLimitations) ? incomingSignals.captureLimitations : [],
      ...nativeSample.captureLimitations
    ]);
    let sentinel = inferSentinelState({
      ...sampledSignals,
      captureLimitations
    });
    const probeEnabled = input.allowScreenProbe !== false;
    const needsProbe = sentinel.shouldProbeScreen && probeEnabled;
    const probeBudget = needsProbe ? consumeProbeBudget(this.probeBudgetPath, this.probeBudgetConfig()) : { allowed: false, remainingTokens: 0 };
    let shouldProbeScreen = false;
    let probeMethod = "";
    let probeConfidence;
    let probeSceneTags = [];
    let probeStatus = "not_run";
    if (needsProbe && probeBudget.allowed) {
      const probe = this.safeRunScreenProbe({
        intent,
        channel: input.channel,
        timeoutMs: this.resolveProbeTimeoutMs()
      });
      shouldProbeScreen = true;
      probeMethod = probe.method ?? "";
      probeConfidence = probe.confidence;
      probeSceneTags = probe.sceneTags;
      probeStatus = probe.status;
      captureLimitations = this.normalizeCaptureLimitations([
        ...captureLimitations,
        ...probe.captureLimitations
      ]);
      sampledSignals = {
        ...sampledSignals,
        ...probe.inferredSignals
      };
      sentinel = inferSentinelState({
        ...sampledSignals,
        captureLimitations,
        screenProbe: probe.status
      });
    }
    const state = sentinel.state;
    const auditID = randomUUID16();
    const at = nowIso27();
    const shadowModeActive = this.isShadowModeActive();
    const fastBrainScore = readFastBrainScore(this.fastBrainPath, {
      state,
      intent,
      urgency,
      channel: input.channel,
      userInitiated
    });
    const trustTarget = getTrustScore(this.trustPath, {
      kind: "target",
      value: input.trust?.target
    });
    const trustSource = getTrustScore(this.trustPath, {
      kind: "source",
      value: input.trust?.source
    });
    const trustAction = getTrustScore(this.trustPath, {
      kind: "action",
      value: input.trust?.action
    });
    const minTrust = Math.min(trustTarget, trustSource, trustAction);
    const trustTier = trustTierFromScore(minTrust);
    const slowBrain = getActiveSlowBrainPolicy(this.projectDir);
    const resonance = this.computeResonanceProfile({
      intent,
      urgency,
      state,
      riskReasons: sentinel.reasons,
      fastBrainScore,
      trustTier,
      shouldProbeScreen: sentinel.shouldProbeScreen && !shouldProbeScreen
    });
    const decisionSeed = this.pickDecision({
      state,
      urgency,
      intent,
      userInitiated,
      shouldProbeScreen: sentinel.shouldProbeScreen && !shouldProbeScreen,
      fastBrainScore,
      trustTier,
      slowBrain,
      resonance
    });
    let decision = decisionSeed;
    let shadowModeApplied = false;
    if (!userInitiated && shadowModeActive && urgency !== "critical") {
      decision = "defer";
      shadowModeApplied = true;
    }
    let budgetHint = "";
    if (!userInitiated) {
      const budget2 = this.applyInterruptionBudget(state, decision === "allow");
      if (decision === "allow" && budget2.blocked) {
        decision = "defer";
        budgetHint = `budget_exhausted:${state}`;
      }
    }
    let explorationApplied = false;
    if (!userInitiated && decision === "defer" && !shadowModeApplied && this.shouldExplore()) {
      decision = "allow";
      explorationApplied = true;
    }
    const reasonMarkers = [
      ...sentinel.reasons,
      ...nativeSample.captureLimitations.map((item) => `native_limit:${item}`),
      allowSignalOverride ? "signal_override_enabled" : "",
      sentinel.shouldProbeScreen && !probeEnabled ? "probe_disabled" : "",
      needsProbe && !shouldProbeScreen ? "probe_rate_limited" : "",
      probeMethod ? `probe_method:${probeMethod}` : "",
      typeof probeConfidence === "number" ? `probe_confidence=${probeConfidence.toFixed(2)}` : "",
      probeSceneTags.length > 0 ? `probe_scene=${probeSceneTags.join("|")}` : "",
      `fast_brain_score=${fastBrainScore.toFixed(2)}`,
      `resonance_score=${resonance.score.toFixed(2)}`,
      `slow_brain=${slowBrain.versionID}`,
      budgetHint,
      explorationApplied ? "epsilon_exploration" : "",
      shadowModeApplied ? "shadow_mode_safe_hold" : ""
    ].filter((item) => item.length > 0);
    const risk = this.resolveRisk({
      state,
      reasons: reasonMarkers,
      needsProbe,
      shouldProbeScreen,
      captureLimitations
    });
    const nextCheckSec = this.resolveNextCheckSec({
      decision,
      urgency,
      state,
      shadowModeApplied,
      risk,
      slowBrain
    });
    const reason = this.buildReason({
      decision,
      state,
      userInitiated,
      urgency,
      intent,
      reasons: reasonMarkers
    });
    const fixability = this.resolveFixability({
      decision,
      state,
      reasons: reasonMarkers,
      trustTier,
      userInitiated
    });
    const approvalMode = this.resolveApprovalMode({
      decision,
      urgency,
      trustTier
    });
    const budget = this.resolveNegotiationBudget(fixability);
    const insightText = this.buildInsightText({
      decision,
      state,
      trustTier,
      approvalMode,
      fixability,
      shouldProbeScreen,
      risk,
      resonance,
      slowBrain
    });
    const result = {
      auditID,
      at,
      intent,
      urgency,
      channel: input.channel,
      userInitiated,
      state,
      confidence: sentinel.confidence,
      decision,
      allowed: decision === "allow",
      reason,
      nextCheckSec,
      retryAfterSec: nextCheckSec,
      shouldProbeScreen,
      reasons: reasonMarkers,
      approvalMode,
      fixability,
      budget,
      trust: {
        target: trustTarget,
        source: trustSource,
        action: trustAction,
        minScore: minTrust,
        tier: trustTier
      },
      risk,
      resonance,
      slowBrain: {
        versionID: slowBrain.versionID,
        consumeAllowThreshold: slowBrain.parameters.consumeAllowThreshold,
        awayAllowThreshold: slowBrain.parameters.awayAllowThreshold,
        deferRetryBaseSec: slowBrain.parameters.deferRetryBaseSec
      },
      insightText
    };
    if (userInitiated && !input.trust?.action?.startsWith("daemon.")) {
      this.applyMissedOpportunityPenalty({
        at,
        state,
        intent,
        urgency,
        channel: input.channel,
        consultAuditID: auditID
      });
    }
    touchFastBrain(this.fastBrainPath, {
      state,
      intent,
      urgency,
      channel: input.channel,
      userInitiated,
      approved: decision === "allow"
    });
    this.appendConsultLog(result);
    appendPsycheObservation(this.trainingDataLogPath, {
      at,
      state,
      intent,
      urgency,
      channel: input.channel,
      userInitiated,
      confidence: sentinel.confidence,
      decision,
      shouldProbeScreen,
      reasons: result.reasons,
      signals: {
        ...sampledSignals,
        screenProbe: probeStatus,
        captureLimitations
      },
      approvalMode: result.approvalMode,
      fixability: result.fixability,
      trust: result.trust
    });
    return result;
  }
  registerOutcome(input) {
    const at = nowIso27();
    const intent = String(input.intent ?? "").trim() || "unknown_intent";
    const urgency = asUrgency(input.urgency);
    const userInitiated = input.userInitiated !== false;
    const feedback = input.explicitFeedback ?? "none";
    const score = this.outcomeScore({
      delivered: input.delivered,
      blockedReason: input.blockedReason,
      explicitFeedback: feedback,
      userReplyWithinSec: input.userReplyWithinSec,
      userInitiatedWithinSec: input.userInitiatedWithinSec
    });
    const reward = score >= 0 ? "positive" : "negative";
    const key = fastBrainBucket({
      state: input.state,
      intent,
      urgency,
      channel: input.channel,
      userInitiated
    });
    adjustFastBrain(this.fastBrainPath, key, reward === "positive" ? Math.abs(score) : 0, reward === "negative" ? Math.abs(score) : 0);
    appendPsycheOutcome(this.trainingDataLogPath, {
      at,
      consultAuditID: input.consultAuditID,
      state: input.state,
      intent,
      urgency,
      channel: input.channel,
      userInitiated,
      delivered: input.delivered,
      blockedReason: input.blockedReason,
      explicitFeedback: feedback,
      userReplyWithinSec: input.userReplyWithinSec,
      userInitiatedWithinSec: input.userInitiatedWithinSec,
      score,
      reward
    });
    const approved = input.delivered && feedback !== "negative";
    const confidence = Number.isFinite(input.trust?.evidenceConfidence) ? Number(input.trust?.evidenceConfidence) : typeof input.userReplyWithinSec === "number" && input.userReplyWithinSec > 0 ? 0.9 : 0.7;
    if (input.trust?.target) {
      updateTrustScore(this.trustPath, {
        kind: "target",
        value: input.trust.target,
        approved,
        confidence,
        highRiskRollback: input.trust.highRiskRollback
      });
    }
    if (input.trust?.source) {
      updateTrustScore(this.trustPath, {
        kind: "source",
        value: input.trust.source,
        approved,
        confidence,
        highRiskRollback: input.trust.highRiskRollback
      });
    }
    if (input.trust?.action) {
      updateTrustScore(this.trustPath, {
        kind: "action",
        value: input.trust.action,
        approved,
        confidence,
        highRiskRollback: input.trust.highRiskRollback
      });
    }
    return {
      at,
      consultAuditID: input.consultAuditID,
      reward,
      score,
      bucket: key
    };
  }
  pickDecision(input) {
    const {
      state,
      urgency,
      userInitiated,
      shouldProbeScreen,
      fastBrainScore,
      trustTier,
      slowBrain,
      resonance
    } = input;
    if (userInitiated) {
      if (state === "UNKNOWN" && urgency === "low")
        return "defer";
      if (trustTier === "low" && urgency === "low")
        return "defer";
      return "allow";
    }
    if (shouldProbeScreen && urgency !== "critical")
      return "defer";
    if (trustTier === "low" && urgency !== "critical")
      return "deny";
    if (urgency === "critical")
      return "allow";
    if (state === "FOCUS" || state === "PLAY" || state === "UNKNOWN")
      return "defer";
    if (state === "CONSUME") {
      const threshold = urgency === "high" ? Math.max(0.3, slowBrain.parameters.consumeAllowThreshold - 0.12) : slowBrain.parameters.consumeAllowThreshold;
      if (resonance.score >= 0.78 && trustTier !== "low")
        return "allow";
      return fastBrainScore >= threshold ? "allow" : "defer";
    }
    const awayThreshold = slowBrain.parameters.awayAllowThreshold;
    if (resonance.score < 0.35 && urgency === "low")
      return "defer";
    return fastBrainScore >= awayThreshold ? "allow" : "defer";
  }
  resolveFixability(input) {
    if (input.decision === "deny") {
      if (input.trustTier === "low" && !input.userInitiated)
        return "impossible";
      return "reduce_scope";
    }
    if (input.reasons.some((item) => item.includes("probe"))) {
      return "need_evidence";
    }
    if (input.state === "FOCUS" || input.state === "PLAY" || input.state === "UNKNOWN") {
      return "retry_later";
    }
    return "rewrite";
  }
  computeResonanceProfile(input) {
    const intent = input.intent.toLowerCase();
    const semanticFocus = clamp7((intent.includes("remind") || intent.includes("checkin") || intent.includes("schedule") ? 0.78 : intent.includes("notify") || intent.includes("reply") ? 0.62 : 0.45) + (input.urgency === "critical" ? 0.25 : input.urgency === "high" ? 0.15 : input.urgency === "medium" ? 0.05 : 0), 0, 1);
    const momentum = clamp7(input.fastBrainScore * 0.65 + (input.state === "AWAY" ? 0.2 : input.state === "CONSUME" ? 0.08 : -0.08), 0, 1);
    const riskPenalty = input.riskReasons.some((item) => item.includes("probe") || item.includes("capture")) ? 0.14 : 0;
    const trustBoost = input.trustTier === "high" ? 0.08 : input.trustTier === "low" ? -0.12 : 0;
    const score = clamp7(semanticFocus * 0.45 + momentum * 0.45 + trustBoost - riskPenalty - (input.shouldProbeScreen ? 0.08 : 0), 0, 1);
    const styleTags = [];
    if (input.state === "FOCUS")
      styleTags.push("low_interruption");
    if (input.state === "CONSUME")
      styleTags.push("ambient");
    if (input.state === "AWAY")
      styleTags.push("asynchronous");
    if (score >= 0.72)
      styleTags.push("resonance_high");
    else if (score <= 0.36)
      styleTags.push("resonance_low");
    return {
      score,
      semanticFocus,
      momentum,
      styleTags
    };
  }
  resolveApprovalMode(input) {
    if (input.decision !== "allow")
      return "modal_approval";
    if (input.trustTier === "high" && input.urgency === "low")
      return "silent_audit";
    if (input.trustTier === "low" || input.urgency === "high" || input.urgency === "critical") {
      return "modal_approval";
    }
    return "toast_gate";
  }
  resolveNegotiationBudget(fixability) {
    if (fixability === "impossible")
      return { autoRetry: 0, humanEdit: 0 };
    if (fixability === "retry_later")
      return { autoRetry: 1, humanEdit: 1 };
    return { autoRetry: 1, humanEdit: 1 };
  }
  buildInsightText(input) {
    const parts = [
      `state=${input.state}`,
      `trust=${input.trustTier}`,
      `decision=${input.decision}`,
      `gate=${input.approvalMode}`,
      `fix=${input.fixability}`,
      `resonance=${input.resonance.score.toFixed(2)}`,
      `slow_brain=${input.slowBrain.versionID}`
    ];
    if (input.shouldProbeScreen)
      parts.push("probe=required");
    if (input.risk.falseIdleUncertain)
      parts.push("risk=false_idle");
    if (input.risk.drmCaptureBlocked)
      parts.push("risk=drm_capture");
    if (input.resonance.styleTags.length > 0) {
      parts.push(`style=${input.resonance.styleTags.join("+")}`);
    }
    return `Psyche: ${parts.join(" | ")}`;
  }
  buildReason(input) {
    const base = `psyche_${input.decision.toLowerCase()}`;
    const markers = [
      `state=${input.state}`,
      `urgency=${input.urgency}`,
      `user_initiated=${input.userInitiated ? "1" : "0"}`,
      `intent=${input.intent}`
    ];
    if (input.reasons.length > 0) {
      markers.push(`signals=${input.reasons.join(",")}`);
    }
    return `${base}:${markers.join(";")}`;
  }
  appendConsultLog(result) {
    fs41.appendFileSync(this.consultLogPath, `${JSON.stringify(result)}
`, "utf-8");
  }
  safeReadNativeSignals() {
    try {
      const sample = this.nativeSignalsProvider();
      return {
        sampledAt: typeof sample.sampledAt === "string" ? sample.sampledAt : nowIso27(),
        signals: sample.signals ?? {},
        captureLimitations: this.normalizeCaptureLimitations(sample.captureLimitations)
      };
    } catch (error92) {
      return {
        sampledAt: nowIso27(),
        signals: {},
        captureLimitations: [
          `native_signal_provider_failed:${error92 instanceof Error ? error92.message : String(error92)}`
        ]
      };
    }
  }
  safeRunScreenProbe(input) {
    try {
      const result = this.screenProbeProvider(input);
      return {
        status: result.status,
        method: result.method,
        captureLimitations: this.normalizeCaptureLimitations(result.captureLimitations),
        sceneTags: Array.isArray(result.sceneTags) ? result.sceneTags.map((item) => String(item ?? "").trim()).filter(Boolean).slice(0, 8) : [],
        confidence: Number.isFinite(result.confidence) ? Number(result.confidence) : 0,
        inferredSignals: result.inferredSignals ?? {}
      };
    } catch (error92) {
      return {
        status: "error",
        captureLimitations: [
          `screen_probe_provider_failed:${error92 instanceof Error ? error92.message : String(error92)}`
        ],
        sceneTags: [],
        confidence: 0,
        inferredSignals: {}
      };
    }
  }
  resolveProbeTimeoutMs() {
    const raw = Number(process.env.MIYA_PSYCHE_SCREEN_PROBE_TIMEOUT_MS ?? 2800);
    if (!Number.isFinite(raw))
      return 2800;
    return Math.max(800, Math.min(1e4, Math.floor(raw)));
  }
  probeBudgetConfig() {
    const capacityRaw = Number(process.env.MIYA_PSYCHE_PROBE_BUCKET_CAPACITY ?? 2);
    const windowSecRaw = Number(process.env.MIYA_PSYCHE_PROBE_BUCKET_WINDOW_SEC ?? 60);
    const capacity = Number.isFinite(capacityRaw) ? Math.max(1, Math.floor(capacityRaw)) : 2;
    const windowSec = Number.isFinite(windowSecRaw) ? Math.max(1, windowSecRaw) : 60;
    return {
      capacity,
      refillPerSec: capacity / windowSec
    };
  }
  resolveEpsilonFromEnv() {
    const raw = Number(process.env.MIYA_PSYCHE_EPSILON ?? 0.01);
    if (!Number.isFinite(raw))
      return 0.01;
    return raw;
  }
  shouldExplore() {
    if (this.epsilon <= 0)
      return false;
    return this.random.next() < this.epsilon;
  }
  resolveShadowModeDays(override) {
    const raw = Number(override ?? process.env.MIYA_PSYCHE_SHADOW_MODE_DAYS ?? process.env.MIYA_PSYCHE_COLDSTART_DAYS ?? 7);
    if (!Number.isFinite(raw))
      return 7;
    return Math.max(0, Math.min(30, Math.floor(raw)));
  }
  ensureLifecycleState() {
    if (fs41.existsSync(this.lifecyclePath))
      return;
    const seed = { firstSeenAt: nowIso27() };
    fs41.writeFileSync(this.lifecyclePath, `${JSON.stringify(seed, null, 2)}
`, "utf-8");
  }
  readLifecycleState() {
    try {
      const parsed = JSON.parse(fs41.readFileSync(this.lifecyclePath, "utf-8"));
      const firstSeenAt = typeof parsed.firstSeenAt === "string" ? parsed.firstSeenAt : nowIso27();
      return { firstSeenAt };
    } catch {
      const fallback = { firstSeenAt: nowIso27() };
      fs41.writeFileSync(this.lifecyclePath, `${JSON.stringify(fallback, null, 2)}
`, "utf-8");
      return fallback;
    }
  }
  isShadowModeActive(nowMs = Date.now()) {
    if (this.shadowModeDays <= 0)
      return false;
    const lifecycle = this.readLifecycleState();
    const firstSeenAtMs = Date.parse(lifecycle.firstSeenAt);
    if (!Number.isFinite(firstSeenAtMs))
      return false;
    return nowMs - firstSeenAtMs < this.shadowModeDays * 24 * 3600 * 1000;
  }
  normalizeCaptureLimitations(value) {
    if (!Array.isArray(value))
      return [];
    return value.map((item) => String(item ?? "").trim().toLowerCase()).filter((item) => item.length > 0).slice(0, 12);
  }
  resolveRisk(input) {
    const reasonSet = new Set(input.reasons);
    const drmCaptureBlocked = reasonSet.has("screen_probe_capture_protected") || input.captureLimitations.some((item) => ["drm", "hdcp", "protected", "pmp"].some((flag) => item.includes(flag)));
    const falseIdleUncertain = input.state === "UNKNOWN" || reasonSet.has("input_signal_conflict") || reasonSet.has("idle_with_media_signal_needs_probe") || reasonSet.has("probe_failed_with_media_signals") || reasonSet.has("probe_failed_fallback_unknown");
    const probeRateLimited = input.needsProbe && !input.shouldProbeScreen;
    return {
      falseIdleUncertain,
      drmCaptureBlocked,
      probeRateLimited,
      probeRequested: input.needsProbe
    };
  }
  resolveNextCheckSec(input) {
    if (input.decision === "allow")
      return 0;
    if (input.shadowModeApplied)
      return 120;
    if (input.urgency === "critical")
      return input.risk.falseIdleUncertain ? 20 : 10;
    let base = input.slowBrain.parameters.deferRetryBaseSec;
    if (input.state === "FOCUS" || input.state === "PLAY")
      base = 300;
    else if (input.state === "UNKNOWN")
      base = 180;
    else if (input.state === "CONSUME")
      base = 120;
    if (input.risk.probeRateLimited)
      base += 60;
    return Math.max(15, Math.min(900, base));
  }
  applyMissedOpportunityPenalty(input) {
    const recent = this.findRecentDeferredConsult(input);
    if (!recent)
      return;
    if (this.delayedPenaltyApplied.has(recent.auditID))
      return;
    this.delayedPenaltyApplied.add(recent.auditID);
    const initiatedAtMs = Date.parse(input.at);
    const deferredAtMs = Date.parse(recent.at);
    const initiatedWithinSec = Number.isFinite(initiatedAtMs) && Number.isFinite(deferredAtMs) ? Math.max(0, Math.floor((initiatedAtMs - deferredAtMs) / 1000)) : undefined;
    const missedScore = -0.25;
    const key = fastBrainBucket({
      state: recent.state,
      intent: recent.intent,
      urgency: recent.urgency,
      channel: recent.channel,
      userInitiated: false
    });
    adjustFastBrain(this.fastBrainPath, key, 0, Math.abs(missedScore));
    appendPsycheOutcome(this.trainingDataLogPath, {
      at: input.at,
      consultAuditID: recent.auditID,
      state: recent.state,
      intent: recent.intent,
      urgency: recent.urgency,
      channel: recent.channel,
      userInitiated: false,
      delivered: false,
      blockedReason: "missed_opportunity_user_initiated",
      explicitFeedback: "none",
      userReplyWithinSec: undefined,
      userInitiatedWithinSec: initiatedWithinSec,
      score: missedScore,
      reward: "negative"
    });
  }
  findRecentDeferredConsult(input) {
    if (!fs41.existsSync(this.consultLogPath))
      return null;
    const nowMs = Date.parse(input.at);
    const lines = fs41.readFileSync(this.consultLogPath, "utf-8").trim().split(/\r?\n/);
    const recentLines = lines.slice(-120).reverse();
    for (const line of recentLines) {
      try {
        const row = JSON.parse(line);
        if (!row || row.auditID === input.consultAuditID)
          continue;
        if (row.userInitiated !== false)
          continue;
        if (row.decision !== "defer")
          continue;
        if (row.state !== "FOCUS" && row.state !== "PLAY" && row.state !== "UNKNOWN")
          continue;
        const rowChannel = typeof row.channel === "string" ? row.channel : undefined;
        if (input.channel && rowChannel && input.channel !== rowChannel)
          continue;
        if (typeof row.at !== "string")
          continue;
        const rowMs = Date.parse(row.at);
        if (!Number.isFinite(rowMs) || !Number.isFinite(nowMs))
          continue;
        const deltaSec = (nowMs - rowMs) / 1000;
        if (deltaSec < 0 || deltaSec > 300)
          continue;
        return {
          auditID: String(row.auditID),
          at: row.at,
          intent: String(row.intent ?? input.intent),
          urgency: asUrgency(row.urgency),
          channel: rowChannel,
          state: row.state
        };
      } catch {}
    }
    return null;
  }
  outcomeScore(input) {
    if (input.explicitFeedback === "negative")
      return -1;
    if (input.explicitFeedback === "positive")
      return 1;
    if (!input.delivered) {
      const blockedReason = String(input.blockedReason ?? "").toLowerCase();
      const userInitiatedWithinSec = Number(input.userInitiatedWithinSec ?? Number.NaN);
      if (Number.isFinite(userInitiatedWithinSec) && userInitiatedWithinSec > 0 && userInitiatedWithinSec <= 300) {
        return -0.25;
      }
      if (blockedReason.includes("psyche_deferred") || blockedReason.includes("safe_hold")) {
        return 0.2;
      }
      return blockedReason ? -0.5 : -0.3;
    }
    if (typeof input.userReplyWithinSec === "number" && input.userReplyWithinSec > 0) {
      if (input.userReplyWithinSec <= 180)
        return 0.8;
      if (input.userReplyWithinSec <= 600)
        return 0.4;
    }
    return 0.2;
  }
  applyInterruptionBudget(state, consumeToken) {
    const policy = DEFAULT_BUDGETS[state] ?? DEFAULT_BUDGETS.UNKNOWN;
    if (policy.maxActions <= 0) {
      return { blocked: true };
    }
    const now = Date.now();
    const store = this.readBudgetStore();
    const current = store.byState[state];
    let active;
    if (!current) {
      active = { windowStartedAt: nowIso27(), used: 0 };
    } else {
      const startedAtMs = Date.parse(current.windowStartedAt);
      if (!Number.isFinite(startedAtMs) || now - startedAtMs >= policy.windowSec * 1000) {
        active = { windowStartedAt: nowIso27(), used: 0 };
      } else {
        active = {
          windowStartedAt: current.windowStartedAt,
          used: Math.max(0, Math.floor(current.used ?? 0))
        };
      }
    }
    const blocked = active.used >= policy.maxActions;
    if (!blocked && consumeToken) {
      active.used += 1;
    }
    store.byState[state] = active;
    fs41.writeFileSync(this.budgetPath, `${JSON.stringify(store, null, 2)}
`, "utf-8");
    return { blocked };
  }
  readBudgetStore() {
    if (!fs41.existsSync(this.budgetPath))
      return { byState: {} };
    try {
      return JSON.parse(fs41.readFileSync(this.budgetPath, "utf-8"));
    } catch {
      return { byState: {} };
    }
  }
}
// src/desktop/runtime.ts
function nowIso28() {
  return new Date().toISOString();
}
function actionScript() {
  return `
$ErrorActionPreference = 'Stop'
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName UIAutomationClient
Add-Type -AssemblyName UIAutomationTypes
Add-Type -AssemblyName WindowsBase
Add-Type @"
using System;
using System.Runtime.InteropServices;
using System.Text;
public static class MiyaDesktopNative {
  [StructLayout(LayoutKind.Sequential)]
  public struct POINT { public int X; public int Y; }
  [StructLayout(LayoutKind.Sequential)]
  public struct RECT { public int Left; public int Top; public int Right; public int Bottom; }
  [DllImport("user32.dll")] public static extern bool GetCursorPos(out POINT point);
  [DllImport("user32.dll")] public static extern short GetAsyncKeyState(int vKey);
  [DllImport("user32.dll")] public static extern bool SetCursorPos(int X, int Y);
  [DllImport("user32.dll")] public static extern void mouse_event(uint dwFlags, uint dx, uint dy, uint dwData, UIntPtr dwExtraInfo);
  [DllImport("user32.dll")] public static extern IntPtr GetForegroundWindow();
  [DllImport("user32.dll")] public static extern bool GetWindowRect(IntPtr hWnd, out RECT rect);
  [DllImport("user32.dll", CharSet = CharSet.Unicode)] public static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);
}
"@

$MOUSEEVENTF_LEFTDOWN = 0x0002
$MOUSEEVENTF_LEFTUP = 0x0004
$MOUSEEVENTF_WHEEL = 0x0800

function New-Result([string]$traceID) {
  return [ordered]@{
    ok = $true
    dryRun = $false
    traceID = $traceID
    platform = 'windows'
    startedAt = [DateTimeOffset]::UtcNow.ToString('o')
    finishedAt = [DateTimeOffset]::UtcNow.ToString('o')
    executedCount = 0
    failureStepID = $null
    failureReason = $null
    inputMutexTriggered = $false
    steps = @()
  }
}

function Escape-SendKeys([string]$text) {
  if ($null -eq $text) { return '' }
  $escaped = $text.Replace('{','{{}').Replace('}','{}}')
  $escaped = $escaped.Replace('+','{+}').Replace('^','{^}').Replace('%','{%}')
  $escaped = $escaped.Replace('~','{~}').Replace('(','{(}').Replace(')','{)}')
  return $escaped
}

function Get-CursorPoint {
  $cursor = New-Object MiyaDesktopNative+POINT
  [void][MiyaDesktopNative]::GetCursorPos([ref]$cursor)
  return @{
    x = [int]$cursor.X
    y = [int]$cursor.Y
  }
}

function Test-UserInterference($baseline, [int]$tolerancePx = 3) {
  $cursor = Get-CursorPoint
  if ([Math]::Abs($cursor.x - $baseline.x) -gt $tolerancePx -or [Math]::Abs($cursor.y - $baseline.y) -gt $tolerancePx) {
    return $true
  }
  $keys = @(0x01, 0x02, 0x09, 0x0D, 0x10, 0x11, 0x12, 0x1B, 0x20)
  foreach ($code in $keys) {
    if (([MiyaDesktopNative]::GetAsyncKeyState($code) -band 0x8000) -ne 0) {
      return $true
    }
  }
  return $false
}

function Get-ForegroundWindowTitle() {
  $hwnd = [MiyaDesktopNative]::GetForegroundWindow()
  if ($hwnd -eq [IntPtr]::Zero) { return '' }
  $builder = New-Object System.Text.StringBuilder 512
  [void][MiyaDesktopNative]::GetWindowText($hwnd, $builder, $builder.Capacity)
  return $builder.ToString()
}

function Get-ForegroundWindowCenter() {
  $hwnd = [MiyaDesktopNative]::GetForegroundWindow()
  if ($hwnd -eq [IntPtr]::Zero) { return $null }
  $rect = New-Object MiyaDesktopNative+RECT
  if (-not [MiyaDesktopNative]::GetWindowRect($hwnd, [ref]$rect)) { return $null }
  $width = [int]($rect.Right - $rect.Left)
  $height = [int]($rect.Bottom - $rect.Top)
  if ($width -le 2 -or $height -le 2) { return $null }
  return @{
    x = [int][Math]::Round($rect.Left + ($width / 2))
    y = [int][Math]::Round($rect.Top + ($height / 2))
  }
}

function Get-ForegroundAutomationRoot() {
  try {
    $hwnd = [MiyaDesktopNative]::GetForegroundWindow()
    if ($hwnd -ne [IntPtr]::Zero) {
      $root = [System.Windows.Automation.AutomationElement]::FromHandle($hwnd)
      if ($null -ne $root) { return $root }
    }
  } catch {}
  try {
    return [System.Windows.Automation.AutomationElement]::RootElement
  } catch {
    return $null
  }
}

function Parse-SelectorCriteria([string]$selector) {
  $criteria = @{}
  $text = [string]$selector
  foreach ($rawPart in ($text -split ';')) {
    $part = [string]$rawPart
    if (-not $part) { continue }
    $trimmed = $part.Trim()
    if (-not $trimmed) { continue }
    $eq = $trimmed.IndexOf('=')
    if ($eq -le 0) { continue }
    $key = $trimmed.Substring(0, $eq).Trim().ToLowerInvariant()
    $value = $trimmed.Substring($eq + 1).Trim()
    if (-not $value) { continue }
    $criteria[$key] = $value
  }
  if ($criteria.Count -eq 0 -and $text.Trim().Length -gt 0) {
    $criteria['name'] = $text.Trim()
  }
  return $criteria
}

function Element-MatchesSelector($element, $criteria) {
  if ($null -eq $element -or $null -eq $criteria -or $criteria.Count -eq 0) { return $false }
  try {
    $name = [string]$element.Current.Name
    $automationId = [string]$element.Current.AutomationId
    $className = [string]$element.Current.ClassName
    $controlType = [string]$element.Current.ControlType.ProgrammaticName
    if ($criteria.ContainsKey('name')) {
      $needle = [string]$criteria['name']
      if (-not $name.ToLowerInvariant().Contains($needle.ToLowerInvariant())) { return $false }
    }
    if ($criteria.ContainsKey('automationid') -or $criteria.ContainsKey('automation_id')) {
      $needle = if ($criteria.ContainsKey('automationid')) { [string]$criteria['automationid'] } else { [string]$criteria['automation_id'] }
      if (-not $automationId.ToLowerInvariant().Contains($needle.ToLowerInvariant())) { return $false }
    }
    if ($criteria.ContainsKey('class') -or $criteria.ContainsKey('classname') -or $criteria.ContainsKey('class_name')) {
      $needle = if ($criteria.ContainsKey('class')) { [string]$criteria['class'] } elseif ($criteria.ContainsKey('classname')) { [string]$criteria['classname'] } else { [string]$criteria['class_name'] }
      if (-not $className.ToLowerInvariant().Contains($needle.ToLowerInvariant())) { return $false }
    }
    if ($criteria.ContainsKey('control') -or $criteria.ContainsKey('controltype') -or $criteria.ContainsKey('control_type')) {
      $needle = if ($criteria.ContainsKey('control')) { [string]$criteria['control'] } elseif ($criteria.ContainsKey('controltype')) { [string]$criteria['controltype'] } else { [string]$criteria['control_type'] }
      if (-not $controlType.ToLowerInvariant().Contains($needle.ToLowerInvariant())) { return $false }
    }
    return $true
  } catch {
    return $false
  }
}

function Find-UiElement($target, [int]$timeoutMs = 1200) {
  if ($null -eq $target -or -not $target.mode) { return $null }
  $mode = [string]$target.mode
  $value = ''
  if ($target.value) { $value = [string]$target.value }
  $deadline = (Get-Date).AddMilliseconds([Math]::Max(50, $timeoutMs))
  $selector = $null
  if ($mode -eq 'selector') {
    $selector = Parse-SelectorCriteria $value
  }
  do {
    $root = Get-ForegroundAutomationRoot
    if ($null -eq $root) {
      Start-Sleep -Milliseconds 60
      continue
    }
    if ($mode -eq 'window' -and $value) {
      try {
        $title = [string]$root.Current.Name
        if ($title.ToLowerInvariant().Contains($value.ToLowerInvariant())) {
          return $root
        }
      } catch {}
    }
    try {
      $all = $root.FindAll([System.Windows.Automation.TreeScope]::Descendants, [System.Windows.Automation.Condition]::TrueCondition)
      for ($i = 0; $i -lt $all.Count; $i++) {
        $el = $all.Item($i)
        if ($null -eq $el) { continue }
        if ($mode -eq 'text' -and $value) {
          try {
            $name = [string]$el.Current.Name
            if ($name.ToLowerInvariant().Contains($value.ToLowerInvariant())) { return $el }
          } catch {}
          continue
        }
        if ($mode -eq 'selector') {
          if (Element-MatchesSelector -element $el -criteria $selector) {
            return $el
          }
        }
      }
    } catch {}
    Start-Sleep -Milliseconds 80
  } while ((Get-Date) -lt $deadline)
  return $null
}

function Get-ElementPoint($element) {
  if ($null -eq $element) { return $null }
  try {
    $pt = New-Object System.Windows.Point
    if ($element.TryGetClickablePoint([ref]$pt)) {
      return @{
        x = [int][Math]::Round($pt.X)
        y = [int][Math]::Round($pt.Y)
      }
    }
  } catch {}
  try {
    $rect = $element.Current.BoundingRectangle
    if ($rect.Width -gt 1 -and $rect.Height -gt 1) {
      return @{
        x = [int][Math]::Round($rect.Left + ($rect.Width / 2))
        y = [int][Math]::Round($rect.Top + ($rect.Height / 2))
      }
    }
  } catch {}
  return $null
}

function Focus-Target($target, [int]$timeoutMs = 1200) {
  if ($null -eq $target -or -not $target.mode) { throw "focus_target_invalid" }
  $mode = [string]$target.mode
  if ($mode -eq 'window') {
    if (-not $target.value) { throw "focus_target_invalid" }
    $ok = $shell.AppActivate([string]$target.value)
    Start-Sleep -Milliseconds 120
    if (-not $ok) { throw "focus_window_not_found" }
    return
  }
  if ($mode -eq 'coordinates') {
    if (-not $target.point) { throw "focus_target_invalid" }
    Invoke-ClickCoordinates -x ([int]$target.point.x) -y ([int]$target.point.y)
    return
  }
  $element = Find-UiElement -target $target -timeoutMs $timeoutMs
  if ($null -eq $element) { throw "focus_element_not_found" }
  try {
    $element.SetFocus()
    Start-Sleep -Milliseconds 70
    return
  } catch {}
  $point = Get-ElementPoint $element
  if ($null -ne $point) {
    Invoke-ClickCoordinates -x ([int]$point.x) -y ([int]$point.y)
    return
  }
  throw "focus_element_not_focusable"
}

function Resolve-TargetPoint($target, [int]$timeoutMs = 1200) {
  if ($null -eq $target -or -not $target.mode) { throw "target_invalid" }
  $mode = [string]$target.mode
  switch ($mode) {
    'coordinates' {
      if (-not $target.point) { throw "target_point_missing" }
      return @{
        x = [int]$target.point.x
        y = [int]$target.point.y
      }
    }
    'window' {
      if (-not $target.value) { throw "window_target_missing" }
      [void]$shell.AppActivate([string]$target.value)
      Start-Sleep -Milliseconds 90
      $center = Get-ForegroundWindowCenter
      if ($null -ne $center) { return $center }
      $windowEl = Find-UiElement -target $target -timeoutMs $timeoutMs
      $point = Get-ElementPoint $windowEl
      if ($null -ne $point) { return $point }
      throw "window_target_unresolved"
    }
    'text' {
      $element = Find-UiElement -target $target -timeoutMs $timeoutMs
      if ($null -eq $element) { throw "text_target_not_found" }
      $point = Get-ElementPoint $element
      if ($null -eq $point) { throw "text_target_not_clickable" }
      return $point
    }
    'selector' {
      $element = Find-UiElement -target $target -timeoutMs $timeoutMs
      if ($null -eq $element) { throw "selector_target_not_found" }
      $point = Get-ElementPoint $element
      if ($null -eq $point) { throw "selector_target_not_clickable" }
      return $point
    }
    default {
      throw "target_mode_not_supported"
    }
  }
}

function Test-TextVisible([string]$expected, [bool]$contains, [int]$timeoutMs = 1000) {
  if (-not $expected) { return $false }
  $deadline = (Get-Date).AddMilliseconds([Math]::Max(50, $timeoutMs))
  do {
    $title = Get-ForegroundWindowTitle
    if ($contains) {
      if ($title.ToLowerInvariant().Contains($expected.ToLowerInvariant())) { return $true }
    } else {
      if ($title -eq $expected) { return $true }
    }
    $root = Get-ForegroundAutomationRoot
    if ($null -ne $root) {
      try {
        $all = $root.FindAll([System.Windows.Automation.TreeScope]::Descendants, [System.Windows.Automation.Condition]::TrueCondition)
        for ($i = 0; $i -lt $all.Count; $i++) {
          $el = $all.Item($i)
          if ($null -eq $el) { continue }
          $name = ''
          try { $name = [string]$el.Current.Name } catch { $name = '' }
          if (-not $name) { continue }
          if ($contains) {
            if ($name.ToLowerInvariant().Contains($expected.ToLowerInvariant())) { return $true }
          } else {
            if ($name -eq $expected) { return $true }
          }
        }
      } catch {}
    }
    Start-Sleep -Milliseconds 80
  } while ((Get-Date) -lt $deadline)
  return $false
}

function Invoke-Hotkey([System.__ComObject]$shell, $keys) {
  if ($null -eq $keys -or $keys.Count -eq 0) { throw "hotkey_keys_missing" }
  $mods = ''
  $main = ''
  foreach ($raw in $keys) {
    $key = [string]$raw
    switch ($key.ToLowerInvariant()) {
      'ctrl' { $mods += '^'; continue }
      'control' { $mods += '^'; continue }
      'shift' { $mods += '+'; continue }
      'alt' { $mods += '%'; continue }
      default { $main = $key; continue }
    }
  }
  if (-not $main) { $main = [string]$keys[$keys.Count - 1] }
  $special = @{
    'enter' = '{ENTER}'
    'tab' = '{TAB}'
    'esc' = '{ESC}'
    'escape' = '{ESC}'
    'space' = ' '
    'up' = '{UP}'
    'down' = '{DOWN}'
    'left' = '{LEFT}'
    'right' = '{RIGHT}'
    'delete' = '{DELETE}'
    'backspace' = '{BACKSPACE}'
  }
  $mainKey = if ($special.ContainsKey($main.ToLowerInvariant())) { $special[$main.ToLowerInvariant()] } else { Escape-SendKeys $main }
  $shell.SendKeys("$mods$mainKey")
}

function Invoke-ClickCoordinates([int]$x, [int]$y) {
  [void][MiyaDesktopNative]::SetCursorPos($x, $y)
  Start-Sleep -Milliseconds 30
  [MiyaDesktopNative]::mouse_event($MOUSEEVENTF_LEFTDOWN, 0, 0, 0, [UIntPtr]::Zero)
  Start-Sleep -Milliseconds 20
  [MiyaDesktopNative]::mouse_event($MOUSEEVENTF_LEFTUP, 0, 0, 0, [UIntPtr]::Zero)
}

function Invoke-Drag([int]$fromX, [int]$fromY, [int]$toX, [int]$toY) {
  [void][MiyaDesktopNative]::SetCursorPos($fromX, $fromY)
  Start-Sleep -Milliseconds 20
  [MiyaDesktopNative]::mouse_event($MOUSEEVENTF_LEFTDOWN, 0, 0, 0, [UIntPtr]::Zero)
  $steps = 10
  for ($i = 1; $i -le $steps; $i++) {
    $x = [int][Math]::Round($fromX + (($toX - $fromX) * ($i / [double]$steps)))
    $y = [int][Math]::Round($fromY + (($toY - $fromY) * ($i / [double]$steps)))
    [void][MiyaDesktopNative]::SetCursorPos($x, $y)
    Start-Sleep -Milliseconds 10
  }
  [MiyaDesktopNative]::mouse_event($MOUSEEVENTF_LEFTUP, 0, 0, 0, [UIntPtr]::Zero)
}

$planPayload = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($env:MIYA_DESKTOP_ACTION_PLAN_B64))
$traceID = [string]$env:MIYA_DESKTOP_TRACE_ID
$plan = $planPayload | ConvertFrom-Json
$result = New-Result -traceID $traceID
$shell = New-Object -ComObject WScript.Shell
$mutexEnabled = [string]$env:MIYA_INPUT_MUTEX_ENABLED -eq '1'
$abortOnInterference = [string]$env:MIYA_ABORT_ON_INTERFERENCE -ne '0'
$cursorBaseline = Get-CursorPoint

try {
  foreach ($action in $plan.actions) {
    $stepStartedAt = Get-Date
    $step = [ordered]@{
      id = [string]$action.id
      kind = [string]$action.kind
      status = 'ok'
      message = ''
      durationMs = 0
    }
    try {
      if ($mutexEnabled -and (Test-UserInterference -baseline $cursorBaseline)) {
        $result.inputMutexTriggered = $true
        if ($abortOnInterference) {
          throw "input_mutex_timeout:user_interference"
        }
      }
      $actionTimeout = 1200
      if ($null -ne $action.timeoutMs) {
        $candidate = [int]$action.timeoutMs
        if ($candidate -gt 0) {
          $actionTimeout = [Math]::Max(100, [Math]::Min(60000, $candidate))
        }
      }
      switch ([string]$action.kind) {
        'focus' {
          Focus-Target -target $action.target -timeoutMs $actionTimeout
        }
        'click' {
          if (-not $action.target) { throw "click_target_missing" }
          $point = Resolve-TargetPoint -target $action.target -timeoutMs $actionTimeout
          Invoke-ClickCoordinates -x ([int]$point.x) -y ([int]$point.y)
        }
        'type' {
          if (-not [string]$action.text) { throw "type_text_missing" }
          if ($action.target) {
            Focus-Target -target $action.target -timeoutMs $actionTimeout
          }
          $shell.SendKeys((Escape-SendKeys ([string]$action.text)))
        }
        'hotkey' {
          Invoke-Hotkey -shell $shell -keys $action.keys
        }
        'scroll' {
          if ($null -eq $action.scrollDeltaY) { throw "scroll_delta_missing" }
          [MiyaDesktopNative]::mouse_event($MOUSEEVENTF_WHEEL, 0, 0, [uint32]([int]$action.scrollDeltaY), [UIntPtr]::Zero)
        }
        'drag' {
          if (-not $action.target -or [string]$action.target.mode -ne 'coordinates' -or -not $action.target.point -or -not $action.dragTo) {
            throw "drag_target_not_supported"
          }
          Invoke-Drag -fromX ([int]$action.target.point.x) -fromY ([int]$action.target.point.y) -toX ([int]$action.dragTo.x) -toY ([int]$action.dragTo.y)
        }
        'assert' {
          if (-not $action.assert) { throw "assert_payload_missing" }
          $expected = [string]$action.assert.expected
          $contains = $true
          if ($null -ne $action.assert.contains) { $contains = [bool]$action.assert.contains }
          if ([string]$action.assert.type -eq 'window') {
            $title = Get-ForegroundWindowTitle
            if ($contains) {
              if (-not $title.ToLowerInvariant().Contains($expected.ToLowerInvariant())) {
                throw "assert_window_mismatch"
              }
            } else {
              if ($title -ne $expected) {
                throw "assert_window_mismatch"
              }
            }
          } elseif ([string]$action.assert.type -eq 'text') {
            if (-not (Test-TextVisible -expected $expected -contains $contains -timeoutMs $actionTimeout)) {
              throw "assert_text_mismatch"
            }
          } elseif ([string]$action.assert.type -eq 'image') {
            throw "assert_image_not_supported"
          } else {
            throw "assert_not_supported"
          }
        }
        default {
          throw "unsupported_action_kind"
        }
      }
      $cursorBaseline = Get-CursorPoint
    } catch {
      $err = [string]$_.Exception.Message
      if ($err.StartsWith('input_mutex_timeout')) {
        $result.inputMutexTriggered = $true
      }
      $step.status = 'failed'
      $step.message = $err
      $result.ok = $false
      $result.failureReason = $err
      $result.failureStepID = [string]$step.id
    }
    $step.durationMs = [Math]::Max(1, [int]((Get-Date) - $stepStartedAt).TotalMilliseconds)
    $result.steps += $step
    if ($step.status -eq 'ok') {
      $result.executedCount += 1
    } else {
      break
    }
  }
} catch {
  $outerErr = [string]$_.Exception.Message
  $result.ok = $false
  if (-not $result.failureReason) {
    $result.failureReason = if ($outerErr) { $outerErr } else { "execution_failed" }
  }
}

$result.finishedAt = [DateTimeOffset]::UtcNow.ToString('o')
$json = $result | ConvertTo-Json -Compress -Depth 8
Write-Output $json
`.trim();
}
function parseJsonFromOutput(raw) {
  const lines = raw.split(/\r?\n/g).map((line) => line.trim()).filter((line) => line.length > 0);
  for (let i = lines.length - 1;i >= 0; i -= 1) {
    const line = lines[i];
    if (!line.startsWith("{") || !line.endsWith("}"))
      continue;
    try {
      return JSON.parse(line);
    } catch {}
  }
  return null;
}
function dryRunResult(plan) {
  const startedAt = nowIso28();
  const steps = plan.actions.map((action) => ({
    id: action.id,
    kind: action.kind,
    status: "planned",
    message: action.notes
  }));
  return {
    ok: true,
    dryRun: true,
    traceID: `${plan.planID}_dry_run`,
    platform: process.platform === "win32" ? "windows" : "other",
    startedAt,
    finishedAt: nowIso28(),
    executedCount: 0,
    retryClass: "none",
    recoveryAdvice: "none",
    nextActionHint: "done",
    inputMutexTriggered: false,
    steps
  };
}
function clampTimeoutMs(value, fallback = 25000) {
  const raw = Number(value ?? fallback);
  if (!Number.isFinite(raw))
    return fallback;
  return Math.max(1000, Math.min(120000, Math.floor(raw)));
}
function clonePlanWithActions(input) {
  return parseDesktopActionPlanV2({
    ...input.plan,
    planID: `${input.plan.planID}_${input.suffix}`,
    createdAt: nowIso28(),
    actions: input.actions
  });
}
function decorateAttemptSteps(steps, attempt, includeRetryHint) {
  return steps.map((step) => ({
    ...step,
    message: includeRetryHint || step.message ? [step.message, `attempt=${attempt}`].filter(Boolean).join("; ") : undefined
  }));
}
function failureText(result) {
  const reason = [
    result.failureReason ?? "",
    ...result.steps.filter((step) => step.status === "failed").map((step) => step.message ?? "")
  ].join("|").toLowerCase();
  return reason;
}
function classifyRetryClass(result) {
  const reason = failureText(result);
  if (!reason)
    return "none";
  if (/input_mutex|user_interference/.test(reason))
    return "input_mutex";
  if (/execution_timeout|timeout/.test(reason))
    return "timeout";
  if (/not_found|unresolved|target_|focus_|window_/.test(reason))
    return "target_not_found";
  if (/post_action_verify_failed|assert_.*mismatch|mismatch|drift/.test(reason)) {
    return "verification_failed";
  }
  if (/unsupported|not_supported|invalid/.test(reason))
    return "unsupported_action";
  return "unknown";
}
function recoveryAdviceByRetryClass(retryClass) {
  if (retryClass === "none")
    return "none";
  if (retryClass === "input_mutex")
    return "wait_user_idle_then_retry";
  if (retryClass === "target_not_found" || retryClass === "verification_failed" || retryClass === "timeout") {
    return "recapture_screen_and_retry";
  }
  return "manual_takeover";
}
function nextActionHintByResult(input) {
  if (input.ok) {
    if (input.singleStep || input.remainingCount > 0)
      return "decide_next_step";
    return "done";
  }
  if (input.retryClass === "input_mutex")
    return "wait_user_idle_then_decide";
  if (input.retryClass === "target_not_found" || input.retryClass === "verification_failed" || input.retryClass === "timeout") {
    return "refresh_observation_then_decide";
  }
  return "manual_takeover";
}
function retryableFailure(result) {
  const retryClass = classifyRetryClass(result);
  return retryClass === "target_not_found" || retryClass === "verification_failed" || retryClass === "timeout";
}
async function backoffBeforeRetry(attempt) {
  const delayMs = Math.min(500, 120 + Math.max(0, attempt - 1) * 180);
  await new Promise((resolve3) => setTimeout(resolve3, delayMs));
}
function buildPostActionVerifyPlan(plan, action, stepIndex) {
  if (!action.target || !action.target.value || action.target.mode === "coordinates")
    return null;
  const expected = action.target.value.trim();
  if (!expected)
    return null;
  const assertType = action.target.mode === "window" ? "window" : "text";
  return clonePlanWithActions({
    plan,
    suffix: `verify_${stepIndex}`,
    actions: [
      {
        id: `${action.id}_post_verify`,
        kind: "assert",
        route: action.route,
        assert: {
          type: assertType,
          expected,
          contains: true
        },
        timeoutMs: 2000,
        notes: "Post action verify guard."
      }
    ]
  });
}
async function executeDesktopActionPlanOnce(input) {
  const plan = parseDesktopActionPlanV2(input.plan);
  const traceID = `desktop_exec_${Date.now().toString(36)}`;
  const planPayload = Buffer.from(JSON.stringify(plan), "utf-8").toString("base64");
  const timeoutMs = clampTimeoutMs(input.timeoutMs, 25000);
  const startedAt = nowIso28();
  const proc = Bun.spawn([
    "powershell",
    "-NoProfile",
    "-NonInteractive",
    "-ExecutionPolicy",
    "Bypass",
    "-Command",
    actionScript()
  ], {
    env: {
      ...process.env,
      MIYA_DESKTOP_TRACE_ID: traceID,
      MIYA_DESKTOP_ACTION_PLAN_B64: planPayload,
      MIYA_INPUT_MUTEX_ENABLED: plan.safety.inputMutex ? "1" : "0",
      MIYA_ABORT_ON_INTERFERENCE: plan.safety.abortOnUserInterference ? "1" : "0"
    },
    windowsHide: true,
    stdio: ["ignore", "pipe", "pipe"]
  });
  let timedOut = false;
  const timer = setTimeout(() => {
    timedOut = true;
    try {
      proc.kill("SIGTERM");
    } catch {}
  }, timeoutMs);
  const exitCode = await proc.exited;
  clearTimeout(timer);
  const stdout = (await new Response(proc.stdout).text()).trim();
  const stderr = (await new Response(proc.stderr).text()).trim();
  const parsed = parseJsonFromOutput(stdout);
  if (!parsed) {
    return {
      ok: false,
      dryRun: false,
      traceID,
      platform: "windows",
      startedAt,
      finishedAt: nowIso28(),
      executedCount: 0,
      failureReason: timedOut ? "execution_timeout" : `execution_parse_failed:${exitCode}`,
      inputMutexTriggered: false,
      steps: [],
      stdout,
      stderr
    };
  }
  const stepRows = Array.isArray(parsed.steps) ? parsed.steps : [];
  const steps = stepRows.map((row) => {
    if (!row || typeof row !== "object")
      return null;
    const item = row;
    const statusRaw = String(item.status ?? "").trim();
    const status = statusRaw === "planned" || statusRaw === "ok" || statusRaw === "failed" || statusRaw === "skipped" ? statusRaw : "failed";
    return {
      id: String(item.id ?? ""),
      kind: String(item.kind ?? ""),
      status,
      message: typeof item.message === "string" && item.message.trim().length > 0 ? item.message.trim() : undefined,
      durationMs: typeof item.durationMs === "number" && Number.isFinite(item.durationMs) ? Math.max(0, Math.floor(item.durationMs)) : undefined
    };
  }).filter((item) => item !== null && item.id.length > 0);
  return {
    ok: parsed.ok === true && !timedOut,
    dryRun: false,
    traceID,
    platform: "windows",
    startedAt: typeof parsed.startedAt === "string" && parsed.startedAt.trim().length > 0 ? parsed.startedAt : startedAt,
    finishedAt: typeof parsed.finishedAt === "string" && parsed.finishedAt.trim().length > 0 ? parsed.finishedAt : nowIso28(),
    executedCount: typeof parsed.executedCount === "number" && Number.isFinite(parsed.executedCount) ? Math.max(0, Math.floor(parsed.executedCount)) : 0,
    failureStepID: typeof parsed.failureStepID === "string" && parsed.failureStepID.trim().length > 0 ? parsed.failureStepID.trim() : undefined,
    failureReason: timedOut ? "execution_timeout" : typeof parsed.failureReason === "string" && parsed.failureReason.trim().length > 0 ? parsed.failureReason.trim() : undefined,
    inputMutexTriggered: parsed.inputMutexTriggered === true,
    steps,
    stdout,
    stderr
  };
}
async function executeDesktopActionPlan(input) {
  const parsedPlan = parseDesktopActionPlanV2(input.plan);
  const singleStep = input.singleStep === true;
  const actionsToRun = singleStep ? parsedPlan.actions.slice(0, 1) : parsedPlan.actions;
  const remainingCount = Math.max(0, parsedPlan.actions.length - actionsToRun.length);
  const plan = clonePlanWithActions({
    plan: parsedPlan,
    actions: actionsToRun,
    suffix: singleStep ? "single_step" : "full"
  });
  if (input.dryRun === true) {
    const result = dryRunResult(plan);
    const retryClass2 = "none";
    return {
      ...result,
      plannedCount: actionsToRun.length,
      remainingCount,
      retryCount: 0,
      retryClass: retryClass2,
      recoveryAdvice: recoveryAdviceByRetryClass(retryClass2),
      nextActionHint: nextActionHintByResult({
        ok: true,
        singleStep,
        remainingCount,
        retryClass: retryClass2
      })
    };
  }
  if (process.platform !== "win32") {
    const retryClass2 = "unsupported_action";
    return {
      ok: false,
      dryRun: false,
      traceID: `${plan.planID}_platform`,
      platform: "other",
      startedAt: nowIso28(),
      finishedAt: nowIso28(),
      executedCount: 0,
      plannedCount: actionsToRun.length,
      remainingCount,
      retryCount: 0,
      retryClass: retryClass2,
      recoveryAdvice: recoveryAdviceByRetryClass(retryClass2),
      nextActionHint: nextActionHintByResult({
        ok: false,
        singleStep,
        remainingCount,
        retryClass: retryClass2
      }),
      failureReason: "platform_not_supported",
      inputMutexTriggered: false,
      steps: []
    };
  }
  const startedAt = nowIso28();
  const traceID = `desktop_exec_seq_${Date.now().toString(36)}`;
  const timeoutMs = clampTimeoutMs(input.timeoutMs, 25000);
  const deadline = Date.now() + timeoutMs;
  const stepRetryLimitRaw = Number(input.stepRetryLimit ?? process.env.MIYA_DESKTOP_STEP_RETRY_LIMIT ?? 2);
  const stepRetryLimit = Number.isFinite(stepRetryLimitRaw) ? Math.max(0, Math.min(4, Math.floor(stepRetryLimitRaw))) : 2;
  const verifyAfterAction = input.verifyAfterAction ?? process.env.MIYA_DESKTOP_VERIFY_AFTER_ACTION !== "0";
  const steps = [];
  let ok = true;
  let executedCount = 0;
  let failureReason;
  let failureStepID;
  let inputMutexTriggered = false;
  let stdout = "";
  let stderr = "";
  let retryCount = 0;
  for (let index = 0;index < actionsToRun.length; index += 1) {
    const action = actionsToRun[index];
    if (!action)
      continue;
    const attemptMax = stepRetryLimit + 1;
    let actionSucceeded = false;
    for (let attempt = 1;attempt <= attemptMax; attempt += 1) {
      if (attempt > 1)
        retryCount += 1;
      const remainingTimeout = Math.max(1000, deadline - Date.now());
      if (remainingTimeout <= 1000 && Date.now() > deadline) {
        ok = false;
        failureReason = "execution_timeout";
        failureStepID = action.id;
        break;
      }
      const stepPlan = clonePlanWithActions({
        plan,
        actions: [action],
        suffix: `step_${index + 1}_attempt_${attempt}`
      });
      const run = await executeDesktopActionPlanOnce({
        plan: stepPlan,
        timeoutMs: remainingTimeout
      });
      stdout = run.stdout ?? stdout;
      stderr = run.stderr ?? stderr;
      inputMutexTriggered = inputMutexTriggered || run.inputMutexTriggered;
      steps.push(...decorateAttemptSteps(run.steps, attempt, attempt > 1));
      if (run.ok) {
        if (verifyAfterAction) {
          const verifyPlan = buildPostActionVerifyPlan(plan, action, index + 1);
          if (verifyPlan) {
            const verifyRun = await executeDesktopActionPlanOnce({
              plan: verifyPlan,
              timeoutMs: Math.max(1000, Math.min(4000, deadline - Date.now()))
            });
            stdout = verifyRun.stdout ?? stdout;
            stderr = verifyRun.stderr ?? stderr;
            inputMutexTriggered = inputMutexTriggered || verifyRun.inputMutexTriggered;
            steps.push(...decorateAttemptSteps(verifyRun.steps.map((step) => ({
              ...step,
              id: `${action.id}_post_verify`
            })), attempt, attempt > 1));
            if (!verifyRun.ok) {
              if (attempt < attemptMax) {
                await backoffBeforeRetry(attempt);
                continue;
              }
              ok = false;
              failureReason = `post_action_verify_failed:${verifyRun.failureReason ?? "verify_failed"}`;
              failureStepID = action.id;
              break;
            }
          }
        }
        actionSucceeded = true;
        executedCount += 1;
        break;
      }
      if (attempt < attemptMax && retryableFailure(run)) {
        await backoffBeforeRetry(attempt);
        continue;
      }
      ok = false;
      failureReason = run.failureReason ?? "execution_failed";
      failureStepID = run.failureStepID ?? action.id;
      break;
    }
    if (!actionSucceeded) {
      break;
    }
  }
  const retryClass = classifyRetryClass({
    ok,
    dryRun: false,
    traceID,
    platform: "windows",
    startedAt,
    finishedAt: nowIso28(),
    executedCount,
    failureStepID,
    failureReason,
    inputMutexTriggered,
    steps,
    stdout,
    stderr
  });
  return {
    ok,
    dryRun: false,
    traceID,
    platform: "windows",
    startedAt,
    finishedAt: nowIso28(),
    executedCount,
    plannedCount: actionsToRun.length,
    remainingCount,
    retryCount,
    retryClass,
    recoveryAdvice: recoveryAdviceByRetryClass(retryClass),
    nextActionHint: nextActionHintByResult({
      ok,
      singleStep,
      remainingCount,
      retryClass
    }),
    failureStepID,
    failureReason,
    inputMutexTriggered,
    steps,
    stdout,
    stderr
  };
}

// src/mcp/context7.ts
var context7 = {
  type: "remote",
  url: "https://mcp.context7.com/mcp",
  headers: process.env.CONTEXT7_API_KEY ? { CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY } : undefined,
  oauth: false,
  capabilities: {
    sampling: false,
    mcpUi: false,
    serviceExpose: true,
    native: true,
    authMode: process.env.CONTEXT7_API_KEY ? "header" : "none",
    ecosystem: "core",
    tags: ["docs", "reference", "libraries"]
  }
};

// src/mcp/grep-app.ts
var grep_app = {
  type: "remote",
  url: "https://mcp.grep.app",
  oauth: false,
  capabilities: {
    sampling: false,
    mcpUi: false,
    serviceExpose: true,
    native: true,
    authMode: "none",
    ecosystem: "community",
    tags: ["code-search", "github", "grep"]
  }
};

// src/mcp/websearch.ts
var websearch = {
  type: "remote",
  url: "https://mcp.exa.ai/mcp?tools=web_search_exa",
  headers: process.env.EXA_API_KEY ? { "x-api-key": process.env.EXA_API_KEY } : undefined,
  oauth: false,
  capabilities: {
    sampling: false,
    mcpUi: false,
    serviceExpose: true,
    native: true,
    authMode: process.env.EXA_API_KEY ? "header" : "none",
    ecosystem: "core",
    tags: ["search", "web", "exa"]
  }
};

// src/mcp/index.ts
var allBuiltinMcps = {
  websearch,
  context7,
  grep_app
};
function createBuiltinMcps(disabledMcps = []) {
  return Object.fromEntries(Object.entries(allBuiltinMcps).filter(([name]) => !disabledMcps.includes(name)));
}
function buildMcpServiceManifest(disabledMcps = []) {
  const builtins = createBuiltinMcps(disabledMcps);
  const mcps = Object.entries(builtins).map(([name, config3]) => {
    const caps = "capabilities" in config3 ? config3.capabilities : undefined;
    const headers = "headers" in config3 && config3.headers && typeof config3.headers === "object" ? Object.values(config3.headers).filter((value) => String(value ?? "").trim().length > 0) : [];
    return {
      name,
      type: config3.type,
      sampling: Boolean(caps?.sampling),
      mcpUi: Boolean(caps?.mcpUi),
      serviceExpose: Boolean(caps?.serviceExpose),
      native: caps?.native !== false,
      authMode: caps?.authMode ?? (config3.type === "remote" ? "header" : "none"),
      ecosystem: caps?.ecosystem ?? "core",
      tags: Array.isArray(caps?.tags) ? caps?.tags.map(String) : [],
      authConfigured: headers.length > 0 || caps?.authMode === "none"
    };
  });
  const summary = {
    total: mcps.length,
    serviceExpose: mcps.filter((item) => item.serviceExpose).length,
    native: mcps.filter((item) => item.native).length,
    authConfigured: mcps.filter((item) => item.authConfigured).length,
    byEcosystem: {
      core: mcps.filter((item) => item.ecosystem === "core").length,
      community: mcps.filter((item) => item.ecosystem === "community").length
    }
  };
  return {
    service: "miya-control-plane",
    version: 2,
    generatedAt: new Date().toISOString(),
    mcps,
    summary,
    controlPlaneEndpoints: [
      "gateway.status.get",
      "gateway.backpressure.stats",
      "daemon.backpressure.stats",
      "provider.override.audit.list",
      "mcp.capabilities.list",
      "mcp.service.expose"
    ]
  };
}

// src/multimodal/image.ts
import * as fs42 from "node:fs";
import * as path40 from "node:path";
var DEFAULT_IMAGE_MODEL = "local:flux.1-schnell";
var DEFAULT_IMAGE_SIZE = "1024x1024";
var MULTIMODAL_TEST_MODE_ENV = "MIYA_MULTIMODAL_TEST_MODE";
var BLANK_PNG_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO6sYz0AAAAASUVORK5CYII=";
function sanitizePrompt(prompt) {
  return prompt.trim().slice(0, 2000);
}
function toBase64FromFile(filePath8) {
  try {
    if (!fs42.existsSync(filePath8))
      return null;
    return fs42.readFileSync(filePath8).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:"))
    return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode() {
  const raw = String(process.env[MULTIMODAL_TEST_MODE_ENV] ?? "").trim().toLowerCase();
  return raw === "1" || raw === "true" || raw === "yes";
}
async function generateImage(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const prompt = sanitizePrompt(input.prompt);
  if (!prompt)
    throw new Error("invalid_prompt");
  const model = input.model?.trim() || DEFAULT_IMAGE_MODEL;
  const size = input.size?.trim() || DEFAULT_IMAGE_SIZE;
  const referenceMediaIDs = (input.referenceMediaIDs ?? []).filter(Boolean);
  const references = referenceMediaIDs.map((id) => getMediaItem(projectDir, id)).filter((item) => Boolean(item)).map((item) => ({
    id: item.id,
    fileName: item.fileName,
    mimeType: item.mimeType,
    localPath: item.localPath
  }));
  const outputDir = getMiyaImageTempDir(projectDir);
  const outputPath = path40.join(outputDir, `flux-${Date.now()}.png`);
  const profileDir = path40.join(getMiyaRuntimeDir(projectDir), "profiles", "companion", "current");
  let inference;
  if (useMultimodalTestMode()) {
    inference = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      inference = await daemon.runFluxImageGenerate({
        prompt,
        outputPath,
        profileDir,
        model,
        references: references.map((item) => item.localPath).filter((item) => Boolean(item)),
        size
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number")
            pending = String(plan.pending);
        } catch {}
        throw new Error(`model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`);
      }
      if (!isRuntimeNotReadyError(error92))
        throw error92;
      inference = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const generatedBase64 = toBase64FromFile(inference.outputPath);
  if (!generatedBase64 && !inference.message.startsWith("python_runtime_not_ready:")) {
    throw new Error(`image_generate_output_missing:${inference.message}`);
  }
  const payloadBase64 = generatedBase64 ?? BLANK_PNG_BASE64;
  const media = ingestMedia(projectDir, {
    source: "multimodal.image.generate",
    kind: "image",
    mimeType: "image/png",
    fileName: `generated-${Date.now()}.png`,
    contentBase64: payloadBase64,
    sizeBytes: Math.floor(payloadBase64.length * 3 / 4),
    metadata: {
      status: inference.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      prompt,
      model,
      size,
      tier: inference.tier,
      degraded: inference.degraded,
      engineMessage: inference.message,
      runtimeError: inference.message.startsWith("python_runtime_not_ready:") ? inference.message : undefined,
      references,
      createdBy: "miya_generate_image"
    }
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "image",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `generated:${model}`
    });
  }
  return {
    media,
    model,
    size,
    prompt
  };
}
// src/multimodal/intent.ts
function extractFriend(text) {
  const bracket = text.match(/\s*\[([^\]]+)\]/);
  if (bracket?.[1])
    return bracket[1].trim();
  const plain = text.match(/\s*([^\s!?]+)/);
  if (plain?.[1])
    return plain[1].trim();
  return "";
}
function detectMultimodalIntent(text) {
  const normalized = text.trim();
  if (!normalized)
    return { type: "unknown" };
  if (/(|||)/.test(normalized)) {
    return {
      type: "selfie",
      prompt: "a natural selfie portrait, indoor soft light, realistic phone camera shot"
    };
  }
  if (/(||)/.test(normalized)) {
    const friend = extractFriend(normalized);
    return {
      type: "voice_to_friend",
      text: normalized,
      friend
    };
  }
  return { type: "unknown" };
}
// src/multimodal/vision-regression.ts
import * as path41 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
var FIXTURE_FILE = path41.join(path41.dirname(fileURLToPath2(import.meta.url)), "fixtures", "desktop-outbound-ocr-regression.json");
// src/multimodal/voice.ts
import * as fs44 from "node:fs";
import * as path43 from "node:path";

// src/voice/state.ts
import { randomUUID as randomUUID17 } from "node:crypto";
import * as fs43 from "node:fs";
import * as path42 from "node:path";
function nowIso29() {
  return new Date().toISOString();
}
function filePath8(projectDir) {
  return path42.join(getMiyaRuntimeDir(projectDir), "voice.json");
}
function ensureDir13(file3) {
  fs43.mkdirSync(path42.dirname(file3), { recursive: true });
}
function defaultState4() {
  return {
    enabled: false,
    wakeWordEnabled: false,
    talkMode: false,
    routeSessionID: "main",
    sttProvider: "local",
    ttsProvider: "local",
    history: []
  };
}
function readVoiceState(projectDir) {
  const file3 = filePath8(projectDir);
  if (!fs43.existsSync(file3))
    return defaultState4();
  try {
    const parsed = JSON.parse(fs43.readFileSync(file3, "utf-8"));
    return {
      ...defaultState4(),
      ...parsed,
      history: Array.isArray(parsed.history) ? parsed.history : []
    };
  } catch {
    return defaultState4();
  }
}
function writeVoiceState(projectDir, state) {
  const file3 = filePath8(projectDir);
  ensureDir13(file3);
  fs43.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
  return state;
}
function patchVoiceState(projectDir, patch) {
  const current = readVoiceState(projectDir);
  const next = {
    ...current,
    ...patch
  };
  return writeVoiceState(projectDir, next);
}
function appendVoiceHistory(projectDir, input) {
  const state = readVoiceState(projectDir);
  const item = {
    id: `voice_${randomUUID17()}`,
    text: input.text,
    source: input.source,
    language: input.language,
    mediaID: input.mediaID,
    createdAt: nowIso29()
  };
  const next = {
    ...state,
    lastInputAt: item.createdAt,
    lastTranscript: item.text,
    history: [item, ...state.history].slice(0, 200)
  };
  writeVoiceState(projectDir, next);
  return item;
}
function clearVoiceHistory(projectDir) {
  const state = readVoiceState(projectDir);
  return writeVoiceState(projectDir, {
    ...state,
    history: [],
    lastInputAt: undefined,
    lastTranscript: undefined
  });
}

// src/multimodal/voice.ts
var DEFAULT_VOICE = "default";
var DEFAULT_TTS_MODEL = "local:gpt-sovits-v2pro";
var MULTIMODAL_TEST_MODE_ENV2 = "MIYA_MULTIMODAL_TEST_MODE";
function normalizeFormat(format) {
  if (format === "mp3" || format === "ogg")
    return format;
  return "wav";
}
function buildSilentWavBase64(durationMs) {
  const sampleRate = 16000;
  const channels = 1;
  const bitsPerSample = 16;
  const bytesPerSample = bitsPerSample / 8;
  const frameCount = Math.max(1, Math.floor(sampleRate * durationMs / 1000));
  const dataSize = frameCount * channels * bytesPerSample;
  const buffer = Buffer.alloc(44 + dataSize);
  buffer.write("RIFF", 0);
  buffer.writeUInt32LE(36 + dataSize, 4);
  buffer.write("WAVE", 8);
  buffer.write("fmt ", 12);
  buffer.writeUInt32LE(16, 16);
  buffer.writeUInt16LE(1, 20);
  buffer.writeUInt16LE(channels, 22);
  buffer.writeUInt32LE(sampleRate, 24);
  buffer.writeUInt32LE(sampleRate * channels * bytesPerSample, 28);
  buffer.writeUInt16LE(channels * bytesPerSample, 32);
  buffer.writeUInt16LE(bitsPerSample, 34);
  buffer.write("data", 36);
  buffer.writeUInt32LE(dataSize, 40);
  return buffer.toString("base64");
}
function toBase64FromFile2(filePath9) {
  try {
    if (!fs44.existsSync(filePath9))
      return null;
    return fs44.readFileSync(filePath9).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:"))
    return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode2() {
  const raw = String(process.env[MULTIMODAL_TEST_MODE_ENV2] ?? "").trim().toLowerCase();
  return raw === "1" || raw === "true" || raw === "yes";
}
async function synthesizeVoiceOutput(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const text = input.text.trim();
  if (!text)
    throw new Error("invalid_tts_text");
  const voice = input.voice?.trim() || DEFAULT_VOICE;
  const model = input.model?.trim() || DEFAULT_TTS_MODEL;
  const format = normalizeFormat(input.format);
  const mimeType = format === "mp3" ? "audio/mpeg" : format === "ogg" ? "audio/ogg" : "audio/wav";
  const estDurationMs = Math.max(600, Math.min(7000, text.length * 55));
  const outputDir = getMiyaVoiceTempDir(projectDir);
  const outputPath = path43.join(outputDir, `tts-${Date.now()}.${format}`);
  const profileDir = path43.join(getMiyaRuntimeDir(projectDir), "profiles", "companion", "current");
  let tts;
  if (useMultimodalTestMode2()) {
    tts = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      tts = await daemon.runSovitsTts({
        text,
        outputPath,
        profileDir,
        voice,
        format
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget2(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number")
            pending = String(plan.pending);
        } catch {}
        throw new Error(`model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`);
      }
      if (!isRuntimeNotReadyError2(error92))
        throw error92;
      tts = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const generatedBase64 = toBase64FromFile2(tts.outputPath);
  if (!generatedBase64 && !tts.message.startsWith("python_runtime_not_ready:")) {
    throw new Error(`sovits_tts_output_missing:${tts.message}`);
  }
  const wavBase64 = generatedBase64 ?? buildSilentWavBase64(estDurationMs);
  const media = ingestMedia(projectDir, {
    source: "multimodal.voice.output",
    kind: "audio",
    mimeType,
    fileName: `tts-${Date.now()}.${format}`,
    contentBase64: wavBase64,
    sizeBytes: Math.floor(wavBase64.length * 3 / 4),
    metadata: {
      status: tts.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      text,
      voice,
      model,
      format,
      tier: tts.tier,
      degraded: tts.degraded,
      engineMessage: tts.message,
      payloadCodec: "pcm_s16le",
      estimatedDurationMs: estDurationMs,
      runtimeError: tts.message.startsWith("python_runtime_not_ready:") ? tts.message : undefined,
      createdBy: "miya_voice_output"
    }
  });
  appendVoiceHistory(projectDir, {
    text,
    source: "talk",
    mediaID: media.id
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "audio",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `voice:${voice}`
    });
  }
  return {
    media,
    voice,
    model,
    format
  };
}
// src/nodes/index.ts
import {
  createHash as createHash12,
  randomBytes as randomBytes2,
  randomUUID as randomUUID18,
  timingSafeEqual
} from "node:crypto";
import * as fs45 from "node:fs";
import * as path44 from "node:path";
var HEARTBEAT_STALE_MS = 2 * 60 * 1000;
function nowIso30() {
  return new Date().toISOString();
}
function hashToken(token) {
  return createHash12("sha256").update(token).digest("hex");
}
function defaultNodePermissions() {
  return {
    screenRecording: false,
    accessibility: false,
    filesystem: "none",
    network: false
  };
}
function inferPermissionsFromCapabilities(capabilities, base) {
  const inferred = defaultNodePermissions();
  for (const capability of capabilities) {
    if (capability === "perm.screenRecording")
      inferred.screenRecording = true;
    if (capability === "perm.accessibility")
      inferred.accessibility = true;
    if (capability === "perm.network")
      inferred.network = true;
    if (capability.startsWith("perm.filesystem.")) {
      const suffix = capability.slice("perm.filesystem.".length);
      if (suffix === "none" || suffix === "read" || suffix === "full") {
        inferred.filesystem = suffix;
      }
    }
  }
  return {
    ...inferred,
    ...base ?? {}
  };
}
function hasCapability(node, matcher) {
  return node.capabilities.some((capability) => matcher(capability));
}
function capabilityStartsWith(capability, prefixes) {
  return prefixes.some((prefix) => capability.startsWith(prefix));
}
function classifyNodeCapabilities(capabilities) {
  const normalized = [
    ...new Set(capabilities.map((item) => String(item).trim()).filter(Boolean))
  ].sort();
  const groups = {
    readOnly: [],
    execute: [],
    desktopAutomation: [],
    networking: [],
    other: []
  };
  for (const capability of normalized) {
    if (capability === "system.info" || capability === "system.which" || capabilityStartsWith(capability, ["query.", "read.", "inspect."])) {
      groups.readOnly.push(capability);
      continue;
    }
    if (capability === "system.run" || capabilityStartsWith(capability, ["exec.", "run.", "write.", "deploy."])) {
      groups.execute.push(capability);
      continue;
    }
    if (capabilityStartsWith(capability, [
      "perm.screenRecording",
      "perm.accessibility",
      "desktop.",
      "uia.",
      "canvas."
    ])) {
      groups.desktopAutomation.push(capability);
      continue;
    }
    if (capabilityStartsWith(capability, [
      "perm.network",
      "network.",
      "http.",
      "ws."
    ])) {
      groups.networking.push(capability);
      continue;
    }
    groups.other.push(capability);
  }
  return groups;
}
function mapNodePermissions(node) {
  const reasons = [];
  const canRun = hasCapability(node, (capability) => capability === "system.run" || capabilityStartsWith(capability, ["exec.", "run."]));
  const canRead = hasCapability(node, (capability) => capability === "system.info" || capability === "system.which" || capabilityStartsWith(capability, ["read.", "query."]));
  const desktopSignals = node.permissions.screenRecording || node.permissions.accessibility;
  const desktopStrong = node.permissions.screenRecording && node.permissions.accessibility;
  const bash = !canRun ? "deny" : node.paired && node.connected ? "allow" : "ask";
  if (canRun)
    reasons.push("capability.system.run");
  if (!node.paired)
    reasons.push("node_unpaired");
  if (!node.connected)
    reasons.push("node_disconnected");
  let edit = "deny";
  if (node.permissions.filesystem === "full")
    edit = node.paired ? "allow" : "ask";
  else if (node.permissions.filesystem === "read" || canRead)
    edit = "ask";
  if (node.permissions.filesystem !== "none")
    reasons.push(`filesystem=${node.permissions.filesystem}`);
  const externalDirectory = node.permissions.filesystem === "full" && node.permissions.network && node.paired ? "allow" : node.permissions.filesystem !== "none" || node.permissions.network ? "ask" : "deny";
  if (node.permissions.network)
    reasons.push("network=true");
  const desktopControl = node.type === "desktop" && desktopStrong && node.paired ? "allow" : node.type === "desktop" && desktopSignals ? "ask" : "deny";
  if (desktopSignals)
    reasons.push("desktop_automation_capable");
  const network = node.permissions.network ? node.paired ? "allow" : "ask" : "deny";
  let riskScore = 0;
  if (bash === "allow")
    riskScore += 2;
  else if (bash === "ask")
    riskScore += 1;
  if (edit === "allow")
    riskScore += 2;
  else if (edit === "ask")
    riskScore += 1;
  if (externalDirectory === "allow")
    riskScore += 2;
  else if (externalDirectory === "ask")
    riskScore += 1;
  if (desktopControl === "allow")
    riskScore += 2;
  else if (desktopControl === "ask")
    riskScore += 1;
  if (network === "allow")
    riskScore += 1;
  if (node.permissions.filesystem === "full" && node.permissions.network)
    riskScore += 2;
  if (!node.paired)
    riskScore += 1;
  if (!node.connected)
    riskScore += 1;
  const riskLevel = riskScore >= 6 ? "HIGH" : riskScore >= 3 ? "MEDIUM" : "LOW";
  return {
    bash,
    edit,
    externalDirectory,
    desktopControl,
    network,
    riskLevel,
    reasons
  };
}
function summarizeNodeGovernance(nodes, pendingPairs = 0) {
  const risk = {
    low: 0,
    medium: 0,
    high: 0
  };
  const permissionCoverage = {
    bashAllow: 0,
    editAllow: 0,
    externalDirectoryAllow: 0,
    desktopControlAllow: 0,
    networkAllow: 0
  };
  for (const node of nodes) {
    const mapped = mapNodePermissions(node);
    if (mapped.riskLevel === "LOW")
      risk.low += 1;
    else if (mapped.riskLevel === "MEDIUM")
      risk.medium += 1;
    else
      risk.high += 1;
    if (mapped.bash === "allow")
      permissionCoverage.bashAllow += 1;
    if (mapped.edit === "allow")
      permissionCoverage.editAllow += 1;
    if (mapped.externalDirectory === "allow")
      permissionCoverage.externalDirectoryAllow += 1;
    if (mapped.desktopControl === "allow")
      permissionCoverage.desktopControlAllow += 1;
    if (mapped.network === "allow")
      permissionCoverage.networkAllow += 1;
  }
  return {
    total: nodes.length,
    connected: nodes.filter((item) => item.connected).length,
    paired: nodes.filter((item) => item.paired).length,
    pendingPairs: Math.max(0, pendingPairs),
    risk,
    permissionCoverage
  };
}
function normalizeNodeRecord(partial3) {
  const capabilityList = Array.isArray(partial3.capabilities) ? partial3.capabilities.map((item) => String(item)).filter(Boolean).sort() : [];
  const fallbackHeartbeat = String(partial3.lastSeenAt ?? nowIso30());
  const permissions = inferPermissionsFromCapabilities(capabilityList, partial3.permissions);
  const status = partial3.connected ? "online" : "offline";
  return {
    nodeID: String(partial3.nodeID ?? ""),
    deviceID: String(partial3.deviceID ?? ""),
    type: partial3.type === "cli" || partial3.type === "desktop" || partial3.type === "mobile" || partial3.type === "browser" ? partial3.type : "cli",
    role: "node",
    platform: String(partial3.platform ?? process.platform),
    permissions,
    capabilities: capabilityList,
    connected: Boolean(partial3.connected),
    paired: Boolean(partial3.paired),
    status: partial3.status === "online" || partial3.status === "offline" || partial3.status === "error" ? partial3.status : status,
    tokenHash: typeof partial3.tokenHash === "string" ? partial3.tokenHash : undefined,
    tokenIssuedAt: typeof partial3.tokenIssuedAt === "string" ? partial3.tokenIssuedAt : undefined,
    tokenLastUsedAt: typeof partial3.tokenLastUsedAt === "string" ? partial3.tokenLastUsedAt : undefined,
    lastHeartbeatAt: typeof partial3.lastHeartbeatAt === "string" ? partial3.lastHeartbeatAt : fallbackHeartbeat,
    lastSeenAt: String(partial3.lastSeenAt ?? fallbackHeartbeat),
    createdAt: String(partial3.createdAt ?? nowIso30()),
    updatedAt: String(partial3.updatedAt ?? nowIso30())
  };
}
function applyHeartbeatHealth(store) {
  const now = Date.now();
  let changed = false;
  for (const node of Object.values(store.nodes)) {
    const heartbeatAt = Date.parse(node.lastHeartbeatAt || node.lastSeenAt);
    if (Number.isNaN(heartbeatAt))
      continue;
    const stale = now - heartbeatAt > HEARTBEAT_STALE_MS;
    if (stale && (node.connected || node.status === "online")) {
      node.connected = false;
      node.status = "offline";
      node.updatedAt = nowIso30();
      changed = true;
    }
  }
  return changed;
}
function filePath9(projectDir) {
  return path44.join(getMiyaRuntimeDir(projectDir), "nodes.json");
}
function ensureDir14(file3) {
  fs45.mkdirSync(path44.dirname(file3), { recursive: true });
}
function readStore10(projectDir) {
  const file3 = filePath9(projectDir);
  if (!fs45.existsSync(file3)) {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
  try {
    const parsed = JSON.parse(fs45.readFileSync(file3, "utf-8"));
    const rawNodes = parsed.nodes ?? {};
    const nodes = {};
    for (const [nodeID, node] of Object.entries(rawNodes)) {
      const normalized = normalizeNodeRecord({
        ...node,
        nodeID: nodeID || node?.nodeID
      });
      if (!normalized.nodeID)
        continue;
      nodes[normalized.nodeID] = normalized;
    }
    return {
      nodes,
      devices: parsed.devices ?? {},
      pairs: Array.isArray(parsed.pairs) ? parsed.pairs : [],
      invokes: parsed.invokes ?? {}
    };
  } catch {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
}
function writeStore8(projectDir, store) {
  const file3 = filePath9(projectDir);
  ensureDir14(file3);
  fs45.writeFileSync(file3, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function readStoreWithHealth(projectDir) {
  const store = readStore10(projectDir);
  if (applyHeartbeatHealth(store)) {
    writeStore8(projectDir, store);
  }
  return store;
}
function verifyNodeToken(node, token) {
  if (!node.tokenHash)
    return true;
  if (!token)
    return false;
  const expected = Buffer.from(node.tokenHash, "hex");
  const actual = Buffer.from(hashToken(token), "hex");
  if (expected.length !== actual.length)
    return false;
  return timingSafeEqual(expected, actual);
}
function registerNode(projectDir, input) {
  const store = readStoreWithHealth(projectDir);
  const existing = store.nodes[input.nodeID];
  if (existing && !verifyNodeToken(existing, input.token)) {
    throw new Error("node_token_invalid");
  }
  const nextCapabilities = [...new Set(input.capabilities)].sort();
  const now = nowIso30();
  const createdAt = store.nodes[input.nodeID]?.createdAt ?? nowIso30();
  const lastHeartbeatAt = now;
  const tokenLastUsedAt = existing?.tokenHash ? now : existing?.tokenLastUsedAt;
  const node = {
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    type: input.type ?? existing?.type ?? "cli",
    role: "node",
    platform: input.platform,
    permissions: inferPermissionsFromCapabilities(nextCapabilities, {
      ...existing?.permissions,
      ...input.permissions ?? {}
    }),
    capabilities: nextCapabilities,
    connected: true,
    paired: existing?.paired ?? false,
    status: "online",
    tokenHash: existing?.tokenHash,
    tokenIssuedAt: existing?.tokenIssuedAt,
    tokenLastUsedAt,
    lastHeartbeatAt,
    lastSeenAt: now,
    createdAt,
    updatedAt: now
  };
  store.nodes[input.nodeID] = node;
  const device = {
    deviceID: input.deviceID,
    label: store.devices[input.deviceID]?.label,
    approved: store.devices[input.deviceID]?.approved ?? false,
    createdAt: store.devices[input.deviceID]?.createdAt ?? now,
    updatedAt: now
  };
  store.devices[input.deviceID] = device;
  writeStore8(projectDir, store);
  return node;
}
function touchNodeHeartbeat(projectDir, nodeID) {
  const store = readStore10(projectDir);
  const node = store.nodes[nodeID];
  if (!node)
    return null;
  const now = nowIso30();
  node.connected = true;
  node.status = "online";
  node.lastHeartbeatAt = now;
  node.lastSeenAt = now;
  node.updatedAt = now;
  writeStore8(projectDir, store);
  return node;
}
function markNodeDisconnected(projectDir, nodeID) {
  const store = readStore10(projectDir);
  const node = store.nodes[nodeID];
  if (!node)
    return;
  node.connected = false;
  node.status = "offline";
  node.updatedAt = nowIso30();
  writeStore8(projectDir, store);
}
function listNodes(projectDir) {
  const store = readStoreWithHealth(projectDir);
  return Object.values(store.nodes).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function listDevices(projectDir) {
  const store = readStoreWithHealth(projectDir);
  return Object.values(store.devices).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function describeNode(projectDir, nodeID) {
  const store = readStoreWithHealth(projectDir);
  return store.nodes[nodeID] ?? null;
}
function issueNodeToken(projectDir, nodeID) {
  const store = readStoreWithHealth(projectDir);
  const node = store.nodes[nodeID];
  if (!node)
    return null;
  const token = `nkt_${randomBytes2(24).toString("hex")}`;
  const issuedAt = nowIso30();
  node.tokenHash = hashToken(token);
  node.tokenIssuedAt = issuedAt;
  node.tokenLastUsedAt = issuedAt;
  node.updatedAt = issuedAt;
  store.nodes[nodeID] = node;
  writeStore8(projectDir, store);
  return { nodeID, token, issuedAt };
}
function createNodePairRequest(projectDir, input) {
  const store = readStore10(projectDir);
  const pending = store.pairs.find((item) => item.nodeID === input.nodeID && item.status === "pending");
  if (pending)
    return pending;
  const pair = {
    id: `npair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    status: "pending",
    requestedAt: nowIso30()
  };
  store.pairs = [pair, ...store.pairs].slice(0, 1000);
  writeStore8(projectDir, store);
  return pair;
}
function listNodePairs(projectDir, status) {
  const store = readStore10(projectDir);
  const pairs = status ? store.pairs.filter((item) => item.status === status) : store.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function resolveNodePair(projectDir, pairID, status) {
  const store = readStore10(projectDir);
  const pair = store.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending")
    return null;
  pair.status = status;
  pair.resolvedAt = nowIso30();
  if (status === "approved") {
    const node = store.nodes[pair.nodeID];
    if (node) {
      node.paired = true;
      node.updatedAt = nowIso30();
    }
    const device = store.devices[pair.deviceID];
    if (device) {
      device.approved = true;
      device.updatedAt = nowIso30();
    }
  }
  writeStore8(projectDir, store);
  return pair;
}
function createInvokeRequest(projectDir, input) {
  const store = readStore10(projectDir);
  const invoke = {
    id: `invoke_${randomUUID18()}`,
    nodeID: input.nodeID,
    capability: input.capability,
    args: input.args,
    status: "pending",
    createdAt: nowIso30(),
    updatedAt: nowIso30()
  };
  store.invokes[invoke.id] = invoke;
  writeStore8(projectDir, store);
  return invoke;
}
function markInvokeSent(projectDir, invokeID) {
  const store = readStore10(projectDir);
  const invoke = store.invokes[invokeID];
  if (!invoke)
    return null;
  invoke.status = "sent";
  invoke.updatedAt = nowIso30();
  writeStore8(projectDir, store);
  return invoke;
}
function resolveInvokeResult(projectDir, invokeID, input) {
  const store = readStore10(projectDir);
  const invoke = store.invokes[invokeID];
  if (!invoke)
    return null;
  invoke.status = input.ok ? "completed" : "failed";
  invoke.result = input.result;
  invoke.error = input.error;
  invoke.updatedAt = nowIso30();
  writeStore8(projectDir, store);
  return invoke;
}
function listInvokeRequests(projectDir, limit = 50) {
  const store = readStore10(projectDir);
  return Object.values(store.invokes).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, limit));
}

// src/policy/decision-fusion.ts
function normalizeConfidence(value) {
  if (!Number.isFinite(value))
    return 0;
  if (value < 0)
    return 0;
  if (value > 1)
    return 1;
  return value;
}
function normalizeTrustScore(value) {
  if (!Number.isFinite(value))
    return 50;
  if (value < 0)
    return 0;
  if (value > 100)
    return 100;
  return Math.round(value);
}
function normalizeTrustMode(input) {
  let silentMin = Math.max(0, Math.min(100, Math.round(input?.silentMin ?? 90)));
  let modalMax = Math.max(0, Math.min(100, Math.round(input?.modalMax ?? 50)));
  if (silentMin <= modalMax) {
    const pivot = Math.round((silentMin + modalMax) / 2);
    silentMin = Math.min(100, pivot + 1);
    modalMax = Math.max(0, pivot - 1);
  }
  if (silentMin - modalMax < 2) {
    if (silentMin < 100)
      silentMin += 1;
    else if (modalMax > 0)
      modalMax -= 1;
  }
  if (silentMin <= modalMax) {
    return { silentMin: 90, modalMax: 50 };
  }
  return { silentMin, modalMax };
}
function resolveApprovalMode(input) {
  if (input.action !== "allow")
    return "modal_approval";
  const thresholds = normalizeTrustMode(input.trustMode);
  const silentMin = thresholds.silentMin;
  const modalMax = thresholds.modalMax;
  if (input.trustScore >= silentMin)
    return "silent_audit";
  if (input.trustScore <= modalMax)
    return "modal_approval";
  return "toast_gate";
}
function evaluateOutboundDecisionFusion(input) {
  const conf = normalizeConfidence(input.confidenceIntent);
  const evidenceConf = normalizeConfidence(input.evidenceConfidence ?? input.confidenceIntent);
  const trustScore = normalizeTrustScore(input.trustMinScore);
  const expressionMatched = input.factorTextSensitive && !input.factorRecipientIsMe || input.factorTextSensitive && input.factorIntentSuspicious;
  if (evidenceConf < 0.35) {
    const action2 = expressionMatched ? conf < 0.5 ? "hard_fuse" : "soft_fuse" : "allow";
    return {
      expressionMatched,
      zone: action2 === "hard_fuse" ? "danger" : "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: action2 === "hard_fuse" ? "decision_fusion_danger_low_evidence" : action2 === "soft_fuse" ? "decision_fusion_gray_low_evidence" : "decision_fusion_low_evidence_confirmation_required"
    };
  }
  if (!expressionMatched) {
    const action2 = "allow";
    return {
      expressionMatched: false,
      zone: "safe",
      action: action2,
      approvalMode: resolveApprovalMode({
        action: action2,
        trustScore,
        trustMode: input.trustMode
      }),
      reason: "decision_fusion_clear"
    };
  }
  if (conf < 0.5) {
    const action2 = "hard_fuse";
    return {
      expressionMatched: true,
      zone: "danger",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_danger"
    };
  }
  if (conf <= 0.85) {
    const action2 = "soft_fuse";
    return {
      expressionMatched: true,
      zone: "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_gray"
    };
  }
  const action = "allow";
  return {
    expressionMatched: true,
    zone: "safe",
    action,
    approvalMode: resolveApprovalMode({
      action,
      trustScore,
      trustMode: input.trustMode
    }),
    reason: "decision_fusion_safe_by_confidence"
  };
}

// src/policy/incident.ts
import { randomUUID as randomUUID19 } from "node:crypto";
import * as fs46 from "node:fs";
import * as path45 from "node:path";
function incidentFile(projectDir) {
  return path45.join(getMiyaRuntimeDir(projectDir), "policy-incidents.jsonl");
}
function appendPolicyIncident(projectDir, incident) {
  assertSemanticTags(incident.semanticTags);
  const semanticTags = normalizeSemanticTags(incident.semanticTags);
  const payload = {
    id: incident.id ?? `incident_${randomUUID19()}`,
    at: incident.at ?? new Date().toISOString(),
    type: incident.type,
    reason: incident.reason,
    channel: incident.channel,
    destination: incident.destination,
    auditID: incident.auditID,
    policyHash: incident.policyHash,
    pausedDomains: incident.pausedDomains,
    statusByDomain: incident.statusByDomain,
    semanticSummary: incident.semanticSummary,
    semanticTags,
    details: incident.details
  };
  const file3 = incidentFile(projectDir);
  fs46.mkdirSync(path45.dirname(file3), { recursive: true });
  fs46.appendFileSync(file3, `${JSON.stringify(payload)}
`, "utf-8");
  return payload;
}
function listPolicyIncidents(projectDir, limit = 50) {
  const file3 = incidentFile(projectDir);
  if (!fs46.existsSync(file3))
    return [];
  const rows = fs46.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}

// src/resource-scheduler/scheduler.ts
import { randomUUID as randomUUID20 } from "node:crypto";

// src/resource-scheduler/store.ts
import * as fs47 from "node:fs";
import * as path46 from "node:path";
function schedulerDir(projectDir) {
  return path46.join(getMiyaRuntimeDir(projectDir), "resource-scheduler");
}
function snapshotPath(projectDir) {
  return path46.join(schedulerDir(projectDir), "state.json");
}
function eventsPath(projectDir) {
  return path46.join(schedulerDir(projectDir), "events.jsonl");
}
function ensureDir15(projectDir) {
  fs47.mkdirSync(schedulerDir(projectDir), { recursive: true });
}
function writeSchedulerSnapshot(projectDir, snapshot) {
  ensureDir15(projectDir);
  fs47.writeFileSync(snapshotPath(projectDir), `${JSON.stringify(snapshot, null, 2)}
`, "utf-8");
}
function appendSchedulerEvent(projectDir, event) {
  ensureDir15(projectDir);
  fs47.appendFileSync(eventsPath(projectDir), `${JSON.stringify(event)}
`, "utf-8");
}

// src/resource-scheduler/vram.ts
function clampNonNegative(value) {
  if (!Number.isFinite(value) || value <= 0)
    return 0;
  return Math.floor(value);
}
function calculateVramBudget(input) {
  const availableMB = Math.max(0, clampNonNegative(input.snapshot.totalVramMB) - clampNonNegative(input.snapshot.safetyMarginMB) - clampNonNegative(input.snapshot.usedVramMB));
  const loaded = new Map(input.snapshot.loadedModels.map((model) => [
    model.modelID,
    clampNonNegative(model.vramMB)
  ]));
  const keepLoaded = new Set;
  let modelsNeedLoadMB = 0;
  for (const model of input.models) {
    if (!model.required)
      continue;
    const need = clampNonNegative(model.vramMB);
    const loadedMB = loaded.get(model.modelID) ?? 0;
    if (loadedMB >= need) {
      keepLoaded.add(model.modelID);
      continue;
    }
    modelsNeedLoadMB += need;
  }
  const requiredMB = clampNonNegative(input.task.taskVramMB) + modelsNeedLoadMB;
  const overflowMB = Math.max(0, requiredMB - availableMB);
  const fit = overflowMB <= 0;
  const suggestedTaskVramMB = fit ? clampNonNegative(input.task.taskVramMB) : Math.max(256, clampNonNegative(input.task.taskVramMB) - overflowMB);
  const unloadFirst = input.snapshot.loadedModels.filter((model) => model.pins <= 0 && !keepLoaded.has(model.modelID)).sort((a, b) => Date.parse(a.lastUsedAt) - Date.parse(b.lastUsedAt)).map((model) => model.modelID);
  return {
    fit,
    availableMB,
    requiredMB,
    overflowMB,
    suggestedTaskVramMB,
    canUseReferenceOnly: suggestedTaskVramMB < 512,
    modelPlan: {
      keepLoaded: [...keepLoaded],
      unloadFirst
    }
  };
}
function decideModelSwapAction(input) {
  const current = (input.currentModelID ?? "").trim();
  const target = (input.targetModelID ?? "").trim();
  if (!target)
    return "reuse";
  if (current && current === target)
    return "reuse";
  if (input.budget.fit)
    return current ? "hot_load" : "reuse";
  if (input.budget.modelPlan.unloadFirst.length > 0)
    return "evict_then_load";
  return "degraded_reference";
}

// src/resource-scheduler/scheduler.ts
function nowIso31() {
  return new Date().toISOString();
}
function toNumber2(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0)
    return fallback;
  return Math.floor(parsed);
}

class ResourceScheduler {
  projectDir;
  totalVramMB;
  safetyMarginMB;
  maxConcurrentTasks;
  hotsetLimitMB;
  warmPoolLimitMB;
  maxOffloadedModels;
  queue = [];
  active = new Map;
  loadedModels = new Map;
  offloadedModels = new Map;
  currentModelByKind = new Map;
  usedVramMB = 0;
  draining = false;
  constructor(projectDir, options = {}) {
    this.projectDir = projectDir;
    this.totalVramMB = Math.min(8192, options.totalVramMB ?? toNumber2(process.env.MIYA_RESOURCE_TOTAL_VRAM_MB, 8192));
    this.safetyMarginMB = options.safetyMarginMB ?? toNumber2(process.env.MIYA_RESOURCE_SAFETY_MARGIN_MB, 768);
    this.maxConcurrentTasks = options.maxConcurrentTasks ?? toNumber2(process.env.MIYA_RESOURCE_MAX_CONCURRENT, 2);
    this.hotsetLimitMB = Math.max(512, Math.min(this.totalVramMB, toNumber2(process.env.MIYA_RESOURCE_HOTSET_MB, Math.max(1024, Math.floor(this.totalVramMB * 0.55)))));
    const warmPoolCapacity = Math.max(0, this.totalVramMB - this.hotsetLimitMB);
    this.warmPoolLimitMB = warmPoolCapacity <= 0 ? 0 : warmPoolCapacity <= 256 ? warmPoolCapacity : Math.max(256, Math.min(warmPoolCapacity, toNumber2(process.env.MIYA_RESOURCE_WARMPOOL_MB, Math.max(512, Math.floor(this.totalVramMB * 0.25)))));
    this.maxOffloadedModels = Math.max(8, toNumber2(process.env.MIYA_RESOURCE_OFFLOAD_MAX, 64));
    this.recordSnapshot();
  }
  async acquire(request) {
    const pendingID = `lease_${randomUUID20()}`;
    return new Promise((resolve3, reject) => {
      const timeoutMs = typeof request.timeoutMs === "number" && request.timeoutMs > 0 ? request.timeoutMs : undefined;
      const timeoutAtMs = timeoutMs ? Date.now() + timeoutMs : undefined;
      const pending = {
        id: pendingID,
        request,
        createdAtMs: Date.now(),
        timeoutAtMs,
        resolve: resolve3,
        reject
      };
      this.queue.push(pending);
      this.queue.sort((a, b) => {
        const priorityA = a.request.priority ?? 0;
        const priorityB = b.request.priority ?? 0;
        if (priorityA !== priorityB)
          return priorityB - priorityA;
        return a.createdAtMs - b.createdAtMs;
      });
      appendSchedulerEvent(this.projectDir, {
        at: nowIso31(),
        type: "queued",
        leaseID: pendingID,
        kind: request.kind,
        priority: request.priority ?? 0,
        requestedVramMB: request.vramMB ?? 0,
        modelID: request.modelID
      });
      this.recordSnapshot();
      this.scheduleDrain();
    });
  }
  async withLease(request, run) {
    const lease = await this.acquire(request);
    try {
      return await run();
    } finally {
      lease.release();
    }
  }
  snapshot() {
    const loadedModels = [...this.loadedModels.values()].sort((a, b) => b.lastUsedAtMs - a.lastUsedAtMs);
    const hotsetUsedMB = loadedModels.filter((model) => model.residency === "hot").reduce((sum, model) => sum + model.vramMB, 0);
    const warmPoolUsedMB = loadedModels.filter((model) => model.residency === "warm").reduce((sum, model) => sum + model.vramMB, 0);
    return {
      timestamp: nowIso31(),
      totalVramMB: this.totalVramMB,
      safetyMarginMB: this.safetyMarginMB,
      usedVramMB: this.usedVramMB,
      activeTasks: this.active.size,
      queueDepth: this.queue.length,
      loadedModels: loadedModels.map((model) => ({
        modelID: model.modelID,
        vramMB: model.vramMB,
        pins: model.pins,
        lastUsedAt: new Date(model.lastUsedAtMs).toISOString(),
        residency: model.residency
      })),
      hydraulics: {
        hotsetLimitMB: this.hotsetLimitMB,
        warmPoolLimitMB: this.warmPoolLimitMB,
        hotsetUsedMB,
        warmPoolUsedMB,
        offloadedModels: [...this.offloadedModels.values()].sort((a, b) => b.offloadedAtMs - a.offloadedAtMs).map((item) => ({
          modelID: item.modelID,
          vramMB: item.vramMB,
          offloadedAt: new Date(item.offloadedAtMs).toISOString(),
          reason: item.reason
        }))
      }
    };
  }
  planVramBudget(request) {
    return calculateVramBudget({
      snapshot: this.snapshot(),
      task: {
        taskID: request.kind,
        taskVramMB: Math.max(0, Math.floor(request.vramMB ?? 0)),
        priority: request.priority
      },
      models: request.modelID ? [
        {
          modelID: request.modelID,
          vramMB: Math.max(0, Math.floor(request.modelVramMB ?? request.vramMB ?? 0)),
          required: true
        }
      ] : []
    });
  }
  scheduleDrain() {
    if (this.draining)
      return;
    this.draining = true;
    queueMicrotask(() => {
      this.draining = false;
      this.drainQueue();
    });
  }
  drainQueue() {
    let progressed = true;
    while (progressed) {
      progressed = false;
      this.removeExpiredPending();
      if (this.active.size >= this.maxConcurrentTasks)
        return;
      const pending = this.queue[0];
      if (!pending)
        return;
      if (!this.canGrant(pending.request))
        return;
      this.queue.shift();
      const grantedAt = nowIso31();
      const requestVramMB = Math.max(0, Math.floor(pending.request.vramMB ?? 0));
      const lease = {
        id: pending.id,
        kind: pending.request.kind,
        grantedAt,
        requestVramMB,
        modelID: pending.request.modelID
      };
      this.active.set(lease.id, lease);
      if (requestVramMB > 0)
        this.usedVramMB += requestVramMB;
      if (pending.request.modelID) {
        const modelVramMB = Math.max(0, Math.floor(pending.request.modelVramMB ?? requestVramMB));
        const swapAction = this.selectModelSwapAction(pending.request.kind, pending.request.modelID, pending.request);
        if (swapAction === "evict_then_load") {
          this.evictModelsIfNeeded(modelVramMB);
        }
        this.ensureModelLoaded(pending.request.modelID, modelVramMB);
        this.pinModel(pending.request.modelID);
        this.currentModelByKind.set(pending.request.kind, pending.request.modelID);
        appendSchedulerEvent(this.projectDir, {
          at: nowIso31(),
          type: "model_swap",
          kind: pending.request.kind,
          action: swapAction,
          modelID: pending.request.modelID,
          vramMB: modelVramMB
        });
      }
      appendSchedulerEvent(this.projectDir, {
        at: grantedAt,
        type: "granted",
        leaseID: lease.id,
        kind: lease.kind,
        requestedVramMB: requestVramMB,
        modelID: lease.modelID
      });
      this.recordSnapshot();
      pending.resolve({
        id: lease.id,
        kind: lease.kind,
        grantedAt,
        vramMB: requestVramMB,
        release: () => this.release(lease.id)
      });
      progressed = true;
    }
  }
  release(leaseID) {
    const lease = this.active.get(leaseID);
    if (!lease)
      return;
    this.active.delete(leaseID);
    if (lease.requestVramMB > 0) {
      this.usedVramMB = Math.max(0, this.usedVramMB - lease.requestVramMB);
    }
    if (lease.modelID) {
      this.unpinModel(lease.modelID);
      this.touchModel(lease.modelID);
    }
    this.rebalanceHydraulics();
    appendSchedulerEvent(this.projectDir, {
      at: nowIso31(),
      type: "released",
      leaseID,
      kind: lease.kind,
      releasedVramMB: lease.requestVramMB,
      modelID: lease.modelID
    });
    this.recordSnapshot();
    this.scheduleDrain();
  }
  canGrant(request) {
    if (this.active.size >= this.maxConcurrentTasks)
      return false;
    const modelVramMB = request.modelID ? Math.max(0, Math.floor(request.modelVramMB ?? request.vramMB ?? 0)) : 0;
    const neededVramMB = Math.max(0, Math.floor(request.vramMB ?? 0));
    if (neededVramMB + modelVramMB <= 0)
      return true;
    this.rebalanceHydraulics();
    this.evictModelsIfNeeded(neededVramMB + modelVramMB);
    return this.availableVramMB() >= neededVramMB + modelVramMB;
  }
  selectModelSwapAction(kind, targetModelID, request) {
    const budget = this.planVramBudget(request);
    return decideModelSwapAction({
      currentModelID: this.currentModelByKind.get(kind),
      targetModelID,
      budget
    });
  }
  availableVramMB() {
    return Math.max(0, this.totalVramMB - this.safetyMarginMB - this.usedVramMB - this.loadedModelsVramMB());
  }
  loadedModelsVramMB() {
    let sum = 0;
    for (const model of this.loadedModels.values())
      sum += model.vramMB;
    return sum;
  }
  removeExpiredPending() {
    const now = Date.now();
    const keep = [];
    for (const pending of this.queue) {
      if (pending.timeoutAtMs && pending.timeoutAtMs <= now) {
        appendSchedulerEvent(this.projectDir, {
          at: nowIso31(),
          type: "timeout",
          leaseID: pending.id,
          kind: pending.request.kind
        });
        pending.reject(new Error("resource_acquire_timeout"));
      } else {
        keep.push(pending);
      }
    }
    if (keep.length !== this.queue.length) {
      this.queue.length = 0;
      this.queue.push(...keep);
      this.recordSnapshot();
    }
  }
  ensureModelLoaded(modelID, vramMB) {
    if (!modelID || vramMB <= 0)
      return;
    const existing = this.loadedModels.get(modelID);
    if (existing) {
      existing.lastUsedAtMs = Date.now();
      if (existing.residency !== "hot")
        existing.residency = "hot";
      return;
    }
    const offloaded = this.offloadedModels.get(modelID);
    if (offloaded) {
      this.offloadedModels.delete(modelID);
      appendSchedulerEvent(this.projectDir, {
        at: nowIso31(),
        type: "model_reloaded",
        modelID,
        vramMB: offloaded.vramMB,
        reason: offloaded.reason
      });
    }
    this.evictModelsIfNeeded(vramMB);
    this.loadedModels.set(modelID, {
      modelID,
      vramMB,
      pins: 0,
      lastUsedAtMs: Date.now(),
      residency: "hot"
    });
    appendSchedulerEvent(this.projectDir, {
      at: nowIso31(),
      type: "model_loaded",
      modelID,
      vramMB
    });
    this.rebalanceHydraulics();
  }
  evictModelsIfNeeded(requiredVramMB) {
    if (requiredVramMB <= 0)
      return;
    if (this.availableVramMB() >= requiredVramMB)
      return;
    const candidates = [...this.loadedModels.values()].filter((item) => item.pins <= 0).sort((a, b) => a.lastUsedAtMs - b.lastUsedAtMs);
    for (const candidate of candidates) {
      this.offloadModel(candidate, "lru_evict");
      if (this.availableVramMB() >= requiredVramMB)
        break;
    }
  }
  offloadModel(model, reason) {
    this.loadedModels.delete(model.modelID);
    this.offloadedModels.set(model.modelID, {
      modelID: model.modelID,
      vramMB: model.vramMB,
      offloadedAtMs: Date.now(),
      reason
    });
    if (this.offloadedModels.size > this.maxOffloadedModels) {
      const stale = [...this.offloadedModels.values()].sort((a, b) => a.offloadedAtMs - b.offloadedAtMs);
      const trim = stale.slice(0, Math.max(0, this.offloadedModels.size - this.maxOffloadedModels));
      for (const item of trim) {
        this.offloadedModels.delete(item.modelID);
      }
    }
    appendSchedulerEvent(this.projectDir, {
      at: nowIso31(),
      type: "model_unloaded",
      modelID: model.modelID,
      vramMB: model.vramMB,
      reason
    });
  }
  pinModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model)
      return;
    model.pins += 1;
    model.lastUsedAtMs = Date.now();
    model.residency = "hot";
  }
  unpinModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model)
      return;
    model.pins = Math.max(0, model.pins - 1);
    model.lastUsedAtMs = Date.now();
  }
  touchModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model)
      return;
    model.lastUsedAtMs = Date.now();
  }
  rebalanceHydraulics() {
    if (this.loadedModels.size === 0)
      return;
    let hotUsed = 0;
    let warmUsed = 0;
    const candidates = [...this.loadedModels.values()].sort((a, b) => b.lastUsedAtMs - a.lastUsedAtMs);
    const toOffload = [];
    for (const model of candidates) {
      const previous = model.residency;
      let next;
      if (model.pins > 0) {
        next = "hot";
      } else if (hotUsed + model.vramMB <= this.hotsetLimitMB) {
        next = "hot";
      } else if (warmUsed + model.vramMB <= this.warmPoolLimitMB) {
        next = "warm";
      } else {
        next = "offload";
      }
      if (next === "hot") {
        hotUsed += model.vramMB;
      } else if (next === "warm") {
        warmUsed += model.vramMB;
      } else {
        toOffload.push(model);
      }
      if (next !== "offload" && previous !== next) {
        model.residency = next;
        appendSchedulerEvent(this.projectDir, {
          at: nowIso31(),
          type: "model_residency",
          modelID: model.modelID,
          residency: next
        });
      }
    }
    for (const model of toOffload) {
      this.offloadModel(model, "hydraulics_offload");
    }
  }
  recordSnapshot() {
    writeSchedulerSnapshot(this.projectDir, this.snapshot());
  }
}

// src/resource-scheduler/index.ts
var schedulers = new Map;
function getResourceScheduler(projectDir, options) {
  const existing = schedulers.get(projectDir);
  if (existing)
    return existing;
  const created = new ResourceScheduler(projectDir, options);
  schedulers.set(projectDir, created);
  return created;
}

// src/router/light-model.ts
var VERSION = "route_light_model_v1";
var FEATURE_WEIGHTS = {
  code_fix: [
    {
      pattern: /(bug|||failing|stack trace|panic|exception|traceback|fix)/i,
      weight: 1.3,
      evidence: "lm_fix_error"
    },
    {
      pattern: /(test fail|ci fail|lint fail||hotfix|patch)/i,
      weight: 0.9,
      evidence: "lm_fix_ci"
    }
  ],
  code_search: [
    {
      pattern: /(find|search|grep||||where)/i,
      weight: 1.2,
      evidence: "lm_search_query"
    },
    {
      pattern: /(||definition|symbol|callsite)/i,
      weight: 0.7,
      evidence: "lm_search_symbol"
    }
  ],
  docs_research: [
    {
      pattern: /(docs?||reference||citation|paper)/i,
      weight: 1.1,
      evidence: "lm_docs_keyword"
    },
    {
      pattern: /(latest||official||source link)/i,
      weight: 0.6,
      evidence: "lm_docs_freshness"
    }
  ],
  architecture: [
    {
      pattern: /(architecture||tradeoff||migration||risk)/i,
      weight: 1.15,
      evidence: "lm_arch_signal"
    },
    {
      pattern: /(pipeline|orchestr|workflow|state machine|)/i,
      weight: 0.7,
      evidence: "lm_arch_workflow"
    }
  ],
  ui_design: [
    {
      pattern: /(ui|||layout|css|||mockup|figma)/i,
      weight: 1.2,
      evidence: "lm_ui_signal"
    },
    {
      pattern: /(font|color|spacing|responsive)/i,
      weight: 0.6,
      evidence: "lm_ui_detail"
    }
  ],
  general: []
};
function softmax(scores) {
  const intents = Object.keys(scores);
  const maxValue = Math.max(...intents.map((intent) => scores[intent]));
  const exps = intents.map((intent) => Math.exp(scores[intent] - maxValue));
  const denom = exps.reduce((sum, value) => sum + value, 0) || 1;
  const probs = {
    code_fix: 0,
    code_search: 0,
    docs_research: 0,
    architecture: 0,
    ui_design: 0,
    general: 0
  };
  intents.forEach((intent, index) => {
    probs[intent] = Number((exps[index] / denom).toFixed(6));
  });
  return probs;
}
function scoreRouteIntentLightModel(text) {
  const input = String(text ?? "").trim();
  const scores = {
    code_fix: 0.25,
    code_search: 0.22,
    docs_research: 0.2,
    architecture: 0.2,
    ui_design: 0.2,
    general: 0.35
  };
  const evidence = [];
  for (const intent of Object.keys(FEATURE_WEIGHTS)) {
    for (const rule of FEATURE_WEIGHTS[intent]) {
      if (!rule.pattern.test(input))
        continue;
      scores[intent] += rule.weight;
      evidence.push(rule.evidence);
    }
  }
  if (/```[\s\S]*```/.test(input)) {
    scores.code_fix += 0.45;
    scores.code_search += 0.3;
    evidence.push("lm_code_block");
  }
  if (/(plan|exec|verify|fix||||)/i.test(input)) {
    scores.architecture += 0.8;
    scores.code_fix += 0.05;
    evidence.push("lm_pipeline_terms");
  }
  if (/(state graph||budget||fixability)/i.test(input)) {
    scores.architecture += 0.9;
    evidence.push("lm_state_graph_budget");
  }
  if (/(|screenshot|gif|)/i.test(input)) {
    scores.ui_design += 0.4;
    evidence.push("lm_visual_assets");
  }
  const domainSignal = scores.code_fix + scores.code_search + scores.docs_research + scores.architecture + scores.ui_design;
  if (domainSignal > 2)
    scores.general = Math.max(0.05, scores.general - 0.2);
  return {
    probabilities: softmax(scores),
    evidence: [...new Set(evidence)].slice(0, 10),
    version: VERSION
  };
}

// src/router/classifier.ts
var INTENT_RULES = [
  {
    intent: "code_fix",
    pattern: /(||bug||test fail|failing|compile|panic|stack trace|)/i,
    weight: 1.4,
    evidence: "fix_error_signal"
  },
  {
    intent: "code_fix",
    pattern: /(rollback|hotfix|patch||)/i,
    weight: 0.8,
    evidence: "fix_action_signal"
  },
  {
    intent: "code_search",
    pattern: /(||where|find|grep|search||)/i,
    weight: 1.3,
    evidence: "search_signal"
  },
  {
    intent: "docs_research",
    pattern: /(|api|docs|reference|||citation|)/i,
    weight: 1.3,
    evidence: "docs_signal"
  },
  {
    intent: "architecture",
    pattern: /(||tradeoff|risk||||migration|)/i,
    weight: 1.2,
    evidence: "architecture_signal"
  },
  {
    intent: "ui_design",
    pattern: /(ui||||||layout|css||)/i,
    weight: 1.2,
    evidence: "ui_signal"
  }
];
function seedScores() {
  return {
    code_fix: 0,
    code_search: 0,
    docs_research: 0,
    architecture: 0,
    ui_design: 0,
    general: 0.2
  };
}
function analyzeRouteSemantics(text) {
  const lower = String(text ?? "").toLowerCase();
  const ruleScores = seedScores();
  const evidence = [];
  for (const rule of INTENT_RULES) {
    if (!rule.pattern.test(lower))
      continue;
    ruleScores[rule.intent] += rule.weight;
    evidence.push(rule.evidence);
  }
  if (/```[\s\S]*```/.test(lower)) {
    ruleScores.code_fix += 0.6;
    ruleScores.code_search += 0.4;
    evidence.push("code_block_present");
  }
  if (/(|mockup|figma|)/i.test(lower)) {
    ruleScores.ui_design += 0.7;
    evidence.push("design_asset_signal");
  }
  if (/(|pipeline|workflow||)/i.test(lower)) {
    ruleScores.architecture += 0.5;
    ruleScores.code_fix += 0.3;
    evidence.push("workflow_signal");
  }
  if (/(state graph||budget||fixability|postmortem)/i.test(lower)) {
    ruleScores.architecture += 1.05;
    evidence.push("state_graph_budget_signal");
  }
  const model = scoreRouteIntentLightModel(lower);
  const modelScale = 1.6;
  const modelWeight = 0.52;
  const combinedScores = seedScores();
  for (const intent2 of Object.keys(combinedScores)) {
    combinedScores[intent2] = (ruleScores[intent2] ?? 0) + (model.probabilities[intent2] ?? 0) * modelScale * modelWeight;
  }
  evidence.push(...model.evidence.map((item) => `light_model:${item}`));
  if (/(||failing|compile|panic|stack trace|bug|error|hotfix|patch)/i.test(lower)) {
    combinedScores.code_fix += 0.2;
    evidence.push("fix_critical_boost");
  }
  const ranked = Object.entries(combinedScores).filter(([intent2]) => intent2 !== "general").sort((a, b) => b[1] - a[1]);
  const top = ranked[0];
  const second = ranked[1];
  let intent = !top || top[1] <= 0.25 ? "general" : top[0];
  if (intent === "code_search" && /(||failing|compile|panic|stack trace|bug|error|hotfix|patch)/i.test(lower) && combinedScores.code_fix >= combinedScores.code_search - 0.08) {
    intent = "code_fix";
    evidence.push("fix_tiebreak_override");
  }
  const confidence = !top ? 0 : Number(Math.max(0, Math.min(1, top[1] / Math.max(1, top[1] + (second?.[1] ?? 0.2)))).toFixed(4));
  const ambiguity = second && top ? Number(Math.max(0, second[1] / Math.max(top[1], 0.0001)).toFixed(4)) : 0;
  return {
    intent,
    confidence,
    evidence: [...new Set(evidence)].slice(0, 8),
    scores: combinedScores,
    ambiguity
  };
}
function classifyIntent(text) {
  return analyzeRouteSemantics(text).intent;
}
function recommendedAgent(intent) {
  if (intent === "code_fix")
    return "5-code-fixer";
  if (intent === "code_search")
    return "2-code-search";
  if (intent === "docs_research")
    return "3-docs-helper";
  if (intent === "architecture")
    return "4-architecture-advisor";
  if (intent === "ui_design")
    return "6-ui-designer";
  return "1-task-manager";
}
// src/router/fallback.ts
function resolveFallbackAgent(intent, availableAgents) {
  const primary = recommendedAgent(intent);
  if (availableAgents.includes(primary))
    return primary;
  if (availableAgents.includes("1-task-manager"))
    return "1-task-manager";
  return availableAgents[0] ?? primary;
}
function resolveAgentWithFeedback(intent, availableAgents, ranked) {
  const base = resolveFallbackAgent(intent, availableAgents);
  if (ranked.length === 0)
    return base;
  const preferred = ranked.find((item) => availableAgents.includes(item.agent) && item.score >= 0.55);
  return preferred?.agent ?? base;
}
// src/router/learner.ts
import * as fs48 from "node:fs";
import * as path47 from "node:path";
var DEFAULT_LEARNING_WEIGHTS = {
  accept: 0.35,
  success: 0.35,
  cost: 0.15,
  risk: 0.15
};
function filePath10(projectDir) {
  return path47.join(getMiyaRuntimeDir(projectDir), "router-history.json");
}
function weightFilePath(projectDir) {
  return path47.join(getMiyaRuntimeDir(projectDir), "router-learning.json");
}
function readStore11(projectDir) {
  const file3 = filePath10(projectDir);
  if (!fs48.existsSync(file3))
    return { records: [] };
  try {
    const parsed = JSON.parse(fs48.readFileSync(file3, "utf-8"));
    return { records: Array.isArray(parsed.records) ? parsed.records : [] };
  } catch {
    return { records: [] };
  }
}
function writeStore9(projectDir, store) {
  const file3 = filePath10(projectDir);
  fs48.mkdirSync(path47.dirname(file3), { recursive: true });
  fs48.writeFileSync(file3, JSON.stringify(store, null, 2) + `
`, "utf-8");
}
function clamp8(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function sanitizeWeights(input) {
  const next = {
    accept: clamp8(Number(input.accept ?? DEFAULT_LEARNING_WEIGHTS.accept), 0, 1),
    success: clamp8(Number(input.success ?? DEFAULT_LEARNING_WEIGHTS.success), 0, 1),
    cost: clamp8(Number(input.cost ?? DEFAULT_LEARNING_WEIGHTS.cost), 0, 1),
    risk: clamp8(Number(input.risk ?? DEFAULT_LEARNING_WEIGHTS.risk), 0, 1)
  };
  const total = next.accept + next.success + next.cost + next.risk;
  if (total <= 0)
    return { ...DEFAULT_LEARNING_WEIGHTS };
  return {
    accept: Number((next.accept / total).toFixed(4)),
    success: Number((next.success / total).toFixed(4)),
    cost: Number((next.cost / total).toFixed(4)),
    risk: Number((next.risk / total).toFixed(4))
  };
}
function readRouteLearningWeights(projectDir) {
  const file3 = weightFilePath(projectDir);
  if (!fs48.existsSync(file3))
    return { ...DEFAULT_LEARNING_WEIGHTS };
  try {
    const parsed = JSON.parse(fs48.readFileSync(file3, "utf-8"));
    return sanitizeWeights(parsed);
  } catch {
    return { ...DEFAULT_LEARNING_WEIGHTS };
  }
}
function addRouteFeedback(projectDir, record3) {
  const store = readStore11(projectDir);
  const next = {
    ...record3,
    costUsdEstimate: typeof record3.costUsdEstimate === "number" ? Math.max(0, Number(record3.costUsdEstimate)) : undefined,
    riskScore: typeof record3.riskScore === "number" ? clamp8(Number(record3.riskScore), 0, 1) : undefined,
    at: new Date().toISOString()
  };
  store.records = [next, ...store.records].slice(0, 1000);
  writeStore9(projectDir, store);
  return next;
}
function rankAgentsByFeedback(projectDir, intent, availableAgents) {
  const weights = readRouteLearningWeights(projectDir);
  const records = readStore11(projectDir).records.filter((item) => item.intent === intent).slice(0, 300);
  const scoredRaw = availableAgents.map((agent) => {
    const matched = records.filter((item) => item.suggestedAgent === agent);
    const accepted = matched.filter((item) => item.accepted).length;
    const success3 = matched.filter((item) => item.success === true).length;
    const samples = matched.length;
    const acceptRate = samples > 0 ? accepted / samples : 0;
    const successRate = samples > 0 ? success3 / samples : 0;
    const avgCostUsd = samples > 0 ? matched.reduce((sum, item) => sum + Number(item.costUsdEstimate ?? 0), 0) / samples : 0;
    const avgRisk = samples > 0 ? matched.reduce((sum, item) => sum + Number(item.riskScore ?? 0.5), 0) / samples : 0.5;
    return {
      agent,
      samples,
      acceptRate: Number(acceptRate.toFixed(4)),
      successRate: Number(successRate.toFixed(4)),
      avgCostUsd: Number(avgCostUsd.toFixed(6)),
      avgRisk: Number(avgRisk.toFixed(4))
    };
  });
  const costValues = scoredRaw.map((item) => item.avgCostUsd).filter((value) => Number.isFinite(value) && value >= 0);
  const minCost = costValues.length > 0 ? Math.min(...costValues) : 0;
  const maxCost = costValues.length > 0 ? Math.max(...costValues) : 1;
  const scored = scoredRaw.map((item) => {
    const normalizedCost = maxCost <= minCost ? item.avgCostUsd > 0 ? 1 : 0 : (item.avgCostUsd - minCost) / (maxCost - minCost);
    const samplePrior = Math.min(0.15, item.samples / 80);
    const blended = weights.accept * item.acceptRate + weights.success * item.successRate + weights.cost * (1 - normalizedCost) + weights.risk * (1 - item.avgRisk) + samplePrior;
    const score = Number(clamp8(blended, 0, 1.2).toFixed(4));
    return {
      ...item,
      score
    };
  });
  return scored.sort((a, b) => b.score - a.score);
}
// src/router/runtime.ts
import { createHash as createHash13 } from "node:crypto";
import * as fs49 from "node:fs";
import * as path48 from "node:path";
var DEFAULT_MODE = {
  ecoMode: true,
  stageTokenMultiplier: {
    low: 0.62,
    medium: 1,
    high: 1.45
  },
  stageCostUsdPer1k: {
    low: 0.0009,
    medium: 0.0018,
    high: 0.0032
  },
  contextHardCapTokens: 1500,
  retryDeltaMaxLines: 14,
  retryBudget: {
    autoRetry: 2,
    humanEdit: 1
  }
};
function modeFile(projectDir) {
  return path48.join(getMiyaRuntimeDir(projectDir), "router-mode.json");
}
function costFile(projectDir) {
  return path48.join(getMiyaRuntimeDir(projectDir), "router-cost.jsonl");
}
function sessionStateFile(projectDir) {
  return path48.join(getMiyaRuntimeDir(projectDir), "router-session-state.json");
}
function ensureDir16(projectDir) {
  fs49.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp9(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function nowIso32() {
  return new Date().toISOString();
}
function parseMode(raw) {
  const input = raw && typeof raw === "object" ? raw : {};
  const forcedStage = input.forcedStage === "low" || input.forcedStage === "medium" || input.forcedStage === "high" ? input.forcedStage : undefined;
  const stageTokenMultiplierInput = input.stageTokenMultiplier && typeof input.stageTokenMultiplier === "object" ? input.stageTokenMultiplier : {};
  const stageCostInput = input.stageCostUsdPer1k && typeof input.stageCostUsdPer1k === "object" ? input.stageCostUsdPer1k : {};
  const retryBudgetInput = input.retryBudget && typeof input.retryBudget === "object" ? input.retryBudget : {};
  const contextHardCapTokens = Number(input.contextHardCapTokens ?? DEFAULT_MODE.contextHardCapTokens);
  const retryDeltaMaxLines = Number(input.retryDeltaMaxLines ?? DEFAULT_MODE.retryDeltaMaxLines);
  return {
    ecoMode: input.ecoMode !== false,
    forcedStage,
    stageTokenMultiplier: {
      low: clamp9(Number(stageTokenMultiplierInput.low ?? DEFAULT_MODE.stageTokenMultiplier.low), 0.2, 2.5),
      medium: clamp9(Number(stageTokenMultiplierInput.medium ?? DEFAULT_MODE.stageTokenMultiplier.medium), 0.3, 3),
      high: clamp9(Number(stageTokenMultiplierInput.high ?? DEFAULT_MODE.stageTokenMultiplier.high), 0.4, 4)
    },
    stageCostUsdPer1k: {
      low: clamp9(Number(stageCostInput.low ?? DEFAULT_MODE.stageCostUsdPer1k.low), 0.0001, 0.1),
      medium: clamp9(Number(stageCostInput.medium ?? DEFAULT_MODE.stageCostUsdPer1k.medium), 0.0001, 0.2),
      high: clamp9(Number(stageCostInput.high ?? DEFAULT_MODE.stageCostUsdPer1k.high), 0.0001, 0.3)
    },
    contextHardCapTokens: clamp9(Number.isFinite(contextHardCapTokens) ? contextHardCapTokens : DEFAULT_MODE.contextHardCapTokens, 300, 8000),
    retryDeltaMaxLines: clamp9(Number.isFinite(retryDeltaMaxLines) ? retryDeltaMaxLines : DEFAULT_MODE.retryDeltaMaxLines, 4, 64),
    retryBudget: {
      autoRetry: clamp9(Number(retryBudgetInput.autoRetry ?? DEFAULT_MODE.retryBudget.autoRetry), 0, 8),
      humanEdit: clamp9(Number(retryBudgetInput.humanEdit ?? DEFAULT_MODE.retryBudget.humanEdit), 0, 4)
    }
  };
}
function readRouterModeConfig(projectDir) {
  const file3 = modeFile(projectDir);
  if (!fs49.existsSync(file3))
    return DEFAULT_MODE;
  try {
    const parsed = JSON.parse(fs49.readFileSync(file3, "utf-8"));
    return parseMode(parsed);
  } catch {
    return DEFAULT_MODE;
  }
}
function readSessionStore(projectDir) {
  const file3 = sessionStateFile(projectDir);
  if (!fs49.existsSync(file3))
    return { sessions: {} };
  try {
    const parsed = JSON.parse(fs49.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions)
      return { sessions: {} };
    return {
      sessions: Object.fromEntries(Object.entries(parsed.sessions).map(([sessionID, state]) => [
        sessionID,
        {
          sessionID,
          consecutiveFailures: clamp9(Number(state?.consecutiveFailures ?? 0), 0, 10),
          lastStage: state?.lastStage === "low" || state?.lastStage === "medium" || state?.lastStage === "high" ? state.lastStage : "medium",
          autoRetryUsed: clamp9(Number(state?.autoRetryUsed ?? 0), 0, 20),
          humanEditUsed: clamp9(Number(state?.humanEditUsed ?? 0), 0, 20),
          lastFixability: state?.lastFixability === "impossible" || state?.lastFixability === "rewrite" || state?.lastFixability === "reduce_scope" || state?.lastFixability === "need_evidence" || state?.lastFixability === "retry_later" || state?.lastFixability === "unknown" ? state.lastFixability : "unknown",
          lastFailureReason: typeof state?.lastFailureReason === "string" ? state.lastFailureReason.slice(0, 200) : undefined,
          lastContextHash: typeof state?.lastContextHash === "string" ? state.lastContextHash.slice(0, 128) : undefined,
          lastContextText: typeof state?.lastContextText === "string" ? state.lastContextText.slice(0, 6000) : undefined,
          updatedAt: String(state?.updatedAt ?? nowIso32())
        }
      ]))
    };
  } catch {
    return { sessions: {} };
  }
}
function writeSessionStore(projectDir, store) {
  ensureDir16(projectDir);
  fs49.writeFileSync(sessionStateFile(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function getSessionState2(projectDir, sessionID) {
  const store = readSessionStore(projectDir);
  return store.sessions[sessionID] ?? {
    sessionID,
    consecutiveFailures: 0,
    lastStage: "medium",
    autoRetryUsed: 0,
    humanEditUsed: 0,
    lastFixability: "unknown",
    lastFailureReason: undefined,
    lastContextHash: undefined,
    lastContextText: undefined,
    updatedAt: nowIso32()
  };
}
function stageLevel(stage) {
  if (stage === "low")
    return 0;
  if (stage === "medium")
    return 1;
  return 2;
}
function levelToStage(level) {
  if (level <= 0)
    return "low";
  if (level === 1)
    return "medium";
  return "high";
}
function readCostRows(projectDir, limit = 500) {
  const file3 = costFile(projectDir);
  if (!fs49.existsSync(file3))
    return [];
  const rows = fs49.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => Boolean(item));
  return rows.slice(-Math.max(1, limit));
}
function appendCostRow(projectDir, row) {
  ensureDir16(projectDir);
  fs49.appendFileSync(costFile(projectDir), `${JSON.stringify(row)}
`, "utf-8");
}
function analyzeRouteComplexity(text) {
  const normalized = String(text ?? "").trim();
  const reasons = [];
  let score = 0;
  if (normalized.length > 1600) {
    score += 2;
    reasons.push("long_request");
  } else if (normalized.length > 700) {
    score += 1;
    reasons.push("medium_length");
  }
  if (/```[\s\S]*```/.test(normalized)) {
    score += 2;
    reasons.push("contains_code_block");
  }
  if (/(|tradeoff||risk|migration||performance||security|)/i.test(normalized)) {
    score += 1;
    reasons.push("architecture_or_risk");
  }
  if (/(||pipeline|workflow||verify||fix|loop)/i.test(normalized)) {
    score += 1;
    reasons.push("multi_step_execution");
  }
  if (/(|||critical|p0|severe)/i.test(normalized)) {
    score += 1;
    reasons.push("urgency_signal");
  }
  const complexity = score >= 4 ? "high" : score >= 2 ? "medium" : "low";
  return { complexity, score, reasons };
}
function stageFromComplexity(complexity) {
  if (complexity === "high")
    return "high";
  if (complexity === "medium")
    return "medium";
  return "low";
}
function inferFixabilityFromReason(reason) {
  const text = String(reason ?? "").toLowerCase();
  if (!text)
    return "unknown";
  if (/permission|unauthorized|forbidden|policy_|kill_switch/.test(text)) {
    return "impossible";
  }
  if (/invalid_|bad_request|parse|schema|syntax/.test(text)) {
    return "rewrite";
  }
  if (/timeout|temporar|network|overload|rate_limit/.test(text)) {
    return "retry_later";
  }
  if (/missing_evidence|receipt_uncertain|ui_style_mismatch|mismatch/.test(text)) {
    return "need_evidence";
  }
  if (/too_long|budget|scope/.test(text)) {
    return "reduce_scope";
  }
  return "unknown";
}
function inferRiskScore(input) {
  if (input.success) {
    return input.stage === "high" ? 0.22 : input.stage === "medium" ? 0.16 : 0.1;
  }
  const reason = String(input.failureReason ?? "").toLowerCase();
  if (/permission|forbidden|policy_|kill_switch|security/.test(reason))
    return 0.95;
  if (/timeout|overload|network|rate_limit/.test(reason))
    return 0.75;
  if (/invalid_|schema|parse|bad_request/.test(reason))
    return 0.62;
  return input.stage === "high" ? 0.7 : input.stage === "medium" ? 0.6 : 0.55;
}
function hashText2(text) {
  return createHash13("sha256").update(String(text ?? "")).digest("hex");
}
function compressTextByStage(text, stage) {
  const normalized = String(text ?? "").trim();
  if (!normalized)
    return { text: "", compressed: false };
  if (stage === "high")
    return { text: normalized, compressed: false };
  if (stage === "medium" && normalized.length <= 4200)
    return { text: normalized, compressed: false };
  if (stage === "low" && normalized.length <= 1600)
    return { text: normalized, compressed: false };
  if (stage === "medium") {
    const head2 = normalized.slice(0, 2600);
    const tail2 = normalized.slice(-1200);
    return {
      text: `${head2}

[MIYA_ROUTER_COMPRESSION stage=medium]
...
${tail2}`,
      compressed: true
    };
  }
  const head = normalized.slice(0, 900);
  const bulletLines = normalized.split(/\r?\n/).map((line) => line.trim()).filter((line) => /^[-*0-9.]/.test(line)).slice(0, 8).join(`
`);
  const tail = normalized.slice(-480);
  const merged = [head, bulletLines, tail].filter(Boolean).join(`
`);
  return {
    text: `${merged}

[MIYA_ROUTER_COMPRESSION stage=low reason=eco_mode]`,
    compressed: true
  };
}
function buildRetryDeltaContext(input) {
  const current = String(input.text ?? "").trim();
  const previous = String(input.previousText ?? "").trim();
  if (!current || !previous)
    return { text: current, applied: false };
  const previousLines = new Set(previous.split(/\r?\n/).map((line) => line.trim()).filter(Boolean));
  let deltaLines = current.split(/\r?\n/).map((line) => line.trim()).filter(Boolean).filter((line) => !previousLines.has(line)).slice(0, Math.max(4, input.maxLines));
  if (deltaLines.length === 0) {
    deltaLines = current.split(/\r?\n/).map((line) => line.trim()).filter(Boolean).slice(-Math.max(4, input.maxLines));
  }
  if (deltaLines.length === 0)
    return { text: current, applied: false };
  const baselineHash = (input.previousHash?.trim() || hashText2(previous)).slice(0, 16);
  const reason = (input.failureReason ?? "").trim() || "retry";
  const retryText = [
    "[MIYA_RETRY_DELTA]",
    `baseline_hash=${baselineHash}`,
    `reason=${reason.slice(0, 120)}`,
    ...deltaLines.map((line) => `+ ${line}`),
    "[MIYA_RETRY_DELTA_END]"
  ].join(`
`);
  return { text: retryText, applied: true };
}
function applyContextHardCap(input) {
  const text = String(input.text ?? "").trim();
  const capTokens = Math.max(300, Math.floor(input.capTokens));
  const maxChars = Math.max(900, Math.floor(capTokens * 3.6));
  if (text.length <= maxChars)
    return { text, hardCapped: false };
  const reserve = 180;
  const headBudget = Math.max(300, Math.floor((maxChars - reserve) * 0.62));
  const tailBudget = Math.max(220, maxChars - reserve - headBudget);
  const head = text.slice(0, headBudget);
  const tail = text.slice(-tailBudget);
  const droppedChars = Math.max(0, text.length - head.length - tail.length);
  const ref = hashText2(text).slice(0, 16);
  const cappedText = [
    head,
    "",
    `[MIYA_CONTEXT_HARD_CAP ref=${ref} cap_tokens=${capTokens} dropped_chars=${droppedChars}]`,
    "",
    tail
  ].join(`
`);
  return { text: cappedText, hardCapped: true };
}
function estimateInputTokens(text) {
  const length = String(text ?? "").length;
  return Math.max(20, Math.ceil(length / 3.6));
}
function estimateOutputTokens(inputTokens, stage) {
  if (stage === "low")
    return Math.max(60, Math.ceil(inputTokens * 0.35));
  if (stage === "medium")
    return Math.max(100, Math.ceil(inputTokens * 0.55));
  return Math.max(140, Math.ceil(inputTokens * 0.9));
}
function buildRouteExecutionPlan(input) {
  const semantic = analyzeRouteSemantics(input.text);
  const intent = semantic.intent || classifyIntent(input.text);
  const complexity = analyzeRouteComplexity(input.text);
  const mode = readRouterModeConfig(input.projectDir);
  const session = getSessionState2(input.projectDir, input.sessionID);
  const ranked = rankAgentsByFeedback(input.projectDir, intent, input.availableAgents);
  const preferredAgent = resolveFallbackAgent(intent, input.availableAgents);
  const fallbackAgent = resolveFallbackAgent(intent, input.availableAgents);
  const selectedByFeedback = resolveAgentWithFeedback(intent, input.availableAgents, ranked);
  const pinnedAgent = input.pinnedAgent?.trim();
  const selectedAgent = pinnedAgent && input.availableAgents.includes(pinnedAgent) ? pinnedAgent : selectedByFeedback;
  const feedbackScore = ranked.find((item) => item.agent === selectedAgent)?.score ?? 0;
  const feedbackSamples = ranked.find((item) => item.agent === selectedAgent)?.samples ?? 0;
  let stage = stageFromComplexity(complexity.complexity);
  const reasons = [...complexity.reasons];
  if (semantic.ambiguity >= 0.75)
    reasons.push("semantic_ambiguity_high");
  if (semantic.evidence.length > 0) {
    reasons.push(...semantic.evidence.slice(0, 3).map((item) => `semantic_${item}`));
  }
  let executionMode = "auto";
  const fixabilityHint = session.lastFixability;
  const autoBudget = mode.retryBudget.autoRetry;
  const humanBudget = mode.retryBudget.humanEdit;
  if (mode.forcedStage) {
    stage = mode.forcedStage;
    reasons.push("forced_stage");
  } else {
    if (mode.ecoMode) {
      stage = levelToStage(stageLevel(stage) - 1);
      reasons.push("eco_mode_downshift");
    }
    if (session.consecutiveFailures >= 1) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_1");
    }
    if (session.consecutiveFailures >= 2) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_2");
    }
  }
  if (fixabilityHint === "impossible") {
    executionMode = "human_gate";
    stage = "high";
    reasons.push("fixability_impossible_human_gate");
  } else if (session.autoRetryUsed >= autoBudget && autoBudget >= 0) {
    executionMode = "human_gate";
    stage = "high";
    reasons.push("auto_retry_budget_exhausted");
  } else if (session.lastFixability === "need_evidence") {
    stage = "high";
    reasons.push("evidence_recovery_escalation");
  }
  return {
    intent,
    complexity: complexity.complexity,
    complexityScore: complexity.score,
    semanticConfidence: semantic.confidence,
    semanticAmbiguity: semantic.ambiguity,
    semanticEvidence: semantic.evidence,
    stage,
    agent: selectedAgent,
    preferredAgent,
    fallbackAgent,
    feedbackScore,
    feedbackSamples,
    ecoMode: mode.ecoMode,
    reasons,
    fixabilityHint,
    retryBudget: {
      autoRetry: autoBudget,
      autoUsed: session.autoRetryUsed,
      humanEdit: humanBudget,
      humanUsed: session.humanEditUsed
    },
    executionMode
  };
}
function prepareRoutePayload(projectDir, input) {
  const mode = readRouterModeConfig(projectDir);
  const retryAttempt = Math.max(0, Math.floor(Number(input.retry?.attempt ?? 0)));
  const retryDelta = retryAttempt > 0 ? buildRetryDeltaContext({
    text: input.text,
    previousText: input.retry?.previousContextText,
    previousHash: input.retry?.previousContextHash,
    failureReason: input.retry?.failureReason,
    maxLines: mode.retryDeltaMaxLines
  }) : { text: input.text, applied: false };
  const compressed = compressTextByStage(retryDelta.text, input.stage);
  const hardCap = applyContextHardCap({
    text: compressed.text,
    capTokens: mode.contextHardCapTokens
  });
  const inputTokens = estimateInputTokens(hardCap.text);
  const outputTokensEstimate = estimateOutputTokens(inputTokens, input.stage);
  const totalTokensEstimate = Math.ceil((inputTokens + outputTokensEstimate) * mode.stageTokenMultiplier[input.stage]);
  const baselineHighTokensEstimate = Math.ceil((inputTokens + estimateOutputTokens(inputTokens, "high")) * mode.stageTokenMultiplier.high);
  const costUsdEstimate = Number((totalTokensEstimate / 1000 * mode.stageCostUsdPer1k[input.stage]).toFixed(6));
  return {
    text: hardCap.text,
    compressed: compressed.compressed,
    hardCapped: hardCap.hardCapped,
    retryDeltaApplied: retryDelta.applied,
    contextHash: hashText2(hardCap.text),
    inputTokens,
    outputTokensEstimate,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    costUsdEstimate
  };
}
function recordRouteExecutionOutcome(input) {
  const row = {
    at: nowIso32(),
    sessionID: input.sessionID,
    intent: input.intent,
    complexity: input.complexity,
    stage: input.stage,
    agent: input.agent,
    success: input.success,
    inputTokens: input.inputTokens,
    outputTokensEstimate: input.outputTokensEstimate,
    totalTokensEstimate: input.totalTokensEstimate,
    baselineHighTokensEstimate: input.baselineHighTokensEstimate,
    costUsdEstimate: input.costUsdEstimate
  };
  appendCostRow(input.projectDir, row);
  const store = readSessionStore(input.projectDir);
  const mode = readRouterModeConfig(input.projectDir);
  const current = store.sessions[input.sessionID] ?? {
    sessionID: input.sessionID,
    consecutiveFailures: 0,
    lastStage: input.stage,
    autoRetryUsed: 0,
    humanEditUsed: 0,
    lastFixability: "unknown",
    lastFailureReason: undefined,
    lastContextHash: undefined,
    lastContextText: undefined,
    updatedAt: nowIso32()
  };
  const inferredFixability = input.success ? "unknown" : inferFixabilityFromReason(input.failureReason);
  const attemptType = input.attemptType ?? "auto";
  const nextAutoUsed = input.success ? 0 : attemptType === "auto" ? clamp9(current.autoRetryUsed + 1, 0, 20) : current.autoRetryUsed;
  const nextHumanUsed = input.success ? 0 : attemptType === "human" ? clamp9(current.humanEditUsed + 1, 0, 20) : current.humanEditUsed;
  const next = {
    sessionID: input.sessionID,
    consecutiveFailures: input.success ? 0 : clamp9(current.consecutiveFailures + 1, 0, 10),
    lastStage: input.stage,
    autoRetryUsed: Math.min(nextAutoUsed, mode.retryBudget.autoRetry + 6),
    humanEditUsed: Math.min(nextHumanUsed, mode.retryBudget.humanEdit + 4),
    lastFixability: inferredFixability,
    lastFailureReason: input.success ? undefined : String(input.failureReason ?? "").slice(0, 200),
    lastContextHash: typeof input.contextHash === "string" ? input.contextHash.slice(0, 128) : undefined,
    lastContextText: typeof input.contextText === "string" ? input.contextText.slice(0, 6000) : undefined,
    updatedAt: nowIso32()
  };
  store.sessions[input.sessionID] = next;
  writeSessionStore(input.projectDir, store);
  addRouteFeedback(input.projectDir, {
    text: `${input.intent}|${input.agent}|${input.stage}`,
    intent: input.intent,
    suggestedAgent: input.agent,
    accepted: input.success,
    success: input.success,
    costUsdEstimate: input.costUsdEstimate,
    riskScore: inferRiskScore({
      success: input.success,
      failureReason: input.failureReason,
      stage: input.stage
    }),
    failureReason: input.failureReason,
    stage: input.stage
  });
  const variant = resolveStrategyVariant(input.projectDir, "routing", input.sessionID);
  recordStrategyObservation(input.projectDir, {
    experiment: "routing",
    variant,
    subjectID: input.sessionID,
    success: input.success,
    costUsd: input.costUsdEstimate,
    riskScore: inferRiskScore({
      success: input.success,
      failureReason: input.failureReason,
      stage: input.stage
    }),
    metadata: {
      intent: input.intent,
      stage: input.stage,
      agent: input.agent
    }
  });
  return row;
}
function getRouteCostSummary(projectDir, limit = 300) {
  const rows = readCostRows(projectDir, limit);
  const byStage = {
    low: { records: 0, tokens: 0, costUsd: 0 },
    medium: { records: 0, tokens: 0, costUsd: 0 },
    high: { records: 0, tokens: 0, costUsd: 0 }
  };
  let totalTokensEstimate = 0;
  let baselineHighTokensEstimate = 0;
  let totalCostUsdEstimate = 0;
  for (const row of rows) {
    byStage[row.stage].records += 1;
    byStage[row.stage].tokens += row.totalTokensEstimate;
    byStage[row.stage].costUsd += row.costUsdEstimate;
    totalTokensEstimate += row.totalTokensEstimate;
    baselineHighTokensEstimate += row.baselineHighTokensEstimate;
    totalCostUsdEstimate += row.costUsdEstimate;
  }
  const savingsTokensEstimate = Math.max(0, baselineHighTokensEstimate - totalTokensEstimate);
  const savingsPercentEstimate = baselineHighTokensEstimate > 0 ? Number((savingsTokensEstimate / baselineHighTokensEstimate * 100).toFixed(2)) : 0;
  return {
    totalRecords: rows.length,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    savingsTokensEstimate,
    savingsPercentEstimate,
    totalCostUsdEstimate: Number(totalCostUsdEstimate.toFixed(6)),
    byStage: {
      low: {
        ...byStage.low,
        costUsd: Number(byStage.low.costUsd.toFixed(6))
      },
      medium: {
        ...byStage.medium,
        costUsd: Number(byStage.medium.costUsd.toFixed(6))
      },
      high: {
        ...byStage.high,
        costUsd: Number(byStage.high.costUsd.toFixed(6))
      }
    }
  };
}
function listRouteCostRecords(projectDir, limit = 40) {
  return readCostRows(projectDir, limit);
}
function getRouterSessionState(projectDir, sessionID) {
  return getSessionState2(projectDir, sessionID);
}
// src/safety/risk.ts
import { createHash as createHash14 } from "node:crypto";
var IRREVERSIBLE_BASH_PATTERNS = [
  /\bgit\s+push\b/i,
  /\bgit\s+remote\s+set-url\b/i,
  /\bgit\s+reset\s+--hard\b/i,
  /\bgit\s+clean\b[^\n]*\b-f\b/i,
  /\bgit\s+branch\b[^\n]*\b-D\b/i,
  /\brm\s+-[^\n]*\br\b/i,
  /\brm\s+-[^\n]*\bf\b/i,
  /\brm\s+(-rf|-fr)\b/i,
  /\bdel\s+\/[sfpq]/i,
  /\berase\s+\/[sfpq]/i,
  /\bRemove-Item\b[^\n]*\b(-Recurse|-Force)\b/i,
  /\btruncate\b/i,
  /\bcp\b[^\n]*\b-f\b/i,
  />\s*\.env(\.|$)/i,
  /\b(overwrite|truncate)\b/i
];
var SENSITIVE_PATH_PATTERNS = [
  /\.env(\.|$)/i,
  /\.pem$/i,
  /\.key$/i,
  /cookie/i,
  /credential/i,
  /secret/i,
  /token/i
];
function normalizePattern(pattern) {
  return pattern.trim().replaceAll("\\", "/");
}
function hasIrreversiblePattern(patterns) {
  return patterns.some((pattern) => IRREVERSIBLE_BASH_PATTERNS.some((rule) => rule.test(pattern)));
}
function hasSensitivePath(patterns) {
  return patterns.some((pattern) => SENSITIVE_PATH_PATTERNS.some((rule) => rule.test(pattern)));
}
function hasIrreversibleEditPattern(patterns) {
  return patterns.some((pattern) => /\b(delete|remove|overwrite|truncate|destroy|wipe)\b/i.test(pattern) || pattern.endsWith(".env") || pattern.includes("/.env"));
}
function requiredTierForRequest(request) {
  const patterns = request.patterns.map(normalizePattern);
  if (request.permission === "external_directory")
    return "THOROUGH";
  if (request.permission === "external_message")
    return "THOROUGH";
  if (request.permission === "desktop_control")
    return "THOROUGH";
  if (request.permission === "miya_autopilot" || request.permission === "miya_autoflow") {
    return hasIrreversiblePattern(patterns) ? "THOROUGH" : "STANDARD";
  }
  if (request.permission === "node_invoke") {
    const patterns2 = request.patterns.map(normalizePattern).join(" ");
    if (/\b(system\.run|camera\.capture|canvas\.open|canvas\.render|voice\.)\b/i.test(patterns2)) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  if (request.permission === "skills_install")
    return "THOROUGH";
  if (request.permission === "webhook_outbound")
    return "THOROUGH";
  if (request.permission === "bash") {
    return hasIrreversiblePattern(patterns) ? "THOROUGH" : "STANDARD";
  }
  if (request.permission === "edit") {
    if (hasSensitivePath(patterns) || hasIrreversibleEditPattern(patterns)) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  return "STANDARD";
}
function buildRequestHash(request, includeMessageContext = true) {
  const payload = {
    permission: request.permission,
    patterns: [...request.patterns].map(normalizePattern).sort(),
    toolCallID: includeMessageContext ? request.toolCallID ?? "" : "",
    messageID: includeMessageContext ? request.messageID ?? "" : ""
  };
  return createHash14("sha256").update(JSON.stringify(payload)).digest("hex");
}

// src/security/owner-identity.ts
import { createHash as createHash15, randomUUID as randomUUID21 } from "node:crypto";
import * as fs50 from "node:fs";
import * as path49 from "node:path";
function nowIso33() {
  return new Date().toISOString();
}
function filePath11(projectDir) {
  return path49.join(getMiyaRuntimeDir(projectDir), "security", "owner-identity.json");
}
function guestAuditPath(projectDir) {
  return path49.join(getMiyaRuntimeDir(projectDir), "security", "guest-conversations.jsonl");
}
function clamp10(input, min, max) {
  if (!Number.isFinite(input))
    return min;
  return Math.min(max, Math.max(min, input));
}
function defaultVoiceprintThresholds() {
  return {
    ownerMinScore: 0.78,
    guestMaxScore: 0.62,
    ownerMinLiveness: 0.65,
    guestMaxLiveness: 0.55,
    ownerMinDiarizationRatio: 0.7,
    minSampleDurationSec: 2,
    farTarget: 0.01,
    frrTarget: 0.03
  };
}
function normalizeVoiceprintThresholds(input) {
  const base = defaultVoiceprintThresholds();
  const normalized = {
    ownerMinScore: typeof input?.ownerMinScore === "number" ? clamp10(input.ownerMinScore, 0.5, 0.99) : base.ownerMinScore,
    guestMaxScore: typeof input?.guestMaxScore === "number" ? clamp10(input.guestMaxScore, 0.01, 0.9) : base.guestMaxScore,
    ownerMinLiveness: typeof input?.ownerMinLiveness === "number" ? clamp10(input.ownerMinLiveness, 0.1, 0.99) : base.ownerMinLiveness,
    guestMaxLiveness: typeof input?.guestMaxLiveness === "number" ? clamp10(input.guestMaxLiveness, 0.01, 0.9) : base.guestMaxLiveness,
    ownerMinDiarizationRatio: typeof input?.ownerMinDiarizationRatio === "number" ? clamp10(input.ownerMinDiarizationRatio, 0.1, 1) : base.ownerMinDiarizationRatio,
    minSampleDurationSec: typeof input?.minSampleDurationSec === "number" ? clamp10(input.minSampleDurationSec, 0.5, 20) : base.minSampleDurationSec,
    farTarget: typeof input?.farTarget === "number" ? clamp10(input.farTarget, 0.0001, 0.5) : base.farTarget,
    frrTarget: typeof input?.frrTarget === "number" ? clamp10(input.frrTarget, 0.0001, 0.5) : base.frrTarget
  };
  if (normalized.guestMaxScore >= normalized.ownerMinScore) {
    normalized.guestMaxScore = Math.max(0.01, normalized.ownerMinScore - 0.05);
  }
  return normalized;
}
function defaultState5() {
  return {
    initialized: false,
    mode: "unknown",
    voiceprintModelPath: "",
    voiceprintSampleDir: "",
    voiceprintThresholds: defaultVoiceprintThresholds(),
    updatedAt: nowIso33()
  };
}
function hashSecret(input) {
  return createHash15("sha256").update(input).digest("hex");
}
function defaultVoiceprintModelPath(projectDir) {
  return process.env.MIYA_VOICEPRINT_MODEL_PATH || getMiyaVoiceprintModelDir(projectDir);
}
function defaultVoiceprintSampleDir(projectDir) {
  return process.env.MIYA_VOICEPRINT_SAMPLE_DIR || getMiyaVoiceprintSampleDir(projectDir);
}
function readOwnerIdentityState(projectDir) {
  const file3 = filePath11(projectDir);
  if (!fs50.existsSync(file3)) {
    return {
      ...defaultState5(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
  try {
    const parsed = JSON.parse(fs50.readFileSync(file3, "utf-8"));
    return {
      ...defaultState5(),
      ...parsed,
      voiceprintModelPath: typeof parsed.voiceprintModelPath === "string" ? parsed.voiceprintModelPath : defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: typeof parsed.voiceprintSampleDir === "string" ? parsed.voiceprintSampleDir : defaultVoiceprintSampleDir(projectDir),
      voiceprintThresholds: normalizeVoiceprintThresholds(parsed.voiceprintThresholds),
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso33()
    };
  } catch {
    return {
      ...defaultState5(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
}
function writeOwnerIdentityState(projectDir, state) {
  const file3 = filePath11(projectDir);
  fs50.mkdirSync(path49.dirname(file3), { recursive: true });
  const next = {
    ...state,
    voiceprintThresholds: normalizeVoiceprintThresholds(state.voiceprintThresholds),
    updatedAt: nowIso33()
  };
  fs50.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function initOwnerIdentity(projectDir, input) {
  const current = readOwnerIdentityState(projectDir);
  const next = {
    ...current,
    initialized: true,
    passwordHash: hashSecret(input.password),
    passphraseHash: hashSecret(input.passphrase),
    voiceprintEmbeddingID: input.voiceprintEmbeddingID || current.voiceprintEmbeddingID || `owner_${randomUUID21()}`,
    voiceprintModelPath: input.voiceprintModelPath || current.voiceprintModelPath || defaultVoiceprintModelPath(projectDir),
    voiceprintSampleDir: input.voiceprintSampleDir || current.voiceprintSampleDir || defaultVoiceprintSampleDir(projectDir),
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...input.voiceprintThresholds ?? {}
    }),
    mode: "owner",
    lastSpeakerAt: nowIso33(),
    updatedAt: nowIso33()
  };
  return writeOwnerIdentityState(projectDir, next);
}
function verifyOwnerSecrets(projectDir, input) {
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized || !state.passwordHash || !state.passphraseHash)
    return false;
  const passOk = typeof input.password === "string" && hashSecret(input.password) === state.passwordHash;
  const phraseOk = typeof input.passphrase === "string" && hashSecret(input.passphrase) === state.passphraseHash;
  return passOk || phraseOk;
}
function verifyOwnerPasswordOnly(projectDir, password) {
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized || !state.passwordHash)
    return false;
  if (typeof password !== "string" || !password)
    return false;
  return hashSecret(password) === state.passwordHash;
}
function rotateOwnerSecrets(projectDir, input) {
  if (!verifyOwnerSecrets(projectDir, {
    password: input.currentPassword,
    passphrase: input.currentPassphrase
  })) {
    throw new Error("owner_secret_verification_failed");
  }
  const state = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...state,
    initialized: true,
    passwordHash: hashSecret(input.newPassword),
    passphraseHash: hashSecret(input.newPassphrase),
    mode: "owner",
    lastSpeakerAt: nowIso33(),
    updatedAt: nowIso33()
  });
}
function updateVoiceprintThresholds(projectDir, patch) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...patch
    }),
    updatedAt: nowIso33()
  });
}
function resolveInteractionMode(projectDir, input) {
  const hint = (input.speakerHint || "").trim().toLowerCase();
  if (hint === "owner" || hint === "guest" || hint === "unknown") {
    return hint;
  }
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized)
    return "unknown";
  if (typeof input.speakerScore === "number") {
    if (input.speakerScore >= state.voiceprintThresholds.ownerMinScore)
      return "owner";
    if (input.speakerScore < state.voiceprintThresholds.guestMaxScore)
      return "guest";
  }
  return state.mode === "owner" ? "owner" : "unknown";
}
function setInteractionMode(projectDir, mode) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    mode,
    lastSpeakerAt: nowIso33(),
    updatedAt: nowIso33()
  });
}
function appendGuestConversation(projectDir, input) {
  const file3 = guestAuditPath(projectDir);
  fs50.mkdirSync(path49.dirname(file3), { recursive: true });
  const row = {
    id: `guest_${randomUUID21()}`,
    at: nowIso33(),
    source: input.source,
    sessionID: input.sessionID,
    text: input.text
  };
  fs50.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}

// src/security/owner-sync.ts
import { randomUUID as randomUUID22 } from "node:crypto";
import * as fs51 from "node:fs";
import * as path50 from "node:path";
function nowIso34() {
  return new Date().toISOString();
}
function storeFile2(projectDir) {
  return path50.join(getMiyaRuntimeDir(projectDir), "security", "owner-sync.json");
}
function readStore12(projectDir) {
  const file3 = storeFile2(projectDir);
  if (!fs51.existsSync(file3))
    return { tokens: [] };
  try {
    const parsed = JSON.parse(fs51.readFileSync(file3, "utf-8"));
    return Array.isArray(parsed.tokens) ? parsed : { tokens: [] };
  } catch {
    return { tokens: [] };
  }
}
function writeStore10(projectDir, store) {
  const file3 = storeFile2(projectDir);
  fs51.mkdirSync(path50.dirname(file3), { recursive: true });
  fs51.writeFileSync(file3, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function purgeExpired(tokens) {
  const now = Date.now();
  return tokens.filter((item) => {
    const expiresAt = Date.parse(item.expiresAt);
    if (!Number.isFinite(expiresAt))
      return false;
    if (expiresAt < now && item.status === "pending")
      return false;
    return true;
  });
}
function normalizeToken(input) {
  return input.trim().toUpperCase();
}
function createToken() {
  return `OS${randomUUID22().replaceAll("-", "").slice(0, 10).toUpperCase()}`;
}
function issueOwnerSyncToken(projectDir, input) {
  const ttlMs = Math.max(60000, Number(input.ttlMs ?? 10 * 60000));
  const store = readStore12(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const now = Date.now();
  const existing = store.tokens.find((item) => item.status === "pending" && item.action === input.action && item.payloadHash === input.payloadHash && Date.parse(item.expiresAt) > now);
  if (existing) {
    writeStore10(projectDir, store);
    return existing;
  }
  const createdAt = nowIso34();
  const record3 = {
    token: createToken(),
    action: input.action,
    payloadHash: input.payloadHash,
    status: "pending",
    createdAt,
    expiresAt: new Date(now + ttlMs).toISOString()
  };
  store.tokens.unshift(record3);
  store.tokens = store.tokens.slice(0, 500);
  writeStore10(projectDir, store);
  return record3;
}
function approveOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token)
    return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore12(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore10(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "pending") {
    writeStore10(projectDir, store);
    return {
      ok: false,
      reason: `owner_sync_token_not_pending:${found.status}`
    };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore10(projectDir, store);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  found.status = "approved";
  found.approvedAt = nowIso34();
  found.approvedBy = { channel: input.channel, senderID: input.senderID };
  writeStore10(projectDir, store);
  return { ok: true, record: found };
}
function verifyOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token)
    return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore12(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore10(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore10(projectDir, store);
    return {
      ok: false,
      reason: `owner_sync_token_not_approved:${found.status}`
    };
  }
  if (found.action !== input.action) {
    writeStore10(projectDir, store);
    return { ok: false, reason: "owner_sync_token_action_mismatch" };
  }
  if (found.payloadHash !== input.payloadHash) {
    writeStore10(projectDir, store);
    return { ok: false, reason: "owner_sync_token_payload_mismatch" };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore10(projectDir, store);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  writeStore10(projectDir, store);
  return { ok: true, record: found };
}
function consumeOwnerSyncToken(projectDir, tokenInput) {
  const token = normalizeToken(tokenInput);
  if (!token)
    return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore12(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore10(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore10(projectDir, store);
    return {
      ok: false,
      reason: `owner_sync_token_not_approved:${found.status}`
    };
  }
  found.status = "consumed";
  found.consumedAt = nowIso34();
  writeStore10(projectDir, store);
  return { ok: true };
}
function detectOwnerSyncTokenFromText(text) {
  const normalized = text.trim();
  if (!normalized)
    return null;
  const matched = /(?:||approve|confirm|ok)\s*[:#]?\s*([a-z0-9_-]{6,64})/i.exec(normalized) ?? /(?:\/miya\s+confirm)\s+([a-z0-9_-]{6,64})/i.exec(normalized);
  if (!matched?.[1])
    return null;
  return normalizeToken(matched[1]);
}

// src/sessions/index.ts
import * as fs52 from "node:fs";
import * as path51 from "node:path";
var DEFAULT_POLICY = {
  activation: "active",
  reply: "auto",
  queueStrategy: "fifo"
};
function nowIso35() {
  return new Date().toISOString();
}
function filePath12(projectDir) {
  return path51.join(getMiyaRuntimeDir(projectDir), "sessions.json");
}
function ensureDir17(file3) {
  fs52.mkdirSync(path51.dirname(file3), { recursive: true });
}
function readStore13(projectDir) {
  const file3 = filePath12(projectDir);
  if (!fs52.existsSync(file3)) {
    return { sessions: {} };
  }
  try {
    const parsed = JSON.parse(fs52.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const normalized = { sessions: {} };
    for (const [id, session] of Object.entries(parsed.sessions ?? {})) {
      normalized.sessions[id] = {
        ...session,
        groupId: decryptSensitiveValue(projectDir, String(session.groupId ?? "")),
        title: typeof session.title === "string" ? decryptSensitiveValue(projectDir, session.title) : session.title,
        routing: {
          ...session.routing ?? {
            opencodeSessionID: "main",
            agent: "1-task-manager"
          },
          opencodeSessionID: decryptSensitiveValue(projectDir, String(session.routing?.opencodeSessionID ?? "main"))
        },
        queue: Array.isArray(session.queue) ? session.queue.map((item) => ({
          ...item,
          text: decryptSensitiveValue(projectDir, String(item.text ?? "")),
          source: decryptSensitiveValue(projectDir, String(item.source ?? ""))
        })) : []
      };
    }
    return normalized;
  } catch {
    return { sessions: {} };
  }
}
function writeStore11(projectDir, store) {
  const file3 = filePath12(projectDir);
  ensureDir17(file3);
  const encrypted = { sessions: {} };
  for (const [id, session] of Object.entries(store.sessions)) {
    encrypted.sessions[id] = {
      ...session,
      groupId: encryptSensitiveValue(projectDir, session.groupId),
      title: session.title ? encryptSensitiveValue(projectDir, session.title) : session.title,
      routing: {
        ...session.routing,
        opencodeSessionID: encryptSensitiveValue(projectDir, session.routing.opencodeSessionID)
      },
      queue: session.queue.map((item) => ({
        ...item,
        text: encryptSensitiveValue(projectDir, item.text),
        source: encryptSensitiveValue(projectDir, item.source)
      }))
    };
  }
  fs52.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function sanitizeSession(value) {
  return {
    ...value,
    policy: {
      activation: value.policy?.activation ?? DEFAULT_POLICY.activation,
      reply: value.policy?.reply ?? DEFAULT_POLICY.reply,
      queueStrategy: value.policy?.queueStrategy ?? DEFAULT_POLICY.queueStrategy
    },
    routing: {
      opencodeSessionID: value.routing?.opencodeSessionID ?? "main",
      agent: value.routing?.agent ?? "1-task-manager"
    },
    queue: Array.isArray(value.queue) ? value.queue : []
  };
}
function listSessions(projectDir) {
  const store = readStore13(projectDir);
  return Object.values(store.sessions).map(sanitizeSession).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function getSession(projectDir, sessionID) {
  const store = readStore13(projectDir);
  const session = store.sessions[sessionID];
  return session ? sanitizeSession(session) : null;
}
function upsertSession(projectDir, input) {
  const store = readStore13(projectDir);
  const existing = store.sessions[input.id];
  const createdAt = existing?.createdAt ?? nowIso35();
  const session = sanitizeSession({
    id: input.id,
    kind: input.kind ?? existing?.kind ?? "channel",
    groupId: input.groupId ?? existing?.groupId ?? input.id,
    title: input.title ?? existing?.title,
    policy: existing?.policy ?? DEFAULT_POLICY,
    routing: {
      opencodeSessionID: input.routingSessionID ?? existing?.routing?.opencodeSessionID ?? "main",
      agent: input.agent ?? existing?.routing?.agent ?? "1-task-manager"
    },
    queue: existing?.queue ?? [],
    createdAt,
    updatedAt: nowIso35()
  });
  store.sessions[input.id] = session;
  writeStore11(projectDir, store);
  return session;
}
function setSessionPolicy(projectDir, sessionID, patch) {
  const store = readStore13(projectDir);
  const existing = store.sessions[sessionID];
  if (!existing)
    return null;
  const next = sanitizeSession({
    ...existing,
    policy: {
      ...existing.policy,
      ...patch
    },
    updatedAt: nowIso35()
  });
  store.sessions[sessionID] = next;
  writeStore11(projectDir, store);
  return next;
}
function enqueueSessionMessage(projectDir, sessionID, input) {
  const store = readStore13(projectDir);
  const existing = sanitizeSession(store.sessions[sessionID] ?? upsertSession(projectDir, {
    id: sessionID
  }));
  const message = {
    id: `queue_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    text: input.text,
    source: input.source,
    createdAt: nowIso35()
  };
  const nextQueue = [...existing.queue, message];
  const next = {
    ...existing,
    queue: nextQueue,
    updatedAt: nowIso35()
  };
  store.sessions[sessionID] = next;
  writeStore11(projectDir, store);
  return message;
}
function dequeueSessionMessage(projectDir, sessionID) {
  const store = readStore13(projectDir);
  const existing = store.sessions[sessionID];
  if (!existing || existing.queue.length === 0) {
    return null;
  }
  const [first, ...rest] = existing.queue;
  store.sessions[sessionID] = {
    ...existing,
    queue: rest,
    updatedAt: nowIso35()
  };
  writeStore11(projectDir, store);
  return first;
}

// src/skills/loader.ts
import * as fs53 from "node:fs";
import * as os2 from "node:os";
import * as path52 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";

// src/skills/frontmatter.ts
var LIST_KEYS = new Set(["bins", "env", "platforms", "permissions"]);
function normalizeScalar(value) {
  const trimmed = value.trim();
  if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
    return trimmed.slice(1, -1).trim();
  }
  return trimmed;
}
function normalizeList(value) {
  const trimmed = value.trim();
  if (!trimmed)
    return [];
  const body = trimmed.startsWith("[") && trimmed.endsWith("]") ? trimmed.slice(1, -1) : trimmed;
  return body.split(",").map((item) => normalizeScalar(item)).filter(Boolean);
}
function parseSkillFrontmatter(markdown) {
  const trimmed = markdown.trimStart();
  if (!trimmed.startsWith("---")) {
    return {};
  }
  const lines = trimmed.split(/\r?\n/);
  if (lines.length < 3 || lines[0].trim() !== "---") {
    return {};
  }
  const endIndex = lines.findIndex((line, index) => index > 0 && line.trim() === "---");
  if (endIndex === -1) {
    return {};
  }
  const result = {};
  let activeListKey;
  for (const rawLine of lines.slice(1, endIndex)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#"))
      continue;
    if (activeListKey && line.startsWith("- ")) {
      const value2 = normalizeScalar(line.slice(2));
      if (value2) {
        const existing = result[activeListKey] ?? [];
        result[activeListKey] = [...existing, value2];
      }
      continue;
    }
    activeListKey = undefined;
    const colon = line.indexOf(":");
    if (colon <= 0)
      continue;
    const key = line.slice(0, colon).trim();
    const value = line.slice(colon + 1).trim();
    if (key === "name")
      result.name = value;
    else if (key === "version")
      result.version = value;
    else if (key === "description")
      result.description = value;
    else if (LIST_KEYS.has(key)) {
      const listKey = key;
      const parsed = normalizeList(value);
      if (parsed.length > 0) {
        result[listKey] = parsed;
      } else {
        result[listKey] = [];
        activeListKey = listKey;
      }
    }
  }
  return result;
}

// src/skills/gating.ts
import { spawnSync as spawnSync7 } from "node:child_process";
function hasBinary(bin) {
  const checker = process.platform === "win32" ? "where" : "which";
  const result = spawnSync7(checker, [bin], { stdio: "ignore" });
  return result.status === 0;
}
function evaluateSkillGate(frontmatter) {
  const reasons = [];
  if (Array.isArray(frontmatter.platforms) && frontmatter.platforms.length > 0) {
    if (!frontmatter.platforms.includes(process.platform)) {
      reasons.push(`platform_not_supported:${process.platform}`);
    }
  }
  for (const envName of frontmatter.env ?? []) {
    if (!process.env[envName]) {
      reasons.push(`missing_env:${envName}`);
    }
  }
  for (const bin of frontmatter.bins ?? []) {
    if (!hasBinary(bin)) {
      reasons.push(`missing_bin:${bin}`);
    }
  }
  return {
    loadable: reasons.length === 0,
    reasons
  };
}

// src/skills/loader.ts
function isSkillDir(dir) {
  const skillFile = path52.join(dir, "SKILL.md");
  return fs53.existsSync(skillFile);
}
function listSkillDirs(rootDir) {
  if (!fs53.existsSync(rootDir))
    return [];
  const entries = fs53.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path52.join(rootDir, entry2.name));
  return entries.filter(isSkillDir);
}
function builtinSkillRoots(projectDir) {
  const roots = new Set;
  roots.add(path52.join(projectDir, "miya-src", "src", "skills"));
  roots.add(path52.dirname(fileURLToPath3(import.meta.url)));
  return [...roots];
}
function enforcePermissionMetadataGate(source, frontmatter, gate) {
  if (source === "builtin")
    return gate;
  if ((frontmatter.permissions?.length ?? 0) > 0)
    return gate;
  const reasons = [...gate.reasons, "missing_permission_metadata"];
  return {
    loadable: false,
    reasons: [...new Set(reasons)]
  };
}
function discoverSkills(projectDir, extraDirs = []) {
  const workspaceRoot = path52.join(projectDir, "skills");
  const globalRoot = path52.join(os2.homedir(), ".config", "opencode", "miya", "skills");
  const scopedDirs = [
    { source: "workspace", dirs: listSkillDirs(workspaceRoot) },
    { source: "global", dirs: listSkillDirs(globalRoot) },
    {
      source: "builtin",
      dirs: builtinSkillRoots(projectDir).flatMap((root) => listSkillDirs(root))
    },
    {
      source: "extra",
      dirs: extraDirs.flatMap((root) => listSkillDirs(path52.resolve(projectDir, root)))
    }
  ];
  const precedence = {
    workspace: 4,
    global: 3,
    extra: 2,
    builtin: 1
  };
  const byName = new Map;
  for (const scope of scopedDirs) {
    for (const dir of scope.dirs) {
      const skillFile = path52.join(dir, "SKILL.md");
      let content = "";
      try {
        content = fs53.readFileSync(skillFile, "utf-8");
      } catch {
        continue;
      }
      const frontmatter = parseSkillFrontmatter(content);
      const name = frontmatter.name ?? path52.basename(dir);
      const gate = enforcePermissionMetadataGate(scope.source, frontmatter, evaluateSkillGate(frontmatter));
      const descriptor = {
        id: name,
        name,
        source: scope.source,
        dir,
        skillFile,
        frontmatter,
        gate
      };
      const existing = byName.get(name);
      if (!existing || precedence[scope.source] >= precedence[existing.source]) {
        byName.set(name, descriptor);
      }
    }
  }
  return [...byName.values()].sort((a, b) => a.name.localeCompare(b.name));
}

// src/skills/state.ts
import * as fs54 from "node:fs";
import * as path53 from "node:path";
function nowIso36() {
  return new Date().toISOString();
}
function filePath13(projectDir) {
  return path53.join(getMiyaRuntimeDir(projectDir), "skills.json");
}
function ensureDir18(file3) {
  fs54.mkdirSync(path53.dirname(file3), { recursive: true });
}
function readState2(projectDir) {
  const file3 = filePath13(projectDir);
  if (!fs54.existsSync(file3)) {
    return { enabled: [], updatedAt: nowIso36() };
  }
  try {
    const parsed = JSON.parse(fs54.readFileSync(file3, "utf-8"));
    return {
      enabled: Array.isArray(parsed.enabled) ? parsed.enabled.map(String) : [],
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso36()
    };
  } catch {
    return { enabled: [], updatedAt: nowIso36() };
  }
}
function writeState5(projectDir, state) {
  const file3 = filePath13(projectDir);
  ensureDir18(file3);
  fs54.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
}
function listEnabledSkills(projectDir) {
  return readState2(projectDir).enabled;
}
function setSkillEnabled(projectDir, skillID, enabled) {
  const state = readState2(projectDir);
  const normalized = new Set(state.enabled);
  if (enabled)
    normalized.add(skillID);
  else
    normalized.delete(skillID);
  const next = {
    enabled: [...normalized].sort(),
    updatedAt: nowIso36()
  };
  writeState5(projectDir, next);
  return next.enabled;
}

// src/skills/sync.ts
import { createHash as createHash17 } from "node:crypto";
import * as fs56 from "node:fs";
import * as os3 from "node:os";
import * as path55 from "node:path";

// src/skills/governance.ts
import { createHash as createHash16 } from "node:crypto";
import * as fs55 from "node:fs";
import * as path54 from "node:path";
var DEFAULT_STORE = {
  version: 1,
  updatedAt: new Date(0).toISOString(),
  records: {}
};
var DEFAULT_STRICT_ALLOWED_PERMISSIONS = [
  "shell_exec",
  "fs_read",
  "fs_write",
  "memory_read",
  "memory_write",
  "memory_delete",
  "desktop_control",
  "outbound_send",
  "skills_install",
  "local_build"
];
function nowIso37() {
  return new Date().toISOString();
}
function governanceFile(projectDir) {
  return path54.join(getMiyaRuntimeDir(projectDir), "ecosystem-governance.json");
}
function readStore14(projectDir) {
  const file3 = governanceFile(projectDir);
  if (!fs55.existsSync(file3))
    return { ...DEFAULT_STORE };
  try {
    const parsed = JSON.parse(fs55.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date(0).toISOString(),
      records: parsed.records && typeof parsed.records === "object" ? parsed.records : {}
    };
  } catch {
    return { ...DEFAULT_STORE };
  }
}
function writeStore12(projectDir, store) {
  const file3 = governanceFile(projectDir);
  fs55.mkdirSync(path54.dirname(file3), { recursive: true });
  const next = {
    version: 1,
    updatedAt: nowIso37(),
    records: store.records
  };
  fs55.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function normalizeSemver(version3) {
  const parts = String(version3 || "0.0.0").split(".").map((item) => Number.parseInt(item.replace(/[^\d]/g, ""), 10) || 0);
  return [parts[0] ?? 0, parts[1] ?? 0, parts[2] ?? 0];
}
function compareSemver(a, b) {
  const left = normalizeSemver(a);
  const right = normalizeSemver(b);
  if (left[0] !== right[0])
    return left[0] > right[0] ? 1 : -1;
  if (left[1] !== right[1])
    return left[1] > right[1] ? 1 : -1;
  if (left[2] !== right[2])
    return left[2] > right[2] ? 1 : -1;
  return 0;
}
function readCompatConfig(localDir) {
  const file3 = path54.join(localDir, "miya.compat.json");
  if (!fs55.existsSync(file3))
    return {};
  try {
    return JSON.parse(fs55.readFileSync(file3, "utf-8"));
  } catch {
    return {};
  }
}
function currentMiyaVersion() {
  return process.env.MIYA_VERSION?.trim() || "0.7.0";
}
function resolveCompatibility(localDir) {
  const compat3 = readCompatConfig(localDir);
  const minVersion = compat3.miya?.minVersion?.trim();
  const maxVersion = compat3.miya?.maxVersion?.trim();
  const currentVersion = currentMiyaVersion();
  const minOk = minVersion ? compareSemver(currentVersion, minVersion) >= 0 : true;
  const maxOk = maxVersion ? compareSemver(currentVersion, maxVersion) <= 0 : true;
  const ok = minOk && maxOk;
  return {
    ok,
    currentVersion,
    minVersion,
    maxVersion,
    notes: ok ? "compatible" : "version_out_of_range"
  };
}
function requiredFiles(localDir) {
  const compat3 = readCompatConfig(localDir);
  const custom3 = compat3.smoke?.requiredFiles;
  if (Array.isArray(custom3) && custom3.length > 0) {
    return custom3.map((item) => String(item)).filter(Boolean).slice(0, 30);
  }
  return ["SKILL.md"];
}
function runSmoke(localDir) {
  const files = requiredFiles(localDir);
  const missing = files.filter((entry2) => !fs55.existsSync(path54.join(localDir, entry2)));
  return {
    ok: missing.length === 0,
    requiredFiles: files,
    missingFiles: missing,
    checkedAt: nowIso37()
  };
}
function normalizeRelativePath(relPath) {
  return relPath.replace(/\\/g, "/");
}
function listRelativeFiles(localDir) {
  const root = path54.resolve(localDir);
  const queue = [
    { dir: root, depth: 0 }
  ];
  const files = [];
  const depthLimit = 6;
  const fileLimit = 5000;
  while (queue.length > 0 && files.length < fileLimit) {
    const current = queue.shift();
    if (!current)
      break;
    let entries = [];
    try {
      entries = fs55.readdirSync(current.dir, { withFileTypes: true });
    } catch {
      continue;
    }
    for (const entry2 of entries) {
      const abs = path54.join(current.dir, entry2.name);
      const rel = normalizeRelativePath(path54.relative(root, abs));
      if (!rel || rel.startsWith(".."))
        continue;
      if (entry2.isDirectory()) {
        if (current.depth < depthLimit && entry2.name !== ".git" && entry2.name !== "node_modules" && entry2.name !== ".venv" && entry2.name !== "dist") {
          queue.push({ dir: abs, depth: current.depth + 1 });
        }
        continue;
      }
      if (entry2.isFile()) {
        files.push(rel);
      }
      if (files.length >= fileLimit)
        break;
    }
  }
  return files.sort((a, b) => a.localeCompare(b));
}
function runRegression(localDir, strict = false) {
  const compat3 = readCompatConfig(localDir);
  const files = listRelativeFiles(localDir);
  const required3 = Array.isArray(compat3.regression?.requiredFiles) && compat3.regression?.requiredFiles.length > 0 ? compat3.regression.requiredFiles.map(String).map(normalizeRelativePath).slice(0, 80) : requiredFiles(localDir).map(normalizeRelativePath);
  const missingFiles = required3.filter((entry2) => !fs55.existsSync(path54.join(localDir, entry2)));
  const testArtifacts = files.filter((entry2) => /(^|\/)(__tests__|tests|test)\b|\.test\.[cm]?[jt]sx?$|\.spec\.[cm]?[jt]sx?$/i.test(entry2));
  const requireTestArtifacts = strict || (typeof compat3.regression?.requireTests === "boolean" ? compat3.regression.requireTests : false);
  const ok = missingFiles.length === 0 && (!requireTestArtifacts || testArtifacts.length > 0);
  return {
    ok,
    requiredFiles: required3,
    missingFiles,
    requireTestArtifacts,
    testArtifacts: testArtifacts.slice(0, 200),
    checkedAt: nowIso37()
  };
}
function parsePermissionList(values) {
  if (!Array.isArray(values))
    return [];
  return values.map((item) => String(item).trim().toLowerCase()).filter(Boolean).slice(0, 100);
}
function parsePermissionEnv(value) {
  if (!value)
    return [];
  return value.split(/[,\s]+/g).map((item) => item.trim().toLowerCase()).filter(Boolean).slice(0, 100);
}
function resolveAllowedPermissions(compat3, strict) {
  const fromCompat = parsePermissionList(compat3.security?.allowedPermissions);
  if (fromCompat.length > 0)
    return new Set(fromCompat);
  const fromEnv = parsePermissionEnv(process.env.MIYA_ALLOWED_SKILL_PERMISSIONS);
  if (fromEnv.length > 0)
    return new Set(fromEnv);
  if (!strict)
    return null;
  return new Set(DEFAULT_STRICT_ALLOWED_PERMISSIONS);
}
function resolveDeniedPermissions(compat3) {
  const denied = [
    ...parsePermissionList(compat3.security?.denyPermissions),
    ...parsePermissionEnv(process.env.MIYA_DENY_SKILL_PERMISSIONS)
  ];
  return new Set(denied);
}
function runSecurity(localDir, strict = false) {
  const compat3 = readCompatConfig(localDir);
  const files = listRelativeFiles(localDir);
  const skillFiles = files.filter((entry2) => /(^|\/)SKILL\.md$/i.test(entry2)).slice(0, 200);
  const requirePermissionMetadata = strict || (typeof compat3.security?.requirePermissionMetadata === "boolean" ? compat3.security.requirePermissionMetadata : false);
  const missingPermissionMetadata = [];
  const disallowedPermissions = [];
  const allowed = resolveAllowedPermissions(compat3, strict);
  const denied = resolveDeniedPermissions(compat3);
  for (const rel of skillFiles) {
    const file3 = path54.join(localDir, rel);
    let content = "";
    try {
      content = fs55.readFileSync(file3, "utf-8");
    } catch {
      continue;
    }
    const frontmatter = parseSkillFrontmatter(content);
    const permissions = parsePermissionList(frontmatter.permissions);
    if (permissions.length === 0) {
      if (requirePermissionMetadata) {
        missingPermissionMetadata.push(rel);
      }
      continue;
    }
    for (const permission of permissions) {
      if (denied.has(permission)) {
        disallowedPermissions.push({ skillFile: rel, permission });
        continue;
      }
      if (allowed && !allowed.has(permission)) {
        disallowedPermissions.push({ skillFile: rel, permission });
      }
    }
  }
  if (requirePermissionMetadata && skillFiles.length === 0) {
    missingPermissionMetadata.push("SKILL.md");
  }
  const ok = missingPermissionMetadata.length === 0 && disallowedPermissions.length === 0;
  return {
    ok,
    strict,
    requirePermissionMetadata,
    checkedSkillFiles: skillFiles,
    missingPermissionMetadata,
    disallowedPermissions,
    checkedAt: nowIso37()
  };
}
function buildDigest(localDir, revision) {
  const hasher = createHash16("sha256");
  hasher.update(revision);
  for (const rel of ["SKILL.md", "README.md"]) {
    const file3 = path54.join(localDir, rel);
    if (!fs55.existsSync(file3))
      continue;
    hasher.update(rel);
    hasher.update(`
`);
    hasher.update(fs55.readFileSync(file3, "utf-8"));
    hasher.update(`
`);
  }
  return hasher.digest("hex");
}
function refreshSourcePackGovernance(projectDir, input) {
  const store = readStore14(projectDir);
  const now = nowIso37();
  const record3 = {
    sourcePackID: input.sourcePackID,
    revision: input.revision,
    lock: {
      revision: input.revision,
      lockedAt: now
    },
    signature: {
      algorithm: "sha256",
      digest: buildDigest(input.localDir, input.revision),
      verifiedAt: now
    },
    compatibility: resolveCompatibility(input.localDir),
    smoke: runSmoke(input.localDir),
    regression: runRegression(input.localDir, false),
    security: runSecurity(input.localDir, false),
    updatedAt: now
  };
  store.records[input.sourcePackID] = record3;
  writeStore12(projectDir, store);
  return record3;
}
function getSourcePackGovernance(projectDir, sourcePackID) {
  const store = readStore14(projectDir);
  return store.records[sourcePackID];
}
function verifySourcePackGovernance(projectDir, input) {
  const record3 = getSourcePackGovernance(projectDir, input.sourcePackID);
  if (!record3) {
    return {
      signatureValid: false,
      lockValid: false,
      compatibilityValid: false,
      smokeValid: false,
      regressionValid: false,
      securityValid: false,
      record: undefined
    };
  }
  const strict = input.strict === true;
  const digest = buildDigest(input.localDir, input.revision);
  const signatureValid = digest === record3.signature.digest;
  const lockValid = record3.lock.revision === input.revision;
  const compatibility = resolveCompatibility(input.localDir);
  const compatibilityValid = compatibility.ok;
  const smoke = runSmoke(input.localDir);
  const smokeValid = smoke.ok;
  const regression = runRegression(input.localDir, strict);
  const security = runSecurity(input.localDir, strict);
  return {
    signatureValid,
    lockValid,
    compatibilityValid,
    smokeValid,
    regressionValid: regression.ok,
    securityValid: security.ok,
    record: {
      ...record3,
      compatibility,
      smoke,
      regression,
      security,
      updatedAt: nowIso37()
    }
  };
}

// src/skills/sync.ts
var DEFAULT_STATE2 = {
  version: 1,
  updatedAt: new Date(0).toISOString(),
  sourcePacks: {},
  importPlans: {},
  pinnedReleases: {}
};
var TRUSTED_SOURCE_ALLOWLIST = [
  /^https?:\/\/github\.com\/(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i,
  /^git@github\.com:(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i
];
function nowIso38(options) {
  return options?.now?.() ?? new Date().toISOString();
}
function stateFile2(projectDir) {
  return path55.join(getMiyaRuntimeDir(projectDir), "ecosystem-bridge.json");
}
function readState3(projectDir) {
  const file3 = stateFile2(projectDir);
  if (!fs56.existsSync(file3))
    return { ...DEFAULT_STATE2 };
  try {
    const parsed = JSON.parse(fs56.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date(0).toISOString(),
      sourcePacks: parsed.sourcePacks && typeof parsed.sourcePacks === "object" ? parsed.sourcePacks : {},
      importPlans: parsed.importPlans && typeof parsed.importPlans === "object" ? parsed.importPlans : {},
      pinnedReleases: parsed.pinnedReleases && typeof parsed.pinnedReleases === "object" ? parsed.pinnedReleases : {}
    };
  } catch {
    return { ...DEFAULT_STATE2 };
  }
}
function writeState6(projectDir, state, options) {
  const file3 = stateFile2(projectDir);
  fs56.mkdirSync(path55.dirname(file3), { recursive: true });
  const next = {
    ...state,
    version: 1,
    updatedAt: nowIso38(options)
  };
  fs56.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
}
function runGit(args, cwd) {
  const proc = Bun.spawnSync(["git", ...args], {
    cwd,
    stdout: "pipe",
    stderr: "pipe"
  });
  return {
    exitCode: proc.exitCode,
    stdout: Buffer.from(proc.stdout).toString("utf-8").trim(),
    stderr: Buffer.from(proc.stderr).toString("utf-8").trim()
  };
}
function git(options, args, cwd) {
  return (options?.gitRunner ?? runGit)(args, cwd);
}
function normalizeText5(value) {
  const trimmed = value?.trim();
  if (!trimmed)
    return;
  return trimmed;
}
function defaultSourceRoots(projectDir) {
  return [
    path55.join(projectDir, "skills"),
    path55.join(os3.homedir(), ".config", "opencode", "miya", "skills")
  ];
}
function listSkillReposFromRoot(rootDir) {
  if (!fs56.existsSync(rootDir))
    return [];
  return fs56.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path55.join(rootDir, entry2.name)).filter((dir) => {
    return fs56.existsSync(path55.join(dir, "SKILL.md")) && fs56.existsSync(path55.join(dir, ".git"));
  });
}
function sanitizeIdSegment(input) {
  return input.replace(/[^a-zA-Z0-9_-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
}
function buildSourcePackID(repo, localDir) {
  const base = sanitizeIdSegment(path55.basename(localDir) || "source-pack") || "source-pack";
  const fingerprint = createHash17("sha256").update(`${repo ?? ""}|${path55.resolve(localDir)}`).digest("hex").slice(0, 12);
  return `${base}-${fingerprint}`;
}
function trustLevelForRepo(repo) {
  if (!repo)
    return "unknown";
  return TRUSTED_SOURCE_ALLOWLIST.some((rule) => rule.test(repo)) ? "allowlisted" : "untrusted";
}
function resolveSkillName(localDir) {
  const manifest = path55.join(localDir, "SKILL.md");
  if (!fs56.existsSync(manifest))
    return path55.basename(localDir);
  try {
    const raw = fs56.readFileSync(manifest, "utf-8");
    const heading = /^#\s+(.+)$/m.exec(raw)?.[1]?.trim();
    if (heading)
      return heading;
  } catch {}
  return path55.basename(localDir);
}
function readGitValue(options, cwd, args) {
  const result = git(options, args, cwd);
  if (result.exitCode !== 0)
    return;
  return normalizeText5(result.stdout);
}
function resolveUpstreamRef(localDir, branch, options) {
  const upstream = readGitValue(options, localDir, [
    "rev-parse",
    "--abbrev-ref",
    "--symbolic-full-name",
    "@{upstream}"
  ]);
  if (upstream)
    return upstream;
  if (branch && branch !== "HEAD")
    return `origin/${branch}`;
  return "origin/HEAD";
}
function resolveRevision(localDir, ref, options) {
  const resolved = readGitValue(options, localDir, [
    "rev-parse",
    `${ref}^{commit}`
  ]);
  if (!resolved) {
    throw new Error(`source_pack_revision_unresolved:${ref}`);
  }
  return resolved;
}
function requireCleanWorkingTree(localDir, options) {
  const status = git(options, ["status", "--porcelain"], localDir);
  if (status.exitCode !== 0) {
    throw new Error(status.stderr || "source_pack_status_failed");
  }
  if (status.stdout.trim()) {
    throw new Error("source_pack_dirty_worktree");
  }
}
function discoverSourcePacks(projectDir, state, options) {
  const roots = options?.sourceRoots?.length ? options.sourceRoots : defaultSourceRoots(projectDir);
  const dirs = new Set;
  for (const root of roots) {
    for (const repoDir of listSkillReposFromRoot(root)) {
      dirs.add(path55.resolve(repoDir));
    }
  }
  const packs = [];
  for (const localDir of [...dirs]) {
    const headRevision = readGitValue(options, localDir, ["rev-parse", "HEAD"]);
    if (!headRevision)
      continue;
    const repo = readGitValue(options, localDir, [
      "config",
      "--get",
      "remote.origin.url"
    ]);
    const branch = readGitValue(options, localDir, ["rev-parse", "--abbrev-ref", "HEAD"]) ?? "HEAD";
    const sourcePackID = buildSourcePackID(repo, localDir);
    const sourceState = state.sourcePacks[sourcePackID];
    const importPlan = state.importPlans[sourcePackID];
    const pinnedRelease = state.pinnedReleases[sourcePackID];
    const governance = getSourcePackGovernance(projectDir, sourcePackID);
    packs.push({
      sourcePackID,
      name: path55.basename(localDir),
      skillName: resolveSkillName(localDir),
      repo,
      localDir,
      branch,
      headRevision,
      latestRevision: sourceState?.latestRevision,
      lastPulledAt: sourceState?.lastPulledAt,
      trustLevel: trustLevelForRepo(repo),
      importPlan,
      pinnedRelease,
      governance
    });
  }
  return packs.sort((a, b) => {
    const byName = a.name.localeCompare(b.name);
    if (byName !== 0)
      return byName;
    return a.sourcePackID.localeCompare(b.sourcePackID);
  });
}
function requireSourcePack(projectDir, sourcePackID, options) {
  const state = readState3(projectDir);
  const packs = discoverSourcePacks(projectDir, state, options);
  const sourcePack = packs.find((item) => item.sourcePackID === sourcePackID);
  if (!sourcePack)
    throw new Error(`unknown_source_pack:${sourcePackID}`);
  return { state, sourcePack };
}
function ensureImportPlan(state, sourcePack, options) {
  const existing = state.importPlans[sourcePack.sourcePackID];
  if (existing) {
    const refreshed = {
      ...existing,
      sourcePackID: sourcePack.sourcePackID,
      localDir: sourcePack.localDir,
      updatedAt: nowIso38(options)
    };
    state.importPlans[sourcePack.sourcePackID] = refreshed;
    return refreshed;
  }
  const created = {
    sourcePackID: sourcePack.sourcePackID,
    localDir: sourcePack.localDir,
    importMode: "skills_only",
    permissionMode: "sandbox_read_only",
    createdAt: nowIso38(options),
    updatedAt: nowIso38(options)
  };
  state.importPlans[sourcePack.sourcePackID] = created;
  return created;
}
function updateSourcePackState(state, sourcePack, patch) {
  const current = state.sourcePacks[sourcePack.sourcePackID];
  state.sourcePacks[sourcePack.sourcePackID] = {
    sourcePackID: sourcePack.sourcePackID,
    repo: sourcePack.repo,
    localDir: sourcePack.localDir,
    latestRevision: current?.latestRevision,
    lastPulledAt: current?.lastPulledAt,
    lastError: current?.lastError,
    ...patch
  };
}
function listEcosystemBridge(projectDir, options) {
  const state = readState3(projectDir);
  const sourcePacks = discoverSourcePacks(projectDir, state, options);
  const bySkillName = new Map;
  for (const pack of sourcePacks) {
    const key = pack.skillName.toLowerCase();
    const list = bySkillName.get(key) ?? [];
    list.push(pack);
    bySkillName.set(key, list);
  }
  const conflicts = [];
  for (const [, list] of bySkillName.entries()) {
    if (list.length <= 1)
      continue;
    conflicts.push({
      type: "skill_name_collision",
      skillName: list[0].skillName,
      sourcePackIDs: list.map((item) => item.sourcePackID).sort()
    });
  }
  const importPlans = Object.values(state.importPlans).sort((a, b) => a.sourcePackID.localeCompare(b.sourcePackID));
  const pinnedReleases = Object.values(state.pinnedReleases).sort((a, b) => a.sourcePackID.localeCompare(b.sourcePackID));
  return {
    sourcePacks,
    importPlans,
    pinnedReleases,
    conflicts: conflicts.sort((a, b) => a.skillName.localeCompare(b.skillName))
  };
}
function pullSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pull = git(options, ["fetch", "--prune", "origin"], resolved.sourcePack.localDir);
  if (pull.exitCode !== 0) {
    updateSourcePackState(resolved.state, resolved.sourcePack, {
      lastError: pull.stderr || "source_pack_fetch_failed"
    });
    writeState6(projectDir, resolved.state, options);
    throw new Error(pull.stderr || "source_pack_fetch_failed");
  }
  const compareRef = resolveUpstreamRef(resolved.sourcePack.localDir, resolved.sourcePack.branch, options);
  const latestRevision = resolveRevision(resolved.sourcePack.localDir, compareRef, options);
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision,
    lastPulledAt: nowIso38(options),
    lastError: undefined
  });
  writeState6(projectDir, resolved.state, options);
  const governance = refreshSourcePackGovernance(projectDir, {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    revision: latestRevision
  });
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    latestRevision,
    compareRef,
    pulledAt: nowIso38(options),
    governance
  };
}
function diffSourcePack(projectDir, sourcePackID, options) {
  const { state, sourcePack } = requireSourcePack(projectDir, sourcePackID, options);
  const compareRef = state.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(sourcePack.localDir, sourcePack.branch, options);
  const compareRevision = resolveRevision(sourcePack.localDir, compareRef, options);
  const count = git(options, ["rev-list", "--left-right", "--count", `HEAD...${compareRevision}`], sourcePack.localDir);
  if (count.exitCode !== 0) {
    throw new Error(count.stderr || "source_pack_diff_failed");
  }
  const [aheadRaw, behindRaw] = count.stdout.split(/\s+/);
  const ahead = Number.parseInt(aheadRaw ?? "0", 10) || 0;
  const behind = Number.parseInt(behindRaw ?? "0", 10) || 0;
  const logResult = git(options, ["log", "--oneline", "--max-count", "20", `HEAD..${compareRevision}`], sourcePack.localDir);
  const pendingCommits = logResult.exitCode === 0 && logResult.stdout ? logResult.stdout.split(`
`).map((line) => line.trim()).filter(Boolean) : [];
  return {
    sourcePackID,
    localDir: sourcePack.localDir,
    headRevision: sourcePack.headRevision,
    compareRevision,
    compareRef,
    ahead,
    behind,
    pendingCommits,
    pinnedRelease: state.pinnedReleases[sourcePackID]
  };
}
function applySourcePack(projectDir, sourcePackID, input = {}, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const targetRef = normalizeText5(input.revision) ?? resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(resolved.sourcePack.localDir, resolved.sourcePack.branch, options);
  const targetRevision = resolveRevision(resolved.sourcePack.localDir, targetRef, options);
  const previousRevision = resolved.sourcePack.headRevision;
  if (previousRevision !== targetRevision) {
    const checkout = git(options, ["checkout", "--detach", targetRevision], resolved.sourcePack.localDir);
    if (checkout.exitCode !== 0) {
      throw new Error(checkout.stderr || "source_pack_apply_failed");
    }
  }
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision: resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? targetRevision,
    lastError: undefined
  });
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : resolved.state.pinnedReleases[sourcePackID]?.previousRevision,
    appliedAt: nowIso38(options)
  };
  writeState6(projectDir, resolved.state, options);
  const governance = refreshSourcePackGovernance(projectDir, {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    revision: targetRevision
  });
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    appliedRevision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : undefined,
    detachedHead: true,
    governance
  };
}
function rollbackSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pinned = resolved.state.pinnedReleases[sourcePackID];
  if (!pinned?.previousRevision) {
    throw new Error(`source_pack_rollback_unavailable:${sourcePackID}`);
  }
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const previousRevision = resolved.sourcePack.headRevision;
  const rollbackRevision = resolveRevision(resolved.sourcePack.localDir, pinned.previousRevision, options);
  const checkout = git(options, ["checkout", "--detach", rollbackRevision], resolved.sourcePack.localDir);
  if (checkout.exitCode !== 0) {
    throw new Error(checkout.stderr || "source_pack_rollback_failed");
  }
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: rollbackRevision,
    previousRevision,
    appliedAt: nowIso38(options)
  };
  writeState6(projectDir, resolved.state, options);
  const governance = refreshSourcePackGovernance(projectDir, {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    revision: rollbackRevision
  });
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    rolledBackTo: rollbackRevision,
    previousRevision,
    detachedHead: true,
    governance
  };
}
function verifySourcePackGovernance2(projectDir, sourcePackID, options) {
  const { sourcePack } = requireSourcePack(projectDir, sourcePackID, options);
  const revision = sourcePack.pinnedRelease?.revision ?? sourcePack.headRevision;
  const report = verifySourcePackGovernance(projectDir, {
    sourcePackID,
    localDir: sourcePack.localDir,
    revision
  });
  return {
    sourcePackID,
    localDir: sourcePack.localDir,
    revision,
    signatureValid: report.signatureValid,
    lockValid: report.lockValid,
    compatibilityValid: report.compatibilityValid,
    smokeValid: report.smokeValid,
    regressionValid: report.regressionValid,
    securityValid: report.securityValid,
    governance: report.record
  };
}
function preflightSourcePackGovernance(projectDir, sourcePackID, options) {
  const { sourcePack } = requireSourcePack(projectDir, sourcePackID, options);
  const revision = sourcePack.pinnedRelease?.revision ?? sourcePack.headRevision;
  const report = verifySourcePackGovernance(projectDir, {
    sourcePackID,
    localDir: sourcePack.localDir,
    revision,
    strict: true
  });
  const pass = report.signatureValid && report.lockValid && report.compatibilityValid && report.smokeValid && report.regressionValid && report.securityValid;
  return {
    sourcePackID,
    localDir: sourcePack.localDir,
    revision,
    signatureValid: report.signatureValid,
    lockValid: report.lockValid,
    compatibilityValid: report.compatibilityValid,
    smokeValid: report.smokeValid,
    regressionValid: report.regressionValid,
    securityValid: report.securityValid,
    pass,
    governance: report.record
  };
}

// src/system/autostart.ts
import { spawnSync as spawnSync8 } from "node:child_process";
import * as fs57 from "node:fs";
import * as path56 from "node:path";
var TEST_MODE_ENV = "MIYA_AUTOSTART_TEST_MODE";
var DEFAULT_TASK_NAME = "MiyaOpenCodeGatewayAutostart";
function nowIso39() {
  return new Date().toISOString();
}
function stateFile3(projectDir) {
  return path56.join(getMiyaRuntimeDir(projectDir), "autostart.json");
}
function isTestMode() {
  const raw = String(process.env[TEST_MODE_ENV] ?? "").trim().toLowerCase();
  return raw === "1" || raw === "true" || raw === "yes";
}
function readJson2(file3) {
  if (!fs57.existsSync(file3))
    return {};
  try {
    const parsed = JSON.parse(fs57.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed))
      return {};
    return parsed;
  } catch {
    return {};
  }
}
function writeJson3(file3, value) {
  fs57.mkdirSync(path56.dirname(file3), { recursive: true });
  fs57.writeFileSync(file3, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function quotePowerShellLiteral(value) {
  return value.replace(/'/g, "''");
}
function isLegacyAutostartCommand(command) {
  const normalized = command.trim().toLowerCase();
  if (!normalized)
    return true;
  if (normalized.includes("miya-gateway-start")) {
    return true;
  }
  if (/--workspace\s+['"][^'"]*[\\\/]\.opencode[\\\/]miya-src['"]/i.test(command)) {
    return true;
  }
  return /miya-src(?:\\\\|\\|\/)miya-src(?:\\\\|\\|\/)dist(?:\\\\|\\|\/)cli(?:\\\\|\\|\/)gateway-supervisor\.node\.js/i.test(command);
}
function resolveAutostartCommand(projectDir, current) {
  const currentCommand = typeof current === "string" ? current.trim() : "";
  if (!currentCommand || isLegacyAutostartCommand(currentCommand)) {
    return defaultCommand(projectDir);
  }
  return currentCommand;
}
function defaultCommand(projectDir) {
  const resolvedProjectDir = path56.resolve(projectDir);
  let workspaceDir = resolvedProjectDir;
  if (path56.basename(resolvedProjectDir).toLowerCase() === "miya-src") {
    const parent = path56.dirname(resolvedProjectDir);
    if (path56.basename(parent).toLowerCase() === ".opencode") {
      workspaceDir = parent;
    }
  }
  const escapedProjectDir = quotePowerShellLiteral(workspaceDir);
  const baseName = path56.basename(workspaceDir).toLowerCase();
  const candidateSet = new Set;
  candidateSet.add(path56.join(workspaceDir, "dist", "cli", "gateway-supervisor.node.js"));
  if (baseName === "miya-src") {
    candidateSet.add(path56.join(path56.dirname(workspaceDir), "miya-src", "dist", "cli", "gateway-supervisor.node.js"));
  } else {
    candidateSet.add(path56.join(workspaceDir, "miya-src", "dist", "cli", "gateway-supervisor.node.js"));
  }
  const supervisorCandidates = [...candidateSet].map((item) => quotePowerShellLiteral(item));
  const scriptList = supervisorCandidates.map((item) => `'${item}'`).join(", ");
  return `powershell -NoProfile -WindowStyle Hidden -Command "Set-Location -LiteralPath '${escapedProjectDir}'; $miyaScripts = @(${scriptList}); $miyaScript = $miyaScripts | Where-Object { Test-Path -LiteralPath $_ } | Select-Object -First 1; if ($miyaScript) { node $miyaScript --workspace '${escapedProjectDir}' } else { exit 1 }"`;
}
function normalizeState3(projectDir, raw) {
  const enabled = raw?.enabled === true;
  const taskNameRaw = typeof raw?.taskName === "string" ? raw.taskName.trim() : "";
  const commandRaw = typeof raw?.command === "string" ? raw.command : "";
  return {
    enabled,
    taskName: taskNameRaw || DEFAULT_TASK_NAME,
    command: resolveAutostartCommand(projectDir, commandRaw),
    updatedAt: typeof raw?.updatedAt === "string" && raw.updatedAt.trim() ? raw.updatedAt : nowIso39()
  };
}
function readState4(projectDir) {
  return normalizeState3(projectDir, readJson2(stateFile3(projectDir)));
}
function writeState7(projectDir, state) {
  writeJson3(stateFile3(projectDir), state);
}
function runSchtasks(args) {
  const proc = spawnSync8("schtasks", args, {
    windowsHide: true,
    encoding: "utf-8",
    stdio: ["ignore", "pipe", "pipe"],
    timeout: 15000
  });
  return {
    ok: proc.status === 0,
    stdout: String(proc.stdout ?? ""),
    stderr: String(proc.stderr ?? "")
  };
}
function queryInstalled(taskName) {
  const query = runSchtasks(["/Query", "/TN", taskName]);
  return query.ok;
}
function installTask(taskName, command) {
  const result = runSchtasks([
    "/Create",
    "/F",
    "/SC",
    "ONLOGON",
    "/RL",
    "HIGHEST",
    "/TN",
    taskName,
    "/TR",
    command
  ]);
  if (result.ok)
    return { ok: true };
  const reason = result.stderr.trim() || result.stdout.trim() || "autostart_install_failed";
  return { ok: false, reason };
}
function uninstallTask(taskName) {
  const result = runSchtasks(["/Delete", "/F", "/TN", taskName]);
  if (result.ok)
    return { ok: true };
  const text = `${result.stdout}
${result.stderr}`.toLowerCase();
  if (text.includes("cannot find") || text.includes("not found")) {
    return { ok: true };
  }
  const reason = result.stderr.trim() || result.stdout.trim() || "autostart_uninstall_failed";
  return { ok: false, reason };
}
function getAutostartStatus(projectDir) {
  const state = readState4(projectDir);
  const supported = process.platform === "win32";
  if (!supported || isTestMode()) {
    const raw = readJson2(stateFile3(projectDir));
    const installed = raw.installed === true;
    return {
      platform: process.platform,
      supported,
      enabled: state.enabled,
      installed: supported ? installed : false,
      taskName: state.taskName,
      command: state.command,
      updatedAt: state.updatedAt,
      reason: supported ? undefined : "platform_not_supported"
    };
  }
  return {
    platform: process.platform,
    supported,
    enabled: state.enabled,
    installed: queryInstalled(state.taskName),
    taskName: state.taskName,
    command: state.command,
    updatedAt: state.updatedAt
  };
}
function setAutostartEnabled(projectDir, input) {
  const current = readState4(projectDir);
  const next = {
    enabled: input.enabled,
    taskName: typeof input.taskName === "string" && input.taskName.trim() ? input.taskName.trim() : current.taskName || DEFAULT_TASK_NAME,
    command: typeof input.command === "string" && input.command.trim() ? input.command.trim() : resolveAutostartCommand(projectDir, current.command),
    updatedAt: nowIso39()
  };
  if (process.platform !== "win32") {
    writeState7(projectDir, next);
    return {
      platform: process.platform,
      supported: false,
      enabled: next.enabled,
      installed: false,
      taskName: next.taskName,
      command: next.command,
      updatedAt: next.updatedAt,
      reason: "platform_not_supported"
    };
  }
  if (isTestMode()) {
    writeJson3(stateFile3(projectDir), {
      ...next,
      installed: next.enabled
    });
    return {
      platform: process.platform,
      supported: true,
      enabled: next.enabled,
      installed: next.enabled,
      taskName: next.taskName,
      command: next.command,
      updatedAt: next.updatedAt
    };
  }
  if (next.enabled) {
    const installed = installTask(next.taskName, next.command);
    if (!installed.ok) {
      throw new Error(`autostart_enable_failed:${installed.reason ?? "unknown"}`);
    }
  } else {
    const removed = uninstallTask(next.taskName);
    if (!removed.ok) {
      throw new Error(`autostart_disable_failed:${removed.reason ?? "unknown"}`);
    }
  }
  writeState7(projectDir, next);
  return getAutostartStatus(projectDir);
}

// src/utils/logger.ts
import * as fs58 from "node:fs";
import * as os4 from "node:os";
import * as path57 from "node:path";
var logFile = path57.join(os4.tmpdir(), "miya.log");
function sanitizeLogValue(value) {
  if (value instanceof Error) {
    return {
      name: value.name,
      message: value.message,
      stack: value.stack
    };
  }
  if (typeof value === "bigint")
    return value.toString();
  if (typeof value === "symbol")
    return String(value);
  return value;
}
function stringifyLogData(data) {
  if (typeof data === "undefined")
    return "";
  const seen = new WeakSet;
  try {
    return JSON.stringify(data, (_key, value) => {
      const sanitized = sanitizeLogValue(value);
      if (sanitized && typeof sanitized === "object") {
        if (seen.has(sanitized))
          return "[circular]";
        seen.add(sanitized);
      }
      return sanitized;
    });
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    return JSON.stringify({
      logger_error: "log_serialize_failed",
      message
    });
  }
}
function log(message, data) {
  try {
    const timestamp = new Date().toISOString();
    const payload = stringifyLogData(data);
    const logEntry = `[${timestamp}] ${message}${payload ? ` ${payload}` : ""}
`;
    fs58.appendFileSync(logFile, logEntry);
  } catch {}
}

// src/gateway/control-ui.ts
import fs59 from "node:fs";
import path58 from "node:path";

// src/gateway/control-ui-shared.ts
function normalizeControlUiBasePath(basePath) {
  if (!basePath)
    return "";
  let normalized = basePath.trim();
  if (!normalized)
    return "";
  if (!normalized.startsWith("/"))
    normalized = `/${normalized}`;
  if (normalized === "/")
    return "";
  if (normalized.endsWith("/"))
    normalized = normalized.slice(0, -1);
  return normalized;
}

// src/gateway/control-ui.ts
function contentTypeForExt(ext) {
  switch (ext) {
    case ".html":
      return "text/html; charset=utf-8";
    case ".js":
      return "application/javascript; charset=utf-8";
    case ".css":
      return "text/css; charset=utf-8";
    case ".json":
    case ".map":
      return "application/json; charset=utf-8";
    case ".svg":
      return "image/svg+xml";
    case ".png":
      return "image/png";
    case ".jpg":
    case ".jpeg":
      return "image/jpeg";
    case ".gif":
      return "image/gif";
    case ".webp":
      return "image/webp";
    case ".ico":
      return "image/x-icon";
    case ".txt":
      return "text/plain; charset=utf-8";
    default:
      return "application/octet-stream";
  }
}
function securityHeaders(contentType) {
  const headers = {
    "cache-control": "no-cache",
    "x-frame-options": "DENY",
    "content-security-policy": "frame-ancestors 'none'",
    "x-content-type-options": "nosniff"
  };
  if (contentType)
    headers["content-type"] = contentType;
  return headers;
}
function textResponse(status, body) {
  return new Response(body, {
    status,
    headers: securityHeaders("text/plain; charset=utf-8")
  });
}
function isSafeRelativePath(relPath) {
  if (!relPath)
    return false;
  const normalized = path58.posix.normalize(relPath);
  if (normalized.startsWith("../") || normalized === "..")
    return false;
  if (normalized.includes("\x00"))
    return false;
  return true;
}
function resolveRequestedFile(pathname, basePath) {
  if (basePath) {
    if (pathname === basePath)
      return "index.html";
    if (!pathname.startsWith(`${basePath}/`))
      return null;
    pathname = pathname.slice(basePath.length);
  }
  if (!pathname.startsWith("/"))
    return null;
  if (pathname === "/" || pathname === "")
    return "index.html";
  const assetsIndex = pathname.indexOf("/assets/");
  const rel = assetsIndex >= 0 ? pathname.slice(assetsIndex + 1) : pathname.slice(1);
  const requested = rel && !rel.endsWith("/") ? rel : `${rel}index.html`;
  return requested || "index.html";
}
function resolveRootState(projectDir) {
  const envRoot = process.env.MIYA_GATEWAY_UI_ROOT?.trim();
  const candidates = envRoot ? [envRoot] : [
    path58.join(projectDir, "miya-src", "gateway-ui", "dist"),
    path58.join(projectDir, "gateway-ui", "dist"),
    path58.join(projectDir, ".opencode", "miya", "gateway-ui", "dist"),
    path58.join(projectDir, ".opencode", "miya", "gateway-ui")
  ];
  for (const candidate of candidates) {
    const indexPath = path58.join(candidate, "index.html");
    if (fs59.existsSync(indexPath) && fs59.statSync(indexPath).isFile()) {
      return { kind: "resolved", path: candidate };
    }
  }
  if (envRoot)
    return { kind: "invalid", path: envRoot };
  return { kind: "missing" };
}
function createControlUiRequestOptions(projectDir) {
  return {
    basePath: normalizeControlUiBasePath(process.env.MIYA_GATEWAY_UI_BASE_PATH),
    root: resolveRootState(projectDir)
  };
}
function handleControlUiHttpRequest(request, opts) {
  if (request.method !== "GET" && request.method !== "HEAD")
    return null;
  const url3 = new URL(request.url);
  const pathname = url3.pathname;
  const basePath = normalizeControlUiBasePath(opts?.basePath);
  const requestedFile = resolveRequestedFile(pathname, basePath);
  if (!requestedFile)
    return null;
  if (!isSafeRelativePath(requestedFile)) {
    return textResponse(404, "Not Found");
  }
  const root = opts?.root;
  if (root?.kind === "invalid") {
    return textResponse(503, `Control UI assets not found at ${root.path}. Set MIYA_GATEWAY_UI_ROOT to a built UI directory.`);
  }
  if (root?.kind === "missing") {
    return textResponse(503, "Control UI assets not found. Set MIYA_GATEWAY_UI_ROOT to a built UI directory.");
  }
  if (!root || root.kind !== "resolved")
    return null;
  const filePath14 = path58.join(root.path, requestedFile);
  if (!filePath14.startsWith(root.path)) {
    return textResponse(404, "Not Found");
  }
  const indexPath = path58.join(root.path, "index.html");
  const resolvedPath = fs59.existsSync(filePath14) && fs59.statSync(filePath14).isFile() ? filePath14 : indexPath;
  if (!fs59.existsSync(resolvedPath) || !fs59.statSync(resolvedPath).isFile()) {
    return textResponse(404, "Not Found");
  }
  const headers = securityHeaders(contentTypeForExt(path58.extname(resolvedPath).toLowerCase()));
  if (request.method === "HEAD") {
    return new Response(null, { status: 200, headers });
  }
  return new Response(fs59.readFileSync(resolvedPath), {
    status: 200,
    headers
  });
}

// src/gateway/cortex-arbiter.ts
function clamp11(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeReasonList(input) {
  const seen = new Set;
  const out = [];
  for (const reason of input) {
    const normalized = reason.trim();
    if (!normalized || seen.has(normalized))
      continue;
    seen.add(normalized);
    out.push(normalized);
  }
  return out.slice(0, 10);
}
function detectUserExplicitIntent(text) {
  const normalized = String(text ?? "").trim().toLowerCase();
  if (!normalized)
    return { preference: "none", confidence: 0, why: [] };
  const why = [];
  let preference = "none";
  let confidence = 0;
  if (/(|||stop work|hold off)/i.test(normalized)) {
    preference = "defer";
    confidence = 0.95;
    why.push("explicit_defer");
  } else if (/(|.*.*.*|work and chat|both)/i.test(normalized)) {
    preference = "mixed";
    confidence = 0.88;
    why.push("explicit_mixed");
  } else if (/(|||chat only|talk only)/i.test(normalized)) {
    preference = "chat";
    confidence = 0.85;
    why.push("explicit_chat");
  } else if (/(|||start work|do it now|implement)/i.test(normalized)) {
    preference = "work";
    confidence = 0.82;
    why.push("explicit_work");
  }
  return {
    preference,
    confidence: Number(clamp11(confidence, 0, 1).toFixed(3)),
    why
  };
}
function buildLeftBrainActionPlan(input) {
  const risk = input.routePlan.stage === "high" ? "high" : input.routePlan.stage === "medium" ? "medium" : "low";
  const executeWork = input.routePlan.executionMode !== "human_gate" && (input.modeKernel.mode === "work" || input.modeKernel.mode === "mixed" || input.routePlan.complexity !== "low");
  const why = [
    `route_stage=${input.routePlan.stage}`,
    `route_complexity=${input.routePlan.complexity}`,
    ...input.routePlan.reasons.slice(0, 4)
  ];
  return {
    objective: `intent=${input.routePlan.intent}`,
    executeWork,
    risk,
    requiredGates: ["policy_domain_gate", "gateway_execution_gate"],
    why: normalizeReasonList(why)
  };
}
function buildRightBrainResponsePlan(input) {
  const normalized = String(input.text ?? "").toLowerCase();
  const suggestions = [];
  if (input.modeKernel.mode === "chat") {
    suggestions.push("");
    suggestions.push("");
  } else if (input.modeKernel.mode === "mixed") {
    suggestions.push("");
    suggestions.push("");
  } else {
    suggestions.push("");
  }
  const highRiskToolSuggestion = /(|||mass send|delete all|password|secret)/i.test(normalized);
  const tone = input.modeKernel.mode === "work" ? "neutral" : input.modeKernel.mode === "mixed" ? "warm" : "supportive";
  return {
    tone,
    suggestions,
    highRiskToolSuggestion,
    why: [
      `mode=${input.modeKernel.mode}`,
      `tone=${tone}`,
      highRiskToolSuggestion ? "high_risk_tool_suggestion_detected" : "tool_suggestion_safe"
    ]
  };
}
function arbitrateCortex(input) {
  const trail = [
    "Safety",
    "User explicit",
    "Work objective",
    "Emotional optimization"
  ];
  const reasons = [];
  let mode = input.modeKernel.mode;
  let executeWork = input.leftBrain.executeWork;
  if (input.modeKernel.confidence < DEFAULT_MODE_SAFE_WORK_CONFIDENCE) {
    mode = "work";
    reasons.push(`mode_kernel_low_confidence_safe_work_fallback:${Number(input.modeKernel.confidence).toFixed(3)}`);
  }
  if (input.safety.blocked) {
    executeWork = false;
    reasons.push(`safety_blocked:${input.safety.reason ?? "unspecified"}`);
  }
  if (!input.safety.blocked && input.userExplicit.preference !== "none" && input.userExplicit.confidence >= 0.55) {
    if (input.userExplicit.preference === "defer") {
      executeWork = false;
      reasons.push("user_explicit_defer");
    } else {
      mode = input.userExplicit.preference;
      reasons.push(`user_explicit_mode=${mode}`);
    }
  }
  if (!input.safety.blocked && executeWork && mode === "chat") {
    mode = "mixed";
    reasons.push("work_objective_promoted_to_mixed");
  }
  if (mode === "work" && input.rightBrain.tone !== "neutral" && !input.safety.blocked) {
    reasons.push("emotional_optimization_kept_secondary");
  }
  const rightBrainSuppressed = input.rightBrain.highRiskToolSuggestion;
  if (rightBrainSuppressed) {
    reasons.push("right_brain_high_risk_suggestion_suppressed");
  }
  return {
    mode,
    executeWork,
    rightBrainSuppressed,
    responseHints: rightBrainSuppressed ? [] : input.rightBrain.suggestions.slice(0, 3),
    priorityTrail: trail,
    why: normalizeReasonList([
      ...reasons,
      ...input.modeKernel.why.slice(0, 3),
      ...input.leftBrain.why.slice(0, 3),
      ...input.rightBrain.why.slice(0, 2),
      ...input.userExplicit.why.slice(0, 2)
    ]),
    executionTrack: "left_brain_single_track"
  };
}

// src/gateway/kernel/action-ledger.ts
import { createHash as createHash18, createHmac, randomUUID as randomUUID23 } from "node:crypto";
import * as fs60 from "node:fs";
import * as path59 from "node:path";
function ledgerFile(projectDir) {
  return path59.join(getMiyaRuntimeDir(projectDir), "audit", "tool-action-ledger.jsonl");
}
function nowIso40() {
  return new Date().toISOString();
}
function digest(input) {
  return createHash18("sha256").update(input).digest("hex");
}
function summarizeParams(params) {
  const keys = Object.keys(params).sort();
  if (keys.length === 0)
    return "(no_params)";
  const snippets = [];
  for (const key of keys.slice(0, 16)) {
    const value = params[key];
    if (typeof value === "string") {
      snippets.push(`${key}=${value.slice(0, 120)}`);
      continue;
    }
    if (typeof value === "number" || typeof value === "boolean") {
      snippets.push(`${key}=${String(value)}`);
      continue;
    }
    if (Array.isArray(value)) {
      snippets.push(`${key}=[len:${value.length}]`);
      continue;
    }
    if (value && typeof value === "object") {
      snippets.push(`${key}={object}`);
    }
  }
  return snippets.join(" | ");
}
function summarizeResult(result) {
  if (result === null || result === undefined)
    return "null";
  if (typeof result === "string")
    return result.slice(0, 240);
  if (typeof result === "number" || typeof result === "boolean")
    return String(result);
  try {
    return JSON.stringify(result).slice(0, 400);
  } catch {
    return String(result).slice(0, 400);
  }
}
function replayToken(eventID, method, inputHash) {
  const secret = process.env.MIYA_ACTION_LEDGER_SECRET?.trim() || "miya-action-ledger-v1";
  return createHmac("sha256", secret).update(`${eventID}:${method}:${inputHash}`).digest("hex");
}
function safeReadRows(file3) {
  if (!fs60.existsSync(file3))
    return [];
  const rows = [];
  const lines = fs60.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean);
  for (const line of lines) {
    try {
      rows.push(JSON.parse(line));
    } catch {}
  }
  return rows;
}
function deriveApprovalBasis(params) {
  const policyHash = typeof params.policyHash === "string" && params.policyHash.trim() ? params.policyHash.trim() : undefined;
  const approvalID = typeof params.approvalID === "string" && params.approvalID.trim() ? params.approvalID.trim() : undefined;
  if (policyHash && approvalID) {
    return `policy_hash+approval_id:${policyHash.slice(0, 16)}:${approvalID.slice(0, 24)}`;
  }
  if (policyHash)
    return `policy_hash:${policyHash.slice(0, 16)}`;
  if (approvalID)
    return `approval_id:${approvalID.slice(0, 24)}`;
  return "implicit_or_not_required";
}
function appendToolActionLedgerEvent(projectDir, input) {
  const file3 = ledgerFile(projectDir);
  fs60.mkdirSync(path59.dirname(file3), { recursive: true });
  const rows = safeReadRows(file3);
  const previousHash = rows[rows.length - 1]?.entryHash ?? "GENESIS";
  const inputSummary = summarizeParams(input.params);
  const inputHash = digest(inputSummary);
  const resultText = input.status === "completed" ? summarizeResult(input.result) : summarizeResult(input.error);
  const resultHash = digest(resultText);
  const id = `tae_${randomUUID23()}`;
  const approvalBasis = input.approvalBasis?.trim() || deriveApprovalBasis(input.params);
  const at = nowIso40();
  const entryHash = digest([
    id,
    at,
    input.method,
    input.clientID,
    input.role,
    input.status,
    inputHash,
    approvalBasis,
    resultHash,
    previousHash
  ].join("|"));
  const event = {
    id,
    at,
    method: input.method,
    clientID: input.clientID,
    role: input.role,
    status: input.status,
    inputSummary,
    inputHash,
    approvalBasis,
    resultHash,
    replayToken: replayToken(id, input.method, inputHash),
    previousHash,
    entryHash
  };
  fs60.appendFileSync(file3, `${JSON.stringify(event)}
`, "utf-8");
  return event;
}
function listToolActionLedgerEvents(projectDir, limit = 100) {
  const rows = safeReadRows(ledgerFile(projectDir));
  return rows.slice(-Math.max(1, Math.min(1000, limit))).reverse();
}

// src/gateway/methods/channels.ts
function registerDomainMethods(methods, domain3, prefixes, register) {
  const before = new Set(methods.list());
  register(methods);
  const added = methods.list().filter((method) => !before.has(method));
  if (added.length === 0) {
    throw new Error(`gateway_domain_registration_empty:${domain3}`);
  }
  const invalid = added.filter((method) => !prefixes.some((prefix) => method.startsWith(prefix)));
  if (invalid.length > 0) {
    throw new Error(`gateway_domain_registration_invalid:${domain3}:${invalid.join(",")}`);
  }
}
function registerGatewayChannelMethods(methods, register) {
  registerDomainMethods(methods, "channels", ["channels."], register);
}

// src/gateway/methods/companion.ts
function registerDomainMethods2(methods, domain3, prefixes, register) {
  const before = new Set(methods.list());
  register(methods);
  const added = methods.list().filter((method) => !before.has(method));
  if (added.length === 0) {
    throw new Error(`gateway_domain_registration_empty:${domain3}`);
  }
  const invalid = added.filter((method) => !prefixes.some((prefix) => method.startsWith(prefix)));
  if (invalid.length > 0) {
    throw new Error(`gateway_domain_registration_invalid:${domain3}:${invalid.join(",")}`);
  }
}
function registerGatewayCompanionMethods(methods, register) {
  registerDomainMethods2(methods, "companion", ["companion."], register);
}

// src/gateway/mode-policy.ts
var MODE_POLICY_FREEZE_V1 = {
  version: "2026-02-16.mode-policy.v1",
  unresolvedFallbackMode: "work",
  workExecutionPersona: "zero",
  workExecutionAddressing: "strip_all",
  notes: [
    "Uncertain mode classification must fallback to work.",
    "Work execution track must remain zero-persona.",
    "Work context must strip affectionate addressing and roleplay tokens."
  ]
};
var WORK_AFFECTIONATE_PREFIX = /^(?:\s*)(?:(?:)?||||dear|honey|sweetie|darling)[,!:\s-]*/i;
function stripWorkAffectionatePrefix(text) {
  const next = text.replace(WORK_AFFECTIONATE_PREFIX, "");
  return {
    text: next,
    stripped: next !== text
  };
}

// src/gateway/methods/core.ts
function parseText(input) {
  return typeof input === "string" ? input.trim() : "";
}
function registerGatewayCoreMethods(methods, deps) {
  methods.register("gateway.status.get", async () => deps.buildSnapshot());
  methods.register("autoflow.status.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const sessions = listAutoflowSessions(deps.projectDir, Math.max(1, Math.min(200, limit)));
    const persistentConfig = readAutoflowPersistentConfig(deps.projectDir);
    const persistentSessions = getAutoflowPersistentRuntimeSnapshot(deps.projectDir, Math.max(1, Math.min(200, limit)));
    return {
      active: sessions.filter((item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing").length,
      sessions,
      persistent: {
        ...persistentConfig,
        sessions: persistentSessions
      }
    };
  });
  methods.register("routing.stats.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 200;
    const mode = readRouterModeConfig(deps.projectDir);
    return {
      mode,
      modePolicy: MODE_POLICY_FREEZE_V1,
      cost: getRouteCostSummary(deps.projectDir, Math.max(1, Math.min(1000, limit))),
      recent: listRouteCostRecords(deps.projectDir, Math.max(1, Math.min(100, limit))),
      modeObservability: readModeObservability(deps.projectDir)
    };
  });
  methods.register("mode.policy.get", async () => ({
    modePolicy: MODE_POLICY_FREEZE_V1
  }));
  methods.register("learning.drafts.stats", async () => ({
    stats: getLearningStats(deps.projectDir)
  }));
  methods.register("learning.drafts.list", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const statusRaw = parseText(params.status);
    const status = statusRaw === "draft" || statusRaw === "recommended" || statusRaw === "accepted" || statusRaw === "rejected" ? statusRaw : undefined;
    return {
      drafts: listSkillDrafts(deps.projectDir, {
        limit: Math.max(1, Math.min(200, limit)),
        status
      })
    };
  });
  methods.register("learning.drafts.recommend", async (params) => {
    const query = parseText(params.query);
    if (!query)
      throw new Error("query_required");
    const threshold = typeof params.threshold === "number" ? Number(params.threshold) : undefined;
    const limit = typeof params.limit === "number" ? Number(params.limit) : undefined;
    return buildLearningInjection(deps.projectDir, query, {
      threshold,
      limit
    });
  });
  methods.register("gateway.shutdown", async () => {
    const state = deps.buildGatewayState();
    deps.scheduleGatewayStop();
    return { ok: true, state };
  });
  methods.register("doctor.run", async () => deps.buildSnapshot().doctor);
  methods.register("gateway.backpressure.stats", async () => ({
    ...deps.runtime.methods.stats(),
    updatedAt: deps.now()
  }));
  methods.register("audit.ledger.list", async (params) => {
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 50;
    const limit = Math.max(1, Math.min(500, Math.floor(limitRaw)));
    return {
      items: deps.listActionLedger(limit)
    };
  });
  methods.register("daemon.backpressure.stats", async () => ({
    ...getLauncherBackpressureStats(deps.projectDir),
    updatedAt: deps.now()
  }));
  methods.register("daemon.psyche.signals.get", async () => {
    const daemon = getMiyaClient(deps.projectDir);
    try {
      const status = await daemon.psycheSignalsGet();
      return {
        ok: true,
        status,
        updatedAt: deps.now()
      };
    } catch (error92) {
      return {
        ok: false,
        error: error92 instanceof Error ? error92.message : String(error92),
        updatedAt: deps.now()
      };
    }
  });
  methods.register("gateway.pressure.run", async (params) => {
    const concurrencyRaw = typeof params.concurrency === "number" ? Number(params.concurrency) : 10;
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 1;
    const timeoutMs = typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : 20000;
    const concurrency = Math.max(1, Math.min(100, Math.floor(concurrencyRaw)));
    const rounds = Math.max(1, Math.min(20, Math.floor(roundsRaw)));
    const daemon = getMiyaClient(deps.projectDir);
    const startedAtMs = Date.now();
    let success3 = 0;
    let failed = 0;
    const errors5 = [];
    for (let round = 0;round < rounds; round += 1) {
      const tasks = Array.from({ length: concurrency }, async (_, index) => {
        try {
          await daemon.runIsolatedProcess({
            kind: "generic",
            command: process.platform === "win32" ? "cmd" : "sh",
            args: process.platform === "win32" ? ["/c", "echo", `miya-pressure-${round}-${index}`] : ["-lc", `echo miya-pressure-${round}-${index}`],
            timeoutMs: Math.max(1000, timeoutMs)
          });
          success3 += 1;
        } catch (error92) {
          failed += 1;
          errors5.push(error92 instanceof Error ? error92.message : String(error92));
        }
      });
      await Promise.all(tasks);
    }
    return {
      success: success3,
      failed,
      elapsedMs: Date.now() - startedAtMs,
      gateway: deps.runtime.methods.stats(),
      daemon: getLauncherBackpressureStats(deps.projectDir),
      errors: errors5.slice(0, 20)
    };
  });
  methods.register("gateway.startup.probe.run", async (params) => {
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 20;
    const rounds = Math.max(1, Math.min(100, Math.floor(roundsRaw)));
    const waitMsRaw = typeof params.waitMs === "number" ? Number(params.waitMs) : 250;
    const waitMs = Math.max(50, Math.min(5000, Math.floor(waitMsRaw)));
    const gatewayState = deps.buildGatewayState();
    const urlFromRuntime = gatewayState && typeof gatewayState.url === "string" && gatewayState.url.trim().length > 0 ? gatewayState.url : undefined;
    const probeUrl = urlFromRuntime ?? deps.ensureGatewayRunning().url;
    let healthy = 0;
    let daemonReady = 0;
    const samples = [];
    for (let index = 0;index < rounds; index += 1) {
      const gatewayAlive = await deps.probeGatewayAlive(probeUrl, 1200);
      const daemonSnapshot = getLauncherDaemonSnapshot(deps.projectDir);
      const daemonConnected = Boolean(daemonSnapshot.connected);
      if (gatewayAlive)
        healthy += 1;
      if (daemonConnected)
        daemonReady += 1;
      samples.push({
        index: index + 1,
        gatewayAlive,
        daemonConnected,
        daemonStatus: daemonSnapshot.statusText
      });
      if (index < rounds - 1) {
        await new Promise((resolve7) => setTimeout(resolve7, waitMs));
      }
    }
    return {
      rounds,
      gatewayHealthy: healthy,
      daemonConnected: daemonReady,
      gatewaySuccessRate: Number((healthy / rounds * 100).toFixed(2)),
      daemonSuccessRate: Number((daemonReady / rounds * 100).toFixed(2)),
      samples
    };
  });
}

// src/gateway/methods/memory.ts
function registerDomainMethods3(methods, domain3, prefixes, register) {
  const before = new Set(methods.list());
  register(methods);
  const added = methods.list().filter((method) => !before.has(method));
  if (added.length === 0) {
    throw new Error(`gateway_domain_registration_empty:${domain3}`);
  }
  const invalid = added.filter((method) => !prefixes.some((prefix) => method.startsWith(prefix)));
  if (invalid.length > 0) {
    throw new Error(`gateway_domain_registration_invalid:${domain3}:${invalid.join(",")}`);
  }
}
function registerGatewayMemoryMethods(methods, register) {
  registerDomainMethods3(methods, "memory", ["companion.memory.", "companion.learning.", "miya.memory."], register);
}

// src/gateway/methods/nodes.ts
function registerDomainMethods4(methods, domain3, prefixes, register) {
  const before = new Set(methods.list());
  register(methods);
  const added = methods.list().filter((method) => !before.has(method));
  if (added.length === 0) {
    throw new Error(`gateway_domain_registration_empty:${domain3}`);
  }
  const invalid = added.filter((method) => !prefixes.some((prefix) => method.startsWith(prefix)));
  if (invalid.length > 0) {
    throw new Error(`gateway_domain_registration_invalid:${domain3}:${invalid.join(",")}`);
  }
}
function registerGatewayNodeMethods(methods, register) {
  registerDomainMethods4(methods, "nodes", [
    "nodes.",
    "devices.",
    "skills.",
    "openclaw.",
    "ecosystem.",
    "miya.sync.",
    "mcp.",
    "media.",
    "voice.",
    "canvas."
  ], register);
}

// src/gateway/methods/security.ts
function registerDomainMethods5(methods, domain3, prefixes, register) {
  const before = new Set(methods.list());
  register(methods);
  const added = methods.list().filter((method) => !before.has(method));
  if (added.length === 0) {
    throw new Error(`gateway_domain_registration_empty:${domain3}`);
  }
  const invalid = added.filter((method) => !prefixes.some((prefix) => method.startsWith(prefix)));
  if (invalid.length > 0) {
    throw new Error(`gateway_domain_registration_invalid:${domain3}:${invalid.join(",")}`);
  }
}
function registerGatewaySecurityMethods(methods, register) {
  registerDomainMethods5(methods, "security", [
    "security.",
    "policy.",
    "daemon.",
    "killswitch.",
    "intervention.",
    "trust.",
    "psyche.",
    "learning.",
    "insight."
  ], register);
}

// src/gateway/sanitizer.ts
var WORK_INSTRUCTION = "You are a technical coding assistant. No small talk.";
var CHAT_INSTRUCTION = "You are Miya, a girlfriend assistant. Be gentle and cute.";
var MIXED_INSTRUCTION = "You are Miya. Execute work rigorously and respond with concise emotional warmth in the same turn.";
var WORK_HINTS = [
  /```/,
  /\b(stack trace|traceback|exception|TypeError|ReferenceError)\b/i,
  /\b(function|class|import|npm|pnpm|bun|pip|pytest|docker|sql|api)\b/i,
  /\b(\.ts|\.tsx|\.js|\.py|\.md|package\.json|tsconfig)\b/i,
  /(|||||||||)/
];
var CHAT_HINTS = [
  /(||||||||||)/,
  /\b(love|dear|sweet|cute|hug)\b/i
];
var WORK_BLOCKED_WORDS = /((?:)?|||||||||dear|honey|sweetie|darling)/gi;
var CODE_CONTEXT_LINE = new RegExp([
  "^\\s*```",
  "^\\s*(src|apps?|packages?)[/\\\\]",
  "^\\s*[A-Za-z]:[/\\\\]",
  "^\\s*at\\s+\\S+\\s*\\(",
  '^\\s*File\\s+".*",\\s+line\\s+\\d+',
  "\\.(ts|tsx|js|jsx|py|java|go|rs|cpp|c|h|json|yaml|yml|toml|md)\\b",
  "\\b(package\\.json|tsconfig|requirements\\.txt|pnpm-lock|bun\\.lock)\\b"
].join("|"), "i");
function normalizeWhitespace(text) {
  return text.replace(/\r\n/g, `
`).trim();
}
function inferContextMode(text) {
  const trimmed = normalizeWhitespace(text);
  if (!trimmed)
    return MODE_POLICY_FREEZE_V1.unresolvedFallbackMode;
  let workScore = 0;
  let chatScore = 0;
  for (const pattern of WORK_HINTS) {
    if (pattern.test(trimmed))
      workScore += 1;
  }
  for (const pattern of CHAT_HINTS) {
    if (pattern.test(trimmed))
      chatScore += 1;
  }
  if (workScore === chatScore) {
    return MODE_POLICY_FREEZE_V1.unresolvedFallbackMode;
  }
  return workScore > chatScore ? "work" : "chat";
}
function sanitizeWorkContext(text) {
  const removed = [];
  let body = normalizeWhitespace(text);
  const strippedPrefix = stripWorkAffectionatePrefix(body);
  body = strippedPrefix.text;
  if (strippedPrefix.stripped) {
    removed.push("affectionate_prefix");
  }
  if (WORK_BLOCKED_WORDS.test(body)) {
    removed.push("persona_words");
    body = body.replace(WORK_BLOCKED_WORDS, "");
  }
  body = body.replace(/[ \t]{2,}/g, " ").replace(/\n{3,}/g, `

`).trim();
  return {
    text: ["[Context Mode: WORK]", WORK_INSTRUCTION, body].filter(Boolean).join(`
`),
    removed
  };
}
function sanitizeChatContext(text) {
  const removed = [];
  const lines = normalizeWhitespace(text).split(`
`);
  const kept = [];
  for (const line of lines) {
    if (CODE_CONTEXT_LINE.test(line)) {
      removed.push("code_context_line");
      continue;
    }
    kept.push(line);
  }
  const body = kept.join(`
`).replace(/\n{3,}/g, `

`).trim();
  return {
    text: ["[Context Mode: CHAT]", CHAT_INSTRUCTION, body].filter(Boolean).join(`
`),
    removed
  };
}
function sanitizeGatewayContext(input) {
  const mode = input.modeHint ?? inferContextMode(input.text);
  if (mode === "chat") {
    const sanitized2 = sanitizeChatContext(input.text);
    return {
      mode,
      payload: sanitized2.text,
      removedSignals: sanitized2.removed
    };
  }
  if (mode === "mixed") {
    const work = sanitizeWorkContext(input.text);
    return {
      mode,
      payload: ["[Context Mode: MIXED]", MIXED_INSTRUCTION, work.text].filter(Boolean).join(`
`),
      removedSignals: [...work.removed]
    };
  }
  const sanitized = sanitizeWorkContext(input.text);
  return {
    mode,
    payload: sanitized.text,
    removedSignals: sanitized.removed
  };
}

// src/gateway/mode-kernel.ts
var WORK_HINT = [
  /(||||||||||debug|fix|error|build|run|test|deploy)/i,
  /```[\s\S]*```/,
  /\b(src|package\.json|tsconfig|traceback|stack trace|TypeError|ReferenceError)\b/i
];
var CHAT_HINT = [
  /(|||||||||)/,
  /\b(love|hug|dear|chat|lonely|comfort)\b/i
];
function clamp12(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isWorkHint(text) {
  return WORK_HINT.some((pattern) => pattern.test(text));
}
function isChatHint(text) {
  return CHAT_HINT.some((pattern) => pattern.test(text));
}
function normalizeReasonList2(input) {
  const seen = new Set;
  const out = [];
  for (const reason of input) {
    const normalized = reason.trim();
    if (!normalized || seen.has(normalized))
      continue;
    seen.add(normalized);
    out.push(normalized);
  }
  return out.slice(0, 10);
}
function inferSignalMode(text) {
  const work = isWorkHint(text);
  const chat = isChatHint(text);
  if (work && chat)
    return "mixed";
  return work ? "work" : chat ? "chat" : "work";
}
function evaluateModeKernel(input) {
  const text = String(input.text ?? "").trim();
  const normalized = text.toLowerCase();
  const reasons = [];
  let workScore = 0;
  let chatScore = 0;
  let explicitMixed = false;
  const sanitizerMode = input.sanitizerModeHint && input.sanitizerModeHint !== "mixed" ? input.sanitizerModeHint : inferContextMode(text);
  if (sanitizerMode === "work") {
    workScore += 2;
    reasons.push("sanitizer=work");
  } else {
    chatScore += 2;
    reasons.push("sanitizer=chat");
  }
  const signalMode = inferSignalMode(text);
  if (signalMode === "work") {
    workScore += 1.3;
    reasons.push("text_signal=work");
  } else if (signalMode === "chat") {
    chatScore += 1.3;
    reasons.push("text_signal=chat");
  } else {
    workScore += 0.9;
    chatScore += 0.9;
    reasons.push("text_signal=mixed");
  }
  const complexity = input.routeComplexity;
  if (complexity) {
    if (complexity.complexity === "high") {
      workScore += 1.4;
      reasons.push("route_complexity=high");
    } else if (complexity.complexity === "medium") {
      workScore += 0.8;
      reasons.push("route_complexity=medium");
    } else {
      reasons.push("route_complexity=low");
    }
  }
  if (input.psycheSignals) {
    const sentinel = inferSentinelState(input.psycheSignals);
    if (sentinel.state === "FOCUS") {
      workScore += 1.1;
      reasons.push("psyche=focus");
    } else if (sentinel.state === "CONSUME" || sentinel.state === "AWAY") {
      chatScore += 0.9;
      reasons.push(`psyche=${sentinel.state.toLowerCase()}`);
    } else if (sentinel.state === "PLAY") {
      chatScore += 0.7;
      reasons.push("psyche=play");
    } else {
      workScore += 0.5;
      reasons.push("psyche=unknown_safe_work");
    }
  }
  const session = input.sessionState;
  if (session) {
    if (session.activation === "queued" || session.awaitingConfirmation) {
      workScore += 0.8;
      reasons.push("session=pending_workflow");
    }
    if (session.reply === "manual" || session.activation === "muted") {
      chatScore += 0.2;
      reasons.push("session=manual_reply_bias");
    }
    if ((session.queueLength ?? 0) > 0) {
      workScore += 0.4;
      reasons.push("session=queue_backlog");
    }
  }
  if (/(||||chat only|talk only)/i.test(normalized)) {
    chatScore += 1;
    reasons.push("explicit_chat_preference");
  }
  if (/(|||start work|do it now)/i.test(normalized)) {
    workScore += 1;
    reasons.push("explicit_work_preference");
  }
  if (/(|.*.*.*|work and chat)/i.test(normalized)) {
    explicitMixed = true;
    workScore += 0.8;
    chatScore += 0.8;
    reasons.push("explicit_mixed_preference");
  }
  const mixedScore = Math.min(workScore, chatScore) + (workScore >= 1 && chatScore >= 1 ? 0.75 : 0) + (signalMode === "mixed" ? 0.55 : 0);
  const primary = Math.max(workScore, chatScore, mixedScore);
  const ranked = [
    ["work", workScore],
    ["chat", chatScore],
    ["mixed", mixedScore]
  ];
  ranked.sort((a, b) => b[1] - a[1]);
  const second = ranked[1]?.[1] ?? 0;
  const margin = primary - second;
  const signalDensity = normalizeReasonList2(reasons).length;
  const confidence = clamp12(0.45 + clamp12(margin / Math.max(primary, 1), 0, 1) * 0.4 + Math.min(0.15, signalDensity * 0.015), 0.35, 0.99);
  let mode;
  if (explicitMixed && workScore >= 1 && chatScore >= 1) {
    mode = "mixed";
  } else if (mixedScore >= workScore - 0.15 && mixedScore >= chatScore - 0.15 && workScore >= 1 && chatScore >= 1) {
    mode = "mixed";
  } else {
    mode = workScore >= chatScore ? "work" : "chat";
  }
  if (input.lastMode && margin <= 0.08) {
    mode = input.lastMode;
    reasons.push("mode_hysteresis");
  }
  return {
    mode,
    confidence: Number(confidence.toFixed(3)),
    why: normalizeReasonList2(reasons),
    scores: {
      work: Number(workScore.toFixed(3)),
      chat: Number(chatScore.toFixed(3)),
      mixed: Number(mixedScore.toFixed(3))
    }
  };
}

// src/gateway/negotiation-budget.ts
function nowIso41() {
  return new Date().toISOString();
}
function sanitizeBudget(input) {
  const autoRetry = Number.isFinite(input.autoRetry) ? Math.max(0, Math.floor(input.autoRetry)) : 0;
  const humanEdit = Number.isFinite(input.humanEdit) ? Math.max(0, Math.floor(input.humanEdit)) : 0;
  return { autoRetry, humanEdit };
}
function applyNegotiationBudget(store, input) {
  const budget = sanitizeBudget(input.budget);
  const fixability = input.fixability;
  const existing = store.get(input.key);
  const state = existing ? {
    ...existing,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    updatedAt: nowIso41()
  } : {
    key: input.key,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    autoUsed: 0,
    humanUsed: 0,
    updatedAt: nowIso41()
  };
  if (!input.attemptType) {
    store.set(input.key, state);
    return { allowed: true, state };
  }
  if (state.fixability === "impossible") {
    store.set(input.key, state);
    return { allowed: false, reason: "fixability_impossible", state };
  }
  if (input.attemptType === "auto") {
    if (state.autoUsed >= state.budget.autoRetry) {
      store.set(input.key, state);
      return { allowed: false, reason: "auto_retry_exhausted", state };
    }
    state.autoUsed += 1;
  } else {
    if (state.humanUsed >= state.budget.humanEdit) {
      store.set(input.key, state);
      return { allowed: false, reason: "human_edit_exhausted", state };
    }
    state.humanUsed += 1;
  }
  state.updatedAt = nowIso41();
  store.set(input.key, state);
  return { allowed: true, state };
}

// src/gateway/protocol.ts
var GATEWAY_PROTOCOL_VERSION = "1.1";
var LEGACY_GATEWAY_PROTOCOL_VERSION = "1.0";
var SUPPORTED_GATEWAY_PROTOCOL_VERSIONS = [
  LEGACY_GATEWAY_PROTOCOL_VERSION,
  GATEWAY_PROTOCOL_VERSION
];
var JsonValue2 = exports_external2.lazy(() => exports_external2.union([
  exports_external2.string(),
  exports_external2.number(),
  exports_external2.boolean(),
  exports_external2.null(),
  exports_external2.array(JsonValue2),
  exports_external2.record(exports_external2.string(), JsonValue2)
]));
var JsonObject2 = exports_external2.record(exports_external2.string(), JsonValue2);
var PlanBundleAuditEventSchema = exports_external2.object({
  id: exports_external2.string().min(1),
  at: exports_external2.string().min(1),
  stage: exports_external2.enum([
    "plan",
    "approval",
    "execution",
    "rollback",
    "audit",
    "finalize"
  ]),
  action: exports_external2.string().min(1),
  inputSummary: exports_external2.string().min(1),
  inputHash: exports_external2.string().min(16),
  approvalBasis: exports_external2.string().min(1),
  resultHash: exports_external2.string().min(16),
  replayToken: exports_external2.string().min(16)
});
var PlanBundleApprovalSchema = exports_external2.object({
  required: exports_external2.boolean(),
  approved: exports_external2.boolean(),
  approver: exports_external2.string().optional(),
  reason: exports_external2.string().optional(),
  policyHash: exports_external2.string().optional(),
  requestedAt: exports_external2.string().optional(),
  approvedAt: exports_external2.string().optional()
});
var PlanBundleRollbackSchema = exports_external2.object({
  command: exports_external2.string().optional(),
  attempted: exports_external2.boolean(),
  ok: exports_external2.boolean().optional(),
  exitCode: exports_external2.number().int().optional(),
  result: JsonObject2.optional(),
  reason: exports_external2.string().optional()
});
var PlanBundleSchema = exports_external2.object({
  bundleId: exports_external2.string().min(1),
  id: exports_external2.string().min(1),
  version: exports_external2.literal("1.0"),
  goal: exports_external2.string().min(1),
  mode: exports_external2.enum(["work", "chat", "mixed", "subagent"]),
  riskTier: exports_external2.enum(["LIGHT", "STANDARD", "THOROUGH"]),
  lifecycleState: exports_external2.enum([
    "draft",
    "proposed",
    "approved",
    "executing",
    "verifying",
    "done",
    "failed",
    "postmortem"
  ]),
  budget: exports_external2.object({
    timeMs: exports_external2.number().int().nonnegative(),
    costUsd: exports_external2.number().nonnegative(),
    retries: exports_external2.number().int().nonnegative()
  }),
  capabilitiesNeeded: exports_external2.array(exports_external2.string().min(1)),
  steps: exports_external2.array(exports_external2.object({
    id: exports_external2.string().min(1),
    intent: exports_external2.string().min(1),
    tools: exports_external2.array(exports_external2.string().min(1)),
    expectedArtifacts: exports_external2.array(exports_external2.string().min(1)),
    rollback: exports_external2.string().min(1),
    done: exports_external2.boolean(),
    command: exports_external2.string().optional()
  })),
  approvalPolicy: exports_external2.object({
    required: exports_external2.boolean(),
    mode: exports_external2.enum(["manual", "auto"])
  }),
  verificationPlan: exports_external2.object({
    command: exports_external2.string().optional(),
    checks: exports_external2.array(exports_external2.string().min(1))
  }),
  policyHash: exports_external2.string().min(16),
  createdAt: exports_external2.string().min(1),
  updatedAt: exports_external2.string().min(1),
  status: exports_external2.enum([
    "draft",
    "pending_approval",
    "approved",
    "running",
    "completed",
    "failed",
    "rolled_back"
  ]),
  plan: exports_external2.object({
    goal: exports_external2.string().min(1),
    createdAt: exports_external2.string().min(1),
    steps: exports_external2.array(exports_external2.object({
      id: exports_external2.string().min(1),
      title: exports_external2.string().min(1),
      kind: exports_external2.enum(["analysis", "execution", "verification"]),
      command: exports_external2.string().optional(),
      done: exports_external2.boolean(),
      note: exports_external2.string().optional()
    }))
  }),
  approval: PlanBundleApprovalSchema,
  execution: exports_external2.array(JsonObject2),
  verification: JsonObject2.optional(),
  rollback: PlanBundleRollbackSchema,
  audit: exports_external2.array(PlanBundleAuditEventSchema)
});
var HelloFrameSchema = exports_external2.object({
  type: exports_external2.literal("hello"),
  role: exports_external2.enum(["ui", "admin", "node", "channel", "unknown"]).default("unknown"),
  clientID: exports_external2.string().optional(),
  protocolVersion: exports_external2.string().optional(),
  auth: exports_external2.object({
    token: exports_external2.string().optional(),
    challenge: exports_external2.object({
      nonce: exports_external2.string().min(8).max(128),
      ts: exports_external2.number().int().nonnegative(),
      signature: exports_external2.string().min(16).max(256)
    }).optional()
  }).optional(),
  capabilities: exports_external2.array(exports_external2.string()).optional()
});
var RequestFrameSchema = exports_external2.object({
  type: exports_external2.literal("request"),
  id: exports_external2.string().min(1),
  method: exports_external2.string().min(1),
  params: JsonObject2.default({}),
  idempotencyKey: exports_external2.string().min(1).max(128).optional()
});
var PingFrameSchema = exports_external2.object({
  type: exports_external2.literal("ping"),
  ts: exports_external2.number().int().nonnegative()
});
var PongFrameSchema = exports_external2.object({
  type: exports_external2.literal("pong"),
  ts: exports_external2.number().int().nonnegative()
});
var ResponseFrameSchema = exports_external2.object({
  type: exports_external2.literal("response"),
  id: exports_external2.string(),
  ok: exports_external2.boolean(),
  result: JsonValue2.optional(),
  error: exports_external2.object({
    code: exports_external2.string(),
    message: exports_external2.string(),
    details: JsonValue2.optional()
  }).optional()
});
var EventFrameSchema = exports_external2.object({
  type: exports_external2.literal("event"),
  event: exports_external2.string().min(1),
  payload: JsonValue2,
  stateVersion: exports_external2.record(exports_external2.string(), exports_external2.number()).optional()
});
var GatewayIncomingFrameSchema = exports_external2.union([
  HelloFrameSchema,
  RequestFrameSchema,
  PingFrameSchema
]);
var GatewayOutgoingFrameSchema = exports_external2.union([
  ResponseFrameSchema,
  EventFrameSchema,
  PongFrameSchema
]);

class GatewayMethodRegistry {
  handlers = new Map;
  inFlight = 0;
  queue = [];
  rejectedOverloaded = 0;
  rejectedTimeout = 0;
  queueWaitSamplesMs = [];
  maxInFlight;
  maxQueued;
  queueTimeoutMs;
  constructor(options = {}) {
    this.maxInFlight = Math.max(1, Math.floor(options.maxInFlight ?? Number(process.env.MIYA_GATEWAY_MAX_IN_FLIGHT ?? 8)));
    this.maxQueued = Math.max(1, Math.floor(options.maxQueued ?? Number(process.env.MIYA_GATEWAY_MAX_QUEUED ?? 64)));
    this.queueTimeoutMs = Math.max(100, Math.floor(options.queueTimeoutMs ?? Number(process.env.MIYA_GATEWAY_QUEUE_TIMEOUT_MS ?? 15000)));
  }
  register(method, handler) {
    this.handlers.set(method, handler);
  }
  has(method) {
    return this.handlers.has(method);
  }
  handlerOf(method) {
    return this.handlers.get(method);
  }
  registerAlias(aliasMethod, targetMethod) {
    if (aliasMethod === targetMethod)
      return false;
    if (this.handlers.has(aliasMethod))
      return false;
    const target = this.handlers.get(targetMethod);
    if (!target) {
      throw new Error(`alias_target_not_found:${targetMethod}`);
    }
    this.handlers.set(aliasMethod, async (params, context) => target(params, context));
    return true;
  }
  async invoke(method, params, context) {
    if (this.inFlight < this.maxInFlight) {
      return this.executeNow(method, params, context);
    }
    if (this.queue.length >= this.maxQueued) {
      this.rejectedOverloaded += 1;
      throw new Error(`gateway_backpressure_overloaded:in_flight=${this.inFlight}:queued=${this.queue.length}`);
    }
    return await new Promise((resolve7, reject) => {
      const queued = {
        method,
        params,
        context,
        enqueuedAtMs: Date.now(),
        resolve: resolve7,
        reject,
        timeout: setTimeout(() => {
          const index = this.queue.indexOf(queued);
          if (index >= 0)
            this.queue.splice(index, 1);
          this.rejectedTimeout += 1;
          reject(new Error("gateway_backpressure_timeout"));
        }, this.queueTimeoutMs)
      };
      this.queue.push(queued);
    });
  }
  list() {
    return [...this.handlers.keys()].sort();
  }
  stats() {
    const rejectedOverloaded = this.rejectedOverloaded;
    const rejectedTimeout = this.rejectedTimeout;
    const queueWaitMsP95 = this.queueWaitMsP95();
    return {
      inFlight: this.inFlight,
      queued: this.queue.length,
      maxInFlight: this.maxInFlight,
      maxQueued: this.maxQueued,
      rejected_overloaded: rejectedOverloaded,
      rejected_timeout: rejectedTimeout,
      queue_wait_ms_p95: queueWaitMsP95,
      rejectedOverloaded,
      rejectedTimeout,
      queueWaitMsP95
    };
  }
  async executeNow(method, params, context) {
    const handler = this.handlers.get(method);
    if (!handler)
      throw new Error(`unknown_method:${method}`);
    this.inFlight += 1;
    try {
      return await handler(params, context);
    } finally {
      this.inFlight = Math.max(0, this.inFlight - 1);
      this.drainQueue();
    }
  }
  drainQueue() {
    if (this.inFlight >= this.maxInFlight)
      return;
    const next = this.queue.shift();
    if (!next)
      return;
    clearTimeout(next.timeout);
    this.recordQueueWait(Date.now() - next.enqueuedAtMs);
    this.executeNow(next.method, next.params, next.context).then((value) => next.resolve(value)).catch((error92) => next.reject(error92)).finally(() => {
      if (this.inFlight < this.maxInFlight && this.queue.length > 0) {
        this.drainQueue();
      }
    });
  }
  recordQueueWait(waitMs) {
    if (!Number.isFinite(waitMs) || waitMs < 0)
      return;
    this.queueWaitSamplesMs.push(waitMs);
    if (this.queueWaitSamplesMs.length > 256) {
      this.queueWaitSamplesMs.splice(0, this.queueWaitSamplesMs.length - 256);
    }
  }
  queueWaitMsP95() {
    if (this.queueWaitSamplesMs.length === 0)
      return 0;
    const sorted = [...this.queueWaitSamplesMs].sort((a, b) => a - b);
    const index = Math.max(0, Math.min(sorted.length - 1, Math.floor(sorted.length * 0.95)));
    return Math.floor(sorted[index] ?? 0);
  }
}
function parseIncomingFrame(message) {
  let payload = message;
  if (typeof message === "string") {
    const raw = message.trim();
    if (!raw)
      return { error: "empty_message" };
    if (raw === "status") {
      payload = {
        type: "request",
        id: "legacy-status",
        method: "gateway.status.get",
        params: {}
      };
    } else {
      try {
        payload = JSON.parse(raw);
      } catch {
        return { error: "invalid_json" };
      }
    }
  }
  try {
    const frame = GatewayIncomingFrameSchema.parse(payload);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}
function toResponseFrame(input) {
  const result = toJsonCompatible(input.result);
  const errorDetails = toJsonCompatible(input.errorDetails);
  if (input.ok) {
    return ResponseFrameSchema.parse({
      type: "response",
      id: input.id,
      ok: true,
      result
    });
  }
  return ResponseFrameSchema.parse({
    type: "response",
    id: input.id,
    ok: false,
    error: {
      code: input.errorCode ?? "internal_error",
      message: input.errorMessage ?? "Internal error",
      details: errorDetails
    }
  });
}
function toEventFrame(input) {
  const payload = toJsonCompatible(input.payload);
  return EventFrameSchema.parse({
    type: "event",
    event: input.event,
    payload,
    stateVersion: input.stateVersion
  });
}
function toPongFrame(ts) {
  return PongFrameSchema.parse({
    type: "pong",
    ts
  });
}
function toJsonCompatible(input) {
  if (input === undefined)
    return null;
  if (input === null)
    return null;
  if (typeof input === "string" || typeof input === "number" || typeof input === "boolean") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map((item) => toJsonCompatible(item));
  }
  if (typeof input === "object") {
    const source = input;
    const next = {};
    for (const [key, value] of Object.entries(source)) {
      if (value === undefined)
        continue;
      next[key] = toJsonCompatible(value);
    }
    return next;
  }
  return String(input);
}

// src/gateway/turn-evidence.ts
import * as fs61 from "node:fs";
import * as path60 from "node:path";
function evidenceFile(projectDir) {
  return path60.join(getMiyaRuntimeDir(projectDir), "gateway-turn-evidence.jsonl");
}
function appendTurnEvidencePack(projectDir, pack) {
  const file3 = evidenceFile(projectDir);
  fs61.mkdirSync(path60.dirname(file3), { recursive: true });
  fs61.appendFileSync(file3, `${JSON.stringify(pack)}
`, "utf-8");
}

// src/gateway/index.ts
var z3 = tool.schema;
var runtimes2 = new Map;
var dependencies = new Map;
var ownerTokens = new Map;
var controlUiFallbackLoggedAtByDir = new Map;
var statusSnapshotFailureLoggedAtByDir = new Map;
var followerRecoveryTimers = new Map;
function nowIso42() {
  return new Date().toISOString();
}
function periodicTaskError(projectDir, input) {
  log("[gateway] periodic task failed", {
    projectDir,
    task: input.taskName,
    error: input.error instanceof Error ? input.error.message : String(input.error),
    cooldownUntilMs: input.cooldownUntilMs
  });
}
function resolveKillSwitchMode(projectDir, kill) {
  if (kill.active)
    return "all_stop";
  const outbound = isDomainExecutionAllowed(projectDir, "outbound_send");
  const desktop = isDomainExecutionAllowed(projectDir, "desktop_control");
  if (!outbound && !desktop)
    return "all_stop";
  if (!outbound)
    return "outbound_only";
  if (!desktop)
    return "desktop_only";
  return "off";
}
function resolvePsycheApprovalMode(input) {
  if (input.decision !== "allow")
    return "modal_approval";
  if (input.urgency === "high" || input.urgency === "critical")
    return "modal_approval";
  if (input.trust.minScore >= input.mode.silentMin)
    return "silent_audit";
  if (input.trust.minScore <= input.mode.modalMax)
    return "modal_approval";
  return "toast_gate";
}
function appendNexusInsight(runtime, input) {
  const trimmed = input.text.trim();
  if (!trimmed)
    return;
  runtime.nexus.insights.push({
    at: input.at ?? nowIso42(),
    text: trimmed,
    auditID: input.auditID
  });
  if (runtime.nexus.insights.length > 30) {
    runtime.nexus.insights.splice(0, runtime.nexus.insights.length - 30);
  }
}
function shouldEmitThrottledLog(cache, key, windowMs) {
  const now = Date.now();
  const last = cache.get(key) ?? 0;
  if (now - last < windowMs)
    return false;
  cache.set(key, now);
  return true;
}
function depsOf(projectDir) {
  return dependencies.get(projectDir) ?? {};
}
function gatewayFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway.json");
}
function gatewayAuthFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-auth.json");
}
function buildGatewayChallengeSignature(input) {
  return createHmac2("sha256", input.secret).update(`${input.clientID}|${input.protocolVersion}|${input.nonce}|${String(input.ts)}`).digest("hex");
}
function resolveGatewayAuthConfig(projectDir) {
  const envToken = String(process.env.MIYA_GATEWAY_TOKEN ?? "").trim();
  const challengeSecret = String(process.env.MIYA_GATEWAY_CHALLENGE_SECRET ?? "").trim() || undefined;
  if (envToken) {
    return {
      token: envToken,
      tokenSource: "env",
      challengeSecret,
      challengeRequired: Boolean(challengeSecret)
    };
  }
  const file3 = gatewayAuthFile(projectDir);
  const raw = safeReadJsonObject(file3);
  const existingToken = raw && typeof raw.token === "string" ? raw.token.trim() : "";
  const token = existingToken || randomUUID24().replace(/-/g, "");
  if (!existingToken) {
    writeJsonAtomic(file3, {
      token,
      source: "generated",
      createdAt: nowIso42(),
      note: "Generated by Miya Gateway for local control-plane authentication."
    });
  }
  return {
    token,
    tokenSource: "generated",
    challengeSecret,
    challengeRequired: Boolean(challengeSecret)
  };
}
function normalizeIncomingProtocolVersion(input) {
  const raw = String(input ?? "").trim();
  if (!raw)
    return LEGACY_GATEWAY_PROTOCOL_VERSION;
  return raw;
}
function isSupportedProtocolVersion(version3) {
  return SUPPORTED_GATEWAY_PROTOCOL_VERSIONS.includes(version3);
}
var DEFAULT_TRUST_MODE = {
  silentMin: 90,
  modalMax: 50
};
var DEFAULT_PSYCHE_MODE = {
  resonanceEnabled: true,
  captureProbeEnabled: true,
  signalOverrideEnabled: false,
  slowBrainEnabled: true,
  slowBrainShadowEnabled: true,
  slowBrainShadowRollout: 15,
  shadowCohortSalt: "miya-psyche-shadow-v1",
  proactivePingEnabled: true,
  proactivePingMinIntervalMinutes: 90,
  proactivePingMaxPerDay: 12,
  quietHoursEnabled: true,
  quietHoursStart: "23:00",
  quietHoursEnd: "08:00",
  quietHoursTimezoneOffsetMinutes: -new Date().getTimezoneOffset()
};
var DEFAULT_LEARNING_GATE = {
  candidateMode: "toast_gate",
  persistentRequiresApproval: true
};
function trustModeFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-trust-mode.json");
}
function psycheModeFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-psyche-mode.json");
}
function psycheModeHistoryFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-psyche-mode-history.jsonl");
}
function psycheShadowAuditFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-psyche-shadow-audit.jsonl");
}
function learningGateFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-learning-gate.json");
}
function proactivePingStateFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-proactive-ping-state.json");
}
function normalizeTrustMode2(input) {
  const silentMinRaw = Number(input?.silentMin ?? DEFAULT_TRUST_MODE.silentMin);
  const modalMaxRaw = Number(input?.modalMax ?? DEFAULT_TRUST_MODE.modalMax);
  const silentMin = Math.max(0, Math.min(100, Number.isFinite(silentMinRaw) ? silentMinRaw : DEFAULT_TRUST_MODE.silentMin));
  const modalMax = Math.max(0, Math.min(100, Number.isFinite(modalMaxRaw) ? modalMaxRaw : DEFAULT_TRUST_MODE.modalMax));
  const correctedSilentMin = Math.max(Math.ceil(modalMax), Math.round(silentMin));
  return {
    silentMin: correctedSilentMin,
    modalMax: Math.round(modalMax)
  };
}
function readTrustModeConfig(projectDir) {
  const raw = safeReadJsonObject(trustModeFile(projectDir));
  if (!raw)
    return DEFAULT_TRUST_MODE;
  return normalizeTrustMode2({
    silentMin: typeof raw.silentMin === "number" ? raw.silentMin : undefined,
    modalMax: typeof raw.modalMax === "number" ? raw.modalMax : undefined
  });
}
function writeTrustModeConfig(projectDir, config3) {
  const normalized = normalizeTrustMode2(config3);
  writeJsonAtomic(trustModeFile(projectDir), normalized);
  return normalized;
}
function normalizeQuietHourText(value, fallback) {
  const raw = String(value ?? "").trim();
  const matched = /^(\d{1,2}):(\d{1,2})$/.exec(raw);
  if (!matched)
    return fallback;
  const hour = Number(matched[1]);
  const minute = Number(matched[2]);
  if (!Number.isFinite(hour) || !Number.isFinite(minute))
    return fallback;
  if (hour < 0 || hour > 23 || minute < 0 || minute > 59)
    return fallback;
  return `${String(Math.floor(hour)).padStart(2, "0")}:${String(Math.floor(minute)).padStart(2, "0")}`;
}
function quietHourTextToMinutes(value) {
  const [hourRaw, minuteRaw] = value.split(":");
  const hour = Number(hourRaw);
  const minute = Number(minuteRaw);
  if (!Number.isFinite(hour) || !Number.isFinite(minute))
    return 0;
  return Math.max(0, Math.min(1439, Math.floor(hour) * 60 + Math.floor(minute)));
}
function normalizePsycheMode(input) {
  const rolloutRaw = Number(input?.slowBrainShadowRollout ?? DEFAULT_PSYCHE_MODE.slowBrainShadowRollout);
  const rollout = Number.isFinite(rolloutRaw) ? Math.max(0, Math.min(100, Math.round(rolloutRaw))) : DEFAULT_PSYCHE_MODE.slowBrainShadowRollout;
  const proactivePingMinIntervalRaw = Number(input?.proactivePingMinIntervalMinutes ?? DEFAULT_PSYCHE_MODE.proactivePingMinIntervalMinutes);
  const proactivePingMinIntervalMinutes = Number.isFinite(proactivePingMinIntervalRaw) ? Math.max(1, Math.min(24 * 60, Math.round(proactivePingMinIntervalRaw))) : DEFAULT_PSYCHE_MODE.proactivePingMinIntervalMinutes;
  const proactivePingMaxPerDayRaw = Number(input?.proactivePingMaxPerDay ?? DEFAULT_PSYCHE_MODE.proactivePingMaxPerDay);
  const proactivePingMaxPerDay = Number.isFinite(proactivePingMaxPerDayRaw) ? Math.max(1, Math.min(200, Math.round(proactivePingMaxPerDayRaw))) : DEFAULT_PSYCHE_MODE.proactivePingMaxPerDay;
  const timezoneOffsetRaw = Number(input?.quietHoursTimezoneOffsetMinutes ?? DEFAULT_PSYCHE_MODE.quietHoursTimezoneOffsetMinutes);
  const quietHoursTimezoneOffsetMinutes = Number.isFinite(timezoneOffsetRaw) ? Math.max(-12 * 60, Math.min(14 * 60, Math.round(timezoneOffsetRaw))) : DEFAULT_PSYCHE_MODE.quietHoursTimezoneOffsetMinutes;
  return {
    resonanceEnabled: typeof input?.resonanceEnabled === "boolean" ? input.resonanceEnabled : DEFAULT_PSYCHE_MODE.resonanceEnabled,
    captureProbeEnabled: typeof input?.captureProbeEnabled === "boolean" ? input.captureProbeEnabled : DEFAULT_PSYCHE_MODE.captureProbeEnabled,
    signalOverrideEnabled: typeof input?.signalOverrideEnabled === "boolean" ? input.signalOverrideEnabled : DEFAULT_PSYCHE_MODE.signalOverrideEnabled,
    slowBrainEnabled: typeof input?.slowBrainEnabled === "boolean" ? input.slowBrainEnabled : DEFAULT_PSYCHE_MODE.slowBrainEnabled,
    slowBrainShadowEnabled: typeof input?.slowBrainShadowEnabled === "boolean" ? input.slowBrainShadowEnabled : DEFAULT_PSYCHE_MODE.slowBrainShadowEnabled,
    slowBrainShadowRollout: rollout,
    shadowCohortSalt: typeof input?.shadowCohortSalt === "string" && input.shadowCohortSalt.trim().length > 0 ? input.shadowCohortSalt.trim().slice(0, 80) : DEFAULT_PSYCHE_MODE.shadowCohortSalt,
    proactivePingEnabled: typeof input?.proactivePingEnabled === "boolean" ? input.proactivePingEnabled : DEFAULT_PSYCHE_MODE.proactivePingEnabled,
    proactivePingMinIntervalMinutes,
    proactivePingMaxPerDay,
    quietHoursEnabled: typeof input?.quietHoursEnabled === "boolean" ? input.quietHoursEnabled : DEFAULT_PSYCHE_MODE.quietHoursEnabled,
    quietHoursStart: normalizeQuietHourText(input?.quietHoursStart, DEFAULT_PSYCHE_MODE.quietHoursStart),
    quietHoursEnd: normalizeQuietHourText(input?.quietHoursEnd, DEFAULT_PSYCHE_MODE.quietHoursEnd),
    quietHoursTimezoneOffsetMinutes
  };
}
function readPsycheModeConfig(projectDir) {
  const raw = safeReadJsonObject(psycheModeFile(projectDir));
  if (!raw)
    return DEFAULT_PSYCHE_MODE;
  return normalizePsycheMode({
    resonanceEnabled: typeof raw.resonanceEnabled === "boolean" ? raw.resonanceEnabled : undefined,
    captureProbeEnabled: typeof raw.captureProbeEnabled === "boolean" ? raw.captureProbeEnabled : undefined,
    signalOverrideEnabled: typeof raw.signalOverrideEnabled === "boolean" ? raw.signalOverrideEnabled : undefined,
    slowBrainEnabled: typeof raw.slowBrainEnabled === "boolean" ? raw.slowBrainEnabled : undefined,
    slowBrainShadowEnabled: typeof raw.slowBrainShadowEnabled === "boolean" ? raw.slowBrainShadowEnabled : undefined,
    slowBrainShadowRollout: typeof raw.slowBrainShadowRollout === "number" ? raw.slowBrainShadowRollout : undefined,
    shadowCohortSalt: typeof raw.shadowCohortSalt === "string" ? raw.shadowCohortSalt : undefined,
    proactivePingEnabled: typeof raw.proactivePingEnabled === "boolean" ? raw.proactivePingEnabled : undefined,
    proactivePingMinIntervalMinutes: typeof raw.proactivePingMinIntervalMinutes === "number" ? raw.proactivePingMinIntervalMinutes : undefined,
    proactivePingMaxPerDay: typeof raw.proactivePingMaxPerDay === "number" ? raw.proactivePingMaxPerDay : undefined,
    quietHoursEnabled: typeof raw.quietHoursEnabled === "boolean" ? raw.quietHoursEnabled : undefined,
    quietHoursStart: typeof raw.quietHoursStart === "string" ? raw.quietHoursStart : undefined,
    quietHoursEnd: typeof raw.quietHoursEnd === "string" ? raw.quietHoursEnd : undefined,
    quietHoursTimezoneOffsetMinutes: typeof raw.quietHoursTimezoneOffsetMinutes === "number" ? raw.quietHoursTimezoneOffsetMinutes : undefined
  });
}
function writePsycheModeConfig(projectDir, config3) {
  const current = readPsycheModeConfig(projectDir);
  const normalized = normalizePsycheMode({
    ...current,
    ...config3
  });
  writeJsonAtomic(psycheModeFile(projectDir), normalized);
  fs62.mkdirSync(path61.dirname(psycheModeHistoryFile(projectDir)), {
    recursive: true
  });
  fs62.appendFileSync(psycheModeHistoryFile(projectDir), `${JSON.stringify({
    at: nowIso42(),
    token: `psy_mode_${randomUUID24()}`,
    previous: current,
    next: normalized
  })}
`, "utf-8");
  return normalized;
}
function rollbackPsycheModeConfig(projectDir, token) {
  const file3 = psycheModeHistoryFile(projectDir);
  if (!fs62.existsSync(file3)) {
    return { mode: readPsycheModeConfig(projectDir) };
  }
  const rows = fs62.readFileSync(file3, "utf-8").split(/\r?\n/).map((line) => line.trim()).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  if (rows.length === 0)
    return { mode: readPsycheModeConfig(projectDir) };
  const target = token?.trim() ? rows.find((row) => row.token === token.trim()) : rows[rows.length - 1];
  if (!target?.previous)
    return { mode: readPsycheModeConfig(projectDir) };
  const restored = normalizePsycheMode(target.previous);
  writeJsonAtomic(psycheModeFile(projectDir), restored);
  return {
    mode: restored,
    rollbackToken: target.token
  };
}
function appendPsycheShadowAudit(projectDir, input) {
  fs62.mkdirSync(path61.dirname(psycheShadowAuditFile(projectDir)), {
    recursive: true
  });
  fs62.appendFileSync(psycheShadowAuditFile(projectDir), `${JSON.stringify({
    id: `psy_shadow_${randomUUID24()}`,
    at: input.at ?? nowIso42(),
    ...input
  })}
`, "utf-8");
}
function readPsycheShadowAuditSummary(projectDir, limit = 200) {
  const file3 = psycheShadowAuditFile(projectDir);
  if (!fs62.existsSync(file3)) {
    return { samples: 0, divergence: 0, divergenceRate: 0, recent: [] };
  }
  const rows = fs62.readFileSync(file3, "utf-8").split(/\r?\n/).map((line) => line.trim()).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  const recent = rows.slice(-Math.max(1, Math.min(2000, limit)));
  const divergence = recent.filter((row) => row.divergence === true).length;
  return {
    samples: recent.length,
    divergence,
    divergenceRate: recent.length > 0 ? Number((divergence / recent.length).toFixed(4)) : 0,
    recent: recent.slice(-50)
  };
}
function normalizeLearningGate(input) {
  return {
    candidateMode: input?.candidateMode === "silent_audit" ? "silent_audit" : "toast_gate",
    persistentRequiresApproval: typeof input?.persistentRequiresApproval === "boolean" ? input.persistentRequiresApproval : DEFAULT_LEARNING_GATE.persistentRequiresApproval
  };
}
function readLearningGateConfig(projectDir) {
  const raw = safeReadJsonObject(learningGateFile(projectDir));
  if (!raw)
    return DEFAULT_LEARNING_GATE;
  return normalizeLearningGate({
    candidateMode: raw.candidateMode === "silent_audit" || raw.candidateMode === "toast_gate" ? raw.candidateMode : undefined,
    persistentRequiresApproval: typeof raw.persistentRequiresApproval === "boolean" ? raw.persistentRequiresApproval : undefined
  });
}
function writeLearningGateConfig(projectDir, config3) {
  const current = readLearningGateConfig(projectDir);
  const normalized = normalizeLearningGate({
    ...current,
    ...config3
  });
  writeJsonAtomic(learningGateFile(projectDir), normalized);
  return normalized;
}
function resolvePsycheConsultEnabled(projectDir, mode) {
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "1")
    return true;
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "0")
    return false;
  const config3 = readConfig(projectDir);
  const configured = config3.automation?.psycheConsultEnabled;
  if (typeof configured === "boolean")
    return configured;
  return mode.resonanceEnabled;
}
function resolvePsycheConsultTimeoutMs(input) {
  if (input.shadow) {
    const raw2 = Number(process.env.MIYA_PSYCHE_SHADOW_TIMEOUT_MS ?? 900);
    if (!Number.isFinite(raw2))
      return 900;
    return Math.max(200, Math.min(8000, Math.floor(raw2)));
  }
  const fallback = input.userInitiated ? 3500 : 1600;
  const raw = Number(process.env.MIYA_PSYCHE_CONSULT_TIMEOUT_MS ?? fallback);
  if (!Number.isFinite(raw))
    return fallback;
  return Math.max(300, Math.min(12000, Math.floor(raw)));
}
async function withTimeout(promise3, timeoutMs, code) {
  let timer;
  const timeoutPromise = new Promise((_resolve, reject) => {
    timer = setTimeout(() => reject(new Error(code)), timeoutMs);
  });
  try {
    return await Promise.race([promise3, timeoutPromise]);
  } finally {
    if (timer)
      clearTimeout(timer);
  }
}
function gatewayOwnerLockFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-owner.json");
}
function ensureDir19(file3) {
  fs62.mkdirSync(path61.dirname(file3), { recursive: true });
}
function isRetryableAtomicReplaceError(error92) {
  if (!error92 || typeof error92 !== "object")
    return false;
  const code = String(error92.code ?? "").toUpperCase();
  return code === "EPERM" || code === "EACCES" || code === "EBUSY";
}
function writeJsonAtomic(file3, payload) {
  ensureDir19(file3);
  const content = `${JSON.stringify(payload, null, 2)}
`;
  let lastError;
  for (let attempt = 0;attempt < 4; attempt += 1) {
    const tmp = `${file3}.tmp.${process.pid}.${Date.now()}.${attempt}`;
    fs62.writeFileSync(tmp, content, "utf-8");
    try {
      fs62.renameSync(tmp, file3);
      return;
    } catch (error92) {
      lastError = error92;
      if (!isRetryableAtomicReplaceError(error92)) {
        try {
          fs62.unlinkSync(tmp);
        } catch {}
        throw error92;
      }
      try {
        fs62.copyFileSync(tmp, file3);
        fs62.unlinkSync(tmp);
        return;
      } catch (copyError) {
        lastError = copyError;
        try {
          fs62.unlinkSync(tmp);
        } catch {}
      }
    }
  }
  try {
    fs62.writeFileSync(file3, content, "utf-8");
    return;
  } catch {}
  throw lastError instanceof Error ? lastError : new Error("gateway_state_write_failed");
}
function safeReadJsonObject(file3) {
  if (!fs62.existsSync(file3))
    return null;
  try {
    const parsed = JSON.parse(fs62.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed))
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function readGatewayOwnerLock(projectDir) {
  const raw = safeReadJsonObject(gatewayOwnerLockFile(projectDir));
  if (!raw)
    return null;
  const pid = Number(raw.pid);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  const startedAt = String(raw.startedAt ?? "");
  if (!Number.isFinite(pid) || !token || !updatedAt || !startedAt)
    return null;
  return { pid, token, updatedAt, startedAt };
}
function describeOwnerLock(lock) {
  if (!lock)
    return { exists: false };
  return {
    exists: true,
    pid: lock.pid,
    updatedAt: lock.updatedAt,
    startedAt: lock.startedAt,
    fresh: isOwnerLockFresh(lock),
    alive: isProcessAlive(lock.pid)
  };
}
function isProcessAlive(pid) {
  if (!Number.isFinite(pid) || pid <= 0)
    return false;
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function isOwnerLockFresh(lock) {
  const ts = Date.parse(lock.updatedAt);
  if (!Number.isFinite(ts))
    return false;
  return Date.now() - ts <= 15000;
}
function ownerSummary(projectDir) {
  const lock = readGatewayOwnerLock(projectDir);
  if (!lock) {
    return {
      isOwner: false,
      ownerFresh: false
    };
  }
  const token = ownerTokens.get(projectDir);
  return {
    isOwner: Boolean(token) && lock.pid === process.pid && lock.token === token,
    ownerPID: lock.pid,
    ownerFresh: isOwnerLockFresh(lock)
  };
}
function writeOwnerLock(projectDir, token) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const existing = readGatewayOwnerLock(projectDir);
  const lock = {
    pid: process.pid,
    token,
    updatedAt: nowIso42(),
    startedAt: existing?.pid === process.pid && existing.token === token ? existing.startedAt : nowIso42()
  };
  writeJsonAtomic(file3, lock);
  return lock;
}
function touchOwnerLock(projectDir) {
  const token = ownerTokens.get(projectDir);
  if (!token)
    return;
  writeOwnerLock(projectDir, token);
}
function removeOwnerLock(projectDir) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  const token = ownerTokens.get(projectDir);
  if (!lock || !token)
    return;
  if (lock.pid === process.pid && lock.token === token) {
    try {
      fs62.unlinkSync(file3);
    } catch {}
  }
}
function acquireGatewayOwner(projectDir) {
  const existingToken = ownerTokens.get(projectDir) ?? randomUUID24();
  ownerTokens.set(projectDir, existingToken);
  const lockFile = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  if (lock && lock.pid === process.pid && lock.token === existingToken && isOwnerLockFresh(lock)) {
    const refreshed = {
      ...lock,
      updatedAt: nowIso42()
    };
    writeJsonAtomic(lockFile, refreshed);
    return { owned: true, owner: refreshed };
  }
  if (lock && isProcessAlive(lock.pid) && isOwnerLockFresh(lock)) {
    return { owned: false, owner: lock };
  }
  const created = writeOwnerLock(projectDir, existingToken);
  return { owned: true, owner: created };
}
function readGatewayStateFile(projectDir) {
  const raw = safeReadJsonObject(gatewayFile(projectDir));
  if (!raw)
    return null;
  const url3 = String(raw.url ?? "").trim();
  const uiUrl = String(raw.uiUrl ?? url3).trim();
  const port = Number(raw.port);
  const pid = Number(raw.pid);
  const startedAt = String(raw.startedAt ?? "");
  const status = String(raw.status ?? "running");
  const authTokenFromState = typeof raw.authToken === "string" && raw.authToken.trim().length > 0 ? raw.authToken.trim() : undefined;
  const authRaw = safeReadJsonObject(gatewayAuthFile(projectDir));
  const authTokenFromFile = authRaw && typeof authRaw.token === "string" && authRaw.token.trim().length > 0 ? authRaw.token.trim() : undefined;
  const authToken = authTokenFromState ?? authTokenFromFile;
  if (!url3 || !Number.isFinite(port) || !Number.isFinite(pid) || !startedAt) {
    return null;
  }
  return {
    url: url3,
    uiUrl: uiUrl || url3,
    port,
    pid,
    startedAt,
    status: status === "killswitch" ? "killswitch" : "running",
    authToken
  };
}
function describeGatewayState(state) {
  if (!state)
    return { exists: false };
  return {
    exists: true,
    url: state.url,
    uiUrl: state.uiUrl.replace(/\?.*$/, ""),
    port: state.port,
    pid: state.pid,
    startedAt: state.startedAt,
    status: state.status,
    authTokenPresent: Boolean(state.authToken),
    pidAlive: isProcessAlive(state.pid)
  };
}
function clearGatewayStateFile(projectDir) {
  try {
    fs62.unlinkSync(gatewayFile(projectDir));
  } catch {}
}
async function probeGatewayAlive(url3, timeoutMs = 800) {
  const controller = new AbortController;
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const response = await fetch(`${url3.replace(/\/+$/, "")}/api/status`, {
      method: "GET",
      signal: controller.signal
    });
    return response.ok;
  } catch {
    return false;
  } finally {
    clearTimeout(timer);
  }
}
function killAwareStatus(projectDir) {
  return readKillSwitch(projectDir).active ? "killswitch" : "running";
}
function gatewayPort(runtime) {
  return Number(runtime.server.port ?? 0);
}
function resolveGatewayListenOptions(projectDir) {
  const config3 = readConfig(projectDir);
  const gateway = config3.gateway ?? {};
  const rawHost = String(gateway.bindHost ?? "").trim();
  const rawPort = Number(gateway.port);
  const hostname5 = rawHost || "127.0.0.1";
  const port = Number.isFinite(rawPort) && rawPort > 0 && rawPort <= 65535 ? Math.floor(rawPort) : 0;
  return { hostname: hostname5, port };
}
function isAddressInUseError(error92) {
  if (!error92 || typeof error92 !== "object") {
    return false;
  }
  const code = String(error92.code ?? "");
  if (code === "EADDRINUSE") {
    return true;
  }
  const message = String(error92.message ?? "");
  return message.includes("EADDRINUSE");
}
function logControlUiFallback(projectDir, pathname, controlUi, responseStatus) {
  const logKey = `${projectDir}:control-ui-fallback`;
  if (!shouldEmitThrottledLog(controlUiFallbackLoggedAtByDir, logKey, 1e4))
    return;
  log("[gateway] control-ui fallback to built-in console", {
    projectDir,
    pathname,
    responseStatus,
    uiRootKind: controlUi.root?.kind ?? "unknown",
    uiRootPath: controlUi.root && "path" in controlUi.root ? String(controlUi.root.path) : undefined,
    uiBasePath: controlUi.basePath ?? "",
    envUiRoot: process.env.MIYA_GATEWAY_UI_ROOT ?? "",
    envUiBasePath: process.env.MIYA_GATEWAY_UI_BASE_PATH ?? ""
  });
}
function logStatusSnapshotFailure(projectDir, error92) {
  const logKey = `${projectDir}:status-snapshot-failure`;
  if (!shouldEmitThrottledLog(statusSnapshotFailureLoggedAtByDir, logKey, 1e4)) {
    return;
  }
  log("[gateway] status snapshot failed; fallback payload emitted", {
    projectDir,
    error: error92 instanceof Error ? error92.message : String(error92)
  });
}
function toGatewayState(projectDir, runtime) {
  const host = String(runtime.server.hostname ?? "127.0.0.1") || "127.0.0.1";
  const url3 = `http://${host}:${gatewayPort(runtime)}`;
  return {
    url: url3,
    uiUrl: url3,
    port: gatewayPort(runtime),
    pid: process.pid,
    startedAt: runtime.startedAt,
    status: killAwareStatus(projectDir),
    authToken: runtime.auth.token
  };
}
function writeGatewayState(projectDir, state) {
  const file3 = gatewayFile(projectDir);
  writeJsonAtomic(file3, state);
}
function syncGatewayState(projectDir, runtime) {
  const state = toGatewayState(projectDir, runtime);
  writeGatewayState(projectDir, state);
  return state;
}
function toPublicGatewayState(state) {
  return {
    ...state,
    uiUrl: state.url,
    authToken: undefined
  };
}
function buildStatusFallbackPayload(projectDir, runtime, error92) {
  const message = error92 instanceof Error ? error92.message : String(error92);
  let gateway = {
    status: "degraded",
    url: "",
    uiUrl: ""
  };
  try {
    gateway = {
      ...toPublicGatewayState(syncGatewayState(projectDir, runtime)),
      status: "degraded"
    };
  } catch {}
  let daemon = { connected: false };
  try {
    daemon = {
      ...getLauncherDaemonSnapshot(projectDir),
      connected: false
    };
  } catch {}
  return {
    updatedAt: nowIso42(),
    gateway,
    daemon,
    policyHash: "",
    sessions: { total: 0, active: 0, queued: 0, muted: 0 },
    jobs: { total: 0, enabled: 0, pendingApprovals: 0, recentRuns: [] },
    nodes: { total: 0, connected: 0, list: [] },
    nexus: {
      sessionId: runtime.nexus.sessionId,
      pendingTickets: runtime.nexus.pendingTickets,
      killSwitchMode: runtime.nexus.killSwitchMode,
      insights: [],
      trustMode: runtime.nexus.trustMode,
      psycheMode: runtime.nexus.psycheMode,
      guardianSafeHoldReason: "status_snapshot_failed"
    },
    statusError: {
      code: "status_snapshot_failed",
      message,
      hint: " daemon  localhost/127.0.0.1/::1"
    }
  };
}
function stopGateway(projectDir) {
  const runtime = runtimes2.get(projectDir);
  if (!runtime)
    return { stopped: false };
  try {
    enqueueReflectWorkerJob(projectDir, {
      reason: "session_end",
      force: true,
      minLogs: 50,
      maxLogs: 200,
      maxWrites: 60,
      cooldownMinutes: 0
    });
    setTimeout(() => {
      try {
        runReflectWorkerTick(projectDir, {
          maxJobs: 2,
          writeBudget: 60,
          mergeBudget: 60
        });
      } catch {}
    }, 0);
  } catch {}
  const previous = toGatewayState(projectDir, runtime);
  if (runtime.wizardTickTimer) {
    clearInterval(runtime.wizardTickTimer);
    runtime.wizardTickTimer = undefined;
  }
  if (runtime.ownerBeatTimer) {
    clearInterval(runtime.ownerBeatTimer);
    runtime.ownerBeatTimer = undefined;
  }
  if (runtime.memoryReflectTimer) {
    clearInterval(runtime.memoryReflectTimer);
    runtime.memoryReflectTimer = undefined;
  }
  runtime.pendingQueueGeneration += 1;
  runtime.pendingQueueRescheduleNeeded = false;
  clearPendingOutboundScheduler(runtime);
  writePendingOutboundQueue(projectDir, runtime.pendingOutboundQueue);
  if (runtime.daemonLauncherUnsubscribe) {
    runtime.daemonLauncherUnsubscribe();
    runtime.daemonLauncherUnsubscribe = undefined;
  }
  stopMiyaLauncher(projectDir);
  try {
    runtime.channelRuntime.stop();
  } catch {}
  try {
    runtime.server.stop(true);
  } catch {}
  runtimes2.delete(projectDir);
  clearGatewayStateFile(projectDir);
  removeOwnerLock(projectDir);
  return { stopped: true, previous };
}
function hashText3(input) {
  return createHash19("sha256").update(input).digest("hex");
}
function shouldSamplePsycheShadow(input) {
  if (!input.mode.slowBrainShadowEnabled)
    return false;
  if (input.mode.slowBrainShadowRollout <= 0)
    return false;
  const key = `${input.mode.shadowCohortSalt}|${input.sessionID}|${input.payloadHash}`;
  const hash3 = hashText3(key);
  const bucket2 = Number.parseInt(hash3.slice(0, 8), 16) % 100;
  return bucket2 < input.mode.slowBrainShadowRollout;
}
function parseText2(value) {
  return typeof value === "string" ? value : "";
}
function envFlagEnabled(name) {
  const raw = String(process.env[name] ?? "").trim().toLowerCase();
  return raw === "1" || raw === "true" || raw === "yes";
}
function useGatewayAsrTestMode() {
  return envFlagEnabled("MIYA_MULTIMODAL_TEST_MODE") || envFlagEnabled("MIYA_ASR_TEST_MODE");
}
function parseChannel(value) {
  return isChannelName(value) ? value : null;
}
function parseMemoryDomain(value) {
  const raw = parseText2(value).trim().toLowerCase();
  if (raw === "work")
    return "work";
  if (raw === "relationship")
    return "relationship";
  return;
}
function parseDesktopRouteLevel(value) {
  const raw = parseText2(value).trim();
  if (raw === "L0_ACTION_MEMORY" || raw === "L1_UIA" || raw === "L2_OCR" || raw === "L3_SOM_VLM") {
    return raw;
  }
  return;
}
function parseEvidenceList(value) {
  if (!Array.isArray(value))
    return [];
  return value.map((item) => String(item ?? "").trim()).filter((item) => item.length > 0).slice(0, 20);
}
var WIZARD_PROMPT_PHOTOS = "15";
var WIZARD_PROMPT_VOICE = "";
var WIZARD_PROMPT_PERSONALITY = "";
var WIZARD_PROMPT_DONE = "";
var WIZARD_CANCELLED_MESSAGE = "/";
function wizardPromptByState(state) {
  if (state === "awaiting_photos")
    return WIZARD_PROMPT_PHOTOS;
  if (state === "awaiting_voice")
    return WIZARD_PROMPT_VOICE;
  if (state === "awaiting_personality")
    return WIZARD_PROMPT_PERSONALITY;
  if (state === "completed")
    return WIZARD_PROMPT_DONE;
  return "";
}
function contextEnvelopeByMode(mode) {
  if (mode === "guest") {
    return [
      "[Guest Mode Active]",
      "Only use public persona.",
      "Do not access memory/vault/relationship private context.",
      "Refuse desktop control, outbound actions, and sensitive data requests."
    ].join(`
`);
  }
  if (mode === "unknown") {
    return "[Unknown Speaker] Safety-first mode: avoid sensitive actions until owner verification.";
  }
  return "[Owner Mode Active] Full private context is available.";
}
function containsSensitiveText(text) {
  const sensitivePattern = /(|||||seed||token|secret|api[_-]?key|wallet||||otp|password)/i;
  return sensitivePattern.test(text);
}
function inferIntentSuspicious(text) {
  const suspiciousPattern = /(|||||||||||||)/i;
  return suspiciousPattern.test(text);
}
function isHighRiskInstruction(text) {
  return /(||||||||||)/i.test(text);
}
function isCriticalInjectionIntent(text) {
  return /(|.*(||)|.*(||)|.*(|).*(|token|)|.*(|))/i.test(text);
}
function shouldBypassIntentGuard(source) {
  return /^policy:|^system:/.test(source);
}
function buildSessionPayloadByMode(mode, text) {
  if (mode === "guest") {
    if (containsSensitiveText(text) || isHighRiskInstruction(text)) {
      const digest2 = hashText3(text).slice(0, 16);
      return {
        redacted: true,
        payload: [
          "[Guest Mode Active]",
          "Private context pointers: memory=null, vault=null, relationship=null.",
          "Sensitive request is blocked in guest mode.",
          `redacted_request_sha256=${digest2}`,
          "Reply policy: refuse sensitive actions and keep light conversation only."
        ].join(`
`)
      };
    }
    return {
      redacted: false,
      payload: [
        contextEnvelopeByMode(mode),
        "Private context pointers: memory=null, vault=null, relationship=null.",
        text
      ].join(`
`)
    };
  }
  if (mode === "unknown") {
    return {
      redacted: false,
      payload: [contextEnvelopeByMode(mode), text].join(`
`)
    };
  }
  return {
    redacted: false,
    payload: [contextEnvelopeByMode(mode), text].join(`
`)
  };
}
async function enforceCriticalIntentGuard(projectDir, input) {
  if (shouldBypassIntentGuard(input.source))
    return false;
  if (!isCriticalInjectionIntent(input.text))
    return false;
  const traceID = randomUUID24();
  const reason = "critical_intent_killswitch_triggered";
  activateKillSwitch(projectDir, reason, traceID);
  appendPolicyIncident(projectDir, {
    type: "decision_fusion_hard",
    reason,
    pausedDomains: ["outbound_send", "desktop_control"],
    statusByDomain: {
      outbound_send: "paused",
      desktop_control: "paused"
    },
    semanticSummary: {
      trigger: "critical_intent_guard",
      keyAssertion: "Message matched critical injection / exfiltration intent pattern.",
      recovery: "Use OpenCode local password to unlock and manually resume domains."
    },
    semanticTags: ["recipient_mismatch"],
    details: {
      source: input.source,
      sessionID: input.sessionID,
      textDigest: hashText3(input.text).slice(0, 24)
    }
  });
  await notifySafetyReport(projectDir, input.sessionID, [
    "Miya Kill-Switch",
    `: ${reason}`,
    "/",
    " OpenCode "
  ]);
  return true;
}
function collectStringValues(input, maxItems = 40) {
  const out = [];
  const stack = [input];
  while (stack.length > 0 && out.length < maxItems) {
    const current = stack.pop();
    if (typeof current === "string") {
      const text = current.trim();
      if (text.length > 0)
        out.push(text);
      continue;
    }
    if (!current || typeof current !== "object")
      continue;
    if (Array.isArray(current)) {
      for (const item of current)
        stack.push(item);
      continue;
    }
    for (const value of Object.values(current)) {
      stack.push(value);
    }
  }
  return out;
}
function shouldGuardMethod(method) {
  if (method.startsWith("policy.") || method.startsWith("gateway.") || method.startsWith("doctor.")) {
    return false;
  }
  return true;
}
var UI_ALLOWED_METHODS = new Set([
  "gateway.status.get",
  "gateway.backpressure.stats",
  "audit.ledger.list",
  "daemon.backpressure.stats",
  "doctor.run",
  "config.center.get",
  "provider.override.audit.list",
  "strategy.experiments.get",
  "strategy.experiments.replay",
  "sessions.list",
  "sessions.get",
  "cron.list",
  "cron.runs.list",
  "cron.runs.remove",
  "cron.run.now",
  "cron.approvals.list",
  "policy.domain.pause",
  "policy.domain.resume",
  "killswitch.set_mode",
  "trust.set_mode",
  "psyche.mode.set",
  "insight.append",
  "channels.list",
  "channels.status",
  "channels.governance.get",
  "channels.pair.list",
  "channels.contact.tier.get",
  "channels.contact.tier.list",
  "security.identity.status",
  "security.audit",
  "security.voiceprint.threshold.get",
  "policy.get",
  "policy.domains.list",
  "policy.incidents.list",
  "psyche.mode.get",
  "psyche.shadow.stats",
  "psyche.training.summary",
  "psyche.slowbrain.get",
  "learning.gate.get",
  "nodes.list",
  "nodes.status",
  "nodes.governance.summary",
  "nodes.describe",
  "nodes.pair.list",
  "devices.list",
  "skills.status",
  "miya.sync.list",
  "miya.sync.diff",
  "miya.sync.verify",
  "miya.sync.preflight",
  "mcp.capabilities.list",
  "openclaw.status.get",
  "openclaw.skills.list",
  "openclaw.session.status",
  "openclaw.pairing.query",
  "openclaw.routing.map",
  "openclaw.audit.replay",
  "media.get",
  "media.list",
  "voice.status",
  "voice.history.list",
  "canvas.status",
  "canvas.list",
  "canvas.get",
  "companion.status",
  "companion.persona.presets.list",
  "companion.world.presets.list",
  "companion.session.persona_world.get",
  "companion.wizard.status",
  "companion.memory.list",
  "companion.memory.pending.list",
  "companion.memory.corrections.list",
  "companion.memory.search",
  "companion.memory.vector.list",
  "companion.memory.drift.report",
  "companion.learning.metrics.get",
  "miya.memory.sqlite.stats",
  "miya.memory.embedding.providers.list",
  "miya.memory.embedding.provider.get",
  "miya.memory.graph.stats",
  "miya.memory.graph.search",
  "miya.memory.graph.neighbors",
  "miya.memory.recall.benchmark.run",
  "miya.memory.reflect.queue.list",
  "daemon.vram.budget",
  "daemon.vram.hydraulics.get",
  "autoflow.status.get",
  "routing.stats.get",
  "lifecycle.sync.plan",
  "desktop.automation.kpi.get",
  "desktop.replay.skills.list",
  "learning.drafts.stats",
  "learning.drafts.list",
  "learning.drafts.recommend",
  "intervention.approve",
  "intervention.pause",
  "intervention.kill",
  "intervention.annotate"
]);
function assertConsoleMethodAllowed(method, context) {
  if (context.role !== "ui")
    return;
  const normalized = method.startsWith("v2.") ? method.slice(3) : method;
  if (UI_ALLOWED_METHODS.has(method) || UI_ALLOWED_METHODS.has(normalized))
    return;
  throw new Error(`console_method_forbidden:${method}`);
}
function interventionAuditFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "audit", "intervention.jsonl");
}
function appendInterventionAudit(projectDir, input) {
  const id = `intervention_${randomUUID24()}`;
  const file3 = interventionAuditFile(projectDir);
  fs62.mkdirSync(path61.dirname(file3), { recursive: true });
  fs62.appendFileSync(file3, `${JSON.stringify({
    id,
    at: nowIso42(),
    ...input
  })}
`, "utf-8");
  return id;
}
function normalizeApprovalTier(input) {
  if (input === "high" || input === "thorough")
    return "THOROUGH";
  if (input === "low" || input === "light")
    return "LIGHT";
  return "STANDARD";
}
async function invokeGatewayMethod(projectDir, runtime, method, params, context) {
  assertConsoleMethodAllowed(method, context);
  if (shouldGuardMethod(method)) {
    const texts = collectStringValues(params);
    for (const text of texts) {
      if (await enforceCriticalIntentGuard(projectDir, {
        sessionID: parseText2(params.sessionID) || "main",
        text,
        source: `method:${method}`
      })) {
        throw new Error("kill_switch_triggered_by_critical_intent");
      }
    }
  }
  try {
    const result = await runtime.methods.invoke(method, params, context);
    appendToolActionLedgerEvent(projectDir, {
      method,
      clientID: context.clientID,
      role: context.role,
      params,
      status: "completed",
      result
    });
    recordStrategyObservation(projectDir, {
      experiment: "approval_threshold",
      variant: resolveStrategyVariant(projectDir, "approval_threshold", context.clientID),
      subjectID: context.clientID,
      success: true,
      riskScore: 0.12,
      metadata: {
        method,
        role: context.role
      }
    });
    return result;
  } catch (error92) {
    appendToolActionLedgerEvent(projectDir, {
      method,
      clientID: context.clientID,
      role: context.role,
      params,
      status: "failed",
      error: error92 instanceof Error ? error92.message : String(error92)
    });
    const message = error92 instanceof Error ? error92.message : String(error92);
    recordStrategyObservation(projectDir, {
      experiment: "approval_threshold",
      variant: resolveStrategyVariant(projectDir, "approval_threshold", context.clientID),
      subjectID: context.clientID,
      success: false,
      riskScore: /approval_required|forbidden|policy_|kill_switch/i.test(message) ? 0.9 : 0.6,
      metadata: {
        method,
        role: context.role,
        error: message
      }
    });
    throw error92;
  }
}
function parseExecSpec(raw) {
  const input = raw.trim();
  if (!input)
    return null;
  const tokens = [];
  let current = "";
  let quote = null;
  for (let i = 0;i < input.length; i += 1) {
    const ch = input[i] ?? "";
    if ((ch === '"' || ch === "'") && (!quote || quote === ch)) {
      quote = quote ? null : ch;
      continue;
    }
    if (!quote && /\s/.test(ch)) {
      if (current)
        tokens.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current)
    tokens.push(current);
  if (tokens.length === 0)
    return null;
  return {
    command: tokens[0],
    args: tokens.slice(1)
  };
}
async function verifyVoiceprintWithLocalModel(projectDir, input) {
  const config3 = readConfig(projectDir);
  const strictFromConfig = config3.security?.voiceprint?.strict !== false;
  const strict = process.env.MIYA_VOICEPRINT_STRICT !== undefined ? process.env.MIYA_VOICEPRINT_STRICT !== "0" : strictFromConfig;
  const hintMode = resolveInteractionMode(projectDir, {
    speakerHint: input.speakerHint,
    speakerScore: input.speakerScore
  });
  const audioPath = (input.mediaPath ?? "").trim();
  const cmdRaw = String(process.env.MIYA_VOICEPRINT_VERIFY_CMD ?? "").trim();
  if (!audioPath || !fs62.existsSync(audioPath)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "no_audio"
    };
  }
  if (!cmdRaw) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : undefined,
      source: "strict_no_cmd"
    };
  }
  const spec = parseExecSpec(cmdRaw);
  if (!spec) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : undefined,
      source: "strict_invalid_cmd"
    };
  }
  const state = readOwnerIdentityState(projectDir);
  if (!state.voiceprintModelPath || !fs62.existsSync(state.voiceprintModelPath)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_model_missing"
    };
  }
  if (!state.voiceprintSampleDir || !fs62.existsSync(state.voiceprintSampleDir)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_samples_missing"
    };
  }
  const daemon = getMiyaClient(projectDir);
  const args = spec.args.map((item) => item.replaceAll("{audio}", audioPath).replaceAll("{model}", state.voiceprintModelPath).replaceAll("{samples}", state.voiceprintSampleDir || "").replaceAll("{embedding}", state.voiceprintEmbeddingID ?? ""));
  try {
    const result = await daemon.runIsolatedProcess({
      kind: "voice.asr",
      command: spec.command,
      args,
      timeoutMs: 45000,
      resource: {
        priority: 90,
        vramMB: 256,
        modelID: "local:eres2net",
        modelVramMB: 512
      },
      metadata: { stage: "security.voiceprint.verify", audioPath }
    });
    if (result.exitCode !== 0) {
      return {
        mode: strict ? "unknown" : hintMode,
        score: input.speakerScore,
        source: "strict_cmd_failed"
      };
    }
    const stdout = result.stdout.trim();
    const parsed = JSON.parse(stdout);
    const score = typeof parsed.speaker_score === "number" ? Number(parsed.speaker_score) : input.speakerScore;
    const liveness = typeof parsed.liveness_score === "number" ? Number(parsed.liveness_score) : undefined;
    const sampleDuration = typeof parsed.sample_duration_sec === "number" ? Number(parsed.sample_duration_sec) : undefined;
    const diarization = Array.isArray(parsed.diarization) ? parsed.diarization : [];
    const ownerSegments = diarization.filter((seg) => String(seg.speaker ?? "").toLowerCase() === "owner").length;
    const thresholds = state.voiceprintThresholds;
    const diarizationLooksOwner = diarization.length === 0 ? true : ownerSegments / diarization.length >= thresholds.ownerMinDiarizationRatio;
    const sampleDurationOk = typeof sampleDuration !== "number" || sampleDuration >= thresholds.minSampleDurationSec;
    const mode = parsed.mode && ["owner", "guest", "unknown"].includes(parsed.mode) ? parsed.mode : !sampleDurationOk ? "unknown" : typeof score === "number" ? score >= thresholds.ownerMinScore && (liveness ?? 1) >= thresholds.ownerMinLiveness && diarizationLooksOwner ? "owner" : score < thresholds.guestMaxScore || typeof liveness === "number" && liveness < thresholds.guestMaxLiveness ? "guest" : "unknown" : "unknown";
    return { mode, score, source: "voiceprint_cmd" };
  } catch {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_cmd_error"
    };
  }
}
function normalizeRuntimeDependencyRecommendations(status) {
  const fromPlan = Array.isArray(status.repairPlan?.recommendations) ? status.repairPlan?.recommendations ?? [] : [];
  if (fromPlan.length > 0)
    return fromPlan;
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const fallback = [];
  if (issues.some((issue3) => issue3.startsWith("torch_not_installed"))) {
    fallback.push({
      package: "torch",
      recommendedVersion: ">=2.2.0",
      reason: "PyTorch runtime is required by FLUX/GPT-SoVITS tasks.",
      command: 'pip install "torch>=2.2.0" "torchvision>=0.17.0" "torchaudio>=2.2.0"'
    });
  }
  if (issues.some((issue3) => issue3.startsWith("ffmpeg_missing"))) {
    fallback.push({
      package: "ffmpeg",
      recommendedVersion: "system_latest",
      reason: "Audio conversion requires ffmpeg binary in PATH.",
      command: "winget install --id Gyan.FFmpeg -e"
    });
  }
  if (fallback.length === 0 && issues.length > 0) {
    fallback.push({
      package: "python-deps",
      recommendedVersion: "requirements.txt",
      reason: "Environment check reported dependency issues.",
      command: "python -m pip install --upgrade pip setuptools wheel && python -m pip install --disable-pip-version-check -r miya-src/python/requirements.txt"
    });
  }
  return fallback;
}
function buildDependencyAssistPrompt(status) {
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const recommendations = normalizeRuntimeDependencyRecommendations(status);
  const recommendationLines = recommendations.map((item) => `- ${item.package} ${item.recommendedVersion}
  reason: ${item.reason}
  cmd: ${item.command}`).join(`
`);
  return [
    "Miya dependency fault detected in local Python runtime.",
    `python: ${status.pythonPath ?? "unknown"}`,
    `issues: ${issues.join(", ") || "none"}`,
    "Please produce a short repair guide with exact commands and conflict explanation.",
    "Use and refine these baseline recommendations:",
    recommendationLines || "- reinstall requirements and inspect pip stderr"
  ].join(`
`);
}
async function maybeTriggerDependencyAssist(projectDir, runtime, status) {
  const issueType = status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok";
  if (issueType !== "dependency_fault")
    return { triggered: false };
  const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
  const digest2 = hashText3(prompt);
  if (runtime.dependencyAssistHashes.has(digest2)) {
    return { triggered: false };
  }
  runtime.dependencyAssistHashes.add(digest2);
  const routed = await routeSessionMessage(projectDir, {
    sessionID: "main",
    source: "daemon.python.env.dependency_fault",
    text: prompt
  });
  return { triggered: true, routed };
}
function deriveRiskLevel(input) {
  if (input.containsSensitive && (input.factorIntentSuspicious || !input.factorRecipientIsMe)) {
    return "HIGH";
  }
  if (input.containsSensitive || input.factorIntentSuspicious) {
    return "MEDIUM";
  }
  return "LOW";
}
function requirePolicyHash(projectDir, providedHash) {
  const policyGuard = assertPolicyHash(projectDir, providedHash);
  if (!policyGuard.ok) {
    throw new Error(`${policyGuard.reason}:expected=${policyGuard.hash}`);
  }
  return policyGuard.hash;
}
function requireDomainRunning(projectDir, domain3) {
  if (!isDomainRunning(projectDir, domain3) || !isDomainExecutionAllowed(projectDir, domain3)) {
    throw new Error(`domain_paused:${domain3}`);
  }
}
function requireOwnerMode(projectDir) {
  const disableByEnv = process.env.MIYA_DISABLE_OWNER_CHECK === "1" || String(process.env.DISABLE_OWNER_CHECK ?? "").trim().toLowerCase() === "true";
  if (disableByEnv)
    return;
  const config3 = readConfig(projectDir);
  const strictOwnerCheck = config3.security?.ownerCheck ?? false;
  if (!strictOwnerCheck)
    return;
  const state = readOwnerIdentityState(projectDir);
  if (state.mode !== "owner") {
    throw new Error(`owner_mode_required:current=${state.mode}`);
  }
}
function resolveNegotiationID(input) {
  const explicit = (input.explicitID ?? "").trim();
  if (explicit)
    return explicit;
  const consultAuditID = (input.consultAuditID ?? "").trim();
  if (consultAuditID)
    return consultAuditID;
  return `neg_${hashText3(`${input.sessionID}|${input.channel}|${input.destination}|${input.payloadHash}`).slice(0, 24)}`;
}
function consumeNegotiationBudget(input) {
  const applied = applyNegotiationBudget(input.runtime.negotiationBudgets, {
    key: input.negotiationID,
    fixability: input.fixability,
    budget: input.budget,
    attemptType: input.attemptType
  });
  if (applied.allowed)
    return { ok: true, state: applied.state };
  return {
    ok: false,
    state: applied.state,
    reason: applied.reason
  };
}
function proactiveTargetKey(channel, destination) {
  return `${channel}:${destination.trim().toLowerCase()}`;
}
function localDayKey(now, timezoneOffsetMinutes) {
  const shifted = new Date(now.getTime() + timezoneOffsetMinutes * 60000);
  const year = shifted.getUTCFullYear();
  const month = String(shifted.getUTCMonth() + 1).padStart(2, "0");
  const day = String(shifted.getUTCDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}
function readProactivePingState(projectDir, mode, now = new Date) {
  const raw = safeReadJsonObject(proactivePingStateFile(projectDir));
  const dayKey = localDayKey(now, mode.quietHoursTimezoneOffsetMinutes);
  const storedDay = typeof raw?.dayKey === "string" ? raw.dayKey : "";
  const sentTodayRaw = Number(raw?.sentToday ?? 0);
  const sentToday = Number.isFinite(sentTodayRaw) ? Math.max(0, Math.floor(sentTodayRaw)) : 0;
  const sentByTargetRaw = raw?.sentByTarget && typeof raw.sentByTarget === "object" && !Array.isArray(raw.sentByTarget) ? raw.sentByTarget : {};
  const sentByTarget = {};
  for (const [key, value] of Object.entries(sentByTargetRaw)) {
    if (typeof value !== "string" || !value.trim())
      continue;
    sentByTarget[key] = value;
  }
  if (storedDay !== dayKey) {
    return {
      dayKey,
      sentToday: 0,
      sentByTarget: {}
    };
  }
  return {
    dayKey,
    sentToday,
    sentByTarget
  };
}
function writeProactivePingState(projectDir, state) {
  writeJsonAtomic(proactivePingStateFile(projectDir), {
    updatedAt: nowIso42(),
    dayKey: state.dayKey,
    sentToday: state.sentToday,
    sentByTarget: state.sentByTarget
  });
}
function isQuietHoursActive(mode, now = new Date) {
  if (!mode.quietHoursEnabled)
    return false;
  const start = quietHourTextToMinutes(mode.quietHoursStart);
  const end = quietHourTextToMinutes(mode.quietHoursEnd);
  const shifted = new Date(now.getTime() + mode.quietHoursTimezoneOffsetMinutes * 60000);
  const minuteNow = shifted.getUTCHours() * 60 + shifted.getUTCMinutes();
  if (start === end)
    return true;
  if (start < end)
    return minuteNow >= start && minuteNow < end;
  return minuteNow >= start || minuteNow < end;
}
function nextQuietHoursReleaseSeconds(mode, now = new Date) {
  if (!mode.quietHoursEnabled)
    return 0;
  if (!isQuietHoursActive(mode, now))
    return 0;
  const end = quietHourTextToMinutes(mode.quietHoursEnd);
  const shifted = new Date(now.getTime() + mode.quietHoursTimezoneOffsetMinutes * 60000);
  const minuteNow = shifted.getUTCHours() * 60 + shifted.getUTCMinutes();
  let minutesUntil = 0;
  if (minuteNow === end) {
    minutesUntil = 0;
  } else if (minuteNow < end) {
    minutesUntil = end - minuteNow;
  } else {
    minutesUntil = 24 * 60 - minuteNow + end;
  }
  return Math.max(60, minutesUntil * 60);
}
function checkProactivePingGate(input) {
  const now = input.now ?? new Date;
  if (!input.mode.proactivePingEnabled) {
    return { ok: false, reason: "proactive_ping_disabled", retryAfterSec: 300 };
  }
  if (isQuietHoursActive(input.mode, now)) {
    return {
      ok: false,
      reason: "quiet_hours",
      retryAfterSec: nextQuietHoursReleaseSeconds(input.mode, now)
    };
  }
  const state = readProactivePingState(input.projectDir, input.mode, now);
  if (state.sentToday >= input.mode.proactivePingMaxPerDay) {
    return {
      ok: false,
      reason: "proactive_daily_quota_reached",
      retryAfterSec: 60 * 30
    };
  }
  const targetKey = proactiveTargetKey(input.channel, input.destination);
  const last = state.sentByTarget[targetKey];
  if (last) {
    const lastMs = Date.parse(last);
    if (Number.isFinite(lastMs)) {
      const minIntervalMs = input.mode.proactivePingMinIntervalMinutes * 60000;
      const remainingMs = minIntervalMs - (now.getTime() - lastMs);
      if (remainingMs > 0) {
        return {
          ok: false,
          reason: "proactive_interval_limited",
          retryAfterSec: Math.max(60, Math.ceil(remainingMs / 1000))
        };
      }
    }
  }
  return { ok: true };
}
function markProactivePingSent(projectDir, mode, channel, destination, at = new Date) {
  const state = readProactivePingState(projectDir, mode, at);
  state.sentToday += 1;
  state.sentByTarget[proactiveTargetKey(channel, destination)] = at.toISOString();
  writeProactivePingState(projectDir, state);
}
function pendingOutboundQueueFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "gateway-pending-outbound-queue.json");
}
function readPendingOutboundQueue(projectDir) {
  const file3 = pendingOutboundQueueFile(projectDir);
  const raw = safeReadJsonObject(file3);
  const rows = Array.isArray(raw?.items) ? raw.items : [];
  const out = [];
  for (const row of rows) {
    if (!row || typeof row !== "object")
      continue;
    const request = row.request;
    if (!request || typeof request !== "object")
      continue;
    const requestObj = request;
    if (!isChannelName(requestObj.channel))
      continue;
    if (typeof requestObj.destination !== "string" || typeof requestObj.text !== "string")
      continue;
    const id = parseText2(row.id) || `poq_${randomUUID24()}`;
    const createdAt = parseText2(row.createdAt) || nowIso42();
    const nextRunAt = parseText2(row.nextRunAt) || nowIso42();
    const attemptsRaw = Number(row.attempts);
    const attempts = Number.isFinite(attemptsRaw) ? Math.max(0, Math.floor(attemptsRaw)) : 0;
    const payloadHash = parseText2(row.payloadHash) || hashText3(`${requestObj.channel}|${requestObj.destination}|${requestObj.text}|${requestObj.mediaPath ?? ""}`);
    out.push({
      id,
      createdAt,
      nextRunAt,
      attempts,
      lastReason: parseText2(row.lastReason),
      payloadHash,
      request: requestObj
    });
  }
  return out.slice(-400);
}
function writePendingOutboundQueue(projectDir, items) {
  writeJsonAtomic(pendingOutboundQueueFile(projectDir), {
    updatedAt: nowIso42(),
    items: items.slice(-400)
  });
}
function clearPendingOutboundScheduler(runtime) {
  if (!runtime.pendingQueueKickTimer)
    return;
  clearTimeout(runtime.pendingQueueKickTimer);
  runtime.pendingQueueKickTimer = undefined;
}
function schedulePendingOutboundQueue(projectDir, runtime, options) {
  clearPendingOutboundScheduler(runtime);
  if (runtime.pendingQueueBusy) {
    runtime.pendingQueueRescheduleNeeded = true;
    return;
  }
  if (runtime.pendingOutboundQueue.length === 0)
    return;
  runtime.pendingOutboundQueue.sort((a, b) => Date.parse(a.nextRunAt) - Date.parse(b.nextRunAt));
  const next = runtime.pendingOutboundQueue[0];
  const runAt = next ? Date.parse(next.nextRunAt) : Number.NaN;
  const delay = options?.immediate === true ? 0 : Number.isFinite(runAt) ? Math.max(0, Math.min(30000, runAt - Date.now())) : 0;
  const generation = runtime.pendingQueueGeneration;
  runtime.pendingQueueKickTimer = setTimeout(() => {
    runtime.pendingQueueKickTimer = undefined;
    const active = runtimes2.get(projectDir);
    if (!active || active !== runtime)
      return;
    if (active.pendingQueueGeneration !== generation)
      return;
    processPendingOutboundQueue(projectDir, active).catch((error92) => {
      periodicTaskError(projectDir, error92);
      schedulePendingOutboundQueue(projectDir, active, { immediate: false });
    });
  }, delay);
}
function enqueuePendingOutbound(input) {
  const retryAfterSec = Math.max(10, Math.min(900, Math.floor(input.retryAfterSec)));
  const now = Date.now();
  const queue = input.runtime.pendingOutboundQueue;
  const negotiationID = parseText2(input.request.outboundCheck?.negotiationID);
  const existing = queue.find((item2) => {
    const sameNegotiation = negotiationID.length > 0 && parseText2(item2.request.outboundCheck?.negotiationID) === negotiationID;
    if (sameNegotiation)
      return true;
    return item2.request.channel === input.request.channel && item2.request.destination === input.request.destination && item2.payloadHash === input.payloadHash;
  });
  const nextRunAtIso = new Date(now + retryAfterSec * 1000).toISOString();
  if (existing) {
    existing.nextRunAt = nextRunAtIso;
    existing.lastReason = input.reason;
    existing.request = input.request;
    writePendingOutboundQueue(input.projectDir, queue);
    schedulePendingOutboundQueue(input.projectDir, input.runtime);
    return existing;
  }
  const item = {
    id: `poq_${randomUUID24()}`,
    createdAt: nowIso42(),
    nextRunAt: nextRunAtIso,
    attempts: 0,
    lastReason: input.reason,
    payloadHash: input.payloadHash,
    request: input.request
  };
  queue.push(item);
  if (queue.length > 400)
    queue.splice(0, queue.length - 400);
  writePendingOutboundQueue(input.projectDir, queue);
  schedulePendingOutboundQueue(input.projectDir, input.runtime);
  return item;
}
function removePendingOutboundByNegotiationID(projectDir, runtime, negotiationID) {
  const key = parseText2(negotiationID);
  if (!key)
    return;
  const next = runtime.pendingOutboundQueue.filter((item) => parseText2(item.request.outboundCheck?.negotiationID) !== key);
  if (next.length === runtime.pendingOutboundQueue.length)
    return;
  runtime.pendingOutboundQueue = next;
  writePendingOutboundQueue(projectDir, runtime.pendingOutboundQueue);
  schedulePendingOutboundQueue(projectDir, runtime);
}
async function processPendingOutboundQueue(projectDir, runtime) {
  if (runtime.pendingQueueBusy)
    return;
  const generation = runtime.pendingQueueGeneration;
  runtime.pendingQueueBusy = true;
  try {
    if (!runtimes2.has(projectDir))
      return;
    if (runtime.pendingOutboundQueue.length === 0)
      return;
    const nowMs = Date.now();
    runtime.pendingOutboundQueue.sort((a, b) => Date.parse(a.nextRunAt) - Date.parse(b.nextRunAt));
    const item = runtime.pendingOutboundQueue.find((candidate) => {
      const runAt = Date.parse(candidate.nextRunAt);
      return Number.isFinite(runAt) && runAt <= nowMs;
    });
    if (!item)
      return;
    item.attempts += 1;
    const outboundCheck = item.request.outboundCheck ?? {};
    let send;
    try {
      send = await sendChannelMessageGuarded(projectDir, runtime, {
        ...item.request,
        outboundCheck: {
          ...outboundCheck,
          userInitiated: false,
          pendingQueueDelivery: true,
          retryAttemptType: "auto"
        }
      });
    } catch (error92) {
      if (runtime.pendingQueueGeneration !== generation || !runtimes2.has(projectDir))
        return;
      item.lastReason = error92 instanceof Error ? error92.message : String(error92);
      item.nextRunAt = new Date(Date.now() + Math.min(900, 30 * Math.max(1, item.attempts)) * 1000).toISOString();
      writePendingOutboundQueue(projectDir, runtime.pendingOutboundQueue);
      return;
    }
    if (runtime.pendingQueueGeneration !== generation || !runtimes2.has(projectDir))
      return;
    const sent = Boolean(send.sent);
    if (sent) {
      runtime.pendingOutboundQueue = runtime.pendingOutboundQueue.filter((row) => row.id !== item.id);
      writePendingOutboundQueue(projectDir, runtime.pendingOutboundQueue);
      return;
    }
    const message = parseText2(send.message);
    const retryAfterSecRaw = Number(send.retryAfterSec);
    const retryAfterSec = Number.isFinite(retryAfterSecRaw) ? Math.max(10, Math.min(900, Math.floor(retryAfterSecRaw))) : Math.min(900, 30 * Math.max(1, item.attempts));
    if (message.includes("negotiation_budget_exhausted") || message.includes("psyche_denied") || message.includes("high_risk_confirmation_required")) {
      runtime.pendingOutboundQueue = runtime.pendingOutboundQueue.filter((row) => row.id !== item.id);
      writePendingOutboundQueue(projectDir, runtime.pendingOutboundQueue);
      return;
    }
    item.lastReason = message || "pending_retry";
    item.nextRunAt = new Date(Date.now() + retryAfterSec * 1000).toISOString();
    writePendingOutboundQueue(projectDir, runtime.pendingOutboundQueue);
  } finally {
    runtime.pendingQueueBusy = false;
    let shouldReschedule = true;
    if (runtime.pendingQueueGeneration !== generation || !runtimes2.has(projectDir)) {
      runtime.pendingQueueRescheduleNeeded = false;
      clearPendingOutboundScheduler(runtime);
      shouldReschedule = false;
    }
    if (shouldReschedule) {
      const immediate = runtime.pendingQueueRescheduleNeeded;
      runtime.pendingQueueRescheduleNeeded = false;
      schedulePendingOutboundQueue(projectDir, runtime, { immediate });
    }
  }
}
async function sendChannelMessageGuarded(projectDir, runtime, input) {
  const resolvedPolicyHash = requirePolicyHash(projectDir, input.policyHash);
  requireDomainRunning(projectDir, "outbound_send");
  requireDomainRunning(projectDir, "desktop_control");
  const identity = readOwnerIdentityState(projectDir);
  const localPhysicalConfirmed = Boolean(input.confirmation?.physicalConfirmed);
  const localPasswordVerified = verifyOwnerPasswordOnly(projectDir, input.confirmation?.password);
  const localGuestOverride = (identity.mode === "guest" || identity.mode === "unknown") && localPhysicalConfirmed && localPasswordVerified;
  if ((identity.mode === "guest" || identity.mode === "unknown") && !localGuestOverride) {
    return {
      sent: false,
      message: "outbound_blocked:guest_mode",
      policyHash: currentPolicyHash(projectDir)
    };
  }
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = hashText3(`${input.text}||${mediaPath}`);
  const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
  const intent = input.outboundCheck?.intent ?? "initiate";
  const factorRecipientIsMeInput = input.outboundCheck?.factorRecipientIsMe;
  const factorRecipientIsMe = typeof factorRecipientIsMeInput === "boolean" ? factorRecipientIsMeInput : getContactTier(projectDir, input.channel, input.destination) === "owner";
  const containsSensitive = containsSensitiveText(input.text);
  const factorIntentSuspicious = inferIntentSuspicious(input.text);
  const confidenceIntentRaw = factorIntentSuspicious ? 0.35 : containsSensitive ? 0.75 : 0.95;
  const riskLevel = deriveRiskLevel({
    containsSensitive,
    factorIntentSuspicious,
    factorRecipientIsMe
  });
  const captureLimitations = Array.isArray(input.outboundCheck?.captureLimitations) ? input.outboundCheck.captureLimitations : [];
  let evidenceConfidence = typeof input.outboundCheck?.evidenceConfidence === "number" && Number.isFinite(input.outboundCheck.evidenceConfidence) ? Number(input.outboundCheck.evidenceConfidence) : confidenceIntentRaw;
  evidenceConfidence = Math.max(0, Math.min(1, evidenceConfidence));
  if (captureLimitations.some((item) => item === "no_desktop_screenshot" || item === "pixel_evidence_unavailable" || item.startsWith("capture_tree_exhausted") || item === "capture_method_unspecified")) {
    evidenceConfidence = Math.min(evidenceConfidence, 0.34);
  }
  const userInitiated = input.outboundCheck?.userInitiated !== false;
  const pendingQueueDelivery = input.outboundCheck?.pendingQueueDelivery === true;
  const proactivePing = input.outboundCheck?.proactivePing === true;
  const queueDeferredOutbound = (inputQueue) => {
    if (userInitiated || pendingQueueDelivery)
      return;
    const request = {
      ...input,
      outboundCheck: {
        ...input.outboundCheck ?? {},
        userInitiated: false,
        pendingQueueDelivery: false,
        negotiationID: inputQueue.negotiationID ?? input.outboundCheck?.negotiationID
      }
    };
    enqueuePendingOutbound({
      projectDir,
      runtime,
      request,
      payloadHash,
      reason: inputQueue.reason,
      retryAfterSec: inputQueue.retryAfterSec
    });
  };
  if (proactivePing && !userInitiated) {
    const proactiveGate = checkProactivePingGate({
      projectDir,
      mode: runtime.nexus.psycheMode,
      channel: input.channel,
      destination: input.destination
    });
    if (!proactiveGate.ok) {
      appendNexusInsight(runtime, {
        text: proactiveGate.reason === "quiet_hours" ? "proactive_ping  quiet_hours " : `proactive_ping ${proactiveGate.reason}`
      });
      const negotiationID2 = resolveNegotiationID({
        explicitID: input.outboundCheck?.negotiationID,
        sessionID: input.sessionID,
        channel: input.channel,
        destination: input.destination,
        payloadHash
      });
      const budgetState = consumeNegotiationBudget({
        runtime,
        negotiationID: negotiationID2,
        fixability: "retry_later",
        budget: { autoRetry: 1, humanEdit: 1 },
        attemptType: input.outboundCheck?.retryAttemptType
      });
      if (!budgetState.ok) {
        removePendingOutboundByNegotiationID(projectDir, runtime, negotiationID2);
        return {
          sent: false,
          message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
          policyHash: resolvedPolicyHash,
          retryAfterSec: proactiveGate.retryAfterSec,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          approvalMode: "modal_approval",
          negotiationID: negotiationID2
        };
      }
      queueDeferredOutbound({
        retryAfterSec: proactiveGate.retryAfterSec,
        reason: `outbound_blocked:${proactiveGate.reason}`,
        negotiationID: negotiationID2
      });
      return {
        sent: false,
        message: `outbound_blocked:${proactiveGate.reason}`,
        policyHash: resolvedPolicyHash,
        retryAfterSec: proactiveGate.retryAfterSec,
        fixability: "retry_later",
        budget: { autoRetry: 1, humanEdit: 1 },
        approvalMode: proactiveGate.reason === "quiet_hours" ? "toast_gate" : "modal_approval",
        negotiationID: negotiationID2
      };
    }
  }
  if (isHighRiskInstruction(input.text)) {
    const physicalConfirmed = localPhysicalConfirmed;
    const secretVerified = verifyOwnerSecrets(projectDir, {
      password: input.confirmation?.password,
      passphrase: input.confirmation?.passphrase
    });
    if (!physicalConfirmed || !secretVerified) {
      return {
        sent: false,
        message: "outbound_blocked:high_risk_confirmation_required",
        requiresConfirmation: true,
        policyHash: currentPolicyHash(projectDir)
      };
    }
    const ownerSyncRequired = process.env.MIYA_OWNER_SYNC_REQUIRED !== "0";
    if (ownerSyncRequired && !localGuestOverride) {
      const providedOwnerSyncToken = String(input.confirmation?.ownerSyncToken ?? "").trim();
      if (!providedOwnerSyncToken) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: "outbound_blocked:owner_sync_confirmation_required",
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: ` QQ/ :  ${pending.token}10`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      const ownerSync = verifyOwnerSyncToken(projectDir, {
        token: providedOwnerSyncToken,
        action: "outbound.high_risk.send",
        payloadHash
      });
      if (!ownerSync.ok) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: `outbound_blocked:owner_sync_confirmation_required:${ownerSync.reason ?? "invalid_token"}`,
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: ` QQ/ :  ${pending.token}10`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      consumeOwnerSyncToken(projectDir, providedOwnerSyncToken);
    }
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    const cached3 = runtime.outboundSendDedupe.get(key);
    if (cached3) {
      return {
        ...cached3.result,
        cached: true
      };
    }
  }
  const fusion = evaluateOutboundDecisionFusion({
    factorTextSensitive: containsSensitive,
    factorRecipientIsMe,
    factorIntentSuspicious,
    confidenceIntent: confidenceIntentRaw,
    trustMinScore: runtime.nexus.trust?.minScore,
    trustMode: runtime.nexus.trustMode,
    evidenceConfidence
  });
  if (fusion.action === "hard_fuse") {
    const safetyState = transitionSafetyState(projectDir, {
      source: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: "decision_fusion_hard",
        keyAssertion: "A=contains_sensitive and decision fusion matched in danger zone (confidence < 0.5).",
        recovery: "Review outbound intent in OpenCode and manually resume paused domains after confirmation."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya",
      `: ${incident.reason}`,
      `: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      ": "
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_hard",
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (fusion.action === "soft_fuse") {
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_soft",
      reason: "outbound_blocked:decision_fusion_soft_confirmation_required",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      semanticSummary: {
        trigger: "decision_fusion_soft",
        keyAssertion: "Decision fusion matched in gray zone (0.5 <= confidence <= 0.85), manual confirmation required.",
        recovery: "Confirm outbound intent in OpenCode, then retry with explicit approval."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya",
      `: ${incident.reason}`,
      `: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      ": "
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_soft_confirmation_required",
      requiresConfirmation: true,
      policyHash: resolvedPolicyHash,
      incident
    };
  }
  const psycheMode = runtime.nexus.psycheMode;
  const psycheConsultEnabled = resolvePsycheConsultEnabled(projectDir, psycheMode);
  const signalOverrideEnabled = psycheMode.signalOverrideEnabled === true;
  const overrideSignals = signalOverrideEnabled ? input.outboundCheck?.psycheSignals : undefined;
  const psycheShadowSampled = shouldSamplePsycheShadow({
    mode: psycheMode,
    sessionID: input.sessionID,
    payloadHash
  });
  const primarySlowBrainEnabled = psycheMode.slowBrainEnabled && psycheConsultEnabled;
  if (!psycheMode.resonanceEnabled && !userInitiated) {
    runtime.nexus.guardianSafeHoldReason = "resonance_disabled";
    appendNexusInsight(runtime, {
      text: ""
    });
    const negotiationID2 = resolveNegotiationID({
      explicitID: input.outboundCheck?.negotiationID,
      sessionID: input.sessionID,
      channel: input.channel,
      destination: input.destination,
      payloadHash
    });
    const budgetState = consumeNegotiationBudget({
      runtime,
      negotiationID: negotiationID2,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      attemptType: input.outboundCheck?.retryAttemptType
    });
    if (!budgetState.ok) {
      removePendingOutboundByNegotiationID(projectDir, runtime, negotiationID2);
      return {
        sent: false,
        message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
        policyHash: resolvedPolicyHash,
        retryAfterSec: 120,
        fixability: "retry_later",
        budget: { autoRetry: 1, humanEdit: 1 },
        approvalMode: "modal_approval",
        negotiationID: negotiationID2
      };
    }
    queueDeferredOutbound({
      retryAfterSec: 120,
      reason: "outbound_blocked:resonance_disabled_safe_hold",
      negotiationID: negotiationID2
    });
    return {
      sent: false,
      message: "outbound_blocked:resonance_disabled_safe_hold",
      policyHash: resolvedPolicyHash,
      retryAfterSec: 120,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      approvalMode: "toast_gate",
      negotiationID: negotiationID2,
      psyche: {
        decision: "defer",
        reason: "resonance_disabled_safe_hold",
        state: "UNKNOWN"
      }
    };
  }
  runtime.nexus.guardianSafeHoldReason = undefined;
  let psycheConsult = null;
  if (primarySlowBrainEnabled) {
    try {
      const daemon = getMiyaClient(projectDir);
      const consult = await withTimeout(daemon.psycheConsult({
        intent: `outbound.send.${input.channel}`,
        urgency: riskLevel === "HIGH" ? "high" : riskLevel === "MEDIUM" ? "medium" : "low",
        channel: input.channel,
        userInitiated,
        allowScreenProbe: psycheMode.captureProbeEnabled,
        allowSignalOverride: signalOverrideEnabled,
        signals: overrideSignals,
        captureLimitations: input.outboundCheck?.captureLimitations,
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence
        }
      }), resolvePsycheConsultTimeoutMs({ userInitiated, shadow: false }), "psyche_consult_timeout");
      psycheConsult = {
        auditID: consult.auditID,
        intent: consult.intent,
        urgency: consult.urgency,
        channel: consult.channel,
        userInitiated: consult.userInitiated,
        state: consult.state
      };
      const approvalMode = resolvePsycheApprovalMode({
        decision: consult.decision,
        urgency: consult.urgency,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      runtime.nexus.trust = consult.trust;
      runtime.nexus.sessionId = input.sessionID;
      runtime.nexus.permission = "external_message";
      appendNexusInsight(runtime, {
        text: consult.insightText,
        auditID: consult.auditID,
        at: consult.at
      });
      publishGatewayEvent(runtime, "insight.append", {
        at: consult.at,
        text: consult.insightText,
        auditID: consult.auditID
      });
      publishGatewayEvent(runtime, "trust.update", {
        at: consult.at,
        auditID: consult.auditID,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      if (consult.decision !== "allow") {
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          consultAuditID: consult.auditID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: consult.fixability,
          budget: consult.budget,
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          removePendingOutboundByNegotiationID(projectDir, runtime, negotiationID2);
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            psyche: consult,
            retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
            fixability: consult.fixability,
            budget: consult.budget,
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        try {
          await daemon.psycheOutcome({
            consultAuditID: consult.auditID,
            intent: consult.intent,
            urgency: consult.urgency,
            channel: consult.channel,
            userInitiated: consult.userInitiated,
            state: consult.state,
            delivered: false,
            blockedReason: consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred",
            trust: {
              target: `${input.channel}:${input.destination}`,
              source: `session:${input.sessionID}`,
              action: `outbound.send.${input.channel}`,
              evidenceConfidence,
              highRiskRollback: riskLevel === "HIGH" && consult.decision === "deny"
            }
          });
        } catch {}
        const blockedMessage = consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred";
        if (consult.decision === "defer") {
          queueDeferredOutbound({
            retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec ?? 120,
            reason: blockedMessage,
            negotiationID: negotiationID2
          });
        }
        return {
          sent: false,
          message: blockedMessage,
          policyHash: resolvedPolicyHash,
          psyche: consult,
          retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
          fixability: consult.fixability,
          budget: consult.budget,
          approvalMode,
          negotiationID: negotiationID2
        };
      }
    } catch (error92) {
      if (!userInitiated) {
        runtime.nexus.guardianSafeHoldReason = "psyche_consult_unavailable";
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          removePendingOutboundByNegotiationID(projectDir, runtime, negotiationID2);
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            retryAfterSec: 30,
            fixability: "retry_later",
            budget: { autoRetry: 1, humanEdit: 1 },
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        queueDeferredOutbound({
          retryAfterSec: 30,
          reason: "outbound_blocked:psyche_deferred",
          negotiationID: negotiationID2
        });
        return {
          sent: false,
          message: "outbound_blocked:psyche_deferred",
          policyHash: resolvedPolicyHash,
          retryAfterSec: 30,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          approvalMode: "modal_approval",
          negotiationID: negotiationID2,
          psyche: {
            decision: "defer",
            reason: "psyche_consult_unavailable",
            state: "UNKNOWN",
            error: error92 instanceof Error ? error92.message : String(error92)
          }
        };
      }
    }
  }
  if (psycheShadowSampled) {
    try {
      const daemon = getMiyaClient(projectDir);
      const shadow = await withTimeout(daemon.psycheConsult({
        intent: `outbound.send.${input.channel}`,
        urgency: riskLevel === "HIGH" ? "high" : riskLevel === "MEDIUM" ? "medium" : "low",
        channel: input.channel,
        userInitiated,
        allowScreenProbe: false,
        allowSignalOverride: signalOverrideEnabled,
        signals: overrideSignals,
        captureLimitations: input.outboundCheck?.captureLimitations,
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence
        }
      }), resolvePsycheConsultTimeoutMs({ userInitiated, shadow: true }), "psyche_shadow_timeout");
      const primaryDecision = primarySlowBrainEnabled ? psycheConsult?.state ? "consulted" : "allow_without_consult" : "allow_by_config";
      appendPsycheShadowAudit(projectDir, {
        sessionID: input.sessionID,
        channel: input.channel,
        destination: input.destination,
        payloadHash,
        primaryDecision,
        shadowDecision: shadow.decision,
        divergence: primarySlowBrainEnabled && psycheConsult === null && shadow.decision !== "allow" || primarySlowBrainEnabled && psycheConsult !== null && shadow.decision === "deny" || !primarySlowBrainEnabled && shadow.decision !== "allow"
      });
    } catch {}
  }
  const outboundTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "external_message",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!outboundTicket.ok)
    throw new Error(`approval_required:${outboundTicket.reason}`);
  const desktopTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "desktop_control",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!desktopTicket.ok)
    throw new Error(`approval_required:${desktopTicket.reason}`);
  const sendFingerprint = hashText3(`${input.channel}|${input.destination}|${payloadHash}|${Math.floor(Date.now() / 60000)}`).slice(0, 40);
  const outboundRuntime = runtime.channelRuntime;
  const result = await outboundRuntime.sendMessage({
    channel: input.channel,
    destination: input.destination,
    text: input.text,
    mediaPath: mediaPath || undefined,
    sessionID: input.sessionID,
    sendFingerprint,
    payloadHash,
    approvalTickets: {
      outboundSend: outboundTicket.ticket,
      desktopControl: desktopTicket.ticket
    },
    outboundCheck: {
      archAdvisorApproved,
      riskLevel,
      intent: intent === "reply" ? "reply" : "initiate",
      containsSensitive,
      policyHash: resolvedPolicyHash
    }
  });
  runtime.nexus.guardianSafeHoldReason = undefined;
  const negotiationID = (input.outboundCheck?.negotiationID ?? "").trim();
  if (Boolean(result.sent) && negotiationID) {
    runtime.negotiationBudgets.delete(negotiationID);
    removePendingOutboundByNegotiationID(projectDir, runtime, negotiationID);
  }
  if (proactivePing && Boolean(result.sent)) {
    markProactivePingSent(projectDir, runtime.nexus.psycheMode, input.channel, input.destination);
  }
  if (psycheConsultEnabled && psycheConsult) {
    try {
      const daemon = getMiyaClient(projectDir);
      await daemon.psycheOutcome({
        consultAuditID: psycheConsult.auditID,
        intent: psycheConsult.intent,
        urgency: psycheConsult.urgency,
        channel: psycheConsult.channel,
        userInitiated: psycheConsult.userInitiated,
        state: psycheConsult.state,
        delivered: Boolean(result.sent),
        blockedReason: result.sent ? undefined : String(result.message ?? ""),
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence,
          highRiskRollback: riskLevel === "HIGH" && !result.sent
        }
      });
    } catch {}
  }
  const violationType = result.message === "outbound_blocked:friend_tier_sensitive_content_denied" ? "friend_tier_sensitive_violation" : result.message === "outbound_blocked:friend_tier_can_only_reply" ? "friend_tier_initiate_violation" : null;
  if (violationType) {
    const safetyState = transitionSafetyState(projectDir, {
      source: "friend_tier_violation",
      reason: result.message,
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: violationType,
      reason: result.message,
      channel: input.channel,
      destination: input.destination,
      auditID: result.auditID,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: violationType,
        keyAssertion: `Outbound to friend tier violated policy (${result.message}).`,
        recovery: "Review recipient tier and outbound payload, then manually resume paused domains."
      },
      semanticTags: ["recipient_mismatch"]
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya",
      `: ${result.message}`,
      `: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `: ${input.channel}, : ${input.destination}`,
      ": /"
    ]);
    return {
      ...result,
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    runtime.outboundSendDedupe.set(key, { ts: Date.now(), result });
    const cutoff = Date.now() - 10 * 60 * 1000;
    for (const [dedupeKey, value] of runtime.outboundSendDedupe.entries()) {
      if (value.ts < cutoff)
        runtime.outboundSendDedupe.delete(dedupeKey);
    }
  }
  return {
    ...result,
    policyHash: resolvedPolicyHash,
    sendFingerprint
  };
}
async function notifySafetyReport(projectDir, sessionID, lines) {
  try {
    await routeSessionMessage(projectDir, {
      sessionID: sessionID || "main",
      text: lines.join(`
`),
      source: "policy:incident"
    });
  } catch {}
}
function enforceInteractionModeIsolation(projectDir, mode) {
  if (mode === "owner")
    return;
  transitionSafetyState(projectDir, {
    source: "interaction_mode_isolation",
    reason: `interaction_mode_${mode}`,
    domains: {
      outbound_send: "paused",
      desktop_control: "paused",
      memory_read: "paused",
      memory_write: "paused",
      memory_delete: "paused"
    }
  });
}
function listBackground(projectDir) {
  const manager = depsOf(projectDir).backgroundManager;
  if (!manager) {
    return { total: 0, running: 0, tasks: [] };
  }
  const tasks = manager.listTasks(100);
  return {
    total: tasks.length,
    running: tasks.filter((item) => item.status === "running").length,
    tasks: tasks.map((item) => ({
      id: item.id,
      description: item.description,
      agent: item.agent,
      status: item.status,
      startedAt: item.startedAt.toISOString(),
      completedAt: item.completedAt?.toISOString()
    }))
  };
}
function collectDoctorIssues(projectDir, runtime, base) {
  const issues = [];
  const host = String(runtime.server.hostname ?? "127.0.0.1");
  if (!runtime.auth.token) {
    issues.push({
      code: "gateway_auth_token_missing",
      severity: "error",
      message: "Gateway auth token is missing.",
      fix: "Set MIYA_GATEWAY_TOKEN or delete runtime auth file to regenerate token."
    });
  }
  if (host !== "127.0.0.1" && host !== "localhost" && !runtime.auth.challengeRequired) {
    issues.push({
      code: "gateway_challenge_not_required",
      severity: "warn",
      message: "Gateway is exposed on non-loopback host without challenge signature enforcement.",
      fix: "Set MIYA_GATEWAY_CHALLENGE_SECRET to enforce optional challenge signatures."
    });
  }
  if (host !== "127.0.0.1" && host !== "localhost") {
    issues.push({
      code: "gateway_bind_non_loopback",
      severity: "warn",
      message: `Gateway bind host is ${host}.`,
      fix: "Use loopback bind by default, or add strict external auth."
    });
  }
  if (base.killSwitch.active) {
    issues.push({
      code: "kill_switch_active",
      severity: "error",
      message: `Kill switch active: ${base.killSwitch.reason ?? "unknown"}.`,
      fix: "Resolve cause and run miya_kill_release."
    });
  }
  const signalHub = base.daemon.psycheSignalHub;
  if (base.daemon.connected && !signalHub) {
    issues.push({
      code: "psyche_signal_hub_status_missing",
      severity: "warn",
      message: "Daemon connected but psyche signal hub status is missing.",
      fix: "Check daemon host status payload and launcher status poll parsing."
    });
  }
  if (signalHub) {
    if (!signalHub.running) {
      issues.push({
        code: "psyche_signal_hub_not_running",
        severity: "warn",
        message: "Psyche native signal hub is not running.",
        fix: "Ensure daemon service start() is called and signal hub bootstrap succeeds."
      });
    }
    if (signalHub.stale) {
      issues.push({
        code: "psyche_signal_hub_stale",
        severity: "warn",
        message: `Psyche signal hub snapshot is stale (${signalHub.ageMs}ms).`,
        fix: "Inspect sensor collectors and sampling interval; verify no timer starvation."
      });
    }
    if (signalHub.consecutiveFailures >= 3) {
      issues.push({
        code: "psyche_signal_hub_collect_failures",
        severity: "error",
        message: `Psyche signal hub has ${signalHub.consecutiveFailures} consecutive collect failures.`,
        fix: "Check windows sensor probes and daemon logs; fallback should remain safe hold."
      });
    }
  }
  const channelStore = readChannelStore(projectDir);
  for (const channel of Object.values(channelStore.channels)) {
    if (channel.enabled && channel.name !== "webchat" && channel.allowlist.length === 0) {
      issues.push({
        code: `channel_allowlist_empty_${channel.name}`,
        severity: "warn",
        message: `${channel.name} enabled without allowlist.`,
        fix: "Approve at least one pair request before auto handling."
      });
    }
  }
  for (const node of base.nodes.list) {
    if (node.connected && !node.paired) {
      issues.push({
        code: `node_unpaired_${node.nodeID}`,
        severity: "warn",
        message: `Node ${node.nodeID} connected but not paired.`,
        fix: "Approve node pairing."
      });
    }
  }
  if (base.skills.discovered.some((item) => !item.gate.loadable)) {
    issues.push({
      code: "skills_gate_failures",
      severity: "info",
      message: "Some skills are gated by missing requirements.",
      fix: "Inspect skills.status and satisfy gate requirements."
    });
  }
  if (base.voice.enabled && base.voice.wakeWordEnabled && !base.voice.talkMode) {
    issues.push({
      code: "voice_wake_without_talk_mode",
      severity: "info",
      message: "Voice wake word is enabled while talk mode is disabled.",
      fix: "Enable talk mode if you expect always-on voice behavior."
    });
  }
  if (base.companion.enabled && !base.companion.onboardingCompleted) {
    issues.push({
      code: "companion_onboarding_incomplete",
      severity: "warn",
      message: "Companion mode enabled before onboarding completion.",
      fix: "Run companion.wizard.start and finish profile setup."
    });
  }
  return issues;
}
function runGatewaySecurityAudit(projectDir, runtime) {
  const findings = [];
  const host = String(runtime.server.hostname ?? "127.0.0.1");
  const tokenSource = runtime.auth.tokenSource;
  if (tokenSource === "generated") {
    findings.push({
      code: "gateway_token_generated",
      severity: "info",
      message: "Gateway token uses local generated secret (default safe baseline enabled).",
      fix: "Set MIYA_GATEWAY_TOKEN if you need deterministic shared token management."
    });
  }
  if (!runtime.auth.challengeRequired && host !== "127.0.0.1" && host !== "localhost") {
    findings.push({
      code: "gateway_challenge_missing_external_bind",
      severity: "warn",
      message: "Gateway bind host is non-loopback while challenge signature is disabled.",
      fix: "Set MIYA_GATEWAY_CHALLENGE_SECRET or bind gateway to loopback."
    });
  }
  if (process.env.MIYA_UI_AUTOMATION_ENABLED === "1" && process.platform !== "win32") {
    findings.push({
      code: "desktop_automation_non_windows",
      severity: "warn",
      message: "Desktop outbound automation is enabled on non-Windows host.",
      fix: "Disable MIYA_UI_AUTOMATION_ENABLED or run on Windows runtime."
    });
  }
  const channelStore = readChannelStore(projectDir);
  for (const channel of Object.values(channelStore.channels)) {
    if (!channel.enabled)
      continue;
    if (channel.name === "webchat")
      continue;
    if (channel.allowlist.length === 0) {
      findings.push({
        code: `channel_allowlist_empty_${channel.name}`,
        severity: "warn",
        message: `${channel.name} channel enabled without allowlist.`,
        fix: "Approve at least one pairing contact or disable the channel."
      });
    }
  }
  let status = "ok";
  if (findings.some((item) => item.severity === "error"))
    status = "error";
  else if (findings.some((item) => item.severity === "warn"))
    status = "warn";
  return {
    scannedAt: nowIso42(),
    status,
    findings
  };
}
function withNodeGovernance(node) {
  return {
    ...node,
    permissionMapping: mapNodePermissions(node),
    capabilityGroups: classifyNodeCapabilities(node.capabilities)
  };
}
function resolveEvidenceImageFile(projectDir, auditIDRaw, slotRaw) {
  const auditID = auditIDRaw.trim();
  if (!auditID)
    return null;
  const slot = slotRaw.trim().toLowerCase();
  if (slot !== "pre" && slot !== "post")
    return null;
  const row = listOutboundAudit(projectDir, 400).find((item) => item.id === auditID);
  if (!row)
    return null;
  const candidate = slot === "pre" ? row.preSendScreenshotPath : row.postSendScreenshotPath;
  if (!candidate || typeof candidate !== "string")
    return null;
  const resolved = path61.resolve(candidate);
  const runtimeDir2 = path61.resolve(getMiyaRuntimeDir(projectDir));
  if (!resolved.startsWith(runtimeDir2))
    return null;
  if (!fs62.existsSync(resolved))
    return null;
  return resolved;
}
function buildSnapshot(projectDir, runtime) {
  const deps = depsOf(projectDir);
  const kill = readKillSwitch(projectDir);
  const jobs = deps.automationService?.listJobs() ?? [];
  const approvals = deps.automationService?.listApprovals() ?? [];
  const recentRuns = deps.automationService?.listHistory(20) ?? [];
  const sessions = listSessions(projectDir);
  const channels = runtime.channelRuntime.listChannels();
  const pendingPairs = runtime.channelRuntime.listPairs("pending");
  const recentOutbound = listOutboundAudit(projectDir, 30);
  const channelGovernance = summarizeChannelGovernance(projectDir, 500);
  const nodes = listNodes(projectDir);
  const pendingNodePairs = listNodePairs(projectDir, "pending").length;
  const devices = listDevices(projectDir);
  const invokes = listInvokeRequests(projectDir, 40);
  const enabledSkills = listEnabledSkills(projectDir);
  const discoveredSkills = discoverSkills(projectDir, deps.extraSkillDirs ?? []);
  const mediaRecent = listMediaItems(projectDir, 20);
  const voice = readVoiceState(projectDir);
  const canvas = readCanvasState(projectDir);
  const companion = readCompanionProfile(projectDir);
  const ownerIdentity = readOwnerIdentityState(projectDir);
  const persistedRuntime = readPersistedAgentRuntime(projectDir);
  const owner = ownerSummary(projectDir);
  const autoflowSessions = listAutoflowSessions(projectDir, 30);
  const autoflowPersistentConfig = readAutoflowPersistentConfig(projectDir);
  const autoflowPersistentSessions = getAutoflowPersistentRuntimeSnapshot(projectDir, 30);
  const autopilotStats = readAutopilotStats(projectDir);
  const routingMode = readRouterModeConfig(projectDir);
  const routingCost = getRouteCostSummary(projectDir, 500);
  const routingRecent = listRouteCostRecords(projectDir, 20);
  const modeObservability = readModeObservability(projectDir);
  const psycheTraining = readPsycheTrainingSummary(projectDir, 300);
  const learningStats = getLearningStats(projectDir);
  const learningTopDrafts = listSkillDrafts(projectDir, { limit: 8 }).map((item) => ({
    id: item.id,
    status: item.status,
    source: item.source,
    confidence: item.confidence,
    uses: item.uses,
    hitRate: item.uses > 0 ? Number((item.hits / item.uses).toFixed(3)) : 0,
    title: item.title
  }));
  runtime.nexus.pendingTickets = approvals.filter((item) => item.status === "pending").length;
  runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, kill);
  const nextPending = [...runtime.pendingOutboundQueue].sort((a, b) => Date.parse(a.nextRunAt) - Date.parse(b.nextRunAt)).at(0);
  const base = {
    updatedAt: nowIso42(),
    gateway: toPublicGatewayState(syncGatewayState(projectDir, runtime)),
    runtime: {
      isOwner: owner.isOwner,
      ownerPID: owner.ownerPID,
      ownerFresh: owner.ownerFresh,
      activeAgentId: persistedRuntime.activeAgentId,
      storageRevision: persistedRuntime.revision
    },
    daemon: getLauncherDaemonSnapshot(projectDir),
    policyHash: currentPolicyHash(projectDir),
    configCenter: readConfig(projectDir),
    killSwitch: kill,
    nexus: {
      sessionId: runtime.nexus.sessionId,
      activeTool: runtime.nexus.activeTool,
      permission: runtime.nexus.permission,
      pendingTickets: runtime.nexus.pendingTickets,
      killSwitchMode: resolveKillSwitchMode(projectDir, kill),
      insights: runtime.nexus.insights.slice(-10),
      trust: runtime.nexus.trust,
      trustMode: runtime.nexus.trustMode,
      psycheMode: runtime.nexus.psycheMode,
      psycheTraining,
      learningGate: runtime.nexus.learningGate,
      guardianSafeHoldReason: runtime.nexus.guardianSafeHoldReason,
      pendingQueue: {
        size: runtime.pendingOutboundQueue.length,
        nextRunAt: nextPending?.nextRunAt,
        lastReason: nextPending?.lastReason
      }
    },
    safety: {
      recentSelfApproval: listRecentSelfApprovalRecords(projectDir, 15)
    },
    jobs: {
      total: jobs.length,
      enabled: jobs.filter((item) => item.enabled).length,
      pendingApprovals: approvals.filter((item) => item.status === "pending").length,
      recentRuns
    },
    loop: getSessionState(projectDir, "main"),
    autopilot: autopilotStats,
    autoflow: {
      active: autoflowSessions.filter((item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing").length,
      sessions: autoflowSessions.map((item) => {
        const phaseProgress = item.phase === "planning" ? 10 : item.phase === "execution" ? 45 : item.phase === "verification" ? 70 : item.phase === "fixing" ? 80 : item.phase === "completed" ? 100 : item.phase === "failed" ? 100 : 0;
        const fixProgress = item.maxFixRounds > 0 ? Math.min(20, Math.floor(item.fixRound / item.maxFixRounds * 20)) : 0;
        const retryReason = [...item.history].reverse().find((row) => row.event === "verification_failed" || row.event === "execution_failed")?.summary;
        return {
          sessionID: item.sessionID,
          phase: item.phase,
          goal: item.goal,
          fixRound: item.fixRound,
          maxFixRounds: item.maxFixRounds,
          updatedAt: item.updatedAt,
          progressPct: Math.min(100, phaseProgress + fixProgress),
          retryReason,
          lastError: item.lastError,
          lastDag: item.lastDag
        };
      }),
      persistent: {
        enabled: autoflowPersistentConfig.enabled,
        resumeCooldownMs: autoflowPersistentConfig.resumeCooldownMs,
        maxAutoResumes: autoflowPersistentConfig.maxAutoResumes,
        maxConsecutiveResumeFailures: autoflowPersistentConfig.maxConsecutiveResumeFailures,
        resumeTimeoutMs: autoflowPersistentConfig.resumeTimeoutMs,
        sessions: autoflowPersistentSessions.map((item) => ({
          sessionID: item.sessionID,
          resumeAttempts: item.resumeAttempts,
          resumeFailures: item.resumeFailures,
          userStopped: item.userStopped,
          lastOutcomePhase: item.lastOutcomePhase,
          lastOutcomeSummary: item.lastOutcomeSummary
        }))
      }
    },
    routing: {
      ecoMode: routingMode.ecoMode,
      forcedStage: routingMode.forcedStage,
      cost: routingCost,
      recent: routingRecent,
      mode: modeObservability
    },
    learning: {
      stats: learningStats,
      topDrafts: learningTopDrafts
    },
    background: listBackground(projectDir),
    sessions: {
      total: sessions.length,
      active: sessions.filter((item) => item.policy.activation === "active").length,
      queued: sessions.filter((item) => item.policy.activation === "queued").length,
      muted: sessions.filter((item) => item.policy.activation === "muted").length,
      items: sessions.slice(0, 100)
    },
    channels: {
      states: channels,
      pendingPairs,
      recentOutbound,
      governance: channelGovernance
    },
    nodes: {
      total: nodes.length,
      connected: nodes.filter((item) => item.connected).length,
      pendingPairs: pendingNodePairs,
      governance: summarizeNodeGovernance(nodes, pendingNodePairs),
      list: nodes,
      enriched: nodes.map((item) => withNodeGovernance(item)),
      devices,
      invokes
    },
    skills: {
      enabled: enabledSkills,
      discovered: discoveredSkills
    },
    media: {
      total: mediaRecent.length,
      recent: mediaRecent
    },
    voice,
    canvas: {
      activeDocID: canvas.activeDocID,
      docs: listCanvasDocs(projectDir),
      events: canvas.events.slice(0, 100)
    },
    companion,
    security: {
      ownerIdentity: {
        ...ownerIdentity,
        passwordHash: ownerIdentity.passwordHash ? "***" : undefined,
        passphraseHash: ownerIdentity.passphraseHash ? "***" : undefined
      }
    }
  };
  return {
    ...base,
    doctor: {
      issues: collectDoctorIssues(projectDir, runtime, base)
    }
  };
}
function daemonProgressAuditFile(projectDir) {
  return path61.join(getMiyaRuntimeDir(projectDir), "audit", "daemon-job-progress.jsonl");
}
function appendDaemonProgressAudit(projectDir, input) {
  const file3 = daemonProgressAuditFile(projectDir);
  fs62.mkdirSync(path61.dirname(file3), { recursive: true });
  fs62.appendFileSync(file3, `${JSON.stringify({ id: `dprogress_${randomUUID24()}`, ...input })}
`, "utf-8");
}
async function routeSessionMessage(projectDir, input) {
  const availableAgents = [
    "1-task-manager",
    "2-code-search",
    "3-docs-helper",
    "4-architecture-advisor",
    "5-code-fixer",
    "6-ui-designer"
  ];
  const deps = depsOf(projectDir);
  if (await enforceCriticalIntentGuard(projectDir, input)) {
    return {
      delivered: false,
      queued: false,
      reason: "kill_switch_triggered_by_critical_intent"
    };
  }
  const modeObs = readModeObservability(projectDir);
  const interactionMode = readOwnerIdentityState(projectDir).mode;
  enforceInteractionModeIsolation(projectDir, interactionMode);
  const payload = buildSessionPayloadByMode(interactionMode, input.text);
  const session = getSession(projectDir, input.sessionID) ?? upsertSession(projectDir, {
    id: input.sessionID,
    kind: input.sessionID.startsWith("opencode:") ? "opencode" : "channel",
    groupId: input.sessionID,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  const loopState = getSessionState(projectDir, input.sessionID);
  const routeComplexity = analyzeRouteComplexity(payload.payload);
  const modeKernelRaw = evaluateModeKernel({
    text: payload.payload,
    routeComplexity,
    sessionState: {
      activation: session.policy.activation,
      reply: session.policy.reply,
      queueLength: session.queue.length,
      awaitingConfirmation: loopState.awaitingConfirmation,
      loopEnabled: loopState.loopEnabled
    },
    lastMode: modeObs.lastMode
  });
  const { modeKernel, lowConfidenceSafeFallback } = applyModeSafeWorkFallback(modeKernelRaw, 0.5);
  const turnID = `turn_${randomUUID24()}`;
  const userExplicit = detectUserExplicitIntent(payload.payload);
  const rightBrain = buildRightBrainResponsePlan({
    text: payload.payload,
    modeKernel
  });
  const sanitized = sanitizeGatewayContext({
    text: payload.payload,
    modeHint: modeKernel.mode
  });
  const safeText = sanitized.payload;
  appendShortTermMemoryLog(projectDir, {
    sessionID: input.sessionID,
    sender: "user",
    text: safeText
  });
  if (interactionMode === "guest") {
    appendGuestConversation(projectDir, {
      text: payload.redacted ? "[redacted_sensitive_guest_request]" : input.text,
      source: input.source,
      sessionID: input.sessionID
    });
  }
  const pinnedAgent = session.routing.agent && session.routing.agent !== "1-task-manager" ? session.routing.agent : undefined;
  const plan = buildRouteExecutionPlan({
    projectDir,
    sessionID: input.sessionID,
    text: safeText,
    availableAgents,
    pinnedAgent
  });
  const leftBrain = buildLeftBrainActionPlan({
    routePlan: plan,
    modeKernel
  });
  const arbiter = arbitrateCortex({
    modeKernel,
    safety: {
      blocked: plan.executionMode === "human_gate",
      reason: plan.executionMode === "human_gate" ? `routing_human_gate_required:${plan.fixabilityHint}` : undefined
    },
    userExplicit,
    leftBrain,
    rightBrain
  });
  const effectiveSafeText = arbiter.mode === modeKernel.mode ? safeText : sanitizeGatewayContext({
    text: payload.payload,
    modeHint: arbiter.mode
  }).payload;
  const personaWorld = resolveSessionPersonaWorld(projectDir, input.sessionID);
  const personaWorldPrompt = buildPersonaWorldPrompt(projectDir, input.sessionID);
  const personaWorldPromptInjected = shouldInjectPersonaWorldPrompt({
    mode: arbiter.mode,
    executeWork: arbiter.executeWork
  });
  const learning = arbiter.executeWork ? buildLearningInjection(projectDir, effectiveSafeText, {
    threshold: 0.66,
    limit: 2
  }) : { snippet: "", matchedDraftIDs: [] };
  const routeMeta = [
    `[MIYA_TURN turn_id=${turnID}]`,
    `[MIYA_CORTEX_ARBITER] mode=${arbiter.mode} execute_work=${arbiter.executeWork ? "1" : "0"} priority=${arbiter.priorityTrail.join(">")}`,
    `[MIYA_EXECUTION_TRACK] ${arbiter.executionTrack}`
  ].filter((item) => item.length > 0).join(`
`);
  const enrichedText = [
    routeMeta,
    personaWorldPromptInjected ? personaWorldPrompt : "",
    personaWorld.risk === "high" ? "[MIYA_PERSONA_WORLD_SAFETY] /" : "",
    learning.snippet,
    effectiveSafeText
  ].filter((item) => item && item.trim().length > 0).join(`

---

`);
  const finalStage = !arbiter.executeWork ? "low" : arbiter.mode === "chat" ? "low" : plan.stage;
  const finalAgent = !arbiter.executeWork || arbiter.mode === "chat" ? "1-task-manager" : plan.agent;
  const routerSession = getRouterSessionState(projectDir, input.sessionID);
  const payloadPlan = prepareRoutePayload(projectDir, {
    text: enrichedText,
    stage: finalStage,
    retry: {
      attempt: routerSession.autoRetryUsed,
      previousContextText: routerSession.lastContextText,
      previousContextHash: routerSession.lastContextHash,
      failureReason: routerSession.lastFailureReason
    }
  });
  const finalizeTurn = (result) => {
    appendTurnEvidencePack(projectDir, {
      turnID,
      at: nowIso42(),
      sessionID: input.sessionID,
      source: input.source,
      modeKernel: {
        mode: modeKernel.mode,
        confidence: modeKernel.confidence,
        why: modeKernel.why
      },
      arbiter: {
        mode: arbiter.mode,
        executeWork: arbiter.executeWork,
        rightBrainSuppressed: arbiter.rightBrainSuppressed,
        priorityTrail: arbiter.priorityTrail,
        why: arbiter.why
      },
      tracks: {
        work: {
          planned: arbiter.mode === "work" || arbiter.mode === "mixed",
          executed: result.delivered && arbiter.executeWork
        },
        emotional: {
          planned: arbiter.mode === "chat" || arbiter.mode === "mixed",
          executed: result.delivered
        }
      },
      outcome: result,
      leftBrain: {
        objective: leftBrain.objective,
        executeWork: leftBrain.executeWork,
        risk: leftBrain.risk,
        requiredGates: leftBrain.requiredGates,
        why: leftBrain.why
      },
      rightBrain: {
        tone: rightBrain.tone,
        suggestions: rightBrain.suggestions,
        highRiskToolSuggestion: rightBrain.highRiskToolSuggestion,
        why: rightBrain.why
      },
      routing: {
        intent: plan.intent,
        complexity: plan.complexity,
        stage: plan.stage,
        finalStage,
        agent: plan.agent,
        finalAgent,
        reasons: plan.reasons
      },
      contextPipeline: {
        lowConfidenceSafeFallback,
        personaWorldPromptInjected,
        learningInjected: Boolean(learning.snippet && learning.snippet.trim()),
        retryDeltaApplied: payloadPlan.retryDeltaApplied,
        hardCapApplied: payloadPlan.hardCapped
      }
    });
    recordModeObservability(projectDir, {
      turnID,
      finalMode: arbiter.mode,
      rollback: arbiter.mode !== modeKernel.mode,
      autonomousAttempt: arbiter.executeWork,
      autonomousSuccess: arbiter.executeWork && result.delivered,
      negativeFeedback: detectNegativeFeedbackText(input.text)
    });
    return result;
  };
  if (session.policy.activation !== "active" || session.policy.reply !== "auto") {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: effectiveSafeText,
      source: input.source
    });
    return finalizeTurn({
      delivered: false,
      queued: true,
      reason: `policy_${session.policy.activation}_${session.policy.reply}`
    });
  }
  const client = deps.client;
  if (!client) {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: effectiveSafeText,
      source: input.source
    });
    return finalizeTurn({
      delivered: false,
      queued: true,
      reason: "client_unavailable"
    });
  }
  if (plan.executionMode === "human_gate") {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: effectiveSafeText,
      source: input.source
    });
    return finalizeTurn({
      delivered: false,
      queued: true,
      reason: `routing_human_gate_required:${plan.fixabilityHint}`
    });
  }
  try {
    if (arbiter.executeWork) {
      requireDomainRunning(projectDir, "local_build");
    }
    await client.session.prompt({
      path: { id: session.routing.opencodeSessionID },
      body: {
        agent: finalAgent,
        parts: [{ type: "text", text: payloadPlan.text }]
      },
      query: { directory: projectDir }
    });
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: finalStage,
      agent: finalAgent,
      success: true,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate,
      attemptType: "auto",
      contextHash: payloadPlan.contextHash,
      contextText: payloadPlan.text
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, undefined, { hit: true });
      }
    }
    dequeueSessionMessage(projectDir, input.sessionID);
    return finalizeTurn({ delivered: true, queued: false });
  } catch (error92) {
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: finalStage,
      agent: finalAgent,
      success: false,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate,
      failureReason: error92 instanceof Error ? error92.message : String(error92),
      attemptType: "auto",
      contextHash: payloadPlan.contextHash,
      contextText: payloadPlan.text
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, undefined, { hit: false });
      }
    }
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: effectiveSafeText,
      source: input.source
    });
    return finalizeTurn({
      delivered: false,
      queued: true,
      reason: error92 instanceof Error ? error92.message : String(error92)
    });
  }
}
function resolveApprovalTicket(input) {
  const kill = readKillSwitch(input.projectDir);
  if (kill.active) {
    return { ok: false, reason: "kill_switch_active" };
  }
  const request = {
    sessionID: input.sessionID,
    permission: input.permission,
    patterns: input.patterns
  };
  const tier = requiredTierForRequest(request);
  const requestHash = buildRequestHash({
    permission: input.permission,
    patterns: input.patterns,
    toolCallID: "",
    messageID: ""
  }, false);
  const token = findApprovalToken(input.projectDir, input.sessionID, [requestHash], tier);
  if (token) {
    return {
      ok: true,
      ticket: {
        permission: input.permission,
        requestHash,
        traceID: token.trace_id,
        createdAt: token.created_at,
        expiresAt: token.expires_at,
        tier: token.tier
      }
    };
  }
  activateKillSwitch(input.projectDir, "missing_evidence", randomUUID24());
  return { ok: false, reason: "missing_evidence" };
}
function enforceToken(input) {
  const resolved = resolveApprovalTicket(input);
  return resolved.ok ? { ok: true } : resolved;
}
function renderConsoleHtml(snapshot) {
  const payload = JSON.stringify(snapshot).replace(/</g, "\\u003c");
  return `<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya Gateway React</title>
  <style>
    body { margin: 0; font-family: "Segoe UI", "Microsoft YaHei", sans-serif; background: #0f172a; color: #e2e8f0; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .row { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); margin-bottom: 12px; }
    .card { background: #111827; border: 1px solid #1f2937; border-radius: 10px; padding: 12px; }
    .title { color: #93c5fd; font-size: 12px; text-transform: uppercase; }
    .value { font-size: 20px; font-weight: 700; margin-top: 6px; }
    .ok { color: #4ade80; }
    .bad { color: #f87171; }
    textarea { width: 100%; min-height: 220px; resize: vertical; background: #020617; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; padding: 8px; font-family: Consolas, monospace; }
    button { background: #2563eb; color: #fff; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .line { margin: 6px 0; color: #cbd5e1; font-size: 13px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Miya Gateway</h2>
    <div id="daemonStatus" class="line">loading...</div>
    <div class="row">
      <div class="card">
        <div class="title">Daemon CPU/VRAM/Uptime</div>
        <div id="daemonStats" class="value">--</div>
        <div id="daemonJob" class="line">Active Job: --</div>
      </div>
      <div class="card">
        <div class="title">Sessions</div>
        <div id="sessionsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Jobs</div>
        <div id="jobsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Autoflow</div>
        <div id="autoflowValue" class="value">0 active</div>
        <div id="autoflowPhase" class="line">phase: --</div>
      </div>
      <div class="card">
        <div class="title">Routing Cost</div>
        <div id="routingValue" class="value">--</div>
        <div id="routingStage" class="line">stage: --</div>
      </div>
      <div class="card">
        <div class="title">Learning HitRate</div>
        <div id="learningValue" class="value">--</div>
        <div id="learningDrafts" class="line">drafts: --</div>
      </div>
      <div class="card">
        <div class="title">Policy Hash</div>
        <div id="policyHash" class="line">--</div>
      </div>
    </div>
    <div class="card">
      <div class="title">Configuration Center (read/write .opencode/miya/config.json)</div>
      <div class="line">Patch JSON format: { set: {"ui.language":"zh-CN"}, unset: [] }</div>
      <textarea id="patchText">{"set":{},"unset":[]}</textarea>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <button id="saveButton"></button>
        <span id="saveState" class="line">idle</span>
      </div>
      <pre id="configJson" class="line" style="white-space:pre-wrap;max-height:220px;overflow:auto"></pre>
    </div>
  </div>
  <script>window.__MIYA_SNAPSHOT__ = ${payload};</script>
  <script>
    (function () {
      let state = window.__MIYA_SNAPSHOT__ || {};
      const patchInput = document.getElementById('patchText');
      const saveButton = document.getElementById('saveButton');
      const saveState = document.getElementById('saveState');
      const daemonStatus = document.getElementById('daemonStatus');
      const daemonStats = document.getElementById('daemonStats');
      const daemonJob = document.getElementById('daemonJob');
      const sessionsValue = document.getElementById('sessionsValue');
      const jobsValue = document.getElementById('jobsValue');
      const autoflowValue = document.getElementById('autoflowValue');
      const autoflowPhase = document.getElementById('autoflowPhase');
      const routingValue = document.getElementById('routingValue');
      const routingStage = document.getElementById('routingStage');
      const learningValue = document.getElementById('learningValue');
      const learningDrafts = document.getElementById('learningDrafts');
      const policyHash = document.getElementById('policyHash');
      const configJson = document.getElementById('configJson');

      let ws = null;
      let reqID = 1;
      const pending = new Map();

      function updateSave(value) {
        saveState.textContent = value;
        saveButton.disabled = value === 'saving';
      }

      function render(next) {
        state = next || {};
        const daemonOk = Boolean(state.daemon && state.daemon.connected);
        const label = daemonOk
          ? 'Miya Daemon Connected'
          : ((state.daemon && state.daemon.statusText) || 'Miya Daemon Disconnected');
        daemonStatus.textContent = label;
        daemonStatus.className = 'line ' + (daemonOk ? 'ok' : 'bad');

        const cpu =
          state.daemon && typeof state.daemon.cpuPercent === 'number'
            ? state.daemon.cpuPercent.toFixed(1) + '%'
            : '--';
        const vramUsed =
          state.daemon && typeof state.daemon.vramUsedMB === 'number' ? state.daemon.vramUsedMB : '--';
        const vramTotal =
          state.daemon && typeof state.daemon.vramTotalMB === 'number' ? state.daemon.vramTotalMB : '--';
        const uptime =
          state.daemon && typeof state.daemon.uptimeSec === 'number' ? state.daemon.uptimeSec + 's' : '--';
        daemonStats.textContent = cpu + ' | ' + vramUsed + '/' + vramTotal + ' MB | ' + uptime;

        const jobID = state.daemon && state.daemon.activeJobID ? state.daemon.activeJobID : '--';
        const jobProgress =
          state.daemon && typeof state.daemon.activeJobProgress === 'number'
            ? state.daemon.activeJobProgress + '%'
            : '--';
        daemonJob.textContent = 'Active Job: ' + jobID + ' | ' + jobProgress;

        sessionsValue.textContent =
          String((state.sessions && state.sessions.active) || 0) +
          '/' +
          String((state.sessions && state.sessions.total) || 0);
        jobsValue.textContent =
          String((state.jobs && state.jobs.enabled) || 0) +
          '/' +
          String((state.jobs && state.jobs.total) || 0);
        const activeAutoflow = (state.autoflow && state.autoflow.active) || 0;
        autoflowValue.textContent = String(activeAutoflow) + ' active';
        const firstAutoflow = state.autoflow && state.autoflow.sessions && state.autoflow.sessions[0];
        autoflowPhase.textContent =
          'phase: ' + (firstAutoflow && firstAutoflow.phase ? firstAutoflow.phase : '--');
        const routingCost =
          state.routing && state.routing.cost ? state.routing.cost : null;
        if (routingCost) {
          routingValue.textContent =
            String(routingCost.totalTokensEstimate || 0) +
            ' tk | save ' +
            String(routingCost.savingsPercentEstimate || 0) +
            '%';
        } else {
          routingValue.textContent = '--';
        }
        routingStage.textContent =
          'stage: ' + ((state.routing && state.routing.forcedStage) || (state.routing && state.routing.ecoMode ? 'eco' : 'auto') || '--');
        const learningStats =
          state.learning && state.learning.stats ? state.learning.stats : null;
        if (learningStats) {
          learningValue.textContent =
            (Number(learningStats.hitRate || 0) * 100).toFixed(1) + '%';
          learningDrafts.textContent =
            'drafts: ' + String(learningStats.total || 0) + ' | uses: ' + String(learningStats.totalUses || 0);
        } else {
          learningValue.textContent = '--';
          learningDrafts.textContent = 'drafts: --';
        }
        policyHash.textContent = state.policyHash || '--';
        configJson.textContent = JSON.stringify(state.configCenter || {}, null, 2);
      }

      function sendReq(method, params) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          return Promise.reject(new Error('ws_not_open'));
        }
        const id = 'r-' + reqID++;
        ws.send(
          JSON.stringify({
            type: 'request',
            id,
            method,
            params,
            idempotencyKey: id,
          }),
        );
        return new Promise((resolve, reject) => {
          const timer = setTimeout(() => {
            pending.delete(id);
            reject(new Error('request_timeout'));
          }, 8000);
          pending.set(id, { resolve, reject, timer });
        });
      }

      async function loadStatus() {
        try {
          const res = await fetch('/api/status', { cache: 'no-store' });
          const data = await res.json();
          render(data);
        } catch {}
      }

      function openWs() {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        const params = new URLSearchParams(location.search);
        const token = params.get('token') || localStorage.getItem('miya_gateway_token') || '';
        if (token) {
          localStorage.setItem('miya_gateway_token', token);
          if (params.has('token')) {
            params.delete('token');
            const next = location.pathname + (params.toString() ? '?' + params.toString() : '') + location.hash;
            history.replaceState({}, '', next);
          }
        }

        ws = new WebSocket(proto + '://' + location.host + '/ws');
        ws.onopen = function () {
          ws.send(
            JSON.stringify({
              type: 'hello',
              role: 'ui',
              protocolVersion: '1.1',
              auth: token ? { token } : undefined,
            }),
          );
          ws.send(
            JSON.stringify({
              type: 'request',
              id: 'sub',
              method: 'gateway.subscribe',
              params: { events: ['*'] },
              idempotencyKey: 'sub',
            }),
          );
        };
        ws.onmessage = function (evt) {
          try {
            const frame = JSON.parse(evt.data);
            if (frame.type === 'event' && frame.event === 'gateway.snapshot') {
              render(frame.payload);
              return;
            }
            if (frame.type === 'response') {
              const entry = pending.get(frame.id);
              if (!entry) return;
              pending.delete(frame.id);
              clearTimeout(entry.timer);
              if (frame.ok) entry.resolve(frame.result);
              else entry.reject(new Error((frame.error && frame.error.message) || 'request_failed'));
            }
          } catch {}
        };
        ws.onclose = function () {
          for (const entry of pending.values()) {
            clearTimeout(entry.timer);
            entry.reject(new Error('ws_closed'));
          }
          pending.clear();
        };
      }

      saveButton.addEventListener('click', async function () {
        updateSave('saving');
        try {
          const patch = JSON.parse(patchInput.value || '{}');
          await sendReq('config.center.patch', { patch, policyHash: state ? state.policyHash : undefined });
          updateSave('ok');
        } catch (err) {
          updateSave('error:' + String((err && err.message) || err));
        }
      });

      render(state);
      loadStatus();
      setInterval(loadStatus, 3000);
      openWs();
    })();
  </script>
</body>
</html>`;
}
function renderWebChatHtml() {
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya WebChat</title>
  <style>
    body{margin:0;font-family:Segoe UI,sans-serif;background:#0b1117;color:#e6edf7}
    main{max-width:900px;margin:0 auto;padding:14px;display:grid;gap:10px}
    #log{min-height:360px;border:1px solid #253047;border-radius:8px;background:#111827;padding:10px;white-space:pre-wrap}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px}
    input{border:1px solid #253047;border-radius:8px;background:#111827;color:#e6edf7;padding:8px}
    button{border:1px solid #253047;border-radius:8px;background:#1f6feb;color:#fff;padding:8px 12px;cursor:pointer}
  </style>
</head>
<body>
<main>
  <h2 style="margin:0">Miya WebChat</h2>
  <div id="log"></div>
  <div class="row"><input id="msg" placeholder="Type message"><button id="send">Send</button></div>
</main>
<script>
  const logEl=document.getElementById('log'); const msgEl=document.getElementById('msg'); const sendBtn=document.getElementById('send');
  const p=location.protocol==='https:'?'wss':'ws'; const ws=new WebSocket(p+'://'+location.host+'/ws');
  const log=(t)=>{logEl.textContent+=t+'\\n'; logEl.scrollTop=logEl.scrollHeight;};
  const send=()=>{const text=msgEl.value.trim(); if(!text)return; const id='send-'+Date.now(); ws.send(JSON.stringify({type:'request',id,method:'sessions.send',params:{sessionID:'webchat:main',text,source:'webchat'},idempotencyKey:id})); log('[you] '+text); msgEl.value='';};
  sendBtn.onclick=send; msgEl.addEventListener('keydown',(e)=>{if(e.key==='Enter')send();});
  ws.onopen=()=>{const qs=new URLSearchParams(location.search);const token=qs.get('token')||localStorage.getItem('miya_gateway_token')||'';if(token){localStorage.setItem('miya_gateway_token',token);if(qs.has('token')){qs.delete('token');const next=location.pathname+(qs.toString()?'?'+qs.toString():'')+location.hash;history.replaceState({},'',next);}}ws.send(JSON.stringify({type:'hello',role:'ui',protocolVersion:'1.1',auth:token?{token}:undefined})); ws.send(JSON.stringify({type:'request',id:'sub',method:'gateway.subscribe',params:{events:['*']},idempotencyKey:'sub'})); log('[system] connected');};
  ws.onmessage=(event)=>{try{const frame=JSON.parse(event.data); if(frame.type==='response'&&!frame.ok)log('[error] '+(frame.error?.message||'request_failed'));}catch{}};
</script>
</body>
</html>`;
}
function maybeBroadcast(projectDir, runtime) {
  runtime.stateVersion += 1;
  const frame = toEventFrame({
    event: "gateway.snapshot",
    payload: buildSnapshot(projectDir, runtime),
    stateVersion: { gateway: runtime.stateVersion }
  });
  runtime.server.publish("miya:broadcast", JSON.stringify(frame));
}
function publishGatewayEvent(runtime, event, payload) {
  runtime.stateVersion += 1;
  runtime.server.publish("miya:broadcast", JSON.stringify(toEventFrame({
    event,
    payload,
    stateVersion: { gateway: runtime.stateVersion }
  })));
}
function validateHelloChallenge(runtime, frameClientID, protocolVersion, challenge) {
  if (!runtime.auth.challengeRequired)
    return { ok: true };
  if (!runtime.auth.challengeSecret) {
    return { ok: false, reason: "gateway_challenge_secret_missing" };
  }
  if (!challenge) {
    return { ok: false, reason: "gateway_challenge_missing" };
  }
  const ageMs = Math.abs(Date.now() - Number(challenge.ts));
  if (!Number.isFinite(ageMs) || ageMs > 5 * 60000) {
    return { ok: false, reason: "gateway_challenge_expired" };
  }
  const expected = buildGatewayChallengeSignature({
    secret: runtime.auth.challengeSecret,
    clientID: frameClientID,
    protocolVersion,
    nonce: challenge.nonce,
    ts: challenge.ts
  });
  if (challenge.signature !== expected) {
    return { ok: false, reason: "gateway_challenge_signature_invalid" };
  }
  return { ok: true };
}
function idempotencyWindowMs() {
  return Math.max(1000, Math.min(10 * 60000, Number(process.env.MIYA_GATEWAY_IDEMPOTENCY_TTL_MS ?? 90000)));
}
function cleanupIdempotency(runtime) {
  const ttl = idempotencyWindowMs();
  const now = Date.now();
  for (const [key, value] of runtime.requestIdempotency) {
    if (now - value.atMs > ttl) {
      runtime.requestIdempotency.delete(key);
    }
  }
  const maxEntries = 4096;
  if (runtime.requestIdempotency.size <= maxEntries)
    return;
  const sorted = [...runtime.requestIdempotency.values()].sort((a, b) => a.atMs - b.atMs);
  const overflow = runtime.requestIdempotency.size - maxEntries;
  for (let i = 0;i < overflow; i += 1) {
    const target = sorted[i];
    if (!target)
      continue;
    runtime.requestIdempotency.delete(target.key);
  }
}
function idempotencyScopeKey(frame, clientID) {
  const raw = String(frame.idempotencyKey ?? "").trim();
  if (!raw)
    return null;
  return `${clientID}|${raw}`;
}
function requestFingerprint(frame) {
  return createHash19("sha256").update(`${frame.method}|${JSON.stringify(frame.params ?? {})}`).digest("hex");
}
async function runWizardTrainingWorker(projectDir, runtime) {
  if (runtime.wizardRunnerBusy)
    return;
  const queued = pickQueuedTrainingJob(projectDir);
  if (!queued)
    return;
  runtime.wizardRunnerBusy = true;
  try {
    const runningState = markTrainingJobRunning(projectDir, queued.job.id, queued.sessionId);
    publishGatewayEvent(runtime, "companion.wizard.progress", {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: "training",
      progress: 5,
      step: runningState.state
    });
    const daemon = getMiyaClient(projectDir);
    const profileDir = getCompanionProfileCurrentDir(projectDir, queued.sessionId);
    if (queued.job.type === "training.image") {
      const photosDir = path61.join(profileDir, "photos");
      const result2 = await daemon.runFluxTraining({
        profileDir,
        photosDir,
        jobID: queued.job.id,
        checkpointPath: queued.job.checkpointPath
      });
      if (result2.status === "failed" && result2.checkpointPath && queued.job.attempts < 3) {
        const requeued = requeueTrainingJob(projectDir, {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          checkpointPath: result2.checkpointPath,
          message: "checkpoint"
        });
        publishGatewayEvent(runtime, "companion.wizard.progress", {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          type: queued.job.type,
          status: "pending",
          progress: Math.max(10, queued.job.progress),
          message: "checkpoint",
          step: requeued.state
        });
        return;
      }
      const done2 = markTrainingJobFinished(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        status: result2.status === "failed" ? "failed" : result2.status,
        message: result2.message,
        tier: result2.tier,
        checkpointPath: result2.checkpointPath
      });
      publishGatewayEvent(runtime, "companion.wizard.progress", {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        status: result2.status === "failed" ? "failed" : result2.status,
        progress: result2.status === "failed" || result2.status === "canceled" ? 50 : 100,
        currentTier: result2.tier,
        message: result2.message,
        step: done2.state,
        nextPrompt: wizardPromptByState(done2.state)
      });
      return;
    }
    const voiceSamplePath = path61.join(profileDir, "voice", "original_sample.wav");
    const result = await daemon.runSovitsTraining({
      profileDir,
      voiceSamplePath,
      jobID: queued.job.id,
      checkpointPath: queued.job.checkpointPath
    });
    if (result.status === "failed" && result.checkpointPath && queued.job.attempts < 3) {
      const requeued = requeueTrainingJob(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        checkpointPath: result.checkpointPath,
        message: "checkpoint"
      });
      publishGatewayEvent(runtime, "companion.wizard.progress", {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        status: "pending",
        progress: Math.max(10, queued.job.progress),
        message: "checkpoint",
        step: requeued.state
      });
      return;
    }
    const done = markTrainingJobFinished(projectDir, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      status: result.status === "failed" ? "failed" : result.status,
      message: result.message,
      tier: result.tier,
      checkpointPath: result.checkpointPath
    });
    publishGatewayEvent(runtime, "companion.wizard.progress", {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: result.status === "failed" ? "failed" : result.status,
      progress: result.status === "failed" || result.status === "canceled" ? 50 : 100,
      currentTier: result.tier,
      message: result.message,
      step: done.state,
      nextPrompt: wizardPromptByState(done.state)
    });
  } finally {
    runtime.wizardRunnerBusy = false;
  }
}
function ensureWsData(runtime, ws) {
  const existing = runtime.wsMeta.get(ws);
  if (existing) {
    return existing;
  }
  const fallback = {
    clientID: `ws_${randomUUID24()}`,
    role: "unknown",
    subscriptions: new Set(["*"]),
    authenticated: false
  };
  runtime.wsMeta.set(ws, fallback);
  return fallback;
}
async function onInboundMessage(projectDir, runtime, message) {
  if (message.channel === "qq" || message.channel === "wechat") {
    const tier = getContactTier(projectDir, message.channel, message.senderID);
    if (tier === "owner") {
      const token = detectOwnerSyncTokenFromText(message.text);
      if (token) {
        const approval = approveOwnerSyncToken(projectDir, {
          token,
          channel: message.channel,
          senderID: message.senderID
        });
        await notifySafetyReport(projectDir, "main", [
          approval.ok ? `Miya  token=${token}` : `Miya token=${token} reason=${approval.reason ?? "unknown"}`
        ]);
        maybeBroadcast(projectDir, runtime);
        return;
      }
    }
  }
  const sessionID = `${message.channel}:${message.conversationID}`;
  upsertSession(projectDir, {
    id: sessionID,
    kind: "channel",
    groupId: sessionID,
    title: message.displayName,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  await routeSessionMessage(projectDir, {
    sessionID,
    text: message.text,
    source: message.channel
  });
  maybeBroadcast(projectDir, runtime);
}
function createMethods(projectDir, runtime) {
  const config3 = readConfig(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const maxInFlight = typeof backpressure?.max_in_flight === "number" ? Number(backpressure.max_in_flight) : undefined;
  const maxQueued = typeof backpressure?.max_queued === "number" ? Number(backpressure.max_queued) : undefined;
  const queueTimeoutMs = typeof backpressure?.queue_timeout_ms === "number" ? Number(backpressure.queue_timeout_ms) : undefined;
  const methods = new GatewayMethodRegistry({
    maxInFlight,
    maxQueued,
    queueTimeoutMs
  });
  const openclaw = new OpenClawAdapter(projectDir);
  const callOpenClaw = async (method, params = {}) => {
    const result = await openclaw.execute({
      method,
      params,
      timeoutMs: 1e4
    });
    if (!result.ok) {
      throw new Error(`openclaw_${result.error?.code ?? "request_failed"}:${result.error?.message ?? "request_failed"}`);
    }
    return result.result;
  };
  const parseDesktopSafety = (value) => {
    if (!value || typeof value !== "object" || Array.isArray(value))
      return;
    const raw = value;
    return {
      inputMutex: typeof raw.inputMutex === "boolean" ? Boolean(raw.inputMutex) : undefined,
      abortOnUserInterference: typeof raw.abortOnUserInterference === "boolean" ? Boolean(raw.abortOnUserInterference) : undefined
    };
  };
  const buildDesktopPlanFromParams = (params) => {
    const routeLevel = parseDesktopRouteLevel(params.routeLevel);
    const source = parseText2(params.source).trim() || "gateway.desktop.action.plan";
    const safety = parseDesktopSafety(params.safety);
    const template = parseText2(params.template).trim().toLowerCase();
    if (template === "outbound_send") {
      const destination = parseText2(params.destination).trim();
      if (!destination)
        throw new Error("desktop_plan_destination_required");
      const appNameText = parseText2(params.appName).trim().toLowerCase();
      const appName = appNameText.includes("wechat") ? "WeChat" : "QQ";
      const hasText = typeof params.hasText === "boolean" ? Boolean(params.hasText) : parseText2(params.text).trim().length > 0;
      const hasMedia = typeof params.hasMedia === "boolean" ? Boolean(params.hasMedia) : parseText2(params.mediaPath).trim().length > 0;
      const selectedCandidateId = typeof params.selectedCandidateId === "number" && Number.isFinite(params.selectedCandidateId) ? Math.max(1, Math.floor(Number(params.selectedCandidateId))) : undefined;
      return buildDesktopActionPlanV2FromRequest({
        source,
        appName,
        windowHint: destination,
        routeLevel,
        safety,
        actions: buildDesktopOutboundHumanActions({
          routeLevel: routeLevel ?? "L1_UIA",
          appName,
          destination,
          hasText,
          hasMedia,
          selectedCandidateId
        })
      });
    }
    return buildDesktopActionPlanV2FromRequest({
      source,
      appName: parseText2(params.appName).trim() || undefined,
      windowHint: parseText2(params.windowHint).trim() || undefined,
      routeLevel,
      safety,
      actions: Array.isArray(params.actions) ? params.actions : undefined
    });
  };
  const buildLifecycleStatusSnapshot = () => {
    const currentConfig = readConfig(projectDir);
    const dashboardConfig = currentConfig.ui?.dashboard ?? {};
    const owner = ownerSummary(projectDir);
    const daemon = getLauncherDaemonSnapshot(projectDir);
    const state = syncGatewayState(projectDir, runtime);
    const autostart = getAutostartStatus(projectDir);
    const coupling = {
      openCodeStartsGateway: true,
      gatewayStartsDaemon: true,
      uiFollowsOpenCode: dashboardConfig.openOnStart !== false,
      dockAutoLaunch: process.env.MIYA_DOCK_AUTO_LAUNCH === "1" || process.env.MIYA_DOCK_AUTO_LAUNCH !== "0" && dashboardConfig.dockAutoLaunch !== false,
      autoUiBlockedByEnv: process.env.MIYA_AUTO_UI_OPEN === "0"
    };
    return {
      generatedAt: nowIso42(),
      coupling,
      autostart,
      gateway: {
        url: state.url,
        uiUrl: state.uiUrl,
        status: state.status,
        startedAt: state.startedAt,
        port: state.port,
        isOwner: owner.isOwner,
        ownerFresh: owner.ownerFresh
      },
      daemon: {
        connected: daemon.connected,
        statusText: daemon.statusText,
        lifecycleState: daemon.lifecycleState,
        lifecycleMode: daemon.lifecycleMode ?? "coupled",
        desiredState: daemon.desiredState,
        retryHalted: daemon.retryHalted,
        retryHaltedUntil: daemon.retryHaltedUntil,
        manualStopUntil: daemon.manualStopUntil
      },
      recovery: {
        recommendedAction: daemon.connected ? "none" : daemon.retryHalted ? "manual_intervention" : "wait_or_restart"
      }
    };
  };
  const buildLifecycleSyncPlan = (snapshot) => {
    const actions = [];
    if (snapshot.gateway.status !== "running") {
      actions.push({
        id: "start_gateway",
        required: true,
        reason: "gateway_not_running"
      });
    }
    if (!snapshot.daemon.connected && !snapshot.daemon.retryHalted) {
      actions.push({
        id: "restart_daemon",
        required: true,
        reason: "daemon_not_connected"
      });
    }
    if (snapshot.daemon.retryHalted) {
      actions.push({
        id: "manual_intervention",
        required: true,
        reason: "daemon_retry_halted"
      });
    }
    if (snapshot.coupling.uiFollowsOpenCode && !snapshot.coupling.autoUiBlockedByEnv && snapshot.gateway.status === "running") {
      actions.push({
        id: "open_ui",
        required: false,
        reason: "ui_follow_policy_enabled"
      });
    }
    return {
      ready: actions.filter((item) => item.required).length === 0,
      actions
    };
  };
  registerGatewayCoreMethods(methods, {
    projectDir,
    runtime,
    now: nowIso42,
    buildSnapshot: () => buildSnapshot(projectDir, runtime),
    buildGatewayState: () => syncGatewayState(projectDir, runtime),
    scheduleGatewayStop: () => {
      setTimeout(() => {
        stopGateway(projectDir);
      }, 20);
    },
    ensureGatewayRunning: () => ensureGatewayRunning(projectDir),
    probeGatewayAlive: (url3, timeoutMs) => probeGatewayAlive(url3, timeoutMs),
    listActionLedger: (limit) => listToolActionLedgerEvents(projectDir, limit)
  });
  methods.register("config.center.get", async () => readConfig(projectDir));
  methods.register("provider.override.audit.list", async (params) => {
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 50;
    const limit = Math.max(1, Math.min(500, Math.floor(limitRaw)));
    return listProviderOverrideAudits(projectDir, limit);
  });
  methods.register("config.center.patch", async (params) => {
    const policyHash = parseText2(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    const validation = validateConfigPatch(projectDir, params.patch);
    if (!validation.ok) {
      throw new Error(`config_validation_failed:${validation.errors.join("|")}`);
    }
    const applied = applyConfigPatch(projectDir, validation);
    return {
      updatedConfig: applied.updatedConfig,
      changedKeys: applied.applied.map((item) => item.key)
    };
  });
  methods.register("startup.autostart.get", async () => getAutostartStatus(projectDir));
  methods.register("startup.autostart.set", async (params) => {
    const policyHash = parseText2(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (typeof params.enabled !== "boolean") {
      throw new Error("invalid_autostart_enabled");
    }
    return setAutostartEnabled(projectDir, {
      enabled: Boolean(params.enabled),
      taskName: typeof params.taskName === "string" ? params.taskName : undefined,
      command: typeof params.command === "string" ? params.command : undefined
    });
  });
  methods.register("lifecycle.status.get", async () => {
    const snapshot = buildLifecycleStatusSnapshot();
    return {
      ...snapshot,
      syncPlan: buildLifecycleSyncPlan(snapshot)
    };
  });
  methods.register("lifecycle.sync.plan", async () => {
    const snapshot = buildLifecycleStatusSnapshot();
    return {
      generatedAt: nowIso42(),
      status: snapshot,
      ...buildLifecycleSyncPlan(snapshot)
    };
  });
  methods.register("desktop.action.plan", async (params) => {
    return buildDesktopPlanFromParams(params);
  });
  methods.register("desktop.action.single_step.prompt", async () => {
    return buildDesktopSingleStepPromptKit();
  });
  methods.register("desktop.action.single_step.next", async (params) => {
    const source = parseText2(params.source).trim() || "gateway.desktop.action.single_step.next";
    const routeLevel = parseDesktopRouteLevel(params.routeLevel);
    const safety = parseDesktopSafety(params.safety);
    const stepIndexRaw = typeof params.stepIndex === "number" && Number.isFinite(params.stepIndex) ? Number(params.stepIndex) : 1;
    const stepIndex = Math.max(1, Math.min(1e4, Math.floor(stepIndexRaw)));
    const decisionRaw = params.decision != null ? params.decision : typeof params.modelOutput === "string" ? params.modelOutput : undefined;
    if (decisionRaw == null)
      throw new Error("desktop_single_step_decision_required");
    const decision = parseDesktopSingleStepDecision(decisionRaw);
    const result = buildDesktopSingleStepPlanFromDecision({
      source,
      appName: parseText2(params.appName).trim() || undefined,
      windowHint: parseText2(params.windowHint).trim() || undefined,
      routeLevel: routeLevel ?? "L1_UIA",
      safety,
      stepIndex,
      enforceFocusBeforeAction: typeof params.enforceFocusBeforeAction === "boolean" ? Boolean(params.enforceFocusBeforeAction) : true,
      decision
    });
    return {
      protocol: "desktop_single_step.v1",
      stepIndex,
      ...result,
      promptKit: buildDesktopSingleStepPromptKit(),
      nextActionHint: result.status === "ready" ? "execute" : "refresh_observation_then_decide"
    };
  });
  methods.register("desktop.action.execute", async (params) => {
    const sessionID = parseText2(params.sessionID).trim() || "main";
    const dryRun = params.dryRun === true;
    const timeoutMs = typeof params.timeoutMs === "number" && Number.isFinite(params.timeoutMs) ? Number(params.timeoutMs) : undefined;
    const singleStep = params.singleStep === true;
    const stepRetryLimit = typeof params.stepRetryLimit === "number" && Number.isFinite(params.stepRetryLimit) ? Math.max(0, Math.min(4, Math.floor(Number(params.stepRetryLimit)))) : undefined;
    const verifyAfterAction = typeof params.verifyAfterAction === "boolean" ? Boolean(params.verifyAfterAction) : undefined;
    const plan = params.plan && typeof params.plan === "object" && !Array.isArray(params.plan) ? parseDesktopActionPlanV2(params.plan) : buildDesktopPlanFromParams(params);
    if (!dryRun) {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "desktop_control");
      const token = enforceToken({
        projectDir,
        sessionID,
        permission: "desktop_control",
        patterns: [
          "desktop_action_execute",
          `plan_sha256=${hashText3(JSON.stringify(plan.actions))}`,
          `action_count=${plan.actions.length}`,
          `window_hint=${(plan.context.windowHint ?? "").slice(0, 80)}`
        ]
      });
      if (!token.ok)
        throw new Error(`approval_required:${token.reason}`);
    }
    return executeDesktopActionPlan({
      projectDir,
      plan,
      dryRun,
      timeoutMs,
      singleStep,
      stepRetryLimit,
      verifyAfterAction
    });
  });
  methods.register("desktop.automation.kpi.get", async () => {
    return readDesktopAutomationKpi(projectDir);
  });
  methods.register("desktop.replay.skills.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Math.floor(Number(params.limit))) : 50;
    return {
      items: listDesktopReplaySkills(projectDir, limit)
    };
  });
  methods.register("capability.schema.list", async (params) => {
    const scope = parseText2(params.scope) || "all";
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 500;
    const limit = Math.max(1, Math.min(5000, Math.floor(limitRaw)));
    const includeGateway = scope === "all" || scope === "gateway";
    const includeSkills = scope === "all" || scope === "skills";
    const gatewaySchemas = includeGateway ? buildGatewayCapabilitySchemas(runtime.methods.list()) : [];
    const skills = includeSkills ? discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []) : [];
    const skillSchemas = includeSkills ? buildSkillCapabilitySchemas(skills) : [];
    const capabilities = [...gatewaySchemas, ...skillSchemas].sort((a, b) => a.id.localeCompare(b.id)).slice(0, limit);
    return {
      generatedAt: nowIso42(),
      scope,
      total: capabilities.length,
      capabilities
    };
  });
  methods.register("capability.schema.get", async (params) => {
    const id = parseText2(params.id);
    if (!id)
      throw new Error("capability_id_required");
    const all = [
      ...buildGatewayCapabilitySchemas(runtime.methods.list()),
      ...buildSkillCapabilitySchemas(discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []))
    ];
    const hit = all.find((item) => item.id === id);
    if (!hit)
      throw new Error(`capability_not_found:${id}`);
    return hit;
  });
  methods.register("strategy.experiments.get", async () => readStrategyExperimentConfig(projectDir));
  methods.register("strategy.experiments.set", async (params) => {
    const policyHash = parseText2(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const parseRule = (key) => {
      const raw = params[key];
      if (!raw || typeof raw !== "object")
        return;
      const obj = raw;
      return {
        enabled: obj.enabled === true,
        rolloutPercent: typeof obj.rolloutPercent === "number" ? Number(obj.rolloutPercent) : 0
      };
    };
    return writeStrategyExperimentConfig(projectDir, {
      routing: parseRule("routing"),
      memory_write: parseRule("memory_write"),
      approval_threshold: parseRule("approval_threshold")
    });
  });
  methods.register("strategy.experiments.replay", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(20000, Number(params.limit)) : 5000;
    return replayStrategyOffline(projectDir, { limit });
  });
  methods.register("sessions.list", async () => listSessions(projectDir));
  methods.register("sessions.get", async (params) => {
    const sessionID = parseText2(params.sessionID);
    if (!sessionID)
      throw new Error("invalid_session_id");
    return getSession(projectDir, sessionID);
  });
  methods.register("sessions.policy.set", async (params) => {
    const sessionID = parseText2(params.sessionID);
    const policyHash = parseText2(params.policyHash) || undefined;
    if (!sessionID)
      throw new Error("invalid_session_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const patch = {};
    if (params.activation === "active" || params.activation === "queued" || params.activation === "muted") {
      patch.activation = params.activation;
    }
    if (params.reply === "auto" || params.reply === "manual" || params.reply === "summary_only") {
      patch.reply = params.reply;
    }
    if (params.queueStrategy === "fifo" || params.queueStrategy === "priority" || params.queueStrategy === "cooldown") {
      patch.queueStrategy = params.queueStrategy;
    }
    const updated = setSessionPolicy(projectDir, sessionID, patch);
    if (!updated)
      throw new Error("session_not_found");
    return updated;
  });
  methods.register("sessions.send", async (params) => {
    const sessionID = parseText2(params.sessionID);
    const text = parseText2(params.text);
    if (!sessionID || !text)
      throw new Error("invalid_sessions_send_args");
    if (text.trim() === "/start") {
      const wizard = isCompanionWizardEmpty(projectDir, sessionID) ? startCompanionWizard(projectDir, { sessionId: sessionID }) : readCompanionWizardState(projectDir, sessionID);
      return {
        sessionID: wizard.sessionId,
        wizard,
        checklist: wizardChecklist(wizard),
        message: wizard.state === "awaiting_photos" ? WIZARD_PROMPT_PHOTOS : `${wizardPromptByState(wizard.state)}`,
        instruction: ""
      };
    }
    if (text.trim() === "/reset_personality") {
      const wizard = resetCompanionWizard(projectDir, sessionID);
      return {
        sessionID: wizard.sessionId,
        wizard,
        message: " /start"
      };
    }
    upsertSession(projectDir, {
      id: sessionID,
      kind: sessionID.startsWith("opencode:") ? "opencode" : "channel",
      groupId: sessionID,
      routingSessionID: parseText2(params.routingSessionID) || "main",
      agent: parseText2(params.agent) || "1-task-manager"
    });
    return routeSessionMessage(projectDir, {
      sessionID,
      text,
      source: parseText2(params.source) || "gateway"
    });
  });
  methods.register("cron.list", async () => depsOf(projectDir).automationService?.listJobs() ?? []);
  methods.register("cron.runs.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(200, Number(params.limit)) : 50;
    return depsOf(projectDir).automationService?.listHistory(limit) ?? [];
  });
  methods.register("cron.runs.remove", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText2(params.policyHash) || undefined;
    const runID = parseText2(params.runID);
    if (!runID)
      throw new Error("invalid_run_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return { removed: service.deleteHistoryRecord(runID) };
  });
  methods.register("cron.add", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText2(params.policyHash) || undefined;
    const name = parseText2(params.name);
    const time5 = parseText2(params.time);
    const command = parseText2(params.command);
    if (!name || !time5 || !command)
      throw new Error("invalid_cron_add_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.scheduleDailyCommand({
      name,
      time: time5,
      command,
      cwd: parseText2(params.cwd) || undefined,
      timeoutMs: typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : undefined,
      requireApproval: typeof params.requireApproval === "boolean" ? params.requireApproval : false
    });
  });
  methods.register("cron.remove", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText2(params.policyHash) || undefined;
    const jobID = parseText2(params.jobID);
    if (!jobID)
      throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return { removed: service.deleteJob(jobID) };
  });
  methods.register("cron.update", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText2(params.policyHash) || undefined;
    const jobID = parseText2(params.jobID);
    if (!jobID || typeof params.enabled !== "boolean")
      throw new Error("invalid_cron_update_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.setJobEnabled(jobID, params.enabled);
  });
  methods.register("cron.run.now", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText2(params.policyHash) || undefined;
    const jobID = parseText2(params.jobID);
    if (!jobID)
      throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.runJobNow(jobID);
  });
  methods.register("cron.approvals.list", async () => depsOf(projectDir).automationService?.listApprovals() ?? []);
  methods.register("cron.approvals.approve", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText2(params.policyHash) || undefined;
    const approvalID = parseText2(params.approvalID);
    if (!approvalID)
      throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.approveAndRun(approvalID);
  });
  methods.register("cron.approvals.reject", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText2(params.policyHash) || undefined;
    const approvalID = parseText2(params.approvalID);
    if (!approvalID)
      throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.rejectApproval(approvalID);
  });
  registerGatewayChannelMethods(methods, (methods2) => {
    methods2.register("channels.list", async () => runtime.channelRuntime.listChannels());
    methods2.register("channels.status", async () => ({
      channels: runtime.channelRuntime.listChannels(),
      pendingPairs: runtime.channelRuntime.listPairs("pending"),
      governance: summarizeChannelGovernance(projectDir, 500)
    }));
    methods2.register("channels.governance.get", async (params) => {
      const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 500;
      const limit = Math.max(20, Math.min(5000, Math.floor(limitRaw)));
      return summarizeChannelGovernance(projectDir, limit);
    });
    methods2.register("channels.pair.list", async (params) => {
      if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
        return runtime.channelRuntime.listPairs(params.status);
      }
      return runtime.channelRuntime.listPairs();
    });
    methods2.register("channels.pair.approve", async (params) => {
      const pairID = parseText2(params.pairID);
      if (!pairID)
        throw new Error("invalid_pair_id");
      return runtime.channelRuntime.approvePair(pairID);
    });
    methods2.register("channels.pair.reject", async (params) => {
      const pairID = parseText2(params.pairID);
      if (!pairID)
        throw new Error("invalid_pair_id");
      return runtime.channelRuntime.rejectPair(pairID);
    });
    methods2.register("channels.contact.tier.set", async (params) => {
      const channel = parseChannel(params.channel);
      const senderID = parseText2(params.senderID);
      const tier = parseText2(params.tier);
      if (!channel || !senderID)
        throw new Error("invalid_channels_contact_tier_args");
      if (tier !== "owner" && tier !== "friend") {
        throw new Error("invalid_channels_contact_tier");
      }
      return setContactTier(projectDir, channel, senderID, tier);
    });
    methods2.register("channels.contact.tier.get", async (params) => {
      const channel = parseChannel(params.channel);
      const senderID = parseText2(params.senderID);
      if (!channel || !senderID)
        throw new Error("invalid_channels_contact_tier_args");
      return {
        channel,
        senderID,
        tier: getContactTier(projectDir, channel, senderID)
      };
    });
    methods2.register("channels.contact.tier.list", async (params) => {
      const channel = parseChannel(params.channel);
      return {
        contacts: listContactTiers(projectDir, channel ?? undefined)
      };
    });
    methods2.register("channels.message.send", async (params) => {
      const channel = parseChannel(params.channel);
      const destination = parseText2(params.destination);
      const text = parseText2(params.text);
      const mediaID = parseText2(params.mediaID);
      const mediaPathInput = parseText2(params.mediaPath);
      const idempotencyKey = parseText2(params.idempotencyKey);
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      const mediaFromStore = mediaID ? getMediaItem(projectDir, mediaID) : null;
      const mediaPath = mediaPathInput || mediaFromStore?.localPath || "";
      if (!channel || !destination || !text && !mediaPath) {
        throw new Error("invalid_channels_send_args");
      }
      const outboundCheckRaw = params.outboundCheck && typeof params.outboundCheck === "object" ? params.outboundCheck : null;
      const outboundCheck = {
        archAdvisorApproved: outboundCheckRaw && typeof outboundCheckRaw.archAdvisorApproved === "boolean" ? Boolean(outboundCheckRaw.archAdvisorApproved) : undefined,
        intent: outboundCheckRaw && typeof outboundCheckRaw.intent === "string" ? String(outboundCheckRaw.intent) : undefined,
        factorRecipientIsMe: outboundCheckRaw && typeof outboundCheckRaw.factorRecipientIsMe === "boolean" ? Boolean(outboundCheckRaw.factorRecipientIsMe) : undefined,
        userInitiated: outboundCheckRaw && typeof outboundCheckRaw.userInitiated === "boolean" ? Boolean(outboundCheckRaw.userInitiated) : undefined,
        proactivePing: outboundCheckRaw && typeof outboundCheckRaw.proactivePing === "boolean" ? Boolean(outboundCheckRaw.proactivePing) : undefined,
        negotiationID: outboundCheckRaw && typeof outboundCheckRaw.negotiationID === "string" ? String(outboundCheckRaw.negotiationID) : undefined,
        retryAttemptType: outboundCheckRaw && (outboundCheckRaw.retryAttemptType === "auto" || outboundCheckRaw.retryAttemptType === "human") ? outboundCheckRaw.retryAttemptType : undefined,
        pendingQueueDelivery: outboundCheckRaw && typeof outboundCheckRaw.pendingQueueDelivery === "boolean" ? Boolean(outboundCheckRaw.pendingQueueDelivery) : undefined,
        evidenceConfidence: outboundCheckRaw && typeof outboundCheckRaw.evidenceConfidence === "number" && Number.isFinite(outboundCheckRaw.evidenceConfidence) ? Number(outboundCheckRaw.evidenceConfidence) : undefined,
        captureLimitations: outboundCheckRaw && Array.isArray(outboundCheckRaw.captureLimitations) ? outboundCheckRaw.captureLimitations.filter((item) => typeof item === "string").map((item) => item.trim()).filter((item) => item.length > 0).slice(0, 32) : undefined,
        psycheSignals: outboundCheckRaw && outboundCheckRaw.psycheSignals && typeof outboundCheckRaw.psycheSignals === "object" && !Array.isArray(outboundCheckRaw.psycheSignals) ? outboundCheckRaw.psycheSignals : undefined
      };
      const confirmationRaw = params.confirmation && typeof params.confirmation === "object" ? params.confirmation : null;
      return sendChannelMessageGuarded(projectDir, runtime, {
        channel,
        destination,
        text,
        mediaPath,
        idempotencyKey,
        sessionID,
        policyHash,
        outboundCheck,
        confirmation: {
          physicalConfirmed: confirmationRaw && typeof confirmationRaw.physicalConfirmed === "boolean" ? Boolean(confirmationRaw.physicalConfirmed) : undefined,
          password: confirmationRaw && typeof confirmationRaw.password === "string" ? String(confirmationRaw.password) : undefined,
          passphrase: confirmationRaw && typeof confirmationRaw.passphrase === "string" ? String(confirmationRaw.passphrase) : undefined,
          ownerSyncToken: confirmationRaw && typeof confirmationRaw.ownerSyncToken === "string" ? String(confirmationRaw.ownerSyncToken) : undefined
        }
      });
    });
  });
  registerGatewaySecurityMethods(methods, (methods2) => {
    methods2.register("security.audit", async () => {
      return runGatewaySecurityAudit(projectDir, runtime);
    });
    methods2.register("security.identity.status", async () => {
      const state = readOwnerIdentityState(projectDir);
      return {
        ...state,
        passwordHash: state.passwordHash ? "***" : undefined,
        passphraseHash: state.passphraseHash ? "***" : undefined
      };
    });
    methods2.register("security.identity.init", async (params) => {
      const password = parseText2(params.password);
      const passphrase = parseText2(params.passphrase);
      if (!password || !passphrase)
        throw new Error("invalid_owner_secret_input");
      const next = initOwnerIdentity(projectDir, {
        password,
        passphrase,
        voiceprintEmbeddingID: parseText2(params.voiceprintEmbeddingID) || undefined,
        voiceprintModelPath: parseText2(params.voiceprintModelPath) || undefined,
        voiceprintSampleDir: parseText2(params.voiceprintSampleDir) || undefined,
        voiceprintThresholds: {
          ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : undefined,
          guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : undefined,
          ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : undefined,
          guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : undefined,
          ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : undefined,
          minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : undefined,
          farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : undefined,
          frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : undefined
        }
      });
      return {
        ...next,
        passwordHash: "***",
        passphraseHash: "***"
      };
    });
    methods2.register("security.identity.rotate", async (params) => {
      const newPassword = parseText2(params.newPassword);
      const newPassphrase = parseText2(params.newPassphrase);
      if (!newPassword || !newPassphrase)
        throw new Error("invalid_new_owner_secret");
      const next = rotateOwnerSecrets(projectDir, {
        currentPassword: parseText2(params.currentPassword) || undefined,
        currentPassphrase: parseText2(params.currentPassphrase) || undefined,
        newPassword,
        newPassphrase
      });
      return {
        ...next,
        passwordHash: "***",
        passphraseHash: "***"
      };
    });
    methods2.register("security.voiceprint.threshold.get", async () => {
      const state = readOwnerIdentityState(projectDir);
      return {
        ...state.voiceprintThresholds
      };
    });
    methods2.register("security.voiceprint.threshold.set", async (params) => {
      const next = updateVoiceprintThresholds(projectDir, {
        ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : undefined,
        guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : undefined,
        ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : undefined,
        guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : undefined,
        ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : undefined,
        minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : undefined,
        farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : undefined,
        frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : undefined
      });
      return {
        ...next.voiceprintThresholds
      };
    });
    methods2.register("security.owner_sync.issue", async (params) => {
      const action = parseText2(params.action) || "outbound.high_risk.send";
      const payloadHash = parseText2(params.payloadHash);
      if (!payloadHash)
        throw new Error("invalid_payload_hash");
      return issueOwnerSyncToken(projectDir, {
        action,
        payloadHash,
        ttlMs: typeof params.ttlMs === "number" ? Number(params.ttlMs) : undefined
      });
    });
    methods2.register("policy.get", async () => {
      const policy = readPolicy(projectDir);
      return {
        policy,
        hash: currentPolicyHash(projectDir)
      };
    });
    methods2.register("daemon.python.env.status", async () => {
      const daemon = getMiyaClient(projectDir);
      const status = await daemon.getPythonRuntimeStatus();
      if (!status)
        return null;
      const recommendations = normalizeRuntimeDependencyRecommendations(status);
      const assist = await maybeTriggerDependencyAssist(projectDir, runtime, status);
      return {
        ...status,
        repairPlan: {
          ...status.repairPlan ?? {},
          recommendations
        },
        opencodeAssist: assist
      };
    });
    methods2.register("daemon.python.env.repair.plan", async (params) => {
      const daemon = getMiyaClient(projectDir);
      const status = await daemon.getPythonRuntimeStatus();
      if (!status)
        throw new Error("python_runtime_status_unavailable");
      const recommendations = normalizeRuntimeDependencyRecommendations(status);
      const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
      const route = await routeSessionMessage(projectDir, {
        sessionID: parseText2(params.sessionID) || "main",
        source: "daemon.python.env.repair.plan",
        text: prompt
      });
      return {
        issueType: status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok",
        warnings: status.repairPlan?.warnings ?? [],
        conflicts: status.repairPlan?.conflicts ?? [],
        oneShotCommand: status.repairPlan?.oneShotCommand,
        recommendations,
        routed: route
      };
    });
    methods2.register("daemon.model.lock.status", async () => {
      const daemon = getMiyaClient(projectDir);
      return daemon.getModelLockStatus();
    });
    methods2.register("daemon.model.update.plan", async (params) => {
      const daemon = getMiyaClient(projectDir);
      const target = parseText2(params.target);
      return daemon.getModelUpdatePlan(target || undefined);
    });
    methods2.register("daemon.model.update.apply", async (params) => {
      const daemon = getMiyaClient(projectDir);
      const target = parseText2(params.target);
      return daemon.applyModelUpdate(target || undefined);
    });
    methods2.register("daemon.model.update.wizard", async (params) => {
      const daemon = getMiyaClient(projectDir);
      const target = parseText2(params.target);
      const plan = await daemon.getModelUpdatePlan(target || undefined);
      const pending = Array.isArray(plan.items) ? plan.items.filter((item) => item && item.ok === false) : [];
      const models = pending.map((item) => String(item.model ?? "").trim()).filter(Boolean);
      return {
        pending: typeof plan.pending === "number" ? plan.pending : pending.length,
        models,
        blockers: pending.map((item) => ({
          model: String(item.model ?? ""),
          reason: String(item.reason ?? "metadata_mismatch")
        })),
        suggestedCommands: {
          plan: models.length > 0 ? models.map((model) => `daemon.model.update.plan target=${model}`) : ["daemon.model.update.plan"],
          apply: models.length > 0 ? models.map((model) => `daemon.model.update.apply target=${model}`) : ["daemon.model.update.apply"]
        },
        nextAction: pending.length > 0 ? "apply model update before inference/training" : "model metadata is synchronized"
      };
    });
    methods2.register("policy.domains.list", async () => {
      const policy = readPolicy(projectDir);
      return {
        domains: POLICY_DOMAINS.map((domain3) => ({
          domain: domain3,
          status: policy.domains[domain3]
        })),
        hash: currentPolicyHash(projectDir)
      };
    });
    methods2.register("policy.incidents.list", async (params) => {
      const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
      return {
        incidents: listPolicyIncidents(projectDir, limit)
      };
    });
    methods2.register("policy.domain.pause", async (params) => {
      const domain3 = parseText2(params.domain);
      if (!isPolicyDomain(domain3)) {
        throw new Error("invalid_policy_domain");
      }
      const state = transitionSafetyState(projectDir, {
        source: "policy.domain.pause",
        reason: `manual_pause:${domain3}`,
        policyHash: currentPolicyHash(projectDir),
        domains: {
          [domain3]: "paused"
        }
      });
      appendPolicyIncident(projectDir, {
        type: "manual_pause",
        reason: `manual_pause:${domain3}`,
        pausedDomains: [domain3],
        statusByDomain: {
          [domain3]: state.domains[domain3] === "running" ? "running" : "paused"
        },
        policyHash: currentPolicyHash(projectDir)
      });
      return {
        domain: domain3,
        status: state.domains[domain3] === "running" ? "running" : "paused",
        hash: currentPolicyHash(projectDir)
      };
    });
    methods2.register("policy.domain.resume", async (params) => {
      const domain3 = parseText2(params.domain);
      if (!isPolicyDomain(domain3)) {
        throw new Error("invalid_policy_domain");
      }
      const kill = readKillSwitch(projectDir);
      const safety = readSafetyState(projectDir);
      if (kill.active || safety.globalState === "killed") {
        throw new Error("kill_switch_active");
      }
      const state = transitionSafetyState(projectDir, {
        source: "policy.domain.resume",
        reason: `manual_resume:${domain3}`,
        policyHash: currentPolicyHash(projectDir),
        domains: {
          [domain3]: "running"
        }
      });
      appendPolicyIncident(projectDir, {
        type: "manual_resume",
        reason: `manual_resume:${domain3}`,
        pausedDomains: [domain3],
        statusByDomain: {
          [domain3]: state.domains[domain3] === "running" ? "running" : "paused"
        },
        policyHash: currentPolicyHash(projectDir)
      });
      return {
        domain: domain3,
        status: state.domains[domain3] === "running" ? "running" : "paused",
        hash: currentPolicyHash(projectDir)
      };
    });
    methods2.register("killswitch.set_mode", async (params) => {
      const modeRaw = parseText2(params.mode)?.toLowerCase();
      const mode = modeRaw === "all_stop" || modeRaw === "outbound_only" || modeRaw === "desktop_only" || modeRaw === "off" ? modeRaw : null;
      if (!mode)
        throw new Error("invalid_killswitch_mode");
      const reason = parseText2(params.reason) || `manual_mode:${mode}`;
      if (mode === "all_stop") {
        const traceID = randomUUID24();
        activateKillSwitch(projectDir, reason, traceID);
        transitionSafetyState(projectDir, {
          source: "killswitch.set_mode",
          reason,
          traceID,
          policyHash: currentPolicyHash(projectDir),
          globalState: "killed",
          domains: {
            outbound_send: "killed",
            desktop_control: "killed"
          }
        });
      } else if (mode === "off") {
        releaseKillSwitch(projectDir);
        transitionSafetyState(projectDir, {
          source: "killswitch.set_mode",
          reason,
          policyHash: currentPolicyHash(projectDir),
          globalState: "running",
          domains: {
            outbound_send: "running",
            desktop_control: "running"
          }
        });
      } else {
        releaseKillSwitch(projectDir);
        transitionSafetyState(projectDir, {
          source: "killswitch.set_mode",
          reason,
          policyHash: currentPolicyHash(projectDir),
          globalState: "running",
          domains: {
            outbound_send: mode === "desktop_only" ? "running" : "paused",
            desktop_control: mode === "outbound_only" ? "running" : "paused"
          }
        });
      }
      runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, readKillSwitch(projectDir));
      appendNexusInsight(runtime, {
        text: `KillSwitch mode -> ${runtime.nexus.killSwitchMode}`
      });
      publishGatewayEvent(runtime, "gateway.killswitch.mode", {
        mode: runtime.nexus.killSwitchMode,
        at: nowIso42()
      });
      return {
        mode: runtime.nexus.killSwitchMode,
        hash: currentPolicyHash(projectDir)
      };
    });
    methods2.register("intervention.approve", async (params, context) => {
      const sessionID = parseText2(params.sessionID) || "main";
      const permission = parseText2(params.permission) || "external_message";
      const action = parseText2(params.action) || `intervention_approve:${permission}`;
      const tierText = normalizeApprovalTier(parseText2(params.tier).toLowerCase());
      const patternsRaw = Array.isArray(params.patterns) ? params.patterns : ["*"];
      const patterns = patternsRaw.map((item) => String(item).trim()).filter(Boolean);
      const normalizedPatterns = patterns.length > 0 ? patterns : ["*"];
      const requestHash = buildRequestHash({
        permission,
        patterns: normalizedPatterns,
        toolCallID: "",
        messageID: ""
      }, false);
      const token = saveApprovalToken(projectDir, sessionID, {
        trace_id: randomUUID24(),
        request_hash: requestHash,
        tier: tierText,
        action
      });
      const auditID = appendInterventionAudit(projectDir, {
        command: "approve",
        actor: context.clientID,
        sourceRole: context.role,
        payload: {
          sessionID,
          permission,
          patterns: normalizedPatterns,
          tier: tierText,
          requestHash,
          tokenExpiresAt: token.expires_at
        }
      });
      appendNexusInsight(runtime, {
        text: `Intervention approve -> ${permission} (${sessionID})`,
        auditID
      });
      publishGatewayEvent(runtime, "intervention.approve", {
        at: nowIso42(),
        auditID,
        sessionID,
        permission,
        tier: tierText,
        tokenExpiresAt: token.expires_at
      });
      return {
        status: "recorded",
        auditID,
        grant: {
          sessionID,
          permission,
          requestHash,
          expiresAt: token.expires_at
        }
      };
    });
    methods2.register("intervention.pause", async (params, context) => {
      const domain3 = parseText2(params.domain);
      if (!isPolicyDomain(domain3))
        throw new Error("invalid_policy_domain");
      const result = await methods2.invoke("policy.domain.pause", { domain: domain3 }, { clientID: context.clientID, role: "admin" });
      const auditID = appendInterventionAudit(projectDir, {
        command: "pause",
        actor: context.clientID,
        sourceRole: context.role,
        payload: { domain: domain3, result }
      });
      publishGatewayEvent(runtime, "intervention.pause", {
        at: nowIso42(),
        auditID,
        domain: domain3,
        result
      });
      return {
        status: "recorded",
        auditID,
        domain: domain3,
        result
      };
    });
    methods2.register("intervention.kill", async (params, context) => {
      const reason = parseText2(params.reason) || "intervention_kill";
      const result = await methods2.invoke("killswitch.set_mode", { mode: "all_stop", reason }, { clientID: context.clientID, role: "admin" });
      const auditID = appendInterventionAudit(projectDir, {
        command: "kill",
        actor: context.clientID,
        sourceRole: context.role,
        payload: { reason, result }
      });
      publishGatewayEvent(runtime, "intervention.kill", {
        at: nowIso42(),
        auditID,
        reason,
        result
      });
      return {
        status: "recorded",
        auditID,
        result
      };
    });
    methods2.register("intervention.annotate", async (params, context) => {
      const text = parseText2(params.text);
      if (!text)
        throw new Error("invalid_annotation_text");
      const at = parseText2(params.at) || nowIso42();
      const targetAuditID = parseText2(params.auditID) || undefined;
      const annotation = await methods2.invoke("insight.append", {
        text,
        at,
        auditID: targetAuditID
      }, { clientID: context.clientID, role: "admin" });
      const auditID = appendInterventionAudit(projectDir, {
        command: "annotate",
        actor: context.clientID,
        sourceRole: context.role,
        payload: {
          text,
          at,
          targetAuditID
        }
      });
      publishGatewayEvent(runtime, "intervention.annotate", {
        at,
        auditID,
        targetAuditID,
        text
      });
      return {
        status: "recorded",
        auditID,
        annotation
      };
    });
    methods2.register("trust.set_mode", async (params) => {
      const silentMinRaw = Number(params.silentMin);
      const modalMaxRaw = Number(params.modalMax);
      if (!Number.isFinite(silentMinRaw) || !Number.isFinite(modalMaxRaw)) {
        throw new Error("invalid_trust_mode_thresholds");
      }
      const next = writeTrustModeConfig(projectDir, {
        silentMin: silentMinRaw,
        modalMax: modalMaxRaw
      });
      runtime.nexus.trustMode = next;
      appendNexusInsight(runtime, {
        text: `Trust mode updated: silent>=${next.silentMin}, modal<=${next.modalMax}`
      });
      publishGatewayEvent(runtime, "trust.mode.update", {
        at: nowIso42(),
        mode: next
      });
      return {
        mode: next
      };
    });
    methods2.register("psyche.mode.get", async () => {
      const mode = readPsycheModeConfig(projectDir);
      runtime.nexus.psycheMode = mode;
      return {
        mode,
        consultEnabled: resolvePsycheConsultEnabled(projectDir, mode),
        shadow: readPsycheShadowAuditSummary(projectDir, 120)
      };
    });
    methods2.register("psyche.training.summary", async (params) => {
      const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 400;
      const limit = Math.max(20, Math.min(5000, Math.floor(limitRaw)));
      return readPsycheTrainingSummary(projectDir, limit);
    });
    methods2.register("psyche.slowbrain.get", async () => {
      return readSlowBrainState(projectDir);
    });
    methods2.register("psyche.slowbrain.retrain", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      return retrainSlowBrainPolicy(projectDir, {
        force: params.force === true,
        minOutcomes: typeof params.minOutcomes === "number" && Number.isFinite(params.minOutcomes) ? Number(params.minOutcomes) : undefined
      });
    });
    methods2.register("psyche.slowbrain.rollback", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      return rollbackSlowBrainPolicy(projectDir, parseText2(params.versionID) || undefined);
    });
    methods2.register("psyche.mode.set", async (params) => {
      const next = writePsycheModeConfig(projectDir, {
        resonanceEnabled: typeof params.resonanceEnabled === "boolean" ? Boolean(params.resonanceEnabled) : undefined,
        captureProbeEnabled: typeof params.captureProbeEnabled === "boolean" ? Boolean(params.captureProbeEnabled) : undefined,
        signalOverrideEnabled: typeof params.signalOverrideEnabled === "boolean" ? Boolean(params.signalOverrideEnabled) : undefined,
        slowBrainEnabled: typeof params.slowBrainEnabled === "boolean" ? Boolean(params.slowBrainEnabled) : undefined,
        slowBrainShadowEnabled: typeof params.slowBrainShadowEnabled === "boolean" ? Boolean(params.slowBrainShadowEnabled) : undefined,
        slowBrainShadowRollout: typeof params.slowBrainShadowRollout === "number" ? Number(params.slowBrainShadowRollout) : undefined,
        shadowCohortSalt: typeof params.shadowCohortSalt === "string" ? String(params.shadowCohortSalt) : undefined,
        proactivePingEnabled: typeof params.proactivePingEnabled === "boolean" ? Boolean(params.proactivePingEnabled) : undefined,
        proactivePingMinIntervalMinutes: typeof params.proactivePingMinIntervalMinutes === "number" ? Number(params.proactivePingMinIntervalMinutes) : undefined,
        proactivePingMaxPerDay: typeof params.proactivePingMaxPerDay === "number" ? Number(params.proactivePingMaxPerDay) : undefined,
        quietHoursEnabled: typeof params.quietHoursEnabled === "boolean" ? Boolean(params.quietHoursEnabled) : undefined,
        quietHoursStart: typeof params.quietHoursStart === "string" ? String(params.quietHoursStart) : undefined,
        quietHoursEnd: typeof params.quietHoursEnd === "string" ? String(params.quietHoursEnd) : undefined,
        quietHoursTimezoneOffsetMinutes: typeof params.quietHoursTimezoneOffsetMinutes === "number" ? Number(params.quietHoursTimezoneOffsetMinutes) : undefined
      });
      runtime.nexus.psycheMode = next;
      appendNexusInsight(runtime, {
        text: `=${next.resonanceEnabled ? "" : ""}=${next.captureProbeEnabled ? "" : ""}=${next.signalOverrideEnabled ? "" : ""}slow_brain=${next.slowBrainEnabled ? "" : ""}shadow=${next.slowBrainShadowEnabled ? "" : ""}(${next.slowBrainShadowRollout}%)proactive=${next.proactivePingEnabled ? "" : ""}(${next.proactivePingMinIntervalMinutes}m/${next.proactivePingMaxPerDay})quiet=${next.quietHoursEnabled ? `${next.quietHoursStart}-${next.quietHoursEnd}` : ""}`
      });
      publishGatewayEvent(runtime, "psyche.mode.update", {
        at: nowIso42(),
        mode: next,
        consultEnabled: resolvePsycheConsultEnabled(projectDir, next)
      });
      return {
        mode: next,
        consultEnabled: resolvePsycheConsultEnabled(projectDir, next),
        shadow: readPsycheShadowAuditSummary(projectDir, 120)
      };
    });
    methods2.register("psyche.mode.rollback", async (params) => {
      const token = parseText2(params.token) || undefined;
      const restored = rollbackPsycheModeConfig(projectDir, token);
      runtime.nexus.psycheMode = restored.mode;
      appendNexusInsight(runtime, {
        text: `token=${restored.rollbackToken ?? "latest"}`
      });
      publishGatewayEvent(runtime, "psyche.mode.rollback", {
        at: nowIso42(),
        mode: restored.mode,
        rollbackToken: restored.rollbackToken
      });
      return {
        mode: restored.mode,
        rollbackToken: restored.rollbackToken,
        consultEnabled: resolvePsycheConsultEnabled(projectDir, restored.mode)
      };
    });
    methods2.register("psyche.shadow.stats", async (params) => {
      const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 200;
      const limit = Math.max(20, Math.min(2000, Math.floor(limitRaw)));
      return {
        mode: readPsycheModeConfig(projectDir),
        stats: readPsycheShadowAuditSummary(projectDir, limit)
      };
    });
    methods2.register("psyche.proactive.state.get", async () => {
      const mode = readPsycheModeConfig(projectDir);
      runtime.nexus.psycheMode = mode;
      const now = new Date;
      return {
        mode,
        state: readProactivePingState(projectDir, mode, now),
        quietHoursActive: isQuietHoursActive(mode, now),
        quietHoursReleaseSec: nextQuietHoursReleaseSeconds(mode, now)
      };
    });
    methods2.register("psyche.proactive.ping", async (params) => {
      const channel = parseChannel(params.channel);
      const destination = parseText2(params.destination);
      const text = parseText2(params.text);
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      if (!channel || !destination || !text) {
        throw new Error("invalid_proactive_ping_args");
      }
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "outbound_send");
      const evidenceConfidence = typeof params.evidenceConfidence === "number" && Number.isFinite(params.evidenceConfidence) ? Number(params.evidenceConfidence) : undefined;
      const negotiationID = typeof params.negotiationID === "string" && params.negotiationID.trim() ? params.negotiationID.trim() : undefined;
      const result = await sendChannelMessageGuarded(projectDir, runtime, {
        channel,
        destination,
        text,
        sessionID,
        policyHash,
        outboundCheck: {
          archAdvisorApproved: true,
          intent: "initiate",
          factorRecipientIsMe: true,
          userInitiated: false,
          proactivePing: true,
          evidenceConfidence,
          negotiationID
        }
      });
      return result;
    });
    methods2.register("learning.gate.get", async () => {
      const gate = readLearningGateConfig(projectDir);
      runtime.nexus.learningGate = gate;
      return { gate };
    });
    methods2.register("learning.gate.set", async (params) => {
      const next = writeLearningGateConfig(projectDir, {
        candidateMode: params.candidateMode === "silent_audit" || params.candidateMode === "toast_gate" ? params.candidateMode : undefined,
        persistentRequiresApproval: typeof params.persistentRequiresApproval === "boolean" ? Boolean(params.persistentRequiresApproval) : undefined
      });
      runtime.nexus.learningGate = next;
      appendNexusInsight(runtime, {
        text: `candidate=${next.candidateMode}, persistent_requires_approval=${next.persistentRequiresApproval ? "1" : "0"}`
      });
      publishGatewayEvent(runtime, "learning.gate.update", {
        at: nowIso42(),
        gate: next
      });
      return { gate: next };
    });
    methods2.register("insight.append", async (params) => {
      const text = parseText2(params.text);
      if (!text)
        throw new Error("invalid_insight_text");
      const at = parseText2(params.at) || nowIso42();
      const auditID = parseText2(params.auditID);
      appendNexusInsight(runtime, { text, at, auditID: auditID || undefined });
      publishGatewayEvent(runtime, "insight.append", {
        at,
        text,
        auditID: auditID || undefined
      });
      return {
        ok: true,
        at,
        text,
        auditID: auditID || undefined
      };
    });
  });
  registerGatewayNodeMethods(methods, (methods2) => {
    methods2.register("nodes.register", async (params, context) => {
      const nodeID = parseText2(params.nodeID);
      const deviceID = parseText2(params.deviceID);
      if (!nodeID || !deviceID)
        throw new Error("invalid_nodes_register_args");
      const node = registerNode(projectDir, {
        nodeID,
        deviceID,
        type: params.type === "cli" || params.type === "desktop" || params.type === "mobile" || params.type === "browser" ? params.type : undefined,
        platform: parseText2(params.platform) || process.platform,
        capabilities: Array.isArray(params.capabilities) ? params.capabilities.map(String) : [],
        token: parseText2(params.token) || undefined,
        permissions: params.permissions && typeof params.permissions === "object" ? {
          screenRecording: typeof params.permissions.screenRecording === "boolean" ? Boolean(params.permissions.screenRecording) : undefined,
          accessibility: typeof params.permissions.accessibility === "boolean" ? Boolean(params.permissions.accessibility) : undefined,
          filesystem: params.permissions.filesystem === "none" || params.permissions.filesystem === "read" || params.permissions.filesystem === "full" ? params.permissions.filesystem : undefined,
          network: typeof params.permissions.network === "boolean" ? Boolean(params.permissions.network) : undefined
        } : undefined
      });
      const pair = createNodePairRequest(projectDir, { nodeID, deviceID });
      const ws = context.ws;
      if (ws)
        runtime.nodeSockets.set(nodeID, ws);
      return { node, pair };
    });
    methods2.register("nodes.list", async () => listNodes(projectDir));
    methods2.register("nodes.heartbeat", async (params) => {
      const nodeID = parseText2(params.nodeID);
      if (!nodeID)
        throw new Error("invalid_node_id");
      const node = touchNodeHeartbeat(projectDir, nodeID);
      if (!node)
        throw new Error("node_not_found");
      return node;
    });
    methods2.register("nodes.token.issue", async (params) => {
      const nodeID = parseText2(params.nodeID);
      if (!nodeID)
        throw new Error("invalid_node_id");
      const issued = issueNodeToken(projectDir, nodeID);
      if (!issued)
        throw new Error("node_not_found");
      return issued;
    });
    methods2.register("nodes.status", async () => {
      const nodes = listNodes(projectDir);
      const pendingPairs = listNodePairs(projectDir, "pending");
      return {
        nodes,
        enrichedNodes: nodes.map((item) => withNodeGovernance(item)),
        pendingPairs,
        governance: summarizeNodeGovernance(nodes, pendingPairs.length)
      };
    });
    methods2.register("nodes.governance.summary", async () => {
      const nodes = listNodes(projectDir);
      const pendingPairs = listNodePairs(projectDir, "pending").length;
      return summarizeNodeGovernance(nodes, pendingPairs);
    });
    methods2.register("nodes.describe", async (params) => {
      const nodeID = parseText2(params.nodeID);
      if (!nodeID)
        throw new Error("invalid_node_id");
      const node = describeNode(projectDir, nodeID);
      if (!node)
        return null;
      return withNodeGovernance(node);
    });
    methods2.register("nodes.pair.list", async (params) => {
      if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
        return listNodePairs(projectDir, params.status);
      }
      return listNodePairs(projectDir);
    });
    methods2.register("nodes.pair.approve", async (params) => {
      const pairID = parseText2(params.pairID);
      if (!pairID)
        throw new Error("invalid_pair_id");
      return resolveNodePair(projectDir, pairID, "approved");
    });
    methods2.register("nodes.pair.reject", async (params) => {
      const pairID = parseText2(params.pairID);
      if (!pairID)
        throw new Error("invalid_pair_id");
      return resolveNodePair(projectDir, pairID, "rejected");
    });
    methods2.register("nodes.invoke", async (params) => {
      const nodeID = parseText2(params.nodeID);
      const capability = parseText2(params.capability);
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      const args = params.args && typeof params.args === "object" ? params.args : {};
      if (!nodeID || !capability)
        throw new Error("invalid_nodes_invoke_args");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "desktop_control");
      const token = enforceToken({
        projectDir,
        sessionID,
        permission: "node_invoke",
        patterns: [
          `nodeId=${nodeID}`,
          `cap=${capability}`,
          `args_sha256=${hashText3(JSON.stringify(args))}`
        ]
      });
      if (!token.ok)
        throw new Error(`approval_required:${token.reason}`);
      const invoke = createInvokeRequest(projectDir, {
        nodeID,
        capability,
        args
      });
      markInvokeSent(projectDir, invoke.id);
      const nodeSocket = runtime.nodeSockets.get(nodeID);
      if (nodeSocket) {
        nodeSocket.send(JSON.stringify(toEventFrame({
          event: "node.invoke.request",
          payload: invoke,
          stateVersion: { gateway: runtime.stateVersion }
        })));
      }
      return invoke;
    });
    methods2.register("nodes.invoke.result", async (params) => {
      const invokeID = parseText2(params.invokeID);
      if (!invokeID)
        throw new Error("invalid_invoke_id");
      return resolveInvokeResult(projectDir, invokeID, {
        ok: Boolean(params.ok),
        result: params.result && typeof params.result === "object" ? params.result : undefined,
        error: parseText2(params.error) || undefined
      });
    });
    methods2.register("devices.list", async () => listDevices(projectDir));
    methods2.register("skills.status", async () => ({
      enabled: listEnabledSkills(projectDir),
      discovered: discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? [])
    }));
    methods2.register("openclaw.status.get", async () => {
      return callOpenClaw("status.get", {});
    });
    methods2.register("openclaw.skills.list", async () => {
      return callOpenClaw("skills.list", {});
    });
    methods2.register("openclaw.session.status", async (params) => {
      return callOpenClaw("session.status", {
        sessionID: parseText2(params.sessionID) || undefined
      });
    });
    methods2.register("openclaw.session.send", async (params) => {
      const sessionID = parseText2(params.sessionID);
      const text = parseText2(params.text);
      if (!sessionID || !text)
        throw new Error("invalid_openclaw_session_send");
      return callOpenClaw("session.send", {
        sessionID,
        text,
        source: parseText2(params.source) || "miya"
      });
    });
    methods2.register("openclaw.pairing.query", async (params) => {
      return callOpenClaw("pairing.query", {
        pairID: parseText2(params.pairID) || undefined
      });
    });
    methods2.register("openclaw.skills.sync", async (params) => {
      return callOpenClaw("skills.sync", {
        action: parseText2(params.action) || "list",
        sourcePackID: parseText2(params.sourcePackID) || parseText2(params.source) || parseText2(params.target) || undefined,
        revision: parseText2(params.revision) || undefined,
        sessionID: parseText2(params.sessionID) || undefined,
        policyHash: parseText2(params.policyHash) || undefined,
        dryRun: typeof params.dryRun === "boolean" ? Boolean(params.dryRun) : undefined
      });
    });
    methods2.register("openclaw.routing.map", async (params) => {
      return callOpenClaw("routing.map", {
        limit: typeof params.limit === "number" ? Number(params.limit) : undefined
      });
    });
    methods2.register("openclaw.audit.replay", async (params) => {
      return callOpenClaw("audit.replay", {
        limit: typeof params.limit === "number" ? Number(params.limit) : undefined,
        replayToken: parseText2(params.replayToken) || undefined
      });
    });
    methods2.register("ecosystem.bridge.registry.list", async () => {
      return {
        generatedAt: nowIso42(),
        total: listEcosystemBridgeRegistry().length,
        entries: listEcosystemBridgeRegistry()
      };
    });
    methods2.register("ecosystem.bridge.registry.get", async (params) => {
      const id = parseText2(params.id);
      if (!id)
        throw new Error("invalid_ecosystem_bridge_id");
      const entry2 = getEcosystemBridgeEntry(id);
      if (!entry2)
        throw new Error(`ecosystem_bridge_not_found:${id}`);
      return entry2;
    });
    methods2.register("miya.sync.list", async () => listEcosystemBridge(projectDir));
    methods2.register("miya.sync.diff", async (params) => {
      const sourcePackID = parseText2(params.sourcePackID);
      if (!sourcePackID)
        throw new Error("invalid_source_pack_id");
      return diffSourcePack(projectDir, sourcePackID);
    });
    methods2.register("miya.sync.pull", async (params) => {
      const sourcePackID = parseText2(params.sourcePackID);
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      if (!sourcePackID)
        throw new Error("invalid_source_pack_id");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "shell_exec");
      requireDomainRunning(projectDir, "fs_write");
      const token = enforceToken({
        projectDir,
        sessionID,
        permission: "skills_install",
        patterns: [`sourcePackID=${sourcePackID}`, "action=pull"]
      });
      if (!token.ok)
        throw new Error(`approval_required:${token.reason}`);
      return pullSourcePack(projectDir, sourcePackID);
    });
    methods2.register("miya.sync.apply", async (params) => {
      const sourcePackID = parseText2(params.sourcePackID);
      const revision = parseText2(params.revision) || undefined;
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      if (!sourcePackID)
        throw new Error("invalid_source_pack_id");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "shell_exec");
      requireDomainRunning(projectDir, "fs_write");
      const token = enforceToken({
        projectDir,
        sessionID,
        permission: "skills_install",
        patterns: [
          `sourcePackID=${sourcePackID}`,
          `revision=${revision ?? "latest"}`
        ]
      });
      if (!token.ok)
        throw new Error(`approval_required:${token.reason}`);
      return applySourcePack(projectDir, sourcePackID, { revision });
    });
    methods2.register("miya.sync.rollback", async (params) => {
      const sourcePackID = parseText2(params.sourcePackID);
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      if (!sourcePackID)
        throw new Error("invalid_source_pack_id");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "shell_exec");
      requireDomainRunning(projectDir, "fs_write");
      const token = enforceToken({
        projectDir,
        sessionID,
        permission: "skills_install",
        patterns: [`sourcePackID=${sourcePackID}`, "action=rollback"]
      });
      if (!token.ok)
        throw new Error(`approval_required:${token.reason}`);
      return rollbackSourcePack(projectDir, sourcePackID);
    });
    methods2.register("miya.sync.verify", async (params) => {
      const sourcePackID = parseText2(params.sourcePackID);
      if (!sourcePackID)
        throw new Error("invalid_source_pack_id");
      return verifySourcePackGovernance2(projectDir, sourcePackID);
    });
    methods2.register("miya.sync.preflight", async (params) => {
      const sourcePackID = parseText2(params.sourcePackID);
      if (!sourcePackID)
        throw new Error("invalid_source_pack_id");
      return preflightSourcePackGovernance(projectDir, sourcePackID);
    });
    methods2.register("mcp.capabilities.list", async (params) => {
      const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
      return buildMcpServiceManifest(disabled);
    });
    methods2.register("mcp.service.expose", async (params) => {
      const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
      return buildMcpServiceManifest(disabled);
    });
    methods2.register("skills.enable", async (params) => {
      const skillID = parseText2(params.skillID);
      if (!skillID)
        throw new Error("invalid_skill_id");
      const discovered = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []);
      const descriptor = discovered.find((item) => item.id === skillID || item.name === skillID);
      if (!descriptor)
        throw new Error(`skill_not_found:${skillID}`);
      if (!descriptor.gate.loadable) {
        throw new Error(`skill_not_loadable:${descriptor.gate.reasons.join("|")}`);
      }
      return { enabled: setSkillEnabled(projectDir, descriptor.id, true) };
    });
    methods2.register("skills.disable", async (params) => {
      const skillID = parseText2(params.skillID);
      if (!skillID)
        throw new Error("invalid_skill_id");
      return { enabled: setSkillEnabled(projectDir, skillID, false) };
    });
    methods2.register("skills.install", async (params) => {
      const repo = parseText2(params.repo);
      const targetName = parseText2(params.targetName) || undefined;
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      if (!repo)
        throw new Error("invalid_repo");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "shell_exec");
      requireDomainRunning(projectDir, "fs_write");
      const token = enforceToken({
        projectDir,
        sessionID,
        permission: "skills_install",
        patterns: [`repo=${repo}`]
      });
      if (!token.ok)
        throw new Error(`approval_required:${token.reason}`);
      const root = path61.join(os5.homedir(), ".config", "opencode", "miya", "skills");
      fs62.mkdirSync(root, { recursive: true });
      const name = targetName || repo.split("/").filter(Boolean).pop()?.replace(/\.git$/i, "") || `skill-${Date.now().toString(36)}`;
      const target = path61.join(root, name);
      if (fs62.existsSync(target))
        return { ok: false, message: `target_exists:${target}` };
      const proc = Bun.spawnSync(["git", "clone", "--depth", "1", repo, target], {
        stdout: "pipe",
        stderr: "pipe"
      });
      if (proc.exitCode !== 0) {
        return {
          ok: false,
          message: Buffer.from(proc.stderr).toString("utf-8").trim() || "git_clone_failed"
        };
      }
      const installed = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []).find((item) => path61.resolve(item.dir) === path61.resolve(target));
      if (!installed) {
        fs62.rmSync(target, { recursive: true, force: true });
        return {
          ok: false,
          message: "installed_skill_invalid:manifest_not_found"
        };
      }
      if (installed.gate.reasons.includes("missing_permission_metadata")) {
        fs62.rmSync(target, { recursive: true, force: true });
        return {
          ok: false,
          message: "installed_skill_invalid:missing_permission_metadata"
        };
      }
      return {
        ok: true,
        message: "installed",
        dir: target,
        gate: installed.gate
      };
    });
    methods2.register("skills.update", async (params) => {
      const dir = parseText2(params.dir);
      const sessionID = parseText2(params.sessionID) || "main";
      const policyHash = parseText2(params.policyHash) || undefined;
      if (!dir)
        throw new Error("invalid_dir");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "shell_exec");
      requireDomainRunning(projectDir, "fs_write");
      const token = enforceToken({
        projectDir,
        sessionID,
        permission: "skills_install",
        patterns: [`dir=${dir}`]
      });
      if (!token.ok)
        throw new Error(`approval_required:${token.reason}`);
      const proc = Bun.spawnSync(["git", "-C", dir, "pull", "--ff-only"], {
        stdout: "pipe",
        stderr: "pipe"
      });
      if (proc.exitCode !== 0) {
        return {
          ok: false,
          message: Buffer.from(proc.stderr).toString("utf-8").trim() || "git_pull_failed"
        };
      }
      return {
        ok: true,
        message: Buffer.from(proc.stdout).toString("utf-8").trim() || "updated"
      };
    });
    methods2.register("media.ingest", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      const source = parseText2(params.source);
      const mimeType = parseText2(params.mimeType);
      const fileName = parseText2(params.fileName);
      if (!source || !mimeType || !fileName)
        throw new Error("invalid_media_ingest_args");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "fs_write");
      if (params.kind !== "image" && params.kind !== "audio" && params.kind !== "video" && params.kind !== "file") {
        throw new Error("invalid_media_kind");
      }
      return ingestMedia(projectDir, {
        source,
        kind: params.kind,
        mimeType,
        fileName,
        contentBase64: parseText2(params.contentBase64) || undefined,
        sizeBytes: typeof params.sizeBytes === "number" ? Number(params.sizeBytes) : undefined,
        ttlHours: typeof params.ttlHours === "number" ? Number(params.ttlHours) : undefined,
        metadata: params.metadata && typeof params.metadata === "object" ? params.metadata : undefined
      });
    });
    methods2.register("media.get", async (params) => {
      const mediaID = parseText2(params.mediaID);
      if (!mediaID)
        throw new Error("invalid_media_id");
      return getMediaItem(projectDir, mediaID);
    });
    methods2.register("media.gc.run", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "fs_write");
      return runMediaGc(projectDir);
    });
    methods2.register("media.list", async (params) => {
      const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
      return listMediaItems(projectDir, limit);
    });
    methods2.register("voice.status", async () => readVoiceState(projectDir));
    methods2.register("voice.wake.enable", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      return patchVoiceState(projectDir, {
        enabled: true,
        wakeWordEnabled: true
      });
    });
    methods2.register("voice.wake.disable", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      return patchVoiceState(projectDir, {
        wakeWordEnabled: false
      });
    });
    methods2.register("voice.talk.start", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      return patchVoiceState(projectDir, {
        enabled: true,
        talkMode: true,
        routeSessionID: parseText2(params.sessionID) || readVoiceState(projectDir).routeSessionID
      });
    });
    methods2.register("voice.talk.stop", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      return patchVoiceState(projectDir, {
        talkMode: false
      });
    });
    methods2.register("voice.input.ingest", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const mediaID = parseText2(params.mediaID) || undefined;
      const source = parseText2(params.source) === "wake" || parseText2(params.source) === "talk" || parseText2(params.source) === "media" ? parseText2(params.source) : "manual";
      const language = parseText2(params.language) || undefined;
      const speakerHint = parseText2(params.speakerHint) || undefined;
      const speakerScore = typeof params.speakerScore === "number" ? Number(params.speakerScore) : undefined;
      const mediaPath = mediaID ? getMediaItem(projectDir, mediaID)?.localPath : undefined;
      const voiceprint = await verifyVoiceprintWithLocalModel(projectDir, {
        mediaPath,
        speakerHint,
        speakerScore
      });
      const mode = voiceprint.mode;
      setInteractionMode(projectDir, mode);
      if (mode !== "owner") {
        transitionSafetyState(projectDir, {
          source: "speaker_gate",
          reason: `speaker_mode_${mode}`,
          domains: {
            outbound_send: "paused",
            desktop_control: "paused",
            memory_read: "paused"
          }
        });
      }
      let text = parseText2(params.text);
      let asr;
      let asrError;
      if (!text && mediaID) {
        const media = getMediaItem(projectDir, mediaID);
        const transcript = typeof media?.metadata?.transcript === "string" ? String(media?.metadata?.transcript) : "";
        if (transcript.trim()) {
          text = transcript.trim();
        } else {
          const config4 = readConfig(projectDir);
          const sttMode = config4.voice?.input?.stt;
          const sttEnabled = sttMode !== "off";
          if (sttEnabled && media?.localPath) {
            if (useGatewayAsrTestMode()) {
              asr = {
                text: `[asr:${path61.basename(media.localPath)}]`,
                language: language || "unknown",
                confidence: 0.81,
                model: "test:whisper",
                tier: "reference",
                degraded: true,
                message: "asr_test_mode"
              };
              text = asr.text.trim();
            } else {
              try {
                asr = await getMiyaClient(projectDir).runAsrTranscribe({
                  inputPath: media.localPath,
                  language
                });
                text = asr.text.trim();
              } catch (error92) {
                asrError = error92 instanceof Error ? error92.message : String(error92);
              }
            }
            if (text) {
              patchMediaMetadata(projectDir, mediaID, {
                transcript: text,
                transcriptConfidence: asr?.confidence,
                transcriptLanguage: asr?.language ?? language,
                transcriptModel: asr?.model,
                transcriptAt: nowIso42(),
                transcriptSource: "miya_local_asr"
              });
            }
          }
        }
        if (!text) {
          text = `[media:${mediaID}]`;
        }
      }
      if (!text)
        throw new Error("invalid_voice_input");
      if (mode === "guest") {
        const guestReply = "";
        appendGuestConversation(projectDir, {
          text,
          source,
          sessionID: parseText2(params.sessionID) || "main"
        });
        return {
          item: appendVoiceHistory(projectDir, {
            text,
            source,
            language,
            mediaID
          }),
          routed: {
            delivered: false,
            queued: false,
            reason: "guest_mode_restricted"
          },
          mode,
          voiceprint,
          reply: guestReply,
          asr,
          asrError,
          voice: readVoiceState(projectDir)
        };
      }
      const item = appendVoiceHistory(projectDir, {
        text,
        source,
        language,
        mediaID
      });
      const voice = readVoiceState(projectDir);
      const targetSessionID = parseText2(params.sessionID) || voice.routeSessionID || "main";
      const routed = await routeSessionMessage(projectDir, {
        sessionID: targetSessionID,
        text,
        source: `voice:${source}`
      });
      return {
        item,
        routed,
        mode,
        voiceprint,
        asr,
        asrError,
        voice: readVoiceState(projectDir)
      };
    });
    methods2.register("voice.history.list", async (params) => {
      const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
      return readVoiceState(projectDir).history.slice(0, limit);
    });
    methods2.register("voice.history.clear", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_delete");
      return clearVoiceHistory(projectDir);
    });
    methods2.register("canvas.status", async () => {
      const state = readCanvasState(projectDir);
      return {
        activeDocID: state.activeDocID,
        docs: listCanvasDocs(projectDir),
        events: state.events.slice(0, 100)
      };
    });
    methods2.register("canvas.list", async () => listCanvasDocs(projectDir));
    methods2.register("canvas.get", async (params) => {
      const docID = parseText2(params.docID);
      if (!docID)
        throw new Error("invalid_doc_id");
      return getCanvasDoc(projectDir, docID);
    });
    methods2.register("canvas.open", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      const title = parseText2(params.title);
      const type = parseText2(params.type);
      const content = parseText2(params.content);
      if (!title)
        throw new Error("invalid_canvas_title");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "fs_write");
      if (type && type !== "text" && type !== "markdown" && type !== "json" && type !== "html") {
        throw new Error("invalid_canvas_type");
      }
      const docType = type === "text" || type === "markdown" || type === "json" || type === "html" ? type : undefined;
      return openCanvasDoc(projectDir, {
        title,
        type: docType,
        content,
        actor: parseText2(params.actor) || "gateway"
      });
    });
    methods2.register("canvas.render", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      const docID = parseText2(params.docID);
      const content = parseText2(params.content);
      if (!docID || !content)
        throw new Error("invalid_canvas_render_args");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "fs_write");
      return renderCanvasDoc(projectDir, {
        docID,
        content,
        merge: Boolean(params.merge),
        actor: parseText2(params.actor) || "gateway"
      });
    });
    methods2.register("canvas.close", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      const docID = parseText2(params.docID);
      if (!docID)
        throw new Error("invalid_doc_id");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "fs_write");
      return closeCanvasDoc(projectDir, docID, parseText2(params.actor) || "gateway");
    });
  });
  registerGatewayCompanionMethods(methods, (methods2) => {
    methods2.register("companion.status", async () => readCompanionProfile(projectDir));
    methods2.register("companion.persona.presets.list", async () => {
      requireOwnerMode(projectDir);
      return listPersonaPresets(projectDir);
    });
    methods2.register("companion.world.presets.list", async () => {
      requireOwnerMode(projectDir);
      return listWorldPresets(projectDir);
    });
    methods2.register("companion.persona.preset.upsert", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const name = parseText2(params.name);
      const persona = parseText2(params.persona);
      const style = parseText2(params.style);
      const relationship = parseText2(params.relationship);
      if (!name || !persona || !style || !relationship) {
        throw new Error("invalid_persona_preset_payload");
      }
      const riskRaw = parseText2(params.risk);
      const risk = riskRaw === "high" || riskRaw === "medium" || riskRaw === "low" ? riskRaw : "low";
      return upsertPersonaPreset(projectDir, {
        id: parseText2(params.id) || undefined,
        name,
        persona,
        style,
        relationship,
        risk
      });
    });
    methods2.register("companion.world.preset.upsert", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const name = parseText2(params.name);
      const summary = parseText2(params.summary);
      if (!name || !summary)
        throw new Error("invalid_world_preset_payload");
      const riskRaw = parseText2(params.risk);
      const risk = riskRaw === "high" || riskRaw === "medium" || riskRaw === "low" ? riskRaw : "low";
      return upsertWorldPreset(projectDir, {
        id: parseText2(params.id) || undefined,
        name,
        summary,
        rules: Array.isArray(params.rules) ? params.rules.map(String) : [],
        tags: Array.isArray(params.tags) ? params.tags.map(String) : [],
        risk
      });
    });
    methods2.register("companion.session.persona_world.bind", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const sessionID = parseText2(params.sessionID) || "main";
      const binding = bindSessionPersonaWorld(projectDir, {
        sessionID,
        personaPresetID: parseText2(params.personaPresetID) || undefined,
        worldPresetID: parseText2(params.worldPresetID) || undefined
      });
      const resolved = resolveSessionPersonaWorld(projectDir, sessionID);
      return {
        binding,
        resolved,
        safetyHint: resolved.risk === "high" ? "high_risk_persona_world_requires_explicit_approval_for_outbound_execution" : "normal"
      };
    });
    methods2.register("companion.session.persona_world.get", async (params) => {
      requireOwnerMode(projectDir);
      const sessionID = parseText2(params.sessionID) || "main";
      return resolveSessionPersonaWorld(projectDir, sessionID);
    });
    methods2.register("companion.wizard.start", async (params) => {
      const sessionId = parseText2(params.sessionID) || "wizard:companion";
      const session = upsertSession(projectDir, {
        id: "wizard:companion",
        kind: "wizard",
        groupId: "wizard:companion",
        title: "Companion Onboarding",
        routingSessionID: "main",
        agent: "1-task-manager"
      });
      const profile = readCompanionProfile(projectDir);
      const forceReset = Boolean(params.forceReset);
      const wizard = !forceReset && !isCompanionWizardEmpty(projectDir, sessionId) ? readCompanionWizardState(projectDir, sessionId) : startCompanionWizard(projectDir, {
        sessionId,
        forceReset
      });
      return {
        session,
        profile,
        wizard,
        checklist: wizardChecklist(wizard),
        state: wizard.state,
        message: wizardPromptByState(wizard.state),
        instruction: ""
      };
    });
    methods2.register("companion.wizard.status", async (params) => {
      const wizard = readCompanionWizardState(projectDir, parseText2(params.sessionID) || "main");
      return {
        wizard,
        checklist: wizardChecklist(wizard),
        prompt: wizardPromptByState(wizard.state)
      };
    });
    methods2.register("companion.wizard.photos.submit", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const mediaIDs = Array.isArray(params.photoMediaIDs) ? params.photoMediaIDs.map(String) : Array.isArray(params.imageMediaIDs) ? params.imageMediaIDs.map(String) : [];
      const sessionId = parseText2(params.sessionID) || "main";
      const { state, job } = submitWizardPhotos(projectDir, {
        mediaIDs,
        sessionId
      });
      return {
        state: state.state,
        message: "...",
        jobId: job.id,
        estimatedTime: job.estimatedTime,
        fallbackStrategy: job.fallbackStrategy,
        checklist: wizardChecklist(state)
      };
    });
    methods2.register("companion.wizard.voice.submit", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const mediaID = parseText2(params.mediaID) || parseText2(params.audioMediaID);
      if (!mediaID)
        throw new Error("invalid_voice_media_id");
      const sessionId = parseText2(params.sessionID) || "main";
      const { state, job } = submitWizardVoice(projectDir, {
        mediaID,
        sessionId
      });
      return {
        state: state.state,
        message: "...",
        jobId: job.id,
        estimatedTime: job.estimatedTime,
        checklist: wizardChecklist(state)
      };
    });
    methods2.register("companion.wizard.personality.submit", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const personalityText = parseText2(params.personalityText);
      const sessionId = parseText2(params.sessionID) || "main";
      const wizard = submitWizardPersonality(projectDir, {
        personalityText,
        sessionId
      });
      patchCompanionProfile(projectDir, {
        onboardingCompleted: true
      });
      return {
        state: wizard.state,
        message: WIZARD_PROMPT_DONE,
        personaPreview: wizard.assets.personalityText.slice(0, 120),
        checklist: wizardChecklist(wizard)
      };
    });
    methods2.register("companion.wizard.cancel", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const sessionId = parseText2(params.sessionID) || "main";
      const daemon = getMiyaClient(projectDir);
      const state = readCompanionWizardState(projectDir, sessionId);
      const cancelRequests = [];
      for (const job of state.jobs) {
        if (job.status === "queued" || job.status === "training") {
          cancelRequests.push(daemon.requestTrainingCancel(job.id));
        }
      }
      if (cancelRequests.length > 0) {
        await Promise.allSettled(cancelRequests);
      }
      const canceled = cancelCompanionWizardTraining(projectDir, sessionId);
      return {
        state: canceled.state,
        checklist: wizardChecklist(canceled),
        message: WIZARD_CANCELLED_MESSAGE
      };
    });
    methods2.register("companion.wizard.submit", async (params) => {
      if (Array.isArray(params.photoMediaIDs) || Array.isArray(params.imageMediaIDs)) {
        return invokeGatewayMethod(projectDir, runtime, "companion.wizard.photos.submit", params, { clientID: "gateway", role: "admin" });
      }
      if (typeof params.mediaID === "string" || typeof params.audioMediaID === "string") {
        return invokeGatewayMethod(projectDir, runtime, "companion.wizard.voice.submit", params, { clientID: "gateway", role: "admin" });
      }
      if (typeof params.personalityText === "string") {
        return invokeGatewayMethod(projectDir, runtime, "companion.wizard.personality.submit", params, { clientID: "gateway", role: "admin" });
      }
      throw new Error("invalid_wizard_submit_payload");
    });
    methods2.register("companion.wizard.tick", async () => {
      await runWizardTrainingWorker(projectDir, runtime);
      return {
        wizard: readCompanionWizardState(projectDir, "main")
      };
    });
    methods2.register("companion.wizard.progress.get", async (params) => {
      const jobID = parseText2(params.jobId) || parseText2(params.jobID);
      if (!jobID)
        throw new Error("invalid_job_id");
      const job = getWizardJobById(projectDir, jobID);
      if (!job)
        throw new Error("job_not_found");
      const status = job.status === "queued" ? "pending" : job.status;
      const nextStep = status === "completed" || status === "degraded" ? readCompanionWizardState(projectDir, job.sessionId).state : undefined;
      return {
        status,
        progress: job.progress,
        currentTier: job.currentTier,
        message: job.message ?? "",
        nextStep,
        checkpointPath: job.checkpointPath,
        sessionId: job.sessionId
      };
    });
    methods2.register("companion.profile.update", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      return patchCompanionProfile(projectDir, {
        enabled: typeof params.enabled === "boolean" ? Boolean(params.enabled) : undefined,
        onboardingCompleted: typeof params.onboardingCompleted === "boolean" ? Boolean(params.onboardingCompleted) : undefined,
        name: parseText2(params.name) || undefined,
        persona: parseText2(params.persona) || undefined,
        relationship: parseText2(params.relationship) || undefined,
        style: parseText2(params.style) || undefined
      });
    });
  });
  registerGatewayMemoryMethods(methods, (methods2) => {
    methods2.register("companion.memory.add", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      const fact = parseText2(params.fact);
      if (!fact)
        throw new Error("invalid_memory_fact");
      const domain3 = parseMemoryDomain(params.domain) ?? inferMemoryDomain(fact);
      const evidence = parseEvidenceList(params.evidence);
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const created = upsertCompanionMemoryVector(projectDir, {
        text: fact,
        domain: domain3,
        source: "conversation",
        activate: false,
        evidence,
        sourceType: parseText2(params.sourceType) === "direct_correction" ? "direct_correction" : "conversation"
      });
      const profile = syncCompanionProfileMemoryFacts(projectDir);
      const learningGate = runtime.nexus.learningGate;
      return {
        memory: created,
        stage: created.status,
        learningGate: {
          stage: "candidate",
          approvalMode: learningGate.candidateMode,
          interruptsUser: false
        },
        domain: created.domain,
        crossDomainWrite: created.crossDomainWrite,
        needsCorrectionWizard: Boolean(created.conflictWizardID),
        message: created.crossDomainWrite?.requiresApproval ? "memory_pending_cross_domain_approval_required" : created.conflictWizardID ? "memory_pending_conflict_requires_correction_wizard" : "memory_pending_confirmation_required",
        profile
      };
    });
    methods2.register("companion.memory.list", async (params) => {
      requireOwnerMode(projectDir);
      const domain3 = parseMemoryDomain(params.domain);
      if (domain3) {
        return listCompanionMemoryVectors(projectDir, domain3).filter((item) => item.status === "active").map((item) => item.text);
      }
      return readCompanionProfile(projectDir).memoryFacts;
    });
    methods2.register("companion.memory.pending.list", async (params) => {
      requireOwnerMode(projectDir);
      return listPendingCompanionMemoryVectors(projectDir, parseMemoryDomain(params.domain));
    });
    methods2.register("companion.memory.corrections.list", async () => {
      requireOwnerMode(projectDir);
      return listCompanionMemoryCorrections(projectDir);
    });
    methods2.register("companion.memory.confirm", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const memoryID = parseText2(params.memoryID);
      const sessionID = parseText2(params.sessionID) || "main";
      if (!memoryID)
        throw new Error("invalid_memory_id");
      const target = getCompanionMemoryVector(projectDir, memoryID);
      if (!target)
        throw new Error("memory_not_found");
      const evidence = parseEvidenceList(params.evidence);
      const crossDomainRequiresApproval = Boolean(target.crossDomainWrite?.requiresApproval);
      if (crossDomainRequiresApproval && evidence.length === 0) {
        throw new Error("cross_domain_evidence_required");
      }
      const requiresApproval = runtime.nexus.learningGate.persistentRequiresApproval || crossDomainRequiresApproval;
      if (requiresApproval) {
        const ticket = resolveApprovalTicket({
          projectDir,
          sessionID,
          permission: "memory_write",
          patterns: [
            "memory_stage=persistent",
            `memory_id=${memoryID}`,
            "action=confirm",
            `memory_domain=${target.domain}`,
            crossDomainRequiresApproval ? `cross_domain_from=${target.crossDomainWrite?.from ?? "unknown"}` : "cross_domain_from=none",
            `evidence_count=${evidence.length}`
          ]
        });
        if (!ticket.ok)
          throw new Error(`approval_required:${ticket.reason}`);
      }
      const confirm = typeof params.confirm === "boolean" ? Boolean(params.confirm) : true;
      const updated = confirmCompanionMemoryVector(projectDir, {
        memoryID,
        confirm,
        evidence,
        supersedeConflicts: typeof params.supersedeConflicts === "boolean" ? Boolean(params.supersedeConflicts) : true
      });
      if (!updated)
        throw new Error("memory_not_found");
      const profile = syncCompanionProfileMemoryFacts(projectDir);
      return {
        memory: updated,
        stage: updated.status,
        learningGate: {
          stage: "persistent",
          approvalMode: requiresApproval ? "modal_approval" : "toast_gate",
          interruptsUser: requiresApproval
        },
        profile
      };
    });
    methods2.register("companion.memory.update", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const memoryID = parseText2(params.memoryID);
      const text = parseText2(params.text);
      if (!memoryID)
        throw new Error("invalid_memory_id");
      if (!text)
        throw new Error("invalid_memory_text");
      const domain3 = parseMemoryDomain(params.domain);
      const memoryKindRaw = parseText2(params.memoryKind);
      const memoryKind = memoryKindRaw === "Fact" || memoryKindRaw === "Insight" || memoryKindRaw === "UserPreference" ? memoryKindRaw : undefined;
      const updated = updateCompanionMemoryVector(projectDir, {
        memoryID,
        text,
        domain: domain3,
        memoryKind
      });
      if (!updated)
        throw new Error("memory_not_found");
      const profile = syncCompanionProfileMemoryFacts(projectDir);
      return { memory: updated, profile };
    });
    methods2.register("companion.memory.archive", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_delete");
      const memoryID = parseText2(params.memoryID);
      if (!memoryID)
        throw new Error("invalid_memory_id");
      const archived = typeof params.archived === "boolean" ? Boolean(params.archived) : true;
      const updated = archiveCompanionMemoryVector(projectDir, {
        memoryID,
        archived
      });
      if (!updated)
        throw new Error("memory_not_found");
      const profile = syncCompanionProfileMemoryFacts(projectDir);
      return { memory: updated, profile };
    });
    methods2.register("companion.memory.search", async (params) => {
      requireOwnerMode(projectDir);
      const query = parseText2(params.query);
      if (!query)
        throw new Error("invalid_memory_query");
      const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(20, Number(params.limit)) : 5;
      const threshold = typeof params.threshold === "number" && params.threshold >= 0 ? Number(params.threshold) : undefined;
      const recencyHalfLifeDays = typeof params.recencyHalfLifeDays === "number" && params.recencyHalfLifeDays > 0 ? Number(params.recencyHalfLifeDays) : undefined;
      const domain3 = parseMemoryDomain(params.domain);
      const domains = Array.isArray(params.domains) ? params.domains.map((item) => parseMemoryDomain(item)).filter((item) => Boolean(item)) : undefined;
      const semanticLayers = Array.isArray(params.semanticLayers) ? params.semanticLayers.map((item) => parseText2(item).trim()).filter((item) => item === "episodic" || item === "semantic" || item === "preference" || item === "tool_trace") : undefined;
      const learningStages = Array.isArray(params.learningStages) ? params.learningStages.map((item) => parseText2(item).trim()).filter((item) => item === "ephemeral" || item === "candidate" || item === "persistent") : undefined;
      const vectorHits = searchCompanionMemoryVectors(projectDir, query, limit, {
        threshold,
        recencyHalfLifeDays,
        domain: domain3,
        domains,
        semanticWeight: typeof params.semanticWeight === "number" ? Number(params.semanticWeight) : undefined,
        lexicalWeight: typeof params.lexicalWeight === "number" ? Number(params.lexicalWeight) : undefined,
        semanticLayers,
        learningStages
      });
      const includeGraph = typeof params.includeGraph === "boolean" ? params.includeGraph : false;
      if (!includeGraph)
        return vectorHits;
      const graphLimit = typeof params.graphLimit === "number" && params.graphLimit > 0 ? Math.min(30, Number(params.graphLimit)) : Math.max(3, Math.min(12, limit));
      return {
        vectorHits,
        graphHits: searchCompanionMemoryGraph(projectDir, query, graphLimit, {
          minConfidence: typeof params.minGraphConfidence === "number" ? Number(params.minGraphConfidence) : 0
        })
      };
    });
    methods2.register("companion.memory.decay", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const halfLifeDays = typeof params.halfLifeDays === "number" && params.halfLifeDays > 0 ? Number(params.halfLifeDays) : 30;
      return decayCompanionMemoryVectors(projectDir, halfLifeDays);
    });
    methods2.register("companion.memory.drift.report", async (params) => {
      requireOwnerMode(projectDir);
      return auditCompanionMemoryDrift(projectDir, {
        staleDays: typeof params.staleDays === "number" && params.staleDays > 0 ? Number(params.staleDays) : undefined,
        lowAccessCount: typeof params.lowAccessCount === "number" && params.lowAccessCount >= 0 ? Number(params.lowAccessCount) : undefined,
        minScore: typeof params.minScore === "number" && Number.isFinite(params.minScore) ? Number(params.minScore) : undefined,
        minConfidence: typeof params.minConfidence === "number" && Number.isFinite(params.minConfidence) ? Number(params.minConfidence) : undefined,
        pendingTimeoutDays: typeof params.pendingTimeoutDays === "number" && params.pendingTimeoutDays > 0 ? Number(params.pendingTimeoutDays) : undefined,
        crossDomainPendingDays: typeof params.crossDomainPendingDays === "number" && params.crossDomainPendingDays > 0 ? Number(params.crossDomainPendingDays) : undefined,
        limit: typeof params.limit === "number" && params.limit > 0 ? Number(params.limit) : undefined
      });
    });
    methods2.register("companion.memory.drift.recycle", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      return recycleCompanionMemoryDrift(projectDir, {
        staleDays: typeof params.staleDays === "number" && params.staleDays > 0 ? Number(params.staleDays) : undefined,
        lowAccessCount: typeof params.lowAccessCount === "number" && params.lowAccessCount >= 0 ? Number(params.lowAccessCount) : undefined,
        minScore: typeof params.minScore === "number" && Number.isFinite(params.minScore) ? Number(params.minScore) : undefined,
        minConfidence: typeof params.minConfidence === "number" && Number.isFinite(params.minConfidence) ? Number(params.minConfidence) : undefined,
        pendingTimeoutDays: typeof params.pendingTimeoutDays === "number" && params.pendingTimeoutDays > 0 ? Number(params.pendingTimeoutDays) : undefined,
        crossDomainPendingDays: typeof params.crossDomainPendingDays === "number" && params.crossDomainPendingDays > 0 ? Number(params.crossDomainPendingDays) : undefined,
        limit: typeof params.limit === "number" && params.limit > 0 ? Number(params.limit) : undefined,
        maxActions: typeof params.maxActions === "number" && params.maxActions > 0 ? Number(params.maxActions) : undefined,
        dryRun: typeof params.dryRun === "boolean" ? params.dryRun : undefined
      });
    });
    methods2.register("companion.memory.vector.list", async (params) => {
      requireOwnerMode(projectDir);
      return listCompanionMemoryVectors(projectDir, parseMemoryDomain(params.domain));
    });
    methods2.register("companion.learning.metrics.get", async (params) => {
      requireOwnerMode(projectDir);
      const maxModeMisclassificationRate = typeof params.maxModeMisclassificationRate === "number" && Number.isFinite(params.maxModeMisclassificationRate) ? Number(params.maxModeMisclassificationRate) : undefined;
      const minCorrectionConvergenceRate = typeof params.minCorrectionConvergenceRate === "number" && Number.isFinite(params.minCorrectionConvergenceRate) ? Number(params.minCorrectionConvergenceRate) : undefined;
      const minMemoryHitRate = typeof params.minMemoryHitRate === "number" && Number.isFinite(params.minMemoryHitRate) ? Number(params.minMemoryHitRate) : undefined;
      return readCompanionLearningMetrics(projectDir, {
        maxModeMisclassificationRate,
        minCorrectionConvergenceRate,
        minMemoryHitRate
      });
    });
    methods2.register("miya.memory.sqlite.stats", async () => {
      requireOwnerMode(projectDir);
      return getCompanionMemorySqliteStats(projectDir);
    });
    methods2.register("miya.memory.embedding.providers.list", async () => {
      requireOwnerMode(projectDir);
      return {
        providers: listEmbeddingProviders(),
        active: readEmbeddingProviderConfig(projectDir)
      };
    });
    methods2.register("miya.memory.embedding.provider.get", async () => {
      requireOwnerMode(projectDir);
      return {
        config: readEmbeddingProviderConfig(projectDir)
      };
    });
    methods2.register("miya.memory.embedding.provider.set", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const kindRaw = parseText2(params.kind);
      const kind = kindRaw === "local-hash" || kindRaw === "local-ngram" || kindRaw === "remote-http" ? kindRaw : undefined;
      const fallbackRaw = parseText2(params.fallbackKind);
      const fallbackKind = fallbackRaw === "local-hash" || fallbackRaw === "local-ngram" ? fallbackRaw : undefined;
      const next = writeEmbeddingProviderConfig(projectDir, {
        kind,
        dims: typeof params.dims === "number" ? Number(params.dims) : undefined,
        timeoutMs: typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : undefined,
        model: parseText2(params.model) || undefined,
        url: parseText2(params.url) || undefined,
        fallbackKind,
        headers: params.headers && typeof params.headers === "object" && !Array.isArray(params.headers) ? params.headers : undefined
      });
      return {
        config: next
      };
    });
    methods2.register("miya.memory.graph.stats", async () => {
      requireOwnerMode(projectDir);
      return getCompanionMemoryGraphStats(projectDir);
    });
    methods2.register("miya.memory.graph.search", async (params) => {
      requireOwnerMode(projectDir);
      const query = parseText2(params.query);
      if (!query)
        throw new Error("invalid_memory_query");
      const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(30, Number(params.limit)) : 8;
      const minConfidence = typeof params.minConfidence === "number" ? Number(params.minConfidence) : undefined;
      return searchCompanionMemoryGraph(projectDir, query, limit, {
        minConfidence
      });
    });
    methods2.register("miya.memory.graph.neighbors", async (params) => {
      requireOwnerMode(projectDir);
      const entity = parseText2(params.entity);
      if (!entity)
        throw new Error("invalid_memory_entity");
      const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(50, Number(params.limit)) : 12;
      return listCompanionMemoryGraphNeighbors(projectDir, entity, limit);
    });
    methods2.register("miya.memory.recall.benchmark.run", async (params) => {
      requireOwnerMode(projectDir);
      const datasetPath = parseText2(params.datasetPath) || undefined;
      const kValues = Array.isArray(params.kValues) ? params.kValues.map((item) => Number(item)).filter((item) => Number.isFinite(item)) : undefined;
      return runMemoryRecallBenchmark({
        datasetPath,
        kValues
      });
    });
    methods2.register("miya.memory.log.append", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      const text = parseText2(params.text);
      if (!text)
        throw new Error("invalid_memory_log_text");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const senderRaw = parseText2(params.sender);
      const sender = senderRaw === "assistant" || senderRaw === "system" ? senderRaw : "user";
      const entry2 = appendShortTermMemoryLog(projectDir, {
        sessionID: parseText2(params.sessionID) || "main",
        sender,
        text,
        at: parseText2(params.at) || undefined,
        messageID: parseText2(params.messageID) || undefined
      });
      return {
        entry: entry2,
        learningGate: {
          stage: "ephemeral",
          approvalMode: "silent_audit",
          interruptsUser: false
        }
      };
    });
    methods2.register("miya.memory.reflect", async (params) => {
      requireOwnerMode(projectDir);
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_write");
      const force = typeof params.force === "boolean" ? Boolean(params.force) : false;
      const minLogs = typeof params.minLogs === "number" && params.minLogs > 0 ? Number(params.minLogs) : 1;
      const maxLogs = typeof params.maxLogs === "number" && params.maxLogs > 0 ? Math.min(500, Number(params.maxLogs)) : 50;
      const cooldownMinutes = typeof params.cooldownMinutes === "number" && params.cooldownMinutes >= 0 ? Number(params.cooldownMinutes) : 0;
      const maxWrites = typeof params.maxWrites === "number" && params.maxWrites > 0 ? Number(params.maxWrites) : 40;
      const queued = enqueueReflectWorkerJob(projectDir, {
        reason: "manual",
        force,
        minLogs,
        maxLogs,
        maxWrites,
        cooldownMinutes
      });
      const tick = runReflectWorkerTick(projectDir, {
        maxJobs: 1,
        writeBudget: maxWrites,
        mergeBudget: Math.max(1, Math.floor(maxWrites / 2))
      });
      const latestJob = listReflectWorkerJobs(projectDir, 5).find((job) => job.id === queued.id);
      const profile = syncCompanionProfileMemoryFacts(projectDir);
      return {
        queuedJob: latestJob ?? queued,
        workerTick: tick,
        status: getMemoryReflectStatus(projectDir),
        learningGate: {
          stage: "candidate",
          approvalMode: runtime.nexus.learningGate.candidateMode,
          interruptsUser: false
        },
        profile
      };
    });
    methods2.register("miya.memory.reflect.queue.list", async (params) => {
      requireOwnerMode(projectDir);
      const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(200, Number(params.limit)) : 30;
      return {
        status: getMemoryReflectStatus(projectDir),
        jobs: listReflectWorkerJobs(projectDir, limit)
      };
    });
  });
  registerGatewayCompanionMethods(methods, (methods2) => {
    methods2.register("companion.asset.add", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      const type = parseText2(params.type);
      const pathOrUrl = parseText2(params.pathOrUrl);
      if (!pathOrUrl)
        throw new Error("invalid_asset_path");
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "fs_write");
      if (type !== "image" && type !== "audio")
        throw new Error("invalid_asset_type");
      return addCompanionAsset(projectDir, {
        type,
        pathOrUrl,
        label: parseText2(params.label) || undefined
      });
    });
    methods2.register("companion.asset.list", async () => readCompanionProfile(projectDir).assets);
    methods2.register("companion.reset", async (params) => {
      const policyHash = parseText2(params.policyHash) || undefined;
      requirePolicyHash(projectDir, policyHash);
      requireDomainRunning(projectDir, "memory_delete");
      const profile = resetCompanionProfile(projectDir);
      const wizard = resetCompanionWizard(projectDir);
      return { profile, wizard };
    });
    methods2.register("companion.intent.handle", async (params) => {
      const text = parseText2(params.text);
      if (!text)
        throw new Error("invalid_intent_text");
      const channel = parseChannel(params.channel) ?? "wechat";
      const destination = parseText2(params.destination);
      const sessionID = parseText2(params.sessionID) || "main";
      const intent = detectMultimodalIntent(text);
      if (intent.type === "selfie") {
        const generated = await generateImage(projectDir, {
          prompt: intent.prompt,
          model: "local:flux.1-schnell",
          registerAsCompanionAsset: true
        });
        if (!destination) {
          return {
            intent: "selfie",
            sent: false,
            mediaID: generated.media.id,
            path: generated.media.localPath,
            message: "selfie_generated_destination_missing"
          };
        }
        const send = await sendChannelMessageGuarded(projectDir, runtime, {
          channel,
          destination,
          text: "",
          mediaPath: generated.media.localPath,
          sessionID,
          policyHash: currentPolicyHash(projectDir),
          outboundCheck: {
            archAdvisorApproved: true,
            intent: "reply"
          }
        });
        return {
          intent: "selfie",
          sent: send.sent,
          send,
          mediaID: generated.media.id,
          path: generated.media.localPath
        };
      }
      if (intent.type === "voice_to_friend") {
        const resolvedDestination = destination || intent.friend;
        if (!resolvedDestination)
          throw new Error("voice_destination_missing");
        const voice = await synthesizeVoiceOutput(projectDir, {
          text,
          voice: "companion",
          model: "local:gpt-sovits-v2pro",
          format: "wav",
          registerAsCompanionAsset: true
        });
        const send = await sendChannelMessageGuarded(projectDir, runtime, {
          channel: "wechat",
          destination: resolvedDestination,
          text: "",
          mediaPath: voice.media.localPath,
          sessionID,
          policyHash: currentPolicyHash(projectDir),
          outboundCheck: {
            archAdvisorApproved: true,
            intent: "reply"
          }
        });
        return {
          intent: "voice_to_friend",
          friend: resolvedDestination,
          sent: send.sent,
          send,
          mediaID: voice.media.id,
          path: voice.media.localPath
        };
      }
      return { intent: "unknown", message: "no_multimodal_intent_matched" };
    });
  });
  methods.register("daemon.vram.budget", async (params) => {
    const scheduler = getResourceScheduler(projectDir);
    const modelID = parseText2(params.modelID) || "local:flux.1-schnell";
    const kindRaw = parseText2(params.kind);
    const kind = kindRaw === "image.generate" || kindRaw === "vision.analyze" || kindRaw === "voice.tts" || kindRaw === "voice.asr" || kindRaw === "training.image" || kindRaw === "training.voice" || kindRaw === "shell.exec" ? kindRaw : "generic";
    const requestVram = typeof params.vramMB === "number" ? Number(params.vramMB) : 1024;
    const modelVram = typeof params.modelVramMB === "number" ? Number(params.modelVramMB) : 2048;
    const snapshot = scheduler.snapshot();
    const budget = calculateVramBudget({
      snapshot,
      task: {
        taskID: kind,
        taskVramMB: requestVram
      },
      models: [{ modelID, vramMB: modelVram, required: true }]
    });
    return {
      snapshot,
      budget,
      swapAction: decideModelSwapAction({
        currentModelID: snapshot.loadedModels[0]?.modelID,
        targetModelID: modelID,
        budget
      })
    };
  });
  methods.register("daemon.vram.hydraulics.get", async () => {
    const scheduler = getResourceScheduler(projectDir);
    const snapshot = scheduler.snapshot();
    return {
      timestamp: snapshot.timestamp,
      hydraulics: snapshot.hydraulics,
      loadedModels: snapshot.loadedModels
    };
  });
  const aliasReport = registerGatewayV2Aliases(methods);
  if (aliasReport.created > 0) {
    log("[gateway] v2 compatibility aliases registered", {
      projectDir,
      scanned: aliasReport.scanned,
      created: aliasReport.created,
      skipped: aliasReport.skipped
    });
  }
  return methods;
}
function ensureGatewayRunning(projectDir) {
  const existing = runtimes2.get(projectDir);
  if (existing) {
    const owner2 = acquireGatewayOwner(projectDir);
    if (owner2.owned) {
      touchOwnerLock(projectDir);
    }
    log("[gateway] runtime already active; reused existing runtime", {
      projectDir,
      owner: describeOwnerLock(owner2.owner ?? null)
    });
    return syncGatewayState(projectDir, existing);
  }
  const owner = acquireGatewayOwner(projectDir);
  if (!owner.owned) {
    const state = readGatewayStateFile(projectDir);
    const ownerAlive = owner.owner ? isProcessAlive(owner.owner.pid) : false;
    const ownerFresh = owner.owner ? isOwnerLockFresh(owner.owner) : false;
    log("[gateway] owner lock held by another process", {
      projectDir,
      owner: describeOwnerLock(owner.owner ?? null),
      state: describeGatewayState(state)
    });
    if (state && owner.owner && state.pid !== owner.owner.pid) {
      clearGatewayStateFile(projectDir);
      log("[gateway] cleared stale gateway state file due to pid mismatch", {
        projectDir,
        statePid: state.pid,
        ownerPid: owner.owner.pid
      });
    }
    if (state && isProcessAlive(state.pid)) {
      log("[gateway] follower mode attached to existing owner state", {
        projectDir,
        state: describeGatewayState(state)
      });
      return state;
    }
    if (state && !isProcessAlive(state.pid)) {
      clearGatewayStateFile(projectDir);
      log("[gateway] removed dead gateway state pid", {
        projectDir,
        statePid: state.pid
      });
    }
    if (owner.owner && !ownerAlive) {
      const retry = acquireGatewayOwner(projectDir);
      if (!retry.owned) {
        log("[gateway] ownership reacquire failed after dead owner detected", {
          projectDir,
          previousOwner: describeOwnerLock(owner.owner),
          retryOwner: describeOwnerLock(retry.owner ?? null)
        });
        throw new Error("gateway_owned_by_other_process");
      }
      log("[gateway] ownership reacquired after dead owner detected", {
        projectDir,
        retryOwner: describeOwnerLock(retry.owner ?? null)
      });
    } else {
      log("[gateway] follower refused ownership takeover", {
        projectDir,
        ownerAlive,
        ownerFresh
      });
      throw new Error("gateway_owned_by_other_process");
    }
  }
  let runtime;
  const methods = new GatewayMethodRegistry;
  const controlUi = createControlUiRequestOptions(projectDir);
  const authConfig = resolveGatewayAuthConfig(projectDir);
  const channelRuntime = new ChannelRuntime(projectDir, {
    onInbound: async (message) => {
      await onInboundMessage(projectDir, runtime, message);
    },
    onPairRequested: async () => {
      maybeBroadcast(projectDir, runtime);
    }
  });
  const listen = resolveGatewayListenOptions(projectDir);
  log("[gateway] creating runtime server", {
    projectDir,
    listen,
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
    controlUiRoot: controlUi.root?.kind ?? "unknown",
    auth: {
      tokenSource: authConfig.tokenSource,
      challengeRequired: authConfig.challengeRequired
    }
  });
  const createGatewayServer = (port) => Bun.serve({
    hostname: listen.hostname,
    port,
    fetch(request, currentServer) {
      const url3 = new URL(request.url);
      if (url3.pathname === "/ws") {
        const upgraded = currentServer.upgrade(request, { data: {} });
        if (upgraded)
          return;
        return new Response("websocket upgrade failed", { status: 400 });
      }
      if (url3.pathname === "/api/status") {
        try {
          return Response.json(buildSnapshot(projectDir, runtime), {
            headers: { "cache-control": "no-store" }
          });
        } catch (error92) {
          logStatusSnapshotFailure(projectDir, error92);
          return Response.json(buildStatusFallbackPayload(projectDir, runtime, error92), {
            status: 200,
            headers: {
              "cache-control": "no-store",
              "x-miya-status": "degraded"
            }
          });
        }
      }
      if (url3.pathname === "/api/evidence/image") {
        const auditID = String(url3.searchParams.get("auditID") ?? "").trim();
        const slot = String(url3.searchParams.get("slot") ?? "").trim().toLowerCase();
        const file3 = resolveEvidenceImageFile(projectDir, auditID, slot);
        if (!file3) {
          return new Response("Not Found", {
            status: 404,
            headers: { "cache-control": "no-store" }
          });
        }
        const ext = path61.extname(file3).toLowerCase();
        const contentType = ext === ".png" ? "image/png" : ext === ".jpg" || ext === ".jpeg" ? "image/jpeg" : ext === ".webp" ? "image/webp" : "application/octet-stream";
        return new Response(Bun.file(file3), {
          status: 200,
          headers: {
            "content-type": contentType,
            "cache-control": "no-store",
            "x-content-type-options": "nosniff"
          }
        });
      }
      const controlUiResponse = handleControlUiHttpRequest(request, controlUi);
      if (controlUiResponse) {
        const missingUiFallback = controlUiResponse.status === 503 && controlUi.root?.kind !== "resolved";
        if (missingUiFallback) {
          logControlUiFallback(projectDir, url3.pathname, controlUi, controlUiResponse.status);
        }
        return controlUiResponse;
      }
      if (url3.pathname === "/webchat") {
        return new Response(renderWebChatHtml(), {
          headers: {
            "content-type": "text/html; charset=utf-8",
            "cache-control": "no-store"
          }
        });
      }
      if (url3.pathname.startsWith("/api/webhooks/")) {
        return new Response("HTTP control API disabled; use WebSocket RPC (/ws).", {
          status: 410,
          headers: {
            "content-type": "text/plain; charset=utf-8",
            "cache-control": "no-store"
          }
        });
      }
      if (url3.pathname === "/legacy-console") {
        return new Response(renderConsoleHtml(buildSnapshot(projectDir, runtime)), {
          headers: {
            "content-type": "text/html; charset=utf-8",
            "cache-control": "no-store"
          }
        });
      }
      return new Response("Not Found", { status: 404 });
    },
    websocket: {
      open(ws) {
        ensureWsData(runtime, ws);
      },
      close(ws) {
        const wsData = ensureWsData(runtime, ws);
        if (wsData.nodeID) {
          runtime.nodeSockets.delete(wsData.nodeID);
          markNodeDisconnected(projectDir, wsData.nodeID);
        }
        runtime.wsMeta.delete(ws);
      },
      async message(ws, message) {
        const wsData = ensureWsData(runtime, ws);
        const parsed = parseIncomingFrame(message);
        if (!parsed.frame) {
          ws.send(JSON.stringify(toResponseFrame({
            id: "invalid",
            ok: false,
            errorCode: "bad_request",
            errorMessage: parsed.error ?? "invalid_frame"
          })));
          return;
        }
        const frame = parsed.frame;
        if (frame.type === "ping") {
          ws.send(JSON.stringify(toPongFrame(frame.ts)));
          return;
        }
        if (frame.type === "hello") {
          const incomingVersion = normalizeIncomingProtocolVersion(frame.protocolVersion);
          if (!isSupportedProtocolVersion(incomingVersion)) {
            ws.send(JSON.stringify(toResponseFrame({
              id: "hello",
              ok: false,
              errorCode: "unsupported_protocol_version",
              errorMessage: `unsupported_protocol_version:${incomingVersion}`,
              errorDetails: {
                supported: [...SUPPORTED_GATEWAY_PROTOCOL_VERSIONS],
                latest: GATEWAY_PROTOCOL_VERSION
              }
            })));
            ws.close();
            return;
          }
          const requiredToken = runtime.auth.token;
          const incomingToken = frame.auth?.token;
          if (incomingToken !== requiredToken) {
            ws.send(JSON.stringify(toResponseFrame({
              id: "hello",
              ok: false,
              errorCode: "unauthorized",
              errorMessage: "invalid_gateway_token"
            })));
            ws.close();
            return;
          }
          const validatedClientID = String(frame.clientID ?? wsData.clientID).trim();
          const challenge = validateHelloChallenge(runtime, validatedClientID, incomingVersion, frame.auth?.challenge);
          if (!challenge.ok) {
            ws.send(JSON.stringify(toResponseFrame({
              id: "hello",
              ok: false,
              errorCode: "unauthorized",
              errorMessage: challenge.reason
            })));
            ws.close();
            return;
          }
          wsData.authenticated = true;
          wsData.protocolVersion = incomingVersion;
          if (validatedClientID)
            wsData.clientID = validatedClientID;
          if (frame.role)
            wsData.role = frame.role;
          ws.send(JSON.stringify(toResponseFrame({
            id: "hello",
            ok: true,
            result: {
              clientID: wsData.clientID,
              role: wsData.role,
              protocol: {
                requested: frame.protocolVersion ?? LEGACY_GATEWAY_PROTOCOL_VERSION,
                negotiated: incomingVersion,
                supported: [...SUPPORTED_GATEWAY_PROTOCOL_VERSIONS],
                latest: GATEWAY_PROTOCOL_VERSION,
                legacyCompat: !frame.protocolVersion
              },
              security: {
                tokenRequired: true,
                challengeRequired: runtime.auth.challengeRequired,
                challengeAlgorithm: runtime.auth.challengeRequired ? "hmac-sha256" : undefined
              },
              methods: runtime.methods.list()
            }
          })));
          return;
        }
        if (!wsData.authenticated) {
          ws.send(JSON.stringify(toResponseFrame({
            id: frame.id,
            ok: false,
            errorCode: "unauthorized",
            errorMessage: "send_hello_with_auth_first"
          })));
          return;
        }
        if (frame.method === "gateway.subscribe") {
          ws.subscribe("miya:broadcast");
          wsData.subscriptions = new Set(Array.isArray(frame.params?.events) ? frame.params.events.map(String) : ["*"]);
          ws.send(JSON.stringify(toResponseFrame({
            id: frame.id,
            ok: true,
            result: {
              subscribed: [...wsData.subscriptions]
            }
          })));
          setTimeout(() => {
            try {
              ws.send(JSON.stringify(toEventFrame({
                event: "gateway.snapshot",
                payload: buildSnapshot(projectDir, runtime),
                stateVersion: { gateway: runtime.stateVersion }
              })));
            } catch {}
          }, 0);
          return;
        }
        if (frame.method === "nodes.register") {
          const nodeID = parseText2(frame.params?.nodeID);
          if (nodeID) {
            wsData.nodeID = nodeID;
            runtime.nodeSockets.set(nodeID, ws);
          }
        }
        cleanupIdempotency(runtime);
        const requestHash = requestFingerprint(frame);
        const scopedIdempotencyKey = idempotencyScopeKey(frame, wsData.clientID);
        if (scopedIdempotencyKey) {
          const previous = runtime.requestIdempotency.get(scopedIdempotencyKey);
          if (previous) {
            if (previous.requestHash !== requestHash) {
              ws.send(JSON.stringify(toResponseFrame({
                id: frame.id,
                ok: false,
                errorCode: "idempotency_key_conflict",
                errorMessage: "idempotency_key_reused_with_different_request"
              })));
              return;
            }
            ws.send(JSON.stringify(toResponseFrame({
              id: frame.id,
              ok: previous.ok,
              result: previous.result,
              errorCode: previous.errorCode,
              errorMessage: previous.errorMessage,
              errorDetails: previous.errorDetails
            })));
            return;
          }
        }
        runtime.nexus.activeTool = frame.method;
        const frameSessionID = parseText2(frame.params?.sessionID);
        if (frameSessionID) {
          runtime.nexus.sessionId = frameSessionID;
        }
        try {
          const result = await invokeGatewayMethod(projectDir, runtime, frame.method, frame.params ?? {}, {
            clientID: wsData.clientID,
            role: wsData.role,
            ws
          });
          if (scopedIdempotencyKey) {
            runtime.requestIdempotency.set(scopedIdempotencyKey, {
              key: scopedIdempotencyKey,
              requestHash,
              atMs: Date.now(),
              ok: true,
              result
            });
          }
          ws.send(JSON.stringify(toResponseFrame({ id: frame.id, ok: true, result })));
          if (frame.method !== "gateway.status.get") {
            maybeBroadcast(projectDir, runtime);
          }
        } catch (error92) {
          const messageText = error92 instanceof Error ? error92.message : String(error92);
          const errorCode = messageText.startsWith("unknown_method:") ? "unknown_method" : "method_failed";
          if (scopedIdempotencyKey) {
            runtime.requestIdempotency.set(scopedIdempotencyKey, {
              key: scopedIdempotencyKey,
              requestHash,
              atMs: Date.now(),
              ok: false,
              errorCode,
              errorMessage: messageText
            });
          }
          ws.send(JSON.stringify(toResponseFrame({
            id: frame.id,
            ok: false,
            errorCode,
            errorMessage: messageText
          })));
        }
      }
    }
  });
  let server;
  try {
    try {
      server = createGatewayServer(listen.port);
    } catch (error92) {
      if (!isAddressInUseError(error92) || listen.port <= 0) {
        throw error92;
      }
      server = createGatewayServer(0);
      log("[gateway] configured port already in use; fallback to ephemeral port", {
        projectDir,
        listen,
        resolvedPort: Number(server.port ?? 0)
      });
    }
  } catch (error92) {
    clearGatewayStateFile(projectDir);
    removeOwnerLock(projectDir);
    log("[gateway] failed to bind server", {
      projectDir,
      listen,
      error: error92 instanceof Error ? error92.message : String(error92)
    });
    throw error92;
  }
  runtime = {
    startedAt: nowIso42(),
    server,
    methods,
    stateVersion: 1,
    auth: authConfig,
    controlUi,
    channelRuntime,
    outboundSendDedupe: new Map,
    requestIdempotency: new Map,
    nodeSockets: new Map,
    wsMeta: new WeakMap,
    wizardTickTimer: undefined,
    ownerBeatTimer: undefined,
    memoryReflectTimer: undefined,
    pendingQueueKickTimer: undefined,
    pendingQueueGeneration: 0,
    pendingQueueRescheduleNeeded: false,
    wizardRunnerBusy: false,
    pendingQueueBusy: false,
    pendingOutboundQueue: readPendingOutboundQueue(projectDir),
    dependencyAssistHashes: new Set,
    daemonLauncherUnsubscribe: undefined,
    negotiationBudgets: new Map,
    nexus: {
      sessionId: "main",
      activeTool: undefined,
      permission: undefined,
      pendingTickets: 0,
      killSwitchMode: "off",
      insights: [],
      trust: undefined,
      trustMode: readTrustModeConfig(projectDir),
      psycheMode: readPsycheModeConfig(projectDir),
      learningGate: readLearningGateConfig(projectDir),
      guardianSafeHoldReason: undefined
    }
  };
  runtime.methods = createMethods(projectDir, runtime);
  runtimes2.set(projectDir, runtime);
  runtime.wizardTickTimer = safeInterval("gateway.wizard.training", 1200, async () => {
    await runWizardTrainingWorker(projectDir, runtime);
  }, {
    maxConsecutiveErrors: 3,
    cooldownMs: 15000,
    onError: (error92) => periodicTaskError(projectDir, error92)
  });
  runtime.ownerBeatTimer = safeInterval("gateway.owner.beat", 5000, () => {
    touchOwnerLock(projectDir);
  }, {
    maxConsecutiveErrors: 3,
    cooldownMs: 20000,
    onError: (error92) => periodicTaskError(projectDir, error92)
  });
  runtime.memoryReflectTimer = safeInterval("gateway.memory.reflect", 20000, () => {
    scheduleAutoReflectJob(projectDir, {
      idleMinutes: 5,
      minPendingLogs: 1,
      cooldownMinutes: 3,
      maxLogs: 120,
      maxWrites: 40
    });
    const tick = runReflectWorkerTick(projectDir, {
      maxJobs: 1,
      writeBudget: 40,
      mergeBudget: 40
    });
    if (tick.completed > 0)
      syncCompanionProfileMemoryFacts(projectDir);
  }, {
    maxConsecutiveErrors: 3,
    cooldownMs: 30000,
    onError: (error92) => periodicTaskError(projectDir, error92)
  });
  schedulePendingOutboundQueue(projectDir, runtime);
  runtime.daemonLauncherUnsubscribe = subscribeLauncherEvents(projectDir, (event) => {
    appendDaemonProgressAudit(projectDir, event);
    if (event.type === "job.progress") {
      publishGatewayEvent(runtime, "daemon.job_progress", event);
      const phase = String(event.payload?.phase ?? "");
      if (phase === "audio.filler") {
        publishGatewayEvent(runtime, "daemon.audio_filler", event);
      }
      const config3 = readConfig(projectDir);
      const notifyOnTerminal = config3.runtime?.notifications?.job_toast !== false;
      const status = String(event.payload?.status ?? "").trim().toLowerCase();
      if (notifyOnTerminal && (status === "completed" || status === "failed" || status === "degraded" || status === "canceled")) {
        publishGatewayEvent(runtime, "daemon.job_terminal", event);
      }
      return;
    }
    publishGatewayEvent(runtime, event.type, event);
  });
  runtime.channelRuntime.start();
  log("[gateway] runtime started", {
    projectDir,
    state: toGatewayState(projectDir, runtime),
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir))
  });
  return syncGatewayState(projectDir, runtime);
}

// src/cli/gateway-worker.ts
function normalizeWorkspace(input) {
  const resolved = path62.resolve(input || process.cwd());
  if (path62.basename(resolved).toLowerCase() === ".opencode") {
    return resolved;
  }
  if (path62.basename(resolved).toLowerCase() === "miya-src") {
    const parent = path62.dirname(resolved);
    if (path62.basename(parent).toLowerCase() === ".opencode") {
      return parent;
    }
  }
  const embeddedOpencode = path62.join(resolved, ".opencode");
  if (fs63.existsSync(path62.join(embeddedOpencode, "miya-src", "src", "index.ts"))) {
    return embeddedOpencode;
  }
  return resolved;
}
function parseArgs(argv) {
  let workspace = "";
  for (let i = 0;i < argv.length; i += 1) {
    const current = argv[i] ?? "";
    if (current === "--workspace" && i + 1 < argv.length) {
      workspace = argv[i + 1] ?? "";
      i += 1;
      continue;
    }
    if (current.startsWith("--workspace=")) {
      workspace = current.slice("--workspace=".length);
    }
  }
  return {
    workspace: normalizeWorkspace(workspace || process.cwd()),
    verbose: argv.includes("--verbose")
  };
}
async function main() {
  ensureBunNodeCompat();
  const args = parseArgs(process.argv.slice(2));
  const state = ensureGatewayRunning(args.workspace);
  if (args.verbose) {
    console.log(`[gateway-worker] running workspace=${args.workspace} url=${state.url} pid=${state.pid}`);
  }
  let shuttingDown = false;
  const pulse = setInterval(() => {
    if (shuttingDown)
      return;
    try {
      ensureGatewayRunning(args.workspace);
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      console.error(`[gateway-worker] keepalive_failed:${message}`);
    }
  }, 2500);
  const shutdown = (signal) => {
    if (shuttingDown)
      return;
    shuttingDown = true;
    clearInterval(pulse);
    try {
      const result = stopGateway(args.workspace);
      if (args.verbose) {
        console.log(`[gateway-worker] received ${signal}; stopped=${result.stopped}`);
      }
    } catch {}
    setTimeout(() => process.exit(0), 20);
  };
  process.on("SIGTERM", shutdown);
  process.on("SIGINT", shutdown);
  process.on("SIGHUP", shutdown);
}
main().catch((error92) => {
  const message = error92 instanceof Error ? error92.stack ?? error92.message : String(error92);
  console.error(`[gateway-worker] failed:${message}`);
  process.exit(1);
});
