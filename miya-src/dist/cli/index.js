#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/cli/paths.ts
import { existsSync, mkdirSync } from "node:fs";
import { homedir } from "node:os";
import { join } from "node:path";
function getConfigDir() {
  const userConfigDir = process.env.XDG_CONFIG_HOME ? process.env.XDG_CONFIG_HOME : join(homedir(), ".config");
  return join(userConfigDir, "opencode");
}
function getConfigJson() {
  return join(getConfigDir(), "opencode.json");
}
function getConfigJsonc() {
  return join(getConfigDir(), "opencode.jsonc");
}
function getLiteConfig() {
  return join(getConfigDir(), "miya.json");
}
function getLiteConfigCandidates() {
  const configDir = getConfigDir();
  return [join(configDir, "miya.json")];
}
function getExistingLiteConfigPath() {
  const candidates = getLiteConfigCandidates();
  for (const candidate of candidates) {
    if (existsSync(candidate)) return candidate;
  }
  return getLiteConfig();
}
function getExistingConfigPath() {
  const jsonPath = getConfigJson();
  if (existsSync(jsonPath)) return jsonPath;
  const jsoncPath = getConfigJsonc();
  if (existsSync(jsoncPath)) return jsoncPath;
  return jsonPath;
}
function ensureConfigDir() {
  const configDir = getConfigDir();
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
}
var init_paths = __esm({
  "src/cli/paths.ts"() {
    "use strict";
  }
});

// src/config/constants.ts
var AGENT_ALIASES, SUBAGENT_NAMES, ORCHESTRATOR_NAME, CODE_SIMPLICITY_REVIEWER_NAME, ALL_AGENT_NAMES, DEFAULT_MODELS, DEFAULT_TIMEOUT_MS, MAX_POLL_TIME_MS;
var init_constants = __esm({
  "src/config/constants.ts"() {
    "use strict";
    AGENT_ALIASES = {
      // legacy names -> current names
      orchestrator: "1-task-manager",
      explorer: "2-code-search",
      librarian: "3-docs-helper",
      oracle: "4-architecture-advisor",
      fixer: "5-code-fixer",
      designer: "6-ui-designer",
      "code-simplicity-reviewer": "7-code-simplicity-reviewer",
      simplicity_reviewer: "7-code-simplicity-reviewer",
      // extra compatibility aliases
      explore: "2-code-search",
      "frontend-ui-ux-engineer": "6-ui-designer",
      "4-code-fixer": "5-code-fixer",
      "5-ui-designer": "6-ui-designer",
      "6-architecture-advisor": "4-architecture-advisor"
    };
    SUBAGENT_NAMES = [
      "2-code-search",
      "3-docs-helper",
      "4-architecture-advisor",
      "5-code-fixer",
      "6-ui-designer"
    ];
    ORCHESTRATOR_NAME = "1-task-manager";
    CODE_SIMPLICITY_REVIEWER_NAME = "7-code-simplicity-reviewer";
    ALL_AGENT_NAMES = [
      ORCHESTRATOR_NAME,
      ...SUBAGENT_NAMES,
      CODE_SIMPLICITY_REVIEWER_NAME
    ];
    DEFAULT_MODELS = {
      "1-task-manager": "openrouter/moonshotai/kimi-k2.5",
      "2-code-search": "openrouter/moonshotai/kimi-k2.5",
      "3-docs-helper": "openrouter/moonshotai/kimi-k2.5",
      "4-architecture-advisor": "openrouter/moonshotai/kimi-k2.5",
      "5-code-fixer": "openrouter/z-ai/glm-5",
      "6-ui-designer": "openrouter/z-ai/glm-5",
      "7-code-simplicity-reviewer": "openrouter/z-ai/glm-5"
    };
    DEFAULT_TIMEOUT_MS = 2 * 60 * 1e3;
    MAX_POLL_TIME_MS = 5 * 60 * 1e3;
  }
});

// src/workflow/state.ts
import * as fs from "node:fs";
import * as path from "node:path";
function getMiyaRuntimeDir(projectDir) {
  return path.join(projectDir, ".opencode", "miya");
}
function getLoopStatePath(projectDir) {
  return path.join(getMiyaRuntimeDir(projectDir), "loop-state.json");
}
function readStateFile(filePath12) {
  if (!fs.existsSync(filePath12)) {
    return { sessions: {} };
  }
  try {
    const raw = fs.readFileSync(filePath12, "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    return { sessions: parsed.sessions };
  } catch {
    return { sessions: {} };
  }
}
function getSessionState(projectDir, sessionID) {
  const filePath12 = getLoopStatePath(projectDir);
  const state = readStateFile(filePath12);
  const current = state.sessions[sessionID];
  if (!current) {
    return { ...DEFAULT_STATE };
  }
  return {
    ...DEFAULT_STATE,
    ...current
  };
}
var DEFAULT_STATE;
var init_state = __esm({
  "src/workflow/state.ts"() {
    "use strict";
    DEFAULT_STATE = {
      loopEnabled: true,
      autoContinue: true,
      maxIterationsPerWindow: 8,
      iterationCompleted: 0,
      windowStartIteration: 0,
      awaitingConfirmation: false,
      strictQualityGate: false,
      // Changed: default to false for smoother experience
      lastDone: [],
      lastMissing: [],
      lastUnresolved: [],
      autoContinueIteration: -1,
      autoContinueAt: (/* @__PURE__ */ new Date(0)).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date(0)).toISOString()
    };
  }
});

// src/workflow/saves.ts
var init_saves = __esm({
  "src/workflow/saves.ts"() {
    "use strict";
  }
});

// src/workflow/index.ts
var init_workflow = __esm({
  "src/workflow/index.ts"() {
    "use strict";
    init_state();
    init_saves();
  }
});

// src/config/agent-model-persistence.ts
import * as fs2 from "node:fs";
import * as path2 from "node:path";
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function filePath(projectDir) {
  return path2.join(getMiyaRuntimeDir(projectDir), "agent-runtime.json");
}
function legacyFilePath(projectDir) {
  return path2.join(getMiyaRuntimeDir(projectDir), "agent-models.json");
}
function normalizeAgentName(name) {
  const trimmed = name.trim();
  if (!trimmed) return null;
  const canonical = AGENT_ALIASES[trimmed] ?? trimmed;
  return KNOWN_AGENT_NAMES.has(canonical) ? canonical : null;
}
function normalizeModelRef(value) {
  const normalizeRefText = (input) => {
    const text = LEGACY_MODEL_REWRITE[input.trim()] ?? input.trim();
    const slash = text.indexOf("/");
    if (slash <= 0 || slash >= text.length - 1) {
      return null;
    }
    return text;
  };
  if (typeof value === "string") {
    return normalizeRefText(value);
  }
  if (isObject(value)) {
    const providerID = String(value.providerID ?? value.provider ?? "").trim();
    const modelID = String(value.modelID ?? "").trim();
    if (providerID && modelID) {
      return normalizeRefText(`${providerID}/${modelID}`);
    }
    return normalizeRefText(modelID);
  }
  return null;
}
function parsePersistedModel(value) {
  return normalizeModelRef(value) ?? (isObject(value) ? normalizeModelRef(value.model) : null);
}
function normalizeProviderID(value) {
  const text = String(value ?? "").trim();
  return text || void 0;
}
function normalizeStringValue(value) {
  const text = String(value ?? "").trim();
  return text || void 0;
}
function normalizeOptions(value) {
  if (!isObject(value)) return void 0;
  return JSON.parse(JSON.stringify(value));
}
function normalizeAgentRuntimeEntry(value) {
  if (!isObject(value)) return null;
  const model = parsePersistedModel(value.model ?? value);
  const variant = normalizeStringValue(value.variant);
  const providerID = normalizeProviderID(value.providerID) ?? (model ? normalizeProviderID(model.split("/")[0]) : void 0);
  const options = normalizeOptions(value.options ?? value.providerOptions);
  const apiKey = normalizeStringValue(value.apiKey);
  const baseURL = normalizeStringValue(value.baseURL);
  if (!model && !variant && !providerID && !options && !apiKey && !baseURL) {
    return null;
  }
  return {
    model: model ?? void 0,
    variant,
    providerID,
    options,
    apiKey,
    baseURL,
    updatedAt: normalizeStringValue(value.updatedAt) ?? (/* @__PURE__ */ new Date()).toISOString()
  };
}
function readLegacyModels(projectDir) {
  const file3 = legacyFilePath(projectDir);
  if (!fs2.existsSync(file3)) return {};
  try {
    const raw = fs2.readFileSync(file3, "utf-8");
    const parsed = JSON.parse(raw);
    if (!isObject(parsed.agents)) return {};
    const result = {};
    for (const [rawAgentName, rawModel] of Object.entries(parsed.agents)) {
      const agentName = normalizeAgentName(rawAgentName);
      const model = parsePersistedModel(rawModel);
      if (!agentName || !model) continue;
      result[agentName] = model;
    }
    return result;
  } catch {
    return {};
  }
}
function normalizeRuntimeState(projectDir, parsed) {
  if (!parsed || !isObject(parsed.agents)) {
    const legacy = readLegacyModels(projectDir);
    const agentsFromLegacy = {};
    for (const [agentName, model] of Object.entries(legacy)) {
      agentsFromLegacy[agentName] = {
        model,
        providerID: model.split("/")[0],
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    return {
      version: AGENT_RUNTIME_VERSION,
      revision: 0,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      agents: agentsFromLegacy
    };
  }
  const agents = {};
  for (const [rawAgentName, rawEntry] of Object.entries(parsed.agents)) {
    const agentName = normalizeAgentName(rawAgentName);
    if (!agentName) continue;
    const entry2 = normalizeAgentRuntimeEntry(rawEntry);
    if (!entry2) continue;
    agents[agentName] = entry2;
  }
  const activeAgentId = normalizeAgentName(String(parsed.activeAgentId ?? "")) ?? void 0;
  return {
    version: AGENT_RUNTIME_VERSION,
    revision: Number(parsed.revision ?? 0) || 0,
    updatedAt: normalizeStringValue(parsed.updatedAt) ?? (/* @__PURE__ */ new Date()).toISOString(),
    activeAgentId,
    agents
  };
}
function readRuntimeState(projectDir) {
  const file3 = filePath(projectDir);
  if (!fs2.existsSync(file3)) {
    const migrated = normalizeRuntimeState(projectDir, null);
    if (Object.keys(migrated.agents).length > 0 || fs2.existsSync(legacyFilePath(projectDir))) {
      const runtimeToWrite = {
        ...migrated,
        revision: migrated.revision > 0 ? migrated.revision : 1,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      writeRuntimeStateAtomic(projectDir, runtimeToWrite);
      return runtimeToWrite;
    }
    return migrated;
  }
  try {
    const raw = fs2.readFileSync(file3, "utf-8");
    const parsed = JSON.parse(raw);
    return normalizeRuntimeState(projectDir, parsed);
  } catch {
    return normalizeRuntimeState(projectDir, null);
  }
}
function writeRuntimeStateAtomic(projectDir, runtime) {
  const file3 = filePath(projectDir);
  fs2.mkdirSync(path2.dirname(file3), { recursive: true });
  const orderedAgents = Object.fromEntries(
    Object.keys(runtime.agents).sort((a, b) => a.localeCompare(b)).map((key) => [key, runtime.agents[key]])
  );
  const payload = {
    version: AGENT_RUNTIME_VERSION,
    revision: runtime.revision,
    updatedAt: runtime.updatedAt,
    activeAgentId: runtime.activeAgentId,
    agents: orderedAgents
  };
  const tmp = `${file3}.tmp.${process.pid}.${Date.now()}`;
  fs2.writeFileSync(tmp, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
  fs2.renameSync(tmp, file3);
}
function readPersistedAgentRuntime(projectDir) {
  const runtime = readRuntimeState(projectDir);
  return {
    activeAgentId: runtime.activeAgentId,
    revision: runtime.revision,
    agents: runtime.agents
  };
}
function normalizeSelectionInput(input) {
  const agentName = normalizeAgentName(input.agentName);
  if (!agentName) return null;
  const model = normalizeModelRef(input.model);
  const variant = normalizeStringValue(input.variant);
  const providerID = normalizeProviderID(input.providerID) ?? (model ? normalizeProviderID(model.split("/")[0]) : void 0);
  const options = normalizeOptions(input.options);
  const apiKey = normalizeStringValue(input.apiKey);
  const baseURL = normalizeStringValue(input.baseURL);
  const entryPatch = {};
  if (model) entryPatch.model = model;
  if (variant) entryPatch.variant = variant;
  if (providerID) entryPatch.providerID = providerID;
  if (options) entryPatch.options = options;
  if (apiKey) entryPatch.apiKey = apiKey;
  if (baseURL) entryPatch.baseURL = baseURL;
  const activeAgentId = normalizeAgentName(String(input.activeAgentId ?? "")) ?? void 0;
  if (Object.keys(entryPatch).length === 0 && !activeAgentId) return null;
  return {
    agentName,
    entryPatch,
    activeAgentId
  };
}
function persistAgentRuntimeSelection(projectDir, input) {
  const normalized = normalizeSelectionInput(input);
  if (!normalized) return false;
  for (let attempt = 0; attempt < MAX_WRITE_RETRIES; attempt += 1) {
    const base = readRuntimeState(projectDir);
    const currentEntry = base.agents[normalized.agentName];
    const mergedEntry = {
      ...currentEntry ?? {},
      ...normalized.entryPatch
    };
    const previousComparable = JSON.stringify({
      ...currentEntry ?? {},
      updatedAt: void 0
    });
    const nextComparable = JSON.stringify({
      ...mergedEntry,
      updatedAt: void 0
    });
    const nextEntry = {
      ...currentEntry ?? { updatedAt: (/* @__PURE__ */ new Date()).toISOString() },
      ...normalized.entryPatch,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const entryUnchanged = previousComparable === nextComparable;
    const activeUnchanged = normalized.activeAgentId === void 0 || base.activeAgentId === normalized.activeAgentId;
    if (entryUnchanged && activeUnchanged) {
      return false;
    }
    const latest = readRuntimeState(projectDir);
    if (latest.revision !== base.revision) {
      continue;
    }
    const nextState = {
      ...latest,
      revision: latest.revision + 1,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      activeAgentId: normalized.activeAgentId ?? latest.activeAgentId,
      agents: {
        ...latest.agents,
        [normalized.agentName]: nextEntry
      }
    };
    writeRuntimeStateAtomic(projectDir, nextState);
    return true;
  }
  return false;
}
function removePersistedAgentRuntimeSelection(projectDir, agentName, options) {
  const canonicalAgentName = normalizeAgentName(agentName);
  if (!canonicalAgentName) return false;
  const requestedActiveAgentId = normalizeAgentName(String(options?.activeAgentId ?? "")) ?? void 0;
  for (let attempt = 0; attempt < MAX_WRITE_RETRIES; attempt += 1) {
    const base = readRuntimeState(projectDir);
    const hadEntry = Boolean(base.agents[canonicalAgentName]);
    const nextActiveAgentId = requestedActiveAgentId ?? (options?.clearActive && base.activeAgentId === canonicalAgentName ? void 0 : base.activeAgentId);
    if (!hadEntry && nextActiveAgentId === base.activeAgentId) {
      return false;
    }
    const latest = readRuntimeState(projectDir);
    if (latest.revision !== base.revision) {
      continue;
    }
    const nextAgents = { ...latest.agents };
    delete nextAgents[canonicalAgentName];
    const nextState = {
      ...latest,
      revision: latest.revision + 1,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      activeAgentId: nextActiveAgentId,
      agents: nextAgents
    };
    writeRuntimeStateAtomic(projectDir, nextState);
    return true;
  }
  return false;
}
var KNOWN_AGENT_NAMES, AGENT_RUNTIME_VERSION, MAX_WRITE_RETRIES, LEGACY_MODEL_REWRITE;
var init_agent_model_persistence = __esm({
  "src/config/agent-model-persistence.ts"() {
    "use strict";
    init_workflow();
    init_constants();
    KNOWN_AGENT_NAMES = new Set(ALL_AGENT_NAMES);
    AGENT_RUNTIME_VERSION = 1;
    MAX_WRITE_RETRIES = 4;
    LEGACY_MODEL_REWRITE = {
      "openrouter/minimax/z-ai/glm-5": "openrouter/z-ai/glm-5"
    };
  }
});

// node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer5, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer5(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm({
  "node_modules/zod/v4/core/core.js"() {
    NEVER = Object.freeze({
      status: "aborted"
    });
    $brand = Symbol("zod_brand");
    $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    $ZodEncodeError = class extends Error {
      constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
      }
    };
    globalConfig = {};
  }
});

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject2,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object3, key, getter) {
  let value = void 0;
  Object.defineProperty(object3, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path45) {
  if (!path45)
    return obj;
  return path45.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class3, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class3, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path45, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path45);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config3.customError?.(iss)) ?? unwrapMessage(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base645) {
  const binaryString = atob(base645);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url5) {
  const base645 = base64url5.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base645.length % 4) % 4);
  return base64ToUint8Array(base645 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex5) {
  const cleanHex = hex5.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
var init_util = __esm({
  "node_modules/zod/v4/core/util.js"() {
    EVALUATING = Symbol("evaluating");
    captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
    };
    allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    Class = class {
      constructor(..._args) {
      }
    };
  }
});

// node_modules/zod/v4/core/errors.js
function flattenError(error92, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error92.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error92, mapper = (issue3) => issue3.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error93) => {
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error92);
  return fieldErrors;
}
function treeifyError(error92, mapper = (issue3) => issue3.message) {
  const result = { errors: [] };
  const processError = (error93, path45 = []) => {
    var _a2, _b;
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path45, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error92);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path45 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path45) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error92) {
  const lines = [];
  const issues = [...error92.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue3.path)}`);
  }
  return lines.join("\n");
}
var initializer, $ZodError, $ZodRealError;
var init_errors = __esm({
  "node_modules/zod/v4/core/errors.js"() {
    init_core();
    init_util();
    initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    $ZodError = $constructor("$ZodError", initializer);
    $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  }
});

// node_modules/zod/v4/core/parse.js
var _parse, parse, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync, _encode, encode, _decode, decode, _encodeAsync, encodeAsync, _decodeAsync, decodeAsync, _safeEncode, safeEncode, _safeDecode, safeDecode, _safeEncodeAsync, safeEncodeAsync, _safeDecodeAsync, safeDecodeAsync;
var init_parse = __esm({
  "node_modules/zod/v4/core/parse.js"() {
    init_core();
    init_errors();
    init_util();
    _parse = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    parse = /* @__PURE__ */ _parse($ZodRealError);
    _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
    _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
    _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
    _encode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parse(_Err)(schema, value, ctx);
    };
    encode = /* @__PURE__ */ _encode($ZodRealError);
    _decode = (_Err) => (schema, value, _ctx) => {
      return _parse(_Err)(schema, value, _ctx);
    };
    decode = /* @__PURE__ */ _decode($ZodRealError);
    _encodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parseAsync(_Err)(schema, value, ctx);
    };
    encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
    _decodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _parseAsync(_Err)(schema, value, _ctx);
    };
    decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
    _safeEncode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParse(_Err)(schema, value, ctx);
    };
    safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
    _safeDecode = (_Err) => (schema, value, _ctx) => {
      return _safeParse(_Err)(schema, value, _ctx);
    };
    safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
    _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParseAsync(_Err)(schema, value, ctx);
    };
    safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
    _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _safeParseAsync(_Err)(schema, value, _ctx);
    };
    safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
  }
});

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time5 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji, ipv4, ipv6, mac, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource, date, string, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm({
  "node_modules/zod/v4/core/regexes.js"() {
    init_util();
    cuid = /^[cC][^\s-]{8,}$/;
    cuid2 = /^[0-9a-z]+$/;
    ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid = /^[0-9a-vA-V]{20}$/;
    ksuid = /^[A-Za-z0-9]{27}$/;
    nanoid = /^[a-zA-Z0-9_-]{21}$/;
    duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid = (version3) => {
      if (!version3)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    uuid4 = /* @__PURE__ */ uuid(4);
    uuid6 = /* @__PURE__ */ uuid(6);
    uuid7 = /* @__PURE__ */ uuid(7);
    email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    idnEmail = unicodeEmail;
    browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
    mac = (delimiter) => {
      const escapedDelim = escapeRegex(delimiter ?? ":");
      return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
    };
    cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url = /^[A-Za-z0-9_-]*$/;
    hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
    domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e164 = /^\+[1-9]\d{6,14}$/;
    dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
    string = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    bigint = /^-?\d+n?$/;
    integer = /^-?\d+$/;
    number = /^-?\d+(?:\.\d+)?$/;
    boolean = /^(?:true|false)$/i;
    _null = /^null$/i;
    _undefined = /^undefined$/i;
    lowercase = /^[^A-Z]*$/;
    uppercase = /^[^a-z]*$/;
    hex = /^[0-9a-fA-F]*$/;
    md5_hex = /^[0-9a-fA-F]{32}$/;
    md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
    md5_base64url = /* @__PURE__ */ fixedBase64url(22);
    sha1_hex = /^[0-9a-fA-F]{40}$/;
    sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
    sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
    sha256_hex = /^[0-9a-fA-F]{64}$/;
    sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
    sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
    sha384_hex = /^[0-9a-fA-F]{96}$/;
    sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
    sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
    sha512_hex = /^[0-9a-fA-F]{128}$/;
    sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
    sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
  }
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm({
  "node_modules/zod/v4/core/checks.js"() {
    init_core();
    init_regexes();
    init_util();
    $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a2;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
    });
    numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a2;
        (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              continue: false,
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                inclusive: true,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                inclusive: true,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a2, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/zod/v4/core/doc.js
var Doc;
var init_doc = __esm({
  "node_modules/zod/v4/core/doc.js"() {
    Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm({
  "node_modules/zod/v4/core/versions.js"() {
    version = {
      major: 4,
      minor: 3,
      patch: 6
    };
  }
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base645 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base645.padEnd(Math.ceil(base645.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodXor, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodExactOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm({
  "node_modules/zod/v4/core/schemas.js"() {
    init_checks();
    init_core();
    init_doc();
    init_parse();
    init_regexes();
    init_util();
    init_versions();
    init_util();
    $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a2;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        const handleCanaryResult = (canary, payload, ctx) => {
          if (aborted(canary)) {
            canary.aborted = true;
            return canary;
          }
          const checkResult = runChecks(payload, checks, ctx);
          if (checkResult instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
          }
          return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
          if (ctx.skipChecks) {
            return inst._zod.parse(payload, ctx);
          }
          if (ctx.direction === "backward") {
            const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
            if (canary instanceof Promise) {
              return canary.then((canary2) => {
                return handleCanaryResult(canary2, payload, ctx);
              });
            }
            return handleCanaryResult(canary, payload, ctx);
          }
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      defineLazy(inst, "~standard", () => ({
        validate: (value) => {
          try {
            const r = safeParse(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      }));
    });
    $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
      } else
        def.pattern ?? (def.pattern = uuid());
      $ZodStringFormat.init(inst, def);
    });
    $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email);
      $ZodStringFormat.init(inst, def);
    });
    $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const trimmed = payload.value.trim();
          const url3 = new URL(trimmed);
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url3.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: def.hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url3.protocol.endsWith(":") ? url3.protocol.slice(0, -1) : url3.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.normalize) {
            payload.value = url3.href;
          } else {
            payload.value = trimmed;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji());
      $ZodStringFormat.init(inst, def);
    });
    $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2);
      $ZodStringFormat.init(inst, def);
    });
    $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration);
      $ZodStringFormat.init(inst, def);
    });
    $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv4`;
    });
    $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv6`;
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
      def.pattern ?? (def.pattern = mac(def.delimiter));
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `mac`;
    });
    $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
          if (parts.length !== 2)
            throw new Error();
          const [address, prefix] = parts;
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64";
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64url";
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164);
      $ZodStringFormat.init(inst, def);
    });
    $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const desc = Object.getOwnPropertyDescriptor(def, "shape");
      if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
          get: () => {
            const newSh = { ...sh };
            Object.defineProperty(def, "shape", {
              value: newSh
            });
            return newSh;
          }
        });
      }
      const _normalized = cached(() => normalizeDef(def));
      defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const isObject4 = isObject2;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
          const el = shape[key];
          const isOptionalOut = el._zod.optout === "optional";
          const r = el._zod.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
          } else {
            handlePropertyResult(r, payload, key, input, isOptionalOut);
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
      };
    });
    $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
      $ZodObject.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = cached(() => normalizeDef(def));
      const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
          const id = ids[key];
          const k = esc(key);
          const schema = shape[key];
          const isOptionalOut = schema?._zod?.optout === "optional";
          doc.write(`const ${id} = ${parseStr(key)};`);
          if (isOptionalOut) {
            doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
          } else {
            doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
          }
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject4 = isObject2;
      const jit = !globalConfig.jitless;
      const allowsEval3 = allowsEval;
      const fastEnabled = jit && allowsEval3.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
          if (!catchall)
            return payload;
          return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
      };
    });
    $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
      $ZodUnion.init(inst, def);
      def.inclusive = false;
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            results.push(result);
          }
        }
        if (!async)
          return handleExclusiveUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleExclusiveUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      def.inclusive = false;
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached(() => {
        const opts = def.options;
        const map3 = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues?.[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map3.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map3.set(v, o);
          }
        }
        return map3;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject2(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          discriminator: def.discriminator,
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
        const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
              input,
              inst,
              origin: "array"
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        const values = def.keyType._zod.values;
        if (values) {
          payload.value = {};
          const recordKeys = /* @__PURE__ */ new Set();
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              recordKeys.add(typeof key === "number" ? key.toString() : key);
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!recordKeys.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
            if (checkNumericKey) {
              const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
              if (retryResult instanceof Promise) {
                throw new Error("Async schemas not supported in object keys currently");
              }
              if (retryResult.issues.length === 0) {
                keyResult = retryResult;
              }
            }
            if (keyResult.issues.length) {
              if (def.mode === "loose") {
                payload.value[key] = input[key];
              } else {
                payload.issues.push({
                  code: "invalid_key",
                  origin: "record",
                  issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                  input: key,
                  path: [key],
                  inst
                });
              }
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
      }
      const values = new Set(def.values);
      inst._zod.values = values;
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise)
            return result.then((r) => handleOptionalResult(r, payload.value));
          return handleOptionalResult(result, payload.value);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
      inst._zod.parse = (payload, ctx) => {
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handlePipeResult(right2, def.in, ctx));
          }
          return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
      };
    });
    $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handleCodecAResult(left2, def, ctx));
          }
          return handleCodecAResult(left, def, ctx);
        } else {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handleCodecAResult(right2, def, ctx));
          }
          return handleCodecAResult(right, def, ctx);
        }
      };
    });
    $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
      defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "string",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: def.format ?? "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
      $ZodType.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        return function(...args) {
          const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
          const result = Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return parse(inst._def.output, result);
          }
          return result;
        };
      };
      inst.implementAsync = (func) => {
        if (typeof func !== "function") {
          throw new Error("implementAsync() must be called with a function");
        }
        return async function(...args) {
          const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
          const result = await Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return await parseAsync(inst._def.output, result);
          }
          return result;
        };
      };
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
          payload.issues.push({
            code: "invalid_type",
            expected: "function",
            input: payload.value,
            inst
          });
          return payload;
        }
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
          payload.value = inst.implementAsync(payload.value);
        } else {
          payload.value = inst.implement(payload.value);
        }
        return payload;
      };
      inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: inst._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: inst._def.output
        });
      };
      inst.output = (output) => {
        const F = inst.constructor;
        return new F({
          type: "function",
          input: inst._def.input,
          output
        });
      };
      return inst;
    });
    $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
  }
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error;
var init_ar = __esm({
  "node_modules/zod/v4/locales/ar.js"() {
    init_util();
    error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
            }
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2;
var init_az = __esm({
  "node_modules/zod/v4/locales/az.js"() {
    init_util();
    error2 = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue3.expected}, daxil olan ${received}`;
            }
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue3.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3;
var init_be = __esm({
  "node_modules/zod/v4/locales/be.js"() {
    init_util();
    error3 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u043B\u0456\u043A",
        array: "\u043C\u0430\u0441\u0456\u045E"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
            }
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const maxValue = Number(issue3.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const minValue = Number(issue3.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error4()
  };
}
var error4;
var init_bg = __esm({
  "node_modules/zod/v4/locales/bg.js"() {
    init_util();
    error4 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0445\u043E\u0434",
        email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        json_string: "JSON \u043D\u0438\u0437",
        e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0438\u0432"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
            }
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue3.values[0])}`;
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
            let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
            if (_issue.format === "emoji")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "datetime")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "date")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            if (_issue.format === "time")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "duration")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue3.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue3.origin}`;
          default:
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error5()
  };
}
var error5;
var init_ca = __esm({
  "node_modules/zod/v4/locales/ca.js"() {
    init_util();
    error5 = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Tipus inv\xE0lid: s'esperava instanceof ${issue3.expected}, s'ha rebut ${received}`;
            }
            return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue3.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue3.values, " o ")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue3.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error6()
  };
}
var error6;
var init_cs = __esm({
  "node_modules/zod/v4/locales/cs.js"() {
    init_util();
    error6 = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u010D\xEDslo",
        string: "\u0159et\u011Bzec",
        function: "funkce",
        array: "pole"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue3.expected}, obdr\u017Eeno ${received}`;
            }
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue3.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue3.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error7()
  };
}
var error7;
var init_da = __esm({
  "node_modules/zod/v4/locales/da.js"() {
    init_util();
    error7 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "havde" },
        file: { unit: "bytes", verb: "havde" },
        array: { unit: "elementer", verb: "indeholdt" },
        set: { unit: "elementer", verb: "indeholdt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "e-mailadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkesl\xE6t",
        date: "ISO-dato",
        time: "ISO-klokkesl\xE6t",
        duration: "ISO-varighed",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodet streng",
        base64url: "base64url-kodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        string: "streng",
        number: "tal",
        boolean: "boolean",
        array: "liste",
        object: "objekt",
        set: "s\xE6t",
        file: "fil"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Ugyldigt input: forventede instanceof ${issue3.expected}, fik ${received}`;
            }
            return `Ugyldigt input: forventede ${expected}, fik ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue3.values[0])}`;
            return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
            if (sizing)
              return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
            if (sizing) {
              return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8gle i ${issue3.origin}`;
          case "invalid_union":
            return "Ugyldigt input: matcher ingen af de tilladte typer";
          case "invalid_element":
            return `Ugyldig v\xE6rdi i ${issue3.origin}`;
          default:
            return `Ugyldigt input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error8()
  };
}
var error8;
var init_de = __esm({
  "node_modules/zod/v4/locales/de.js"() {
    init_util();
    error8 = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "Zahl",
        array: "Array"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Ung\xFCltige Eingabe: erwartet instanceof ${issue3.expected}, erhalten ${received}`;
            }
            return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue3.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue3.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error9()
  };
}
var error9;
var init_en = __esm({
  "node_modules/zod/v4/locales/en.js"() {
    init_util();
    error9 = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" },
        map: { unit: "entries", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        mac: "MAC address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        // Compatibility: "nan" -> "NaN" for display
        nan: "NaN"
        // All other type names omitted - they fall back to raw values via ?? operator
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            return `Invalid input: expected ${expected}, received ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
            return `Invalid option: expected one of ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue3.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue3.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error10()
  };
}
var error10;
var init_eo = __esm({
  "node_modules/zod/v4/locales/eo.js"() {
    init_util();
    error10 = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombro",
        array: "tabelo",
        null: "senvalora"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Nevalida enigo: atendi\u011Dis instanceof ${issue3.expected}, ricevi\u011Dis ${received}`;
            }
            return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue3.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue3.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue3.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error11()
  };
}
var error11;
var init_es = __esm({
  "node_modules/zod/v4/locales/es.js"() {
    init_util();
    error11 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN",
        string: "texto",
        number: "n\xFAmero",
        boolean: "booleano",
        array: "arreglo",
        object: "objeto",
        set: "conjunto",
        file: "archivo",
        date: "fecha",
        bigint: "n\xFAmero grande",
        symbol: "s\xEDmbolo",
        undefined: "indefinido",
        null: "nulo",
        function: "funci\xF3n",
        map: "mapa",
        record: "registro",
        tuple: "tupla",
        enum: "enumeraci\xF3n",
        union: "uni\xF3n",
        literal: "literal",
        promise: "promesa",
        void: "vac\xEDo",
        never: "nunca",
        unknown: "desconocido",
        any: "cualquiera"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Entrada inv\xE1lida: se esperaba instanceof ${issue3.expected}, recibido ${received}`;
            }
            return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue3.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
            if (sizing)
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error12()
  };
}
var error12;
var init_fa = __esm({
  "node_modules/zod/v4/locales/fa.js"() {
    init_util();
    error12 = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0639\u062F\u062F",
        array: "\u0622\u0631\u0627\u06CC\u0647"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
            }
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          }
          case "invalid_value":
            if (issue3.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${FormatDictionary[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error13()
  };
}
var error13;
var init_fi = __esm({
  "node_modules/zod/v4/locales/fi.js"() {
    init_util();
    error13 = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Virheellinen tyyppi: odotettiin instanceof ${issue3.expected}, oli ${received}`;
            }
            return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue3.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error14()
  };
}
var error14;
var init_fr = __esm({
  "node_modules/zod/v4/locales/fr.js"() {
    init_util();
    error14 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombre",
        array: "tableau"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Entr\xE9e invalide : instanceof ${issue3.expected} attendu, ${received} re\xE7u`;
            }
            return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive(issue3.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues(issue3.values, "|")} attendue`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue3.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue3.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
var error15;
var init_fr_CA = __esm({
  "node_modules/zod/v4/locales/fr-CA.js"() {
    init_util();
    error15 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Entr\xE9e invalide : attendu instanceof ${issue3.expected}, re\xE7u ${received}`;
            }
            return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue3.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue3.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue3.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error16()
  };
}
var error16;
var init_he = __esm({
  "node_modules/zod/v4/locales/he.js"() {
    init_util();
    error16 = () => {
      const TypeNames = {
        string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
        number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
        boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
        bigint: { label: "BigInt", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
        array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
        object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
        null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
        undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
        symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
        function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
        map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
        set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
        file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
        promise: { label: "Promise", gender: "m" },
        NaN: { label: "NaN", gender: "m" },
        unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
        value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
      };
      const Sizable = {
        string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
        // no unit
      };
      const typeEntry = (t) => t ? TypeNames[t] : void 0;
      const typeLabel = (t) => {
        const e = typeEntry(t);
        if (e)
          return e.label;
        return t ?? TypeNames.unknown.label;
      };
      const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
      const verbFor = (t) => {
        const e = typeEntry(t);
        const gender = e?.gender ?? "m";
        return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
      };
      const getSizing = (origin) => {
        if (!origin)
          return null;
        return Sizable[origin] ?? null;
      };
      const FormatDictionary = {
        regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
        url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
        uuid: { label: "UUID", gender: "m" },
        nanoid: { label: "nanoid", gender: "m" },
        guid: { label: "GUID", gender: "m" },
        cuid: { label: "cuid", gender: "m" },
        cuid2: { label: "cuid2", gender: "m" },
        ulid: { label: "ULID", gender: "m" },
        xid: { label: "XID", gender: "m" },
        ksuid: { label: "KSUID", gender: "m" },
        datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
        time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
        duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
        ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
        ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
        cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
        cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
        base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
        base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
        e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
        jwt: { label: "JWT", gender: "m" },
        ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expectedKey = issue3.expected;
            const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
            }
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
          }
          case "invalid_value": {
            if (issue3.values.length === 1) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue3.values[0])}`;
            }
            const stringified = issue3.values.map((v) => stringifyPrimitive(v));
            if (issue3.values.length === 2) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
            }
            const lastValue = stringified[stringified.length - 1];
            const restValues = stringified.slice(0, -1).join(", ");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
          }
          case "too_big": {
            const sizing = getSizing(issue3.origin);
            const subject = withDefinite(issue3.origin ?? "value");
            if (issue3.origin === "string") {
              return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue3.maximum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
            }
            if (issue3.origin === "number") {
              const comparison = issue3.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue3.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue3.maximum}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue3.origin === "array" || issue3.origin === "set") {
              const verb = issue3.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              const comparison = issue3.inclusive ? `${issue3.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue3.maximum} ${sizing?.unit ?? ""}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue3.inclusive ? "<=" : "<";
            const be = verbFor(issue3.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const sizing = getSizing(issue3.origin);
            const subject = withDefinite(issue3.origin ?? "value");
            if (issue3.origin === "string") {
              return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue3.minimum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
            }
            if (issue3.origin === "number") {
              const comparison = issue3.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue3.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue3.minimum}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue3.origin === "array" || issue3.origin === "set") {
              const verb = issue3.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              if (issue3.minimum === 1 && issue3.inclusive) {
                const singularPhrase = issue3.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
                return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
              }
              const comparison = issue3.inclusive ? `${issue3.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue3.minimum} ${sizing?.unit ?? ""}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue3.inclusive ? ">=" : ">";
            const be = verbFor(issue3.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            const nounEntry = FormatDictionary[_issue.format];
            const noun = nounEntry?.label ?? _issue.format;
            const gender = nounEntry?.gender ?? "m";
            const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
            return `${noun} \u05DC\u05D0 ${adjective}`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key": {
            return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
          }
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element": {
            const place = withDefinite(issue3.origin ?? "array");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
          }
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error17()
  };
}
var error17;
var init_hu = __esm({
  "node_modules/zod/v4/locales/hu.js"() {
    init_util();
    error17 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "sz\xE1m",
        array: "t\xF6mb"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue3.expected}, a kapott \xE9rt\xE9k ${received}`;
            }
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue3.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
function hy_default() {
  return {
    localeError: error18()
  };
}
var error18;
var init_hy = __esm({
  "node_modules/zod/v4/locales/hy.js"() {
    init_util();
    error18 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0576\u0577\u0561\u0576",
            many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        file: {
          unit: {
            one: "\u0562\u0561\u0575\u0569",
            many: "\u0562\u0561\u0575\u0569\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        array: {
          unit: {
            one: "\u057F\u0561\u0580\u0580",
            many: "\u057F\u0561\u0580\u0580\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        set: {
          unit: {
            one: "\u057F\u0561\u0580\u0580",
            many: "\u057F\u0561\u0580\u0580\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0574\u0578\u0582\u057F\u0584",
        email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
        url: "URL",
        emoji: "\u0567\u0574\u0578\u057B\u056B",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
        date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
        time: "ISO \u056A\u0561\u0574",
        duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
        ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
        ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
        cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
        cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
        base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
        base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
        json_string: "JSON \u057F\u0578\u0572",
        e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
        jwt: "JWT",
        template_literal: "\u0574\u0578\u0582\u057F\u0584"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0569\u056B\u057E",
        array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue3.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
            }
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue3.values[1])}`;
            return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const maxValue = Number(issue3.maximum);
              const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue3.maximum.toString()} ${unit}`;
            }
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const minValue = Number(issue3.minimum);
              const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue3.minimum.toString()} ${unit}`;
            }
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin)} \u056C\u056B\u0576\u056B ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
            if (_issue.format === "ends_with")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
            if (_issue.format === "includes")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
            return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue3.divisor}-\u056B`;
          case "unrecognized_keys":
            return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue3.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue3.origin)}-\u0578\u0582\u0574`;
          case "invalid_union":
            return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
          case "invalid_element":
            return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue3.origin)}-\u0578\u0582\u0574`;
          default:
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error19()
  };
}
var error19;
var init_id = __esm({
  "node_modules/zod/v4/locales/id.js"() {
    init_util();
    error19 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Input tidak valid: diharapkan instanceof ${issue3.expected}, diterima ${received}`;
            }
            return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive(issue3.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue3.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue3.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue3.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error20()
  };
}
var error20;
var init_is = __esm({
  "node_modules/zod/v4/locales/is.js"() {
    init_util();
    error20 = () => {
      const Sizable = {
        string: { unit: "stafi", verb: "a\xF0 hafa" },
        file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
        array: { unit: "hluti", verb: "a\xF0 hafa" },
        set: { unit: "hluti", verb: "a\xF0 hafa" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "gildi",
        email: "netfang",
        url: "vefsl\xF3\xF0",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dagsetning og t\xEDmi",
        date: "ISO dagsetning",
        time: "ISO t\xEDmi",
        duration: "ISO t\xEDmalengd",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded strengur",
        base64url: "base64url-encoded strengur",
        json_string: "JSON strengur",
        e164: "E.164 t\xF6lugildi",
        jwt: "JWT",
        template_literal: "gildi"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\xFAmer",
        array: "fylki"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue3.expected}`;
            }
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue3.values[0])}`;
            return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
            return `Rangt ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Rangur lykill \xED ${issue3.origin}`;
          case "invalid_union":
            return "Rangt gildi";
          case "invalid_element":
            return `Rangt gildi \xED ${issue3.origin}`;
          default:
            return `Rangt gildi`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error21()
  };
}
var error21;
var init_it = __esm({
  "node_modules/zod/v4/locales/it.js"() {
    init_util();
    error21 = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "numero",
        array: "vettore"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Input non valido: atteso instanceof ${issue3.expected}, ricevuto ${received}`;
            }
            return `Input non valido: atteso ${expected}, ricevuto ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive(issue3.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue3.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue3.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error22()
  };
}
var error22;
var init_ja = __esm({
  "node_modules/zod/v4/locales/ja.js"() {
    init_util();
    error22 = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u6570\u5024",
        array: "\u914D\u5217"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
            }
            return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue3.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error23()
  };
}
var error23;
var init_ka = __esm({
  "node_modules/zod/v4/locales/ka.js"() {
    init_util();
    error23 = () => {
      const Sizable = {
        string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
        email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        url: "URL",
        emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
        date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
        time: "\u10D3\u10E0\u10DD",
        duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
        ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
        jwt: "JWT",
        template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
        string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
        function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
        array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
            }
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue3.values[0])}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
            }
            if (_issue.format === "ends_with")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
            if (_issue.format === "includes")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
            if (_issue.format === "regex")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
          case "unrecognized_keys":
            return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
          case "invalid_union":
            return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
          case "invalid_element":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
          default:
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error24()
  };
}
var error24;
var init_km = __esm({
  "node_modules/zod/v4/locales/km.js"() {
    init_util();
    error24 = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u179B\u17C1\u1781",
        array: "\u17A2\u17B6\u179A\u17C1 (Array)",
        null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
            }
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue3.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm({
  "node_modules/zod/v4/locales/kh.js"() {
    init_km();
  }
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error25()
  };
}
var error25;
var init_ko = __esm({
  "node_modules/zod/v4/locales/ko.js"() {
    init_util();
    error25 = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
            }
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue3.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue3.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number7) {
  const abs = Math.abs(number7);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error26()
  };
}
var capitalizeFirstCharacter, error26;
var init_lt = __esm({
  "node_modules/zod/v4/locales/lt.js"() {
    init_util();
    capitalizeFirstCharacter = (text) => {
      return text.charAt(0).toUpperCase() + text.slice(1);
    };
    error26 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "simbolis",
            few: "simboliai",
            many: "simboli\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
              notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
              notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
            }
          }
        },
        file: {
          unit: {
            one: "baitas",
            few: "baitai",
            many: "bait\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne didesnis kaip",
              notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
              notInclusive: "turi b\u016Bti didesnis kaip"
            }
          }
        },
        array: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        },
        set: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        }
      };
      function getSizing(origin, unitType, inclusive, targetShouldBe) {
        const result = Sizable[origin] ?? null;
        if (result === null)
          return result;
        return {
          unit: result.unit[unitType],
          verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
        };
      }
      const FormatDictionary = {
        regex: "\u012Fvestis",
        email: "el. pa\u0161to adresas",
        url: "URL",
        emoji: "jaustukas",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO data ir laikas",
        date: "ISO data",
        time: "ISO laikas",
        duration: "ISO trukm\u0117",
        ipv4: "IPv4 adresas",
        ipv6: "IPv6 adresas",
        cidrv4: "IPv4 tinklo prefiksas (CIDR)",
        cidrv6: "IPv6 tinklo prefiksas (CIDR)",
        base64: "base64 u\u017Ekoduota eilut\u0117",
        base64url: "base64url u\u017Ekoduota eilut\u0117",
        json_string: "JSON eilut\u0117",
        e164: "E.164 numeris",
        jwt: "JWT",
        template_literal: "\u012Fvestis"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "skai\u010Dius",
        bigint: "sveikasis skai\u010Dius",
        string: "eilut\u0117",
        boolean: "login\u0117 reik\u0161m\u0117",
        undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
        function: "funkcija",
        symbol: "simbolis",
        array: "masyvas",
        object: "objektas",
        null: "nulin\u0117 reik\u0161m\u0117"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue3.expected}`;
            }
            return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Privalo b\u016Bti ${stringifyPrimitive(issue3.values[0])}`;
            return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue3.values, "|")} pasirinkim\u0173`;
          case "too_big": {
            const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
            const sizing = getSizing(issue3.origin, getUnitTypeFromNumber(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue3.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
          }
          case "too_small": {
            const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
            const sizing = getSizing(issue3.origin, getUnitTypeFromNumber(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue3.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
            return `Neteisingas ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
          case "unrecognized_keys":
            return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return "Rastas klaidingas raktas";
          case "invalid_union":
            return "Klaidinga \u012Fvestis";
          case "invalid_element": {
            const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
            return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
          }
          default:
            return "Klaidinga \u012Fvestis";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error27()
  };
}
var error27;
var init_mk = __esm({
  "node_modules/zod/v4/locales/mk.js"() {
    init_util();
    error27 = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0431\u0440\u043E\u0458",
        array: "\u043D\u0438\u0437\u0430"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
            }
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error28()
  };
}
var error28;
var init_ms = __esm({
  "node_modules/zod/v4/locales/ms.js"() {
    init_util();
    error28 = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombor"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Input tidak sah: dijangka instanceof ${issue3.expected}, diterima ${received}`;
            }
            return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive(issue3.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue3.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue3.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue3.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error29()
  };
}
var error29;
var init_nl = __esm({
  "node_modules/zod/v4/locales/nl.js"() {
    init_util();
    error29 = () => {
      const Sizable = {
        string: { unit: "tekens", verb: "heeft" },
        file: { unit: "bytes", verb: "heeft" },
        array: { unit: "elementen", verb: "heeft" },
        set: { unit: "elementen", verb: "heeft" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "getal"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Ongeldige invoer: verwacht instanceof ${issue3.expected}, ontving ${received}`;
            }
            return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue3.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            const longName = issue3.origin === "date" ? "laat" : issue3.origin === "string" ? "lang" : "groot";
            if (sizing)
              return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
            return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            const shortName = issue3.origin === "date" ? "vroeg" : issue3.origin === "string" ? "kort" : "klein";
            if (sizing) {
              return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
            }
            return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue3.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue3.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error30()
  };
}
var error30;
var init_no = __esm({
  "node_modules/zod/v4/locales/no.js"() {
    init_util();
    error30 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "tall",
        array: "liste"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Ugyldig input: forventet instanceof ${issue3.expected}, fikk ${received}`;
            }
            return `Ugyldig input: forventet ${expected}, fikk ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive(issue3.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue3.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue3.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error31()
  };
}
var error31;
var init_ota = __esm({
  "node_modules/zod/v4/locales/ota.js"() {
    init_util();
    error31 = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "numara",
        array: "saf",
        null: "gayb"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `F\xE2sit giren: umulan instanceof ${issue3.expected}, al\u0131nan ${received}`;
            }
            return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive(issue3.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error32()
  };
}
var error32;
var init_ps = __esm({
  "node_modules/zod/v4/locales/ps.js"() {
    init_util();
    error32 = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0639\u062F\u062F",
        array: "\u0627\u0631\u06D0"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
            }
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          }
          case "invalid_value":
            if (issue3.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue3.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${FormatDictionary[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error33()
  };
}
var error33;
var init_pl = __esm({
  "node_modules/zod/v4/locales/pl.js"() {
    init_util();
    error33 = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "liczba",
        array: "tablica"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue3.expected}, otrzymano ${received}`;
            }
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue3.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error34()
  };
}
var error34;
var init_pt = __esm({
  "node_modules/zod/v4/locales/pt.js"() {
    init_util();
    error34 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\xFAmero",
        null: "nulo"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Tipo inv\xE1lido: esperado instanceof ${issue3.expected}, recebido ${received}`;
            }
            return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue3.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue3.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue3.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error35()
  };
}
var error35;
var init_ru = __esm({
  "node_modules/zod/v4/locales/ru.js"() {
    init_util();
    error35 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0441\u0438\u0432"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
            }
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue3.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const maxValue = Number(issue3.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const minValue = Number(issue3.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error36()
  };
}
var error36;
var init_sl = __esm({
  "node_modules/zod/v4/locales/sl.js"() {
    init_util();
    error36 = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0161tevilo",
        array: "tabela"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue3.expected}, prejeto ${received}`;
            }
            return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue3.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue3.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue3.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error37()
  };
}
var error37;
var init_sv = __esm({
  "node_modules/zod/v4/locales/sv.js"() {
    init_util();
    error37 = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "antal",
        array: "lista"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue3.expected}, fick ${received}`;
            }
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue3.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error38()
  };
}
var error38;
var init_ta = __esm({
  "node_modules/zod/v4/locales/ta.js"() {
    init_util();
    error38 = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0B8E\u0BA3\u0BCD",
        array: "\u0B85\u0BA3\u0BBF",
        null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
            }
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error39()
  };
}
var error39;
var init_th = __esm({
  "node_modules/zod/v4/locales/th.js"() {
    init_util();
    error39 = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
        array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
        null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
            }
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue3.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error40()
  };
}
var error40;
var init_tr = __esm({
  "node_modules/zod/v4/locales/tr.js"() {
    init_util();
    error40 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue3.expected}, al\u0131nan ${received}`;
            }
            return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue3.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error41()
  };
}
var error41;
var init_uk = __esm({
  "node_modules/zod/v4/locales/uk.js"() {
    init_util();
    error41 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0438\u0432"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
            }
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm({
  "node_modules/zod/v4/locales/ua.js"() {
    init_uk();
  }
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error42()
  };
}
var error42;
var init_ur = __esm({
  "node_modules/zod/v4/locales/ur.js"() {
    init_util();
    error42 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0646\u0645\u0628\u0631",
        array: "\u0622\u0631\u06D2",
        null: "\u0646\u0644"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
            }
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/uz.js
function uz_default() {
  return {
    localeError: error43()
  };
}
var error43;
var init_uz = __esm({
  "node_modules/zod/v4/locales/uz.js"() {
    init_util();
    error43 = () => {
      const Sizable = {
        string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
        file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
        array: { unit: "element", verb: "bo\u2018lishi kerak" },
        set: { unit: "element", verb: "bo\u2018lishi kerak" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "kirish",
        email: "elektron pochta manzili",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO sana va vaqti",
        date: "ISO sana",
        time: "ISO vaqt",
        duration: "ISO davomiylik",
        ipv4: "IPv4 manzil",
        ipv6: "IPv6 manzil",
        mac: "MAC manzil",
        cidrv4: "IPv4 diapazon",
        cidrv6: "IPv6 diapazon",
        base64: "base64 kodlangan satr",
        base64url: "base64url kodlangan satr",
        json_string: "JSON satr",
        e164: "E.164 raqam",
        jwt: "JWT",
        template_literal: "kirish"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "raqam",
        array: "massiv"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue3.expected}, qabul qilingan ${received}`;
            }
            return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue3.values[0])}`;
            return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
            return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
            }
            return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
            if (_issue.format === "ends_with")
              return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
            if (_issue.format === "includes")
              return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
            if (_issue.format === "regex")
              return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
            return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Noto\u2018g\u2018ri raqam: ${issue3.divisor} ning karralisi bo\u2018lishi kerak`;
          case "unrecognized_keys":
            return `Noma\u2019lum kalit${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} dagi kalit noto\u2018g\u2018ri`;
          case "invalid_union":
            return "Noto\u2018g\u2018ri kirish";
          case "invalid_element":
            return `${issue3.origin} da noto\u2018g\u2018ri qiymat`;
          default:
            return `Noto\u2018g\u2018ri kirish`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error44()
  };
}
var error44;
var init_vi = __esm({
  "node_modules/zod/v4/locales/vi.js"() {
    init_util();
    error44 = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "s\u1ED1",
        array: "m\u1EA3ng"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
            }
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue3.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
var error45;
var init_zh_CN = __esm({
  "node_modules/zod/v4/locales/zh-CN.js"() {
    init_util();
    error45 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u6570\u5B57",
        array: "\u6570\u7EC4",
        null: "\u7A7A\u503C(null)"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
            }
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue3.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
var error46;
var init_zh_TW = __esm({
  "node_modules/zod/v4/locales/zh-TW.js"() {
    init_util();
    error46 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
            }
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue3.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue3.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error47()
  };
}
var error47;
var init_yo = __esm({
  "node_modules/zod/v4/locales/yo.js"() {
    init_util();
    error47 = () => {
      const Sizable = {
        string: { unit: "\xE0mi", verb: "n\xED" },
        file: { unit: "bytes", verb: "n\xED" },
        array: { unit: "nkan", verb: "n\xED" },
        set: { unit: "nkan", verb: "n\xED" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
        email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\xE0k\xF3k\xF2 ISO",
        date: "\u1ECDj\u1ECD\u0301 ISO",
        time: "\xE0k\xF3k\xF2 ISO",
        duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
        ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
        ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
        cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
        cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
        base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
        base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
        json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
        e164: "n\u1ECD\u0301mb\xE0 E.164",
        jwt: "JWT",
        template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\u1ECD\u0301mb\xE0",
        array: "akop\u1ECD"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
            const receivedType = parsedType(issue3.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue3.expected)) {
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
            }
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
          }
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue3.values[0])}`;
            return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
            return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
          case "unrecognized_keys":
            return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue3.keys, ", ")}`;
          case "invalid_key":
            return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
          case "invalid_union":
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          case "invalid_element":
            return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
          default:
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
var init_locales = __esm({
  "node_modules/zod/v4/locales/index.js"() {
    init_ar();
    init_az();
    init_be();
    init_bg();
    init_ca();
    init_cs();
    init_da();
    init_de();
    init_en();
    init_eo();
    init_es();
    init_fa();
    init_fi();
    init_fr();
    init_fr_CA();
    init_he();
    init_hu();
    init_hy();
    init_id();
    init_is();
    init_it();
    init_ja();
    init_ka();
    init_kh();
    init_km();
    init_ko();
    init_lt();
    init_mk();
    init_ms();
    init_nl();
    init_no();
    init_ota();
    init_ps();
    init_pl();
    init_pt();
    init_ru();
    init_sl();
    init_sv();
    init_ta();
    init_th();
    init_tr();
    init_ua();
    init_uk();
    init_ur();
    init_uz();
    init_vi();
    init_zh_CN();
    init_zh_TW();
    init_yo();
  }
});

// node_modules/zod/v4/core/registries.js
function registry() {
  return new $ZodRegistry();
}
var _a, $output, $input, $ZodRegistry, globalRegistry;
var init_registries = __esm({
  "node_modules/zod/v4/core/registries.js"() {
    $output = Symbol("ZodOutput");
    $input = Symbol("ZodInput");
    $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta3 = _meta[0];
        this._map.set(schema, meta3);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.set(meta3.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta3 = this._map.get(schema);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.delete(meta3.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          const f = { ...pm, ...this._map.get(schema) };
          return Object.keys(f).length ? f : void 0;
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
    globalRegistry = globalThis.__zod_globalRegistry;
  }
});

// node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class3, params) {
  return new Class3({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class3) {
  return new Class3({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class3) {
  return new Class3({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class3, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec3 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec3,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec3;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
var TimePrecision;
var init_api = __esm({
  "node_modules/zod/v4/core/api.js"() {
    init_checks();
    init_registries();
    init_schemas();
    init_util();
    TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
  }
});

// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry2 of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry2[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry2[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry2[0]);
    }
  }
  const makeURI = (entry2) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry2[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry2[1].defId ?? entry2[1].schema.id ?? `schema${ctx.counter++}`;
      entry2[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry2[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry2[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry2) => {
    if (entry2[1].schema.$ref) {
      return;
    }
    const seen = entry2[1];
    const { ref, defId } = makeURI(entry2);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry2 of ctx.seen.entries()) {
      const seen = entry2[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry2 of ctx.seen.entries()) {
    const seen = entry2[1];
    if (schema === entry2[0]) {
      extractToDef(entry2);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry2[0])?.id;
      if (schema !== entry2[0] && ext) {
        extractToDef(entry2);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry2[0])?.id;
    if (id) {
      extractToDef(entry2);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry2);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry2);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry2 of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry2[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry2 of ctx.seen.entries()) {
    const seen = entry2[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod, createStandardJSONSchemaMethod;
var init_to_json_schema = __esm({
  "node_modules/zod/v4/core/to-json-schema.js"() {
    init_registries();
    createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
      const ctx = initializeContext({ ...params, processors });
      process2(schema, ctx);
      extractDefs(ctx, schema);
      return finalize(ctx, schema);
    };
    createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
      const { libraryOptions, target } = params ?? {};
      const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
      process2(schema, ctx);
      extractDefs(ctx, schema);
      return finalize(ctx, schema);
    };
  }
});

// node_modules/zod/v4/core/json-schema-processors.js
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry3 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry2 of registry3._idmap.entries()) {
      const [_, schema] = entry2;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry3,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry2 of registry3._idmap.entries()) {
      const [key, schema] = entry2;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
var formatMap, stringProcessor, numberProcessor, booleanProcessor, bigintProcessor, symbolProcessor, nullProcessor, undefinedProcessor, voidProcessor, neverProcessor, anyProcessor, unknownProcessor, dateProcessor, enumProcessor, literalProcessor, nanProcessor, templateLiteralProcessor, fileProcessor, successProcessor, customProcessor, functionProcessor, transformProcessor, mapProcessor, setProcessor, arrayProcessor, objectProcessor, unionProcessor, intersectionProcessor, tupleProcessor, recordProcessor, nullableProcessor, nonoptionalProcessor, defaultProcessor, prefaultProcessor, catchProcessor, pipeProcessor, readonlyProcessor, promiseProcessor, optionalProcessor, lazyProcessor, allProcessors;
var init_json_schema_processors = __esm({
  "node_modules/zod/v4/core/json-schema-processors.js"() {
    init_to_json_schema();
    init_util();
    formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    stringProcessor = (schema, ctx, _json, _params) => {
      const json3 = _json;
      json3.type = "string";
      const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
      if (typeof minimum === "number")
        json3.minLength = minimum;
      if (typeof maximum === "number")
        json3.maxLength = maximum;
      if (format) {
        json3.format = formatMap[format] ?? format;
        if (json3.format === "")
          delete json3.format;
        if (format === "time") {
          delete json3.format;
        }
      }
      if (contentEncoding)
        json3.contentEncoding = contentEncoding;
      if (patterns && patterns.size > 0) {
        const regexes = [...patterns];
        if (regexes.length === 1)
          json3.pattern = regexes[0].source;
        else if (regexes.length > 1) {
          json3.allOf = [
            ...regexes.map((regex) => ({
              ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
              pattern: regex.source
            }))
          ];
        }
      }
    };
    numberProcessor = (schema, ctx, _json, _params) => {
      const json3 = _json;
      const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
      if (typeof format === "string" && format.includes("int"))
        json3.type = "integer";
      else
        json3.type = "number";
      if (typeof exclusiveMinimum === "number") {
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json3.minimum = exclusiveMinimum;
          json3.exclusiveMinimum = true;
        } else {
          json3.exclusiveMinimum = exclusiveMinimum;
        }
      }
      if (typeof minimum === "number") {
        json3.minimum = minimum;
        if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
          if (exclusiveMinimum >= minimum)
            delete json3.minimum;
          else
            delete json3.exclusiveMinimum;
        }
      }
      if (typeof exclusiveMaximum === "number") {
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json3.maximum = exclusiveMaximum;
          json3.exclusiveMaximum = true;
        } else {
          json3.exclusiveMaximum = exclusiveMaximum;
        }
      }
      if (typeof maximum === "number") {
        json3.maximum = maximum;
        if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
          if (exclusiveMaximum <= maximum)
            delete json3.maximum;
          else
            delete json3.exclusiveMaximum;
        }
      }
      if (typeof multipleOf === "number")
        json3.multipleOf = multipleOf;
    };
    booleanProcessor = (_schema, _ctx, json3, _params) => {
      json3.type = "boolean";
    };
    bigintProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt cannot be represented in JSON Schema");
      }
    };
    symbolProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Symbols cannot be represented in JSON Schema");
      }
    };
    nullProcessor = (_schema, ctx, json3, _params) => {
      if (ctx.target === "openapi-3.0") {
        json3.type = "string";
        json3.nullable = true;
        json3.enum = [null];
      } else {
        json3.type = "null";
      }
    };
    undefinedProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Undefined cannot be represented in JSON Schema");
      }
    };
    voidProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Void cannot be represented in JSON Schema");
      }
    };
    neverProcessor = (_schema, _ctx, json3, _params) => {
      json3.not = {};
    };
    anyProcessor = (_schema, _ctx, _json, _params) => {
    };
    unknownProcessor = (_schema, _ctx, _json, _params) => {
    };
    dateProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Date cannot be represented in JSON Schema");
      }
    };
    enumProcessor = (schema, _ctx, json3, _params) => {
      const def = schema._zod.def;
      const values = getEnumValues(def.entries);
      if (values.every((v) => typeof v === "number"))
        json3.type = "number";
      if (values.every((v) => typeof v === "string"))
        json3.type = "string";
      json3.enum = values;
    };
    literalProcessor = (schema, ctx, json3, _params) => {
      const def = schema._zod.def;
      const vals = [];
      for (const val of def.values) {
        if (val === void 0) {
          if (ctx.unrepresentable === "throw") {
            throw new Error("Literal `undefined` cannot be represented in JSON Schema");
          } else {
          }
        } else if (typeof val === "bigint") {
          if (ctx.unrepresentable === "throw") {
            throw new Error("BigInt literals cannot be represented in JSON Schema");
          } else {
            vals.push(Number(val));
          }
        } else {
          vals.push(val);
        }
      }
      if (vals.length === 0) {
      } else if (vals.length === 1) {
        const val = vals[0];
        json3.type = val === null ? "null" : typeof val;
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json3.enum = [val];
        } else {
          json3.const = val;
        }
      } else {
        if (vals.every((v) => typeof v === "number"))
          json3.type = "number";
        if (vals.every((v) => typeof v === "string"))
          json3.type = "string";
        if (vals.every((v) => typeof v === "boolean"))
          json3.type = "boolean";
        if (vals.every((v) => v === null))
          json3.type = "null";
        json3.enum = vals;
      }
    };
    nanProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("NaN cannot be represented in JSON Schema");
      }
    };
    templateLiteralProcessor = (schema, _ctx, json3, _params) => {
      const _json = json3;
      const pattern = schema._zod.pattern;
      if (!pattern)
        throw new Error("Pattern not found in template literal");
      _json.type = "string";
      _json.pattern = pattern.source;
    };
    fileProcessor = (schema, _ctx, json3, _params) => {
      const _json = json3;
      const file3 = {
        type: "string",
        format: "binary",
        contentEncoding: "binary"
      };
      const { minimum, maximum, mime } = schema._zod.bag;
      if (minimum !== void 0)
        file3.minLength = minimum;
      if (maximum !== void 0)
        file3.maxLength = maximum;
      if (mime) {
        if (mime.length === 1) {
          file3.contentMediaType = mime[0];
          Object.assign(_json, file3);
        } else {
          Object.assign(_json, file3);
          _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
        }
      } else {
        Object.assign(_json, file3);
      }
    };
    successProcessor = (_schema, _ctx, json3, _params) => {
      json3.type = "boolean";
    };
    customProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Custom types cannot be represented in JSON Schema");
      }
    };
    functionProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Function types cannot be represented in JSON Schema");
      }
    };
    transformProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Transforms cannot be represented in JSON Schema");
      }
    };
    mapProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Map cannot be represented in JSON Schema");
      }
    };
    setProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Set cannot be represented in JSON Schema");
      }
    };
    arrayProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      const { minimum, maximum } = schema._zod.bag;
      if (typeof minimum === "number")
        json3.minItems = minimum;
      if (typeof maximum === "number")
        json3.maxItems = maximum;
      json3.type = "array";
      json3.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
    };
    objectProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      json3.type = "object";
      json3.properties = {};
      const shape = def.shape;
      for (const key in shape) {
        json3.properties[key] = process2(shape[key], ctx, {
          ...params,
          path: [...params.path, "properties", key]
        });
      }
      const allKeys = new Set(Object.keys(shape));
      const requiredKeys = new Set([...allKeys].filter((key) => {
        const v = def.shape[key]._zod;
        if (ctx.io === "input") {
          return v.optin === void 0;
        } else {
          return v.optout === void 0;
        }
      }));
      if (requiredKeys.size > 0) {
        json3.required = Array.from(requiredKeys);
      }
      if (def.catchall?._zod.def.type === "never") {
        json3.additionalProperties = false;
      } else if (!def.catchall) {
        if (ctx.io === "output")
          json3.additionalProperties = false;
      } else if (def.catchall) {
        json3.additionalProperties = process2(def.catchall, ctx, {
          ...params,
          path: [...params.path, "additionalProperties"]
        });
      }
    };
    unionProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      const isExclusive = def.inclusive === false;
      const options = def.options.map((x, i) => process2(x, ctx, {
        ...params,
        path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
      }));
      if (isExclusive) {
        json3.oneOf = options;
      } else {
        json3.anyOf = options;
      }
    };
    intersectionProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      const a = process2(def.left, ctx, {
        ...params,
        path: [...params.path, "allOf", 0]
      });
      const b = process2(def.right, ctx, {
        ...params,
        path: [...params.path, "allOf", 1]
      });
      const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
      const allOf = [
        ...isSimpleIntersection(a) ? a.allOf : [a],
        ...isSimpleIntersection(b) ? b.allOf : [b]
      ];
      json3.allOf = allOf;
    };
    tupleProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      json3.type = "array";
      const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
      const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
      const prefixItems = def.items.map((x, i) => process2(x, ctx, {
        ...params,
        path: [...params.path, prefixPath, i]
      }));
      const rest = def.rest ? process2(def.rest, ctx, {
        ...params,
        path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
      }) : null;
      if (ctx.target === "draft-2020-12") {
        json3.prefixItems = prefixItems;
        if (rest) {
          json3.items = rest;
        }
      } else if (ctx.target === "openapi-3.0") {
        json3.items = {
          anyOf: prefixItems
        };
        if (rest) {
          json3.items.anyOf.push(rest);
        }
        json3.minItems = prefixItems.length;
        if (!rest) {
          json3.maxItems = prefixItems.length;
        }
      } else {
        json3.items = prefixItems;
        if (rest) {
          json3.additionalItems = rest;
        }
      }
      const { minimum, maximum } = schema._zod.bag;
      if (typeof minimum === "number")
        json3.minItems = minimum;
      if (typeof maximum === "number")
        json3.maxItems = maximum;
    };
    recordProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      json3.type = "object";
      const keyType = def.keyType;
      const keyBag = keyType._zod.bag;
      const patterns = keyBag?.patterns;
      if (def.mode === "loose" && patterns && patterns.size > 0) {
        const valueSchema = process2(def.valueType, ctx, {
          ...params,
          path: [...params.path, "patternProperties", "*"]
        });
        json3.patternProperties = {};
        for (const pattern of patterns) {
          json3.patternProperties[pattern.source] = valueSchema;
        }
      } else {
        if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
          json3.propertyNames = process2(def.keyType, ctx, {
            ...params,
            path: [...params.path, "propertyNames"]
          });
        }
        json3.additionalProperties = process2(def.valueType, ctx, {
          ...params,
          path: [...params.path, "additionalProperties"]
        });
      }
      const keyValues = keyType._zod.values;
      if (keyValues) {
        const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
        if (validKeyValues.length > 0) {
          json3.required = validKeyValues;
        }
      }
    };
    nullableProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      const inner = process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      if (ctx.target === "openapi-3.0") {
        seen.ref = def.innerType;
        json3.nullable = true;
      } else {
        json3.anyOf = [inner, { type: "null" }];
      }
    };
    nonoptionalProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
    };
    defaultProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      json3.default = JSON.parse(JSON.stringify(def.defaultValue));
    };
    prefaultProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      if (ctx.io === "input")
        json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
    };
    catchProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      let catchValue;
      try {
        catchValue = def.catchValue(void 0);
      } catch {
        throw new Error("Dynamic catch values are not supported in JSON Schema");
      }
      json3.default = catchValue;
    };
    pipeProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
      process2(innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = innerType;
    };
    readonlyProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      json3.readOnly = true;
    };
    promiseProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
    };
    optionalProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
    };
    lazyProcessor = (schema, ctx, _json, params) => {
      const innerType = schema._zod.innerType;
      process2(innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = innerType;
    };
    allProcessors = {
      string: stringProcessor,
      number: numberProcessor,
      boolean: booleanProcessor,
      bigint: bigintProcessor,
      symbol: symbolProcessor,
      null: nullProcessor,
      undefined: undefinedProcessor,
      void: voidProcessor,
      never: neverProcessor,
      any: anyProcessor,
      unknown: unknownProcessor,
      date: dateProcessor,
      enum: enumProcessor,
      literal: literalProcessor,
      nan: nanProcessor,
      template_literal: templateLiteralProcessor,
      file: fileProcessor,
      success: successProcessor,
      custom: customProcessor,
      function: functionProcessor,
      transform: transformProcessor,
      map: mapProcessor,
      set: setProcessor,
      array: arrayProcessor,
      object: objectProcessor,
      union: unionProcessor,
      intersection: intersectionProcessor,
      tuple: tupleProcessor,
      record: recordProcessor,
      nullable: nullableProcessor,
      nonoptional: nonoptionalProcessor,
      default: defaultProcessor,
      prefault: prefaultProcessor,
      catch: catchProcessor,
      pipe: pipeProcessor,
      readonly: readonlyProcessor,
      promise: promiseProcessor,
      optional: optionalProcessor,
      lazy: lazyProcessor
    };
  }
});

// node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator;
var init_json_schema_generator = __esm({
  "node_modules/zod/v4/core/json-schema-generator.js"() {
    init_json_schema_processors();
    init_to_json_schema();
    JSONSchemaGenerator = class {
      /** @deprecated Access via ctx instead */
      get metadataRegistry() {
        return this.ctx.metadataRegistry;
      }
      /** @deprecated Access via ctx instead */
      get target() {
        return this.ctx.target;
      }
      /** @deprecated Access via ctx instead */
      get unrepresentable() {
        return this.ctx.unrepresentable;
      }
      /** @deprecated Access via ctx instead */
      get override() {
        return this.ctx.override;
      }
      /** @deprecated Access via ctx instead */
      get io() {
        return this.ctx.io;
      }
      /** @deprecated Access via ctx instead */
      get counter() {
        return this.ctx.counter;
      }
      set counter(value) {
        this.ctx.counter = value;
      }
      /** @deprecated Access via ctx instead */
      get seen() {
        return this.ctx.seen;
      }
      constructor(params) {
        let normalizedTarget = params?.target ?? "draft-2020-12";
        if (normalizedTarget === "draft-4")
          normalizedTarget = "draft-04";
        if (normalizedTarget === "draft-7")
          normalizedTarget = "draft-07";
        this.ctx = initializeContext({
          processors: allProcessors,
          target: normalizedTarget,
          ...params?.metadata && { metadata: params.metadata },
          ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
          ...params?.override && { override: params.override },
          ...params?.io && { io: params.io }
        });
      }
      /**
       * Process a schema to prepare it for JSON Schema generation.
       * This must be called before emit().
       */
      process(schema, _params = { path: [], schemaPath: [] }) {
        return process2(schema, this.ctx, _params);
      }
      /**
       * Emit the final JSON Schema after processing.
       * Must call process() first.
       */
      emit(schema, _params) {
        if (_params) {
          if (_params.cycles)
            this.ctx.cycles = _params.cycles;
          if (_params.reused)
            this.ctx.reused = _params.reused;
          if (_params.external)
            this.ctx.external = _params.external;
        }
        extractDefs(this.ctx, schema);
        const result = finalize(this.ctx, schema);
        const { "~standard": _, ...plainResult } = result;
        return plainResult;
      }
    };
  }
});

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
var init_json_schema = __esm({
  "node_modules/zod/v4/core/json-schema.js"() {
  }
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});
var init_core2 = __esm({
  "node_modules/zod/v4/core/index.js"() {
    init_core();
    init_parse();
    init_errors();
    init_schemas();
    init_checks();
    init_versions();
    init_util();
    init_regexes();
    init_locales();
    init_registries();
    init_doc();
    init_api();
    init_to_json_schema();
    init_json_schema_processors();
    init_json_schema_generator();
    init_json_schema();
  }
});

// node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});
var init_checks2 = __esm({
  "node_modules/zod/v4/classic/checks.js"() {
    init_core2();
  }
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm({
  "node_modules/zod/v4/classic/iso.js"() {
    init_core2();
    init_schemas2();
    ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
  }
});

// node_modules/zod/v4/classic/errors.js
var initializer2, ZodError, ZodRealError;
var init_errors2 = __esm({
  "node_modules/zod/v4/classic/errors.js"() {
    init_core2();
    init_core2();
    init_util();
    initializer2 = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue3) => {
            inst.issues.push(issue3);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => {
            inst.issues.push(...issues2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    ZodError = $constructor("ZodError", initializer2);
    ZodRealError = $constructor("ZodError", initializer2, {
      Parent: Error
    });
  }
});

// node_modules/zod/v4/classic/parse.js
var parse2, parseAsync2, safeParse2, safeParseAsync2, encode2, decode2, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse2 = __esm({
  "node_modules/zod/v4/classic/parse.js"() {
    init_core2();
    init_errors2();
    parse2 = /* @__PURE__ */ _parse(ZodRealError);
    parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
    safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
    safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
    encode2 = /* @__PURE__ */ _encode(ZodRealError);
    decode2 = /* @__PURE__ */ _decode(ZodRealError);
    encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
    decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
    safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
    safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
    safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
    safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
  }
});

// node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});
function string2(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function mac2(params) {
  return _mac(ZodMAC, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base642(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodXor, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodExactOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, describe2, meta2, stringbool;
var init_schemas2 = __esm({
  "node_modules/zod/v4/classic/schemas.js"() {
    init_core2();
    init_core2();
    init_json_schema_processors();
    init_to_json_schema();
    init_checks2();
    init_iso();
    init_parse2();
    ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      Object.assign(inst["~standard"], {
        jsonSchema: {
          input: createStandardJSONSchemaMethod(inst, "input"),
          output: createStandardJSONSchemaMethod(inst, "output")
        }
      });
      inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(util_exports.mergeDefs(def, {
          checks: [
            ...def.checks ?? [],
            ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
          ]
        }), {
          parent: true
        });
      };
      inst.with = inst.check;
      inst.clone = (def2, params) => clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta3) => {
        reg.add(inst, meta3);
        return inst;
      });
      inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse2(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.encode = (data, params) => encode2(inst, data, params);
      inst.decode = (data, params) => decode2(inst, data, params);
      inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
      inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
      inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
      inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
      inst.refine = (check3, params) => inst.check(refine(check3, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.exactOptional = () => exactOptional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default2(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch2(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      inst.apply = (fn) => fn(inst);
      return inst;
    });
    _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
      inst.slugify = () => inst.check(_slugify());
    });
    ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime2(params));
      inst.date = (params) => inst.check(date2(params));
      inst.time = (params) => inst.check(time2(params));
      inst.duration = (params) => inst.check(duration2(params));
    });
    ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
      $ZodMAC.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
    });
    ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
    });
    ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
    });
    ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
    });
    ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
    });
    ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
    });
    ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
    });
    ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
    });
    ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
    });
    ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
    });
    ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
    });
    ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObjectJIT.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
      util_exports.defineLazy(inst, "shape", () => {
        return def.shape;
      });
      inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports.extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
        return util_exports.safeExtend(inst, incoming);
      };
      inst.merge = (other) => util_exports.merge(inst, other);
      inst.pick = (mask) => util_exports.pick(inst, mask);
      inst.omit = (mask) => util_exports.omit(inst, mask);
      inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
    });
    ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
      inst.options = def.options;
    });
    ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodXor.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
      inst.options = def.options;
    });
    ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
    });
    ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
    });
    ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
      inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue3) => {
          if (typeof issue3 === "string") {
            payload.issues.push(util_exports.issue(issue3, payload.value, def));
          } else {
            const _issue = issue3;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            payload.issues.push(util_exports.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
      $ZodExactOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
    });
    ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
      inst.in = def.in;
      inst.out = def.out;
    });
    ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
      ZodPipe.init(inst, def);
      $ZodCodec.init(inst, def);
    });
    ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
    });
    ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.getter();
    });
    ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
      $ZodFunction.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
    });
    ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
    });
    describe2 = describe;
    meta2 = meta;
    stringbool = (...args) => _stringbool({
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString
    }, ...args);
  }
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap(map3) {
  config({
    customError: map3
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodIssueCode, ZodFirstPartyTypeKind;
var init_compat = __esm({
  "node_modules/zod/v4/classic/compat.js"() {
    init_core2();
    init_core2();
    ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    /* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  }
});

// node_modules/zod/v4/classic/from-json-schema.js
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path45 = ref.slice(1).split("/").filter(Boolean);
  if (path45.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path45[0] === defsKey) {
    const key = path45[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version3 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version3,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
var z, RECOGNIZED_KEYS;
var init_from_json_schema = __esm({
  "node_modules/zod/v4/classic/from-json-schema.js"() {
    init_registries();
    init_checks2();
    init_iso();
    init_schemas2();
    z = {
      ...schemas_exports2,
      ...checks_exports2,
      iso: iso_exports
    };
    RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
      // Schema identification
      "$schema",
      "$ref",
      "$defs",
      "definitions",
      // Core schema keywords
      "$id",
      "id",
      "$comment",
      "$anchor",
      "$vocabulary",
      "$dynamicRef",
      "$dynamicAnchor",
      // Type
      "type",
      "enum",
      "const",
      // Composition
      "anyOf",
      "oneOf",
      "allOf",
      "not",
      // Object
      "properties",
      "required",
      "additionalProperties",
      "patternProperties",
      "propertyNames",
      "minProperties",
      "maxProperties",
      // Array
      "items",
      "prefixItems",
      "additionalItems",
      "minItems",
      "maxItems",
      "uniqueItems",
      "contains",
      "minContains",
      "maxContains",
      // String
      "minLength",
      "maxLength",
      "pattern",
      "format",
      // Number
      "minimum",
      "maximum",
      "exclusiveMinimum",
      "exclusiveMaximum",
      "multipleOf",
      // Already handled metadata
      "description",
      "default",
      // Content
      "contentEncoding",
      "contentMediaType",
      "contentSchema",
      // Unsupported (error-throwing)
      "unevaluatedItems",
      "unevaluatedProperties",
      "if",
      "then",
      "else",
      "dependentSchemas",
      "dependentRequired",
      // OpenAPI
      "nullable",
      "readOnly"
    ]);
  }
});

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm({
  "node_modules/zod/v4/classic/coerce.js"() {
    init_core2();
    init_schemas2();
  }
});

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});
var init_external = __esm({
  "node_modules/zod/v4/classic/external.js"() {
    init_core2();
    init_schemas2();
    init_checks2();
    init_errors2();
    init_parse2();
    init_compat();
    init_core2();
    init_en();
    init_core2();
    init_json_schema_processors();
    init_from_json_schema();
    init_locales();
    init_iso();
    init_iso();
    init_coerce();
    config(en_default());
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// src/config/schema.ts
var AgentModelChainSchema, FallbackChainsSchema, AgentOverrideConfigSchema, TmuxLayoutSchema, TmuxConfigSchema, PresetSchema, McpNameSchema, BackgroundTaskConfigSchema, UiConfigSchema, SlimCompatConfigSchema, ContextGovernanceConfigSchema, FailoverConfigSchema, PluginConfigSchema;
var init_schema = __esm({
  "src/config/schema.ts"() {
    "use strict";
    init_zod();
    AgentModelChainSchema = external_exports.array(external_exports.string()).min(1);
    FallbackChainsSchema = external_exports.object({
      // New agent names
      "1-task-manager": AgentModelChainSchema.optional(),
      "2-code-search": AgentModelChainSchema.optional(),
      "3-docs-helper": AgentModelChainSchema.optional(),
      "4-architecture-advisor": AgentModelChainSchema.optional(),
      "5-code-fixer": AgentModelChainSchema.optional(),
      "6-ui-designer": AgentModelChainSchema.optional(),
      "7-code-simplicity-reviewer": AgentModelChainSchema.optional(),
      // Legacy names (backward compatibility)
      orchestrator: AgentModelChainSchema.optional(),
      explorer: AgentModelChainSchema.optional(),
      librarian: AgentModelChainSchema.optional(),
      oracle: AgentModelChainSchema.optional(),
      fixer: AgentModelChainSchema.optional(),
      designer: AgentModelChainSchema.optional(),
      "code-simplicity-reviewer": AgentModelChainSchema.optional()
    }).strict();
    AgentOverrideConfigSchema = external_exports.object({
      model: external_exports.string().optional(),
      temperature: external_exports.number().min(0).max(2).optional(),
      variant: external_exports.string().optional().catch(void 0),
      providerID: external_exports.string().optional(),
      options: external_exports.record(external_exports.string(), external_exports.unknown()).optional(),
      apiKey: external_exports.string().optional(),
      baseURL: external_exports.string().optional(),
      skills: external_exports.array(external_exports.string()).optional(),
      // skills this agent can use ("*" = all, "!item" = exclude)
      mcps: external_exports.array(external_exports.string()).optional()
      // MCPs this agent can use ("*" = all, "!item" = exclude)
    });
    TmuxLayoutSchema = external_exports.enum([
      "main-horizontal",
      // Main pane on top, agents stacked below
      "main-vertical",
      // Main pane on left, agents stacked on right
      "tiled",
      // All panes equal size grid
      "even-horizontal",
      // All panes side by side
      "even-vertical"
      // All panes stacked vertically
    ]);
    TmuxConfigSchema = external_exports.object({
      enabled: external_exports.boolean().default(false),
      layout: TmuxLayoutSchema.default("main-vertical"),
      main_pane_size: external_exports.number().min(20).max(80).default(60)
      // percentage for main pane
    });
    PresetSchema = external_exports.record(external_exports.string(), AgentOverrideConfigSchema);
    McpNameSchema = external_exports.enum(["websearch", "context7", "grep_app"]);
    BackgroundTaskConfigSchema = external_exports.object({
      maxConcurrentStarts: external_exports.number().min(1).max(50).default(10)
    });
    UiConfigSchema = external_exports.object({
      dashboard: external_exports.object({
        openOnStart: external_exports.boolean().optional(),
        dockAutoLaunch: external_exports.boolean().optional(),
        autoOpenCooldownMs: external_exports.number().min(1e4).max(24 * 6e4).optional()
      }).optional()
    });
    SlimCompatConfigSchema = external_exports.object({
      enabled: external_exports.boolean().default(false),
      useSlimOrchestratorPrompt: external_exports.boolean().default(false),
      enableCodeSimplicityReviewer: external_exports.boolean().default(false),
      enablePostWriteSimplicityNudge: external_exports.boolean().default(false)
    });
    ContextGovernanceConfigSchema = external_exports.object({
      enabled: external_exports.boolean().default(true),
      toolOutputMaxChars: external_exports.number().min(1200).max(2e5).default(12e3),
      toolOutputHeadChars: external_exports.number().min(200).max(1e5).default(4200),
      toolOutputTailChars: external_exports.number().min(100).max(1e5).default(2800),
      recordTtlMs: external_exports.number().min(1e4).max(864e5).default(12 * 60 * 1e3),
      maxRecordsPerSession: external_exports.number().min(5).max(200).default(30),
      maxInjectedRecords: external_exports.number().min(1).max(20).default(3),
      maxInjectedChars: external_exports.number().min(400).max(2e4).default(2400)
    });
    FailoverConfigSchema = external_exports.object({
      enabled: external_exports.boolean().default(true),
      timeoutMs: external_exports.number().min(1e3).max(12e4).default(15e3),
      chains: FallbackChainsSchema.default({})
    });
    PluginConfigSchema = external_exports.object({
      preset: external_exports.string().optional(),
      presets: external_exports.record(external_exports.string(), PresetSchema).optional(),
      agents: external_exports.record(external_exports.string(), AgentOverrideConfigSchema).optional(),
      provider: external_exports.record(external_exports.string(), external_exports.unknown()).optional(),
      disabled_mcps: external_exports.array(external_exports.string()).optional(),
      tmux: TmuxConfigSchema.optional(),
      ui: UiConfigSchema.optional(),
      background: BackgroundTaskConfigSchema.optional(),
      fallback: FailoverConfigSchema.optional(),
      slimCompat: SlimCompatConfigSchema.optional(),
      contextGovernance: ContextGovernanceConfigSchema.optional()
    });
  }
});

// src/config/loader.ts
var init_loader = __esm({
  "src/config/loader.ts"() {
    "use strict";
    init_config_io();
    init_agent_model_persistence();
    init_schema();
  }
});

// src/config/model-health.ts
import * as fs3 from "node:fs";
import * as os from "node:os";
import * as path3 from "node:path";
function getAuthFileCandidates() {
  const home = os.homedir();
  const candidates = [path3.join(home, ".local", "share", "opencode", "auth.json")];
  if (process.env.XDG_DATA_HOME) {
    candidates.unshift(path3.join(process.env.XDG_DATA_HOME, "opencode", "auth.json"));
  }
  if (process.env.LOCALAPPDATA) {
    candidates.push(path3.join(process.env.LOCALAPPDATA, "opencode", "auth.json"));
  }
  if (process.env.APPDATA) {
    candidates.push(path3.join(process.env.APPDATA, "opencode", "auth.json"));
  }
  return candidates;
}
function readAuthProviders() {
  for (const candidate of getAuthFileCandidates()) {
    try {
      if (!fs3.existsSync(candidate)) continue;
      const raw = fs3.readFileSync(candidate, "utf-8");
      const parsed = JSON.parse(raw);
      return new Set(Object.keys(parsed));
    } catch {
    }
  }
  return /* @__PURE__ */ new Set();
}
function hasProviderEnv(providerID) {
  const envNames = PROVIDER_ENV_MAP[providerID] ?? [];
  return envNames.some((name) => (process.env[name] ?? "").trim().length > 0);
}
function normalizeProviderID2(providerID) {
  return providerID.trim().toLowerCase();
}
function getModelProviderID(model) {
  const slash = model.indexOf("/");
  if (slash === -1) return normalizeProviderID2(model);
  return normalizeProviderID2(model.slice(0, slash));
}
function isStrongProviderAvailable(providerID) {
  const normalized = normalizeProviderID2(providerID);
  const authProviders = readAuthProviders();
  return authProviders.has(normalized) || hasProviderEnv(normalized);
}
function isModelLikelyAvailable(model) {
  const providerID = getModelProviderID(model);
  if (STRONG_PROVIDER_IDS.has(providerID)) {
    return isStrongProviderAvailable(providerID);
  }
  if (OPPORTUNISTIC_PROVIDER_IDS.has(providerID)) {
    return true;
  }
  return true;
}
var STRONG_PROVIDER_IDS, OPPORTUNISTIC_PROVIDER_IDS, PROVIDER_ENV_MAP;
var init_model_health = __esm({
  "src/config/model-health.ts"() {
    "use strict";
    STRONG_PROVIDER_IDS = /* @__PURE__ */ new Set([
      "openai",
      "openrouter",
      "anthropic",
      "google",
      "chutes",
      "kimi-for-coding",
      "zai-coding-plan",
      "github-copilot"
    ]);
    OPPORTUNISTIC_PROVIDER_IDS = /* @__PURE__ */ new Set(["opencode"]);
    PROVIDER_ENV_MAP = {
      openai: ["OPENAI_API_KEY"],
      openrouter: ["OPENROUTER_API_KEY"],
      anthropic: ["ANTHROPIC_API_KEY"],
      google: ["GOOGLE_GENERATIVE_AI_API_KEY"],
      chutes: ["CHUTES_API_KEY"],
      "kimi-for-coding": ["KIMI_API_KEY"],
      "zai-coding-plan": ["ZAI_API_KEY"],
      "github-copilot": ["GITHUB_TOKEN", "GITHUB_COPILOT_TOKEN"]
    };
  }
});

// src/config/utils.ts
var init_utils = __esm({
  "src/config/utils.ts"() {
    "use strict";
    init_constants();
  }
});

// src/config/index.ts
var init_config = __esm({
  "src/config/index.ts"() {
    "use strict";
    init_constants();
    init_loader();
    init_model_health();
    init_schema();
    init_utils();
  }
});

// src/config/agent-mcps.ts
var DEFAULT_AGENT_MCPS;
var init_agent_mcps = __esm({
  "src/config/agent-mcps.ts"() {
    "use strict";
    init_config();
    DEFAULT_AGENT_MCPS = {
      "1-task-manager": ["websearch"],
      "2-code-search": [],
      "3-docs-helper": ["websearch", "context7", "grep_app"],
      "4-architecture-advisor": [],
      "5-code-fixer": [],
      "6-ui-designer": [],
      "7-code-simplicity-reviewer": []
    };
  }
});

// src/cli/custom-skills.ts
import {
  copyFileSync,
  existsSync as existsSync5,
  mkdirSync as mkdirSync4,
  readdirSync,
  statSync
} from "node:fs";
import { homedir as homedir3 } from "node:os";
import { dirname as dirname3, join as join5 } from "node:path";
import { fileURLToPath } from "node:url";
function getUserConfigDir() {
  return process.env.XDG_CONFIG_HOME || join5(homedir3(), ".config");
}
function getCustomSkillsDir() {
  return join5(getUserConfigDir(), "opencode", "skills");
}
function copyDirRecursive(src, dest) {
  if (!existsSync5(dest)) {
    mkdirSync4(dest, { recursive: true });
  }
  const entries = readdirSync(src);
  for (const entry2 of entries) {
    const srcPath = join5(src, entry2);
    const destPath = join5(dest, entry2);
    const stat = statSync(srcPath);
    if (stat.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      const destDir = dirname3(destPath);
      if (!existsSync5(destDir)) {
        mkdirSync4(destDir, { recursive: true });
      }
      copyFileSync(srcPath, destPath);
    }
  }
}
function installCustomSkill(skill) {
  try {
    const packageRoot = fileURLToPath(new URL("../..", import.meta.url));
    const sourcePath = join5(packageRoot, skill.sourcePath);
    const targetPath = join5(getCustomSkillsDir(), skill.name);
    if (!existsSync5(sourcePath)) {
      console.error(`Custom skill source not found: ${sourcePath}`);
      return false;
    }
    copyDirRecursive(sourcePath, targetPath);
    return true;
  } catch (error92) {
    console.error(`Failed to install custom skill: ${skill.name}`, error92);
    return false;
  }
}
var CUSTOM_SKILLS;
var init_custom_skills = __esm({
  "src/cli/custom-skills.ts"() {
    "use strict";
    CUSTOM_SKILLS = [
      {
        name: "cartography",
        description: "Repository understanding and hierarchical codemap generation",
        allowedAgents: ["1-task-manager", "orchestrator"],
        sourcePath: "src/skills/cartography"
      }
    ];
  }
});

// src/cli/skills.ts
import { spawnSync } from "node:child_process";
function installSkill(skill) {
  const args = [
    "skills",
    "add",
    skill.repo,
    "--skill",
    skill.skillName,
    "-a",
    "opencode",
    "-y",
    "--global"
  ];
  try {
    const result = spawnSync("npx", args, { stdio: "inherit" });
    if (result.status !== 0) {
      return false;
    }
    if (skill.postInstallCommands && skill.postInstallCommands.length > 0) {
      console.log(`Running post-install commands for ${skill.name}...`);
      for (const cmd of skill.postInstallCommands) {
        console.log(`> ${cmd}`);
        const [command, ...cmdArgs] = cmd.split(" ");
        const cmdResult = spawnSync(command, cmdArgs, { stdio: "inherit" });
        if (cmdResult.status !== 0) {
          console.warn(`Post-install command failed: ${cmd}`);
        }
      }
    }
    return true;
  } catch (error92) {
    console.error(`Failed to install skill: ${skill.name}`, error92);
    return false;
  }
}
var RECOMMENDED_SKILLS;
var init_skills = __esm({
  "src/cli/skills.ts"() {
    "use strict";
    init_custom_skills();
    RECOMMENDED_SKILLS = [
      {
        name: "simplify",
        repo: "https://github.com/brianlovin/claude-config",
        skillName: "simplify",
        allowedAgents: ["1-task-manager", "orchestrator"],
        description: "YAGNI code simplification expert"
      },
      {
        name: "agent-browser",
        repo: "https://github.com/vercel-labs/agent-browser",
        skillName: "agent-browser",
        allowedAgents: ["6-ui-designer", "designer"],
        description: "High-performance browser automation",
        postInstallCommands: [
          "npm install -g agent-browser",
          "agent-browser install"
        ]
      }
    ];
  }
});

// src/cli/providers.ts
function normalizeAgentName2(agentName) {
  return AGENT_ALIASES[agentName] ?? agentName;
}
function normalizeAgentsRecord(agents) {
  const normalized = {};
  for (const [name, config3] of Object.entries(agents)) {
    normalized[normalizeAgentName2(name)] = config3;
  }
  return normalized;
}
function normalizeFallbackChains(chains) {
  const normalized = {};
  for (const [name, chain] of Object.entries(chains)) {
    normalized[normalizeAgentName2(name)] = chain;
  }
  return normalized;
}
function normalizeGeneratedConfig(config3) {
  const presets = config3.presets;
  if (presets) {
    for (const [presetName, preset] of Object.entries(presets)) {
      presets[presetName] = normalizeAgentsRecord(preset);
    }
  }
  const fallback = config3.fallback;
  if (fallback?.chains) {
    fallback.chains = normalizeFallbackChains(fallback.chains);
  }
}
function generateAntigravityMixedPreset(config3, existingPreset) {
  const result = existingPreset ? { ...existingPreset } : {};
  const createAgentConfig = (agentName, modelInfo) => {
    const normalizedAgentName = normalizeAgentName2(agentName);
    const isOrchestrator = normalizedAgentName === "1-task-manager";
    const skills = isOrchestrator ? ["*"] : RECOMMENDED_SKILLS.filter(
      (s) => s.allowedAgents.includes("*") || s.allowedAgents.includes(agentName)
    ).map((s) => s.skillName);
    if ((agentName === "designer" || normalizedAgentName === "6-ui-designer") && !skills.includes("agent-browser")) {
      skills.push("agent-browser");
    }
    return {
      model: modelInfo.model,
      variant: modelInfo.variant,
      skills,
      mcps: DEFAULT_AGENT_MCPS[normalizedAgentName] ?? []
    };
  };
  const antigravityFlash = {
    model: "google/antigravity-gemini-3-flash"
  };
  const chutesPrimary = config3.selectedChutesPrimaryModel ?? MODEL_MAPPINGS.chutes.orchestrator.model;
  const chutesSupport = config3.selectedChutesSecondaryModel ?? MODEL_MAPPINGS.chutes.explorer.model;
  if (config3.hasKimi) {
    result.orchestrator = createAgentConfig(
      "orchestrator",
      MODEL_MAPPINGS.kimi.orchestrator
    );
  } else if (config3.hasChutes) {
    result.orchestrator = createAgentConfig("orchestrator", {
      model: chutesPrimary
    });
  } else if (!result.orchestrator) {
    result.orchestrator = createAgentConfig(
      "orchestrator",
      MODEL_MAPPINGS.antigravity.orchestrator
    );
  }
  if (config3.hasOpenAI) {
    result.oracle = createAgentConfig("oracle", MODEL_MAPPINGS.openai.oracle);
  } else if (!result.oracle) {
    result.oracle = createAgentConfig(
      "oracle",
      MODEL_MAPPINGS.antigravity.oracle
    );
  }
  result.explorer = createAgentConfig("explorer", {
    ...antigravityFlash,
    variant: "low"
  });
  if (config3.hasChutes) {
    result.librarian = createAgentConfig("librarian", {
      model: chutesSupport,
      variant: "low"
    });
    result.designer = createAgentConfig("designer", {
      model: chutesPrimary,
      variant: "medium"
    });
  } else {
    result.librarian = createAgentConfig("librarian", {
      ...antigravityFlash,
      variant: "low"
    });
    result.designer = createAgentConfig("designer", {
      ...antigravityFlash,
      variant: "medium"
    });
  }
  if (config3.hasOpenAI) {
    result.fixer = createAgentConfig("fixer", {
      ...MODEL_MAPPINGS.openai.oracle,
      variant: "low"
    });
  } else if (config3.hasChutes) {
    result.fixer = createAgentConfig("fixer", {
      model: chutesSupport,
      variant: "low"
    });
  } else {
    result.fixer = createAgentConfig("fixer", {
      ...antigravityFlash,
      variant: "low"
    });
  }
  return normalizeAgentsRecord(result);
}
function generateLiteConfig(installConfig) {
  const config3 = {
    preset: "zen-free",
    presets: {},
    slimCompat: {
      enabled: true,
      // Keep Miya's universal orchestrator prompt by default.
      useSlimOrchestratorPrompt: false,
      enableCodeSimplicityReviewer: true,
      enablePostWriteSimplicityNudge: true
    }
  };
  let activePreset = "zen-free";
  if (installConfig.hasAntigravity && installConfig.hasKimi && installConfig.hasOpenAI) {
    activePreset = "antigravity-mixed-both";
  } else if (installConfig.hasAntigravity && installConfig.hasKimi) {
    activePreset = "antigravity-mixed-kimi";
  } else if (installConfig.hasAntigravity && installConfig.hasOpenAI) {
    activePreset = "antigravity-mixed-openai";
  } else if (installConfig.hasAntigravity) {
    activePreset = "antigravity";
  } else if (installConfig.hasKimi) {
    activePreset = "kimi";
  } else if (installConfig.hasOpenAI) {
    activePreset = "openai";
  } else if (installConfig.hasAnthropic) {
    activePreset = "anthropic";
  } else if (installConfig.hasCopilot) {
    activePreset = "copilot";
  } else if (installConfig.hasZaiPlan) {
    activePreset = "zai-plan";
  } else if (installConfig.hasChutes) {
    activePreset = "chutes";
  }
  config3.preset = activePreset;
  const createAgentConfig = (agentName, modelInfo) => {
    const normalizedAgentName = normalizeAgentName2(agentName);
    const isOrchestrator = normalizedAgentName === "1-task-manager";
    const skills = isOrchestrator ? ["*"] : RECOMMENDED_SKILLS.filter(
      (s) => s.allowedAgents.includes("*") || s.allowedAgents.includes(agentName)
    ).map((s) => s.skillName);
    if ((agentName === "designer" || normalizedAgentName === "6-ui-designer") && !skills.includes("agent-browser")) {
      skills.push("agent-browser");
    }
    return {
      model: modelInfo.model,
      variant: modelInfo.variant,
      skills,
      mcps: DEFAULT_AGENT_MCPS[normalizedAgentName] ?? []
    };
  };
  if (installConfig.dynamicModelPlan) {
    const dynamicPreset = Object.fromEntries(
      Object.entries(installConfig.dynamicModelPlan.agents).map(
        ([agentName, assignment]) => [
          agentName,
          createAgentConfig(
            agentName,
            assignment
          )
        ]
      )
    );
    config3.preset = "dynamic";
    config3.presets.dynamic = normalizeAgentsRecord(dynamicPreset);
    config3.fallback = {
      enabled: true,
      timeoutMs: 15e3,
      chains: normalizeFallbackChains(installConfig.dynamicModelPlan.chains)
    };
    if (installConfig.hasTmux) {
      config3.tmux = {
        enabled: true,
        layout: "main-vertical",
        main_pane_size: 60
      };
    }
    normalizeGeneratedConfig(config3);
    return config3;
  }
  const applyOpenCodeFreeAssignments = (presetAgents, hasExternalProviders) => {
    if (!installConfig.useOpenCodeFreeModels) return;
    const primaryModel = installConfig.selectedOpenCodePrimaryModel;
    const secondaryModel = installConfig.selectedOpenCodeSecondaryModel ?? primaryModel;
    if (!primaryModel || !secondaryModel) return;
    const setAgent = (agentName, model) => {
      presetAgents[agentName] = createAgentConfig(agentName, { model });
    };
    if (!hasExternalProviders) {
      setAgent("orchestrator", primaryModel);
      setAgent("oracle", primaryModel);
      setAgent("designer", primaryModel);
    }
    setAgent("librarian", secondaryModel);
    setAgent("explorer", secondaryModel);
    setAgent("fixer", secondaryModel);
  };
  const applyChutesAssignments = (presetAgents) => {
    if (!installConfig.hasChutes) return;
    const hasExternalProviders = installConfig.hasKimi || installConfig.hasOpenAI || installConfig.hasAntigravity;
    if (hasExternalProviders && activePreset !== "chutes") return;
    const primaryModel = installConfig.selectedChutesPrimaryModel;
    const secondaryModel = installConfig.selectedChutesSecondaryModel ?? primaryModel;
    if (!primaryModel || !secondaryModel) return;
    const setAgent = (agentName, model) => {
      presetAgents[agentName] = createAgentConfig(agentName, { model });
    };
    setAgent("orchestrator", primaryModel);
    setAgent("oracle", primaryModel);
    setAgent("designer", primaryModel);
    setAgent("librarian", secondaryModel);
    setAgent("explorer", secondaryModel);
    setAgent("fixer", secondaryModel);
  };
  const dedupeModels = (models) => {
    const seen = /* @__PURE__ */ new Set();
    const result = [];
    for (const model of models) {
      if (!model || seen.has(model)) continue;
      seen.add(model);
      result.push(model);
    }
    return result;
  };
  const getOpenCodeFallbackForAgent = (agentName) => {
    if (!installConfig.useOpenCodeFreeModels) return void 0;
    const isSupport = agentName === "explorer" || agentName === "librarian" || agentName === "fixer";
    if (isSupport) {
      return installConfig.selectedOpenCodeSecondaryModel ?? installConfig.selectedOpenCodePrimaryModel;
    }
    return installConfig.selectedOpenCodePrimaryModel;
  };
  const getChutesFallbackForAgent = (agentName) => {
    if (!installConfig.hasChutes) return void 0;
    const isSupport = agentName === "explorer" || agentName === "librarian" || agentName === "fixer";
    if (isSupport) {
      return installConfig.selectedChutesSecondaryModel ?? installConfig.selectedChutesPrimaryModel ?? MODEL_MAPPINGS.chutes[agentName].model;
    }
    return installConfig.selectedChutesPrimaryModel ?? MODEL_MAPPINGS.chutes[agentName].model;
  };
  const attachFallbackConfig = (presetAgents) => {
    const chains = {};
    for (const agentName of AGENT_NAMES) {
      const currentModel = presetAgents[agentName]?.model;
      const chain = dedupeModels([
        currentModel,
        installConfig.hasOpenAI ? MODEL_MAPPINGS.openai[agentName].model : void 0,
        installConfig.hasAnthropic ? MODEL_MAPPINGS.anthropic[agentName].model : void 0,
        installConfig.hasCopilot ? MODEL_MAPPINGS.copilot[agentName].model : void 0,
        installConfig.hasZaiPlan ? MODEL_MAPPINGS["zai-plan"][agentName].model : void 0,
        installConfig.hasKimi ? MODEL_MAPPINGS.kimi[agentName].model : void 0,
        installConfig.hasAntigravity ? MODEL_MAPPINGS.antigravity[agentName].model : void 0,
        getChutesFallbackForAgent(agentName),
        getOpenCodeFallbackForAgent(agentName),
        MODEL_MAPPINGS["zen-free"][agentName].model
      ]);
      if (chain.length > 0) {
        chains[agentName] = chain;
      }
    }
    config3.fallback = {
      enabled: true,
      timeoutMs: 15e3,
      chains
    };
  };
  const buildPreset = (mappingName) => {
    const mapping = MODEL_MAPPINGS[mappingName];
    return Object.fromEntries(
      Object.entries(mapping).map(([agentName, modelInfo]) => {
        let activeModelInfo = { ...modelInfo };
        if (activePreset === "kimi" && installConfig.hasOpenAI && agentName === "oracle") {
          activeModelInfo = { ...MODEL_MAPPINGS.openai.oracle };
        }
        return [agentName, createAgentConfig(agentName, activeModelInfo)];
      })
    );
  };
  if (activePreset === "antigravity-mixed-both" || activePreset === "antigravity-mixed-kimi" || activePreset === "antigravity-mixed-openai") {
    config3.presets[activePreset] = generateAntigravityMixedPreset(installConfig);
    applyOpenCodeFreeAssignments(
      config3.presets[activePreset],
      installConfig.hasKimi || installConfig.hasOpenAI || installConfig.hasAnthropic || installConfig.hasCopilot || installConfig.hasZaiPlan || installConfig.hasAntigravity || installConfig.hasChutes === true
    );
    applyChutesAssignments(
      config3.presets[activePreset]
    );
    attachFallbackConfig(
      config3.presets[activePreset]
    );
  } else {
    config3.presets[activePreset] = buildPreset(activePreset);
    applyOpenCodeFreeAssignments(
      config3.presets[activePreset],
      installConfig.hasKimi || installConfig.hasOpenAI || installConfig.hasAnthropic || installConfig.hasCopilot || installConfig.hasZaiPlan || installConfig.hasAntigravity || installConfig.hasChutes === true
    );
    applyChutesAssignments(
      config3.presets[activePreset]
    );
    attachFallbackConfig(
      config3.presets[activePreset]
    );
  }
  if (installConfig.hasTmux) {
    config3.tmux = {
      enabled: true,
      layout: "main-vertical",
      main_pane_size: 60
    };
  }
  normalizeGeneratedConfig(config3);
  return config3;
}
var AGENT_NAMES, MODEL_MAPPINGS;
var init_providers = __esm({
  "src/cli/providers.ts"() {
    "use strict";
    init_agent_mcps();
    init_constants();
    init_skills();
    AGENT_NAMES = [
      "orchestrator",
      "oracle",
      "designer",
      "explorer",
      "librarian",
      "fixer"
    ];
    MODEL_MAPPINGS = {
      kimi: {
        orchestrator: { model: "kimi-for-coding/k2p5" },
        oracle: { model: "kimi-for-coding/k2p5", variant: "high" },
        librarian: { model: "kimi-for-coding/k2p5", variant: "low" },
        explorer: { model: "kimi-for-coding/k2p5", variant: "low" },
        designer: { model: "kimi-for-coding/k2p5", variant: "medium" },
        fixer: { model: "kimi-for-coding/k2p5", variant: "low" }
      },
      openai: {
        orchestrator: { model: "openai/gpt-5.3-codex" },
        oracle: { model: "openai/gpt-5.3-codex", variant: "high" },
        librarian: { model: "openai/gpt-5.1-codex-mini", variant: "low" },
        explorer: { model: "openai/gpt-5.1-codex-mini", variant: "low" },
        designer: { model: "openai/gpt-5.1-codex-mini", variant: "medium" },
        fixer: { model: "openai/gpt-5.1-codex-mini", variant: "low" }
      },
      anthropic: {
        orchestrator: { model: "anthropic/claude-opus-4-6" },
        oracle: { model: "anthropic/claude-opus-4-6", variant: "high" },
        librarian: { model: "anthropic/claude-sonnet-4-5", variant: "low" },
        explorer: { model: "anthropic/claude-haiku-4-5", variant: "low" },
        designer: { model: "anthropic/claude-sonnet-4-5", variant: "medium" },
        fixer: { model: "anthropic/claude-sonnet-4-5", variant: "low" }
      },
      copilot: {
        orchestrator: { model: "github-copilot/grok-code-fast-1" },
        oracle: { model: "github-copilot/grok-code-fast-1", variant: "high" },
        librarian: { model: "github-copilot/grok-code-fast-1", variant: "low" },
        explorer: { model: "github-copilot/grok-code-fast-1", variant: "low" },
        designer: { model: "github-copilot/grok-code-fast-1", variant: "medium" },
        fixer: { model: "github-copilot/grok-code-fast-1", variant: "low" }
      },
      "zai-plan": {
        orchestrator: { model: "zai-coding-plan/glm-4.7" },
        oracle: { model: "zai-coding-plan/glm-4.7", variant: "high" },
        librarian: { model: "zai-coding-plan/glm-4.7", variant: "low" },
        explorer: { model: "zai-coding-plan/glm-4.7", variant: "low" },
        designer: { model: "zai-coding-plan/glm-4.7", variant: "medium" },
        fixer: { model: "zai-coding-plan/glm-4.7", variant: "low" }
      },
      antigravity: {
        orchestrator: { model: "google/antigravity-gemini-3-flash" },
        oracle: { model: "google/antigravity-gemini-3-pro" },
        librarian: {
          model: "google/antigravity-gemini-3-flash",
          variant: "low"
        },
        explorer: {
          model: "google/antigravity-gemini-3-flash",
          variant: "low"
        },
        designer: {
          model: "google/antigravity-gemini-3-flash",
          variant: "medium"
        },
        fixer: { model: "google/antigravity-gemini-3-flash", variant: "low" }
      },
      chutes: {
        orchestrator: { model: "chutes/kimi-k2.5" },
        oracle: { model: "chutes/kimi-k2.5", variant: "high" },
        librarian: { model: "chutes/minimax-m2.1", variant: "low" },
        explorer: { model: "chutes/minimax-m2.1", variant: "low" },
        designer: { model: "chutes/kimi-k2.5", variant: "medium" },
        fixer: { model: "chutes/minimax-m2.1", variant: "low" }
      },
      "zen-free": {
        orchestrator: { model: "opencode/big-pickle" },
        oracle: { model: "opencode/big-pickle", variant: "high" },
        librarian: { model: "opencode/big-pickle", variant: "low" },
        explorer: { model: "opencode/big-pickle", variant: "low" },
        designer: { model: "opencode/big-pickle", variant: "medium" },
        fixer: { model: "opencode/big-pickle", variant: "low" }
      }
    };
  }
});

// src/cli/config-io.ts
import {
  copyFileSync as copyFileSync2,
  existsSync as existsSync6,
  readFileSync as readFileSync4,
  renameSync as renameSync2,
  statSync as statSync2,
  writeFileSync as writeFileSync3
} from "node:fs";
function stripJsonComments(json3) {
  const commentPattern = /\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g;
  const trailingCommaPattern = /\\"|"(?:\\"|[^"])*"|(,)(\s*[}\]])/g;
  return json3.replace(
    commentPattern,
    (match, commentGroup) => commentGroup ? "" : match
  ).replace(
    trailingCommaPattern,
    (match, comma, closing) => comma ? closing : match
  );
}
function parseConfigFile(path45) {
  try {
    if (!existsSync6(path45)) return { config: null };
    const stat = statSync2(path45);
    if (stat.size === 0) return { config: null };
    const content = readFileSync4(path45, "utf-8");
    if (content.trim().length === 0) return { config: null };
    return { config: JSON.parse(stripJsonComments(content)) };
  } catch (err) {
    return { config: null, error: String(err) };
  }
}
function parseConfig(path45) {
  const result = parseConfigFile(path45);
  if (result.config || result.error) return result;
  if (path45.endsWith(".json")) {
    const jsoncPath = path45.replace(/\.json$/, ".jsonc");
    return parseConfigFile(jsoncPath);
  }
  return { config: null };
}
function writeConfig(configPath, config3) {
  if (configPath.endsWith(".jsonc")) {
    console.warn(
      "[config-manager] Writing to .jsonc file - comments will not be preserved"
    );
  }
  const tmpPath = `${configPath}.tmp`;
  const bakPath = `${configPath}.bak`;
  const content = `${JSON.stringify(config3, null, 2)}
`;
  if (existsSync6(configPath)) {
    copyFileSync2(configPath, bakPath);
  }
  writeFileSync3(tmpPath, content);
  renameSync2(tmpPath, configPath);
}
async function addPluginToOpenCodeConfig() {
  try {
    ensureConfigDir();
  } catch (err) {
    return {
      success: false,
      configPath: getConfigDir(),
      error: `Failed to create config directory: ${err}`
    };
  }
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error92 } = parseConfig(configPath);
    if (error92) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error92}`
      };
    }
    const config3 = parsedConfig ?? {};
    const plugins = config3.plugin ?? [];
    const filteredPlugins = plugins.filter(
      (p) => p !== PACKAGE_NAME && !p.startsWith(`${PACKAGE_NAME}@`)
    );
    filteredPlugins.push(PACKAGE_NAME);
    config3.plugin = filteredPlugins;
    writeConfig(configPath, config3);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to update opencode config: ${err}`
    };
  }
}
function writeLiteConfig(installConfig) {
  const configPath = getLiteConfig();
  try {
    ensureConfigDir();
    const config3 = generateLiteConfig(installConfig);
    const tmpPath = `${configPath}.tmp`;
    const bakPath = `${configPath}.bak`;
    const content = `${JSON.stringify(config3, null, 2)}
`;
    if (existsSync6(configPath)) {
      copyFileSync2(configPath, bakPath);
    }
    writeFileSync3(tmpPath, content);
    renameSync2(tmpPath, configPath);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to write lite config: ${err}`
    };
  }
}
function disableDefaultAgents() {
  const configPath = getExistingConfigPath();
  try {
    ensureConfigDir();
    const { config: parsedConfig, error: error92 } = parseConfig(configPath);
    if (error92) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error92}`
      };
    }
    const config3 = parsedConfig ?? {};
    const agent = config3.agent ?? {};
    agent.explore = { disable: true };
    agent.general = { disable: true };
    config3.agent = agent;
    writeConfig(configPath, config3);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to disable default agents: ${err}`
    };
  }
}
function addAntigravityPlugin() {
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error92 } = parseConfig(configPath);
    if (error92) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error92}`
      };
    }
    const config3 = parsedConfig ?? {};
    const plugins = config3.plugin ?? [];
    const pluginName = "opencode-antigravity-auth@latest";
    if (!plugins.includes(pluginName)) {
      plugins.push(pluginName);
    }
    config3.plugin = plugins;
    writeConfig(configPath, config3);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to add antigravity plugin: ${err}`
    };
  }
}
function addGoogleProvider() {
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error92 } = parseConfig(configPath);
    if (error92) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error92}`
      };
    }
    const config3 = parsedConfig ?? {};
    const providers = config3.provider ?? {};
    providers.google = {
      models: {
        "antigravity-gemini-3-pro": {
          name: "Gemini 3 Pro (Antigravity)",
          limit: { context: 1048576, output: 65535 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            low: { thinkingLevel: "low" },
            high: { thinkingLevel: "high" }
          }
        },
        "antigravity-gemini-3-flash": {
          name: "Gemini 3 Flash (Antigravity)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            minimal: { thinkingLevel: "minimal" },
            low: { thinkingLevel: "low" },
            medium: { thinkingLevel: "medium" },
            high: { thinkingLevel: "high" }
          }
        },
        "antigravity-claude-sonnet-4-5": {
          name: "Claude Sonnet 4.5 (Antigravity)",
          limit: { context: 2e5, output: 64e3 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "antigravity-claude-sonnet-4-5-thinking": {
          name: "Claude Sonnet 4.5 Thinking (Antigravity)",
          limit: { context: 2e5, output: 64e3 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            low: { thinkingConfig: { thinkingBudget: 8192 } },
            max: { thinkingConfig: { thinkingBudget: 32768 } }
          }
        },
        "antigravity-claude-opus-4-5-thinking": {
          name: "Claude Opus 4.5 Thinking (Antigravity)",
          limit: { context: 2e5, output: 64e3 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            low: { thinkingConfig: { thinkingBudget: 8192 } },
            max: { thinkingConfig: { thinkingBudget: 32768 } }
          }
        },
        "gemini-2.5-flash": {
          name: "Gemini 2.5 Flash (Gemini CLI)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "gemini-2.5-pro": {
          name: "Gemini 2.5 Pro (Gemini CLI)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "gemini-3-flash-preview": {
          name: "Gemini 3 Flash Preview (Gemini CLI)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "gemini-3-pro-preview": {
          name: "Gemini 3 Pro Preview (Gemini CLI)",
          limit: { context: 1048576, output: 65535 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        }
      }
    };
    config3.provider = providers;
    writeConfig(configPath, config3);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to add google provider: ${err}`
    };
  }
}
function addChutesProvider() {
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error92 } = parseConfig(configPath);
    if (error92) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error92}`
      };
    }
    const config3 = parsedConfig ?? {};
    const providers = config3.provider ?? {};
    providers.chutes = {
      npm: "@ai-sdk/openai-compatible",
      name: "Chutes",
      options: {
        baseURL: "https://llm.chutes.ai/v1",
        apiKey: "{env:CHUTES_API_KEY}"
      }
    };
    config3.provider = providers;
    writeConfig(configPath, config3);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to add chutes provider: ${err}`
    };
  }
}
function detectCurrentConfig() {
  const result = {
    isInstalled: false,
    hasKimi: false,
    hasOpenAI: false,
    hasAnthropic: false,
    hasCopilot: false,
    hasZaiPlan: false,
    hasAntigravity: false,
    hasChutes: false,
    hasOpencodeZen: false,
    hasTmux: false
  };
  const { config: config3 } = parseConfig(getExistingConfigPath());
  if (!config3) return result;
  const plugins = config3.plugin ?? [];
  result.isInstalled = plugins.some((p) => p.startsWith(PACKAGE_NAME));
  result.hasAntigravity = plugins.some(
    (p) => p.startsWith("opencode-antigravity-auth")
  );
  const providers = config3.provider;
  result.hasKimi = !!providers?.kimi;
  result.hasAnthropic = !!providers?.anthropic;
  result.hasCopilot = !!providers?.["github-copilot"];
  result.hasZaiPlan = !!providers?.["zai-coding-plan"];
  result.hasChutes = !!providers?.chutes;
  if (providers?.google) result.hasAntigravity = true;
  const { config: liteConfig } = parseConfig(getExistingLiteConfigPath());
  if (liteConfig && typeof liteConfig === "object") {
    const configObj = liteConfig;
    const presetName = configObj.preset;
    const presets = configObj.presets;
    const agents = presets?.[presetName];
    if (agents) {
      const models = Object.values(agents).map((a) => a?.model).filter(Boolean);
      result.hasOpenAI = models.some((m) => m?.startsWith("openai/"));
      result.hasAnthropic = models.some((m) => m?.startsWith("anthropic/"));
      result.hasCopilot = models.some((m) => m?.startsWith("github-copilot/"));
      result.hasZaiPlan = models.some((m) => m?.startsWith("zai-coding-plan/"));
      result.hasOpencodeZen = models.some((m) => m?.startsWith("opencode/"));
      if (models.some((m) => m?.startsWith("google/"))) {
        result.hasAntigravity = true;
      }
      if (models.some((m) => m?.startsWith("chutes/"))) {
        result.hasChutes = true;
      }
    }
    if (configObj.tmux && typeof configObj.tmux === "object") {
      const tmuxConfig = configObj.tmux;
      result.hasTmux = tmuxConfig.enabled === true;
    }
  }
  return result;
}
var PACKAGE_NAME;
var init_config_io = __esm({
  "src/cli/config-io.ts"() {
    "use strict";
    init_paths();
    init_providers();
    PACKAGE_NAME = "miya";
  }
});

// src/settings/registry.ts
function entry(input) {
  return {
    ...input,
    requiresEvidence: input.risk === "HIGH"
  };
}
function cloneValue(value) {
  return JSON.parse(JSON.stringify(value));
}
function keySegments(key) {
  return key.split(".").map((segment) => segment.trim()).filter((segment) => segment.length > 0);
}
function getNestedValue(root, key) {
  if (!root || typeof root !== "object") return void 0;
  const segments = keySegments(key);
  let current = root;
  for (const segment of segments) {
    if (!current || typeof current !== "object") return void 0;
    current = current[segment];
  }
  return current;
}
function setNestedValue(root, key, value) {
  const segments = keySegments(key);
  if (segments.length === 0) return;
  let current = root;
  for (let index = 0; index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const next = current[segment];
    if (!next || typeof next !== "object" || Array.isArray(next)) {
      current[segment] = {};
    }
    current = current[segment];
  }
  current[segments[segments.length - 1]] = value;
}
function leafSchema(entryValue) {
  if (entryValue.type === "boolean") return { type: "boolean" };
  if (entryValue.type === "integer") {
    const schema = { type: "integer" };
    if (typeof entryValue.minimum === "number") schema.minimum = entryValue.minimum;
    if (typeof entryValue.maximum === "number") schema.maximum = entryValue.maximum;
    return schema;
  }
  if (entryValue.type === "string") return { type: "string" };
  if (entryValue.type === "enum") {
    return { type: "string", enum: [...entryValue.enumValues ?? []] };
  }
  if (entryValue.type === "array") return { type: "array" };
  return { type: "object" };
}
function setSchemaAtPath(root, key, schema) {
  const segments = keySegments(key);
  if (segments.length === 0) return;
  let current = root;
  for (let index = 0; index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const existing = current[segment];
    if (!existing || typeof existing !== "object") {
      current[segment] = {
        type: "object",
        additionalProperties: true,
        properties: {}
      };
    }
    const node = current[segment];
    if (!node.properties || typeof node.properties !== "object") {
      node.properties = {};
    }
    current = node.properties;
  }
  current[segments[segments.length - 1]] = schema;
}
function getSettingEntry(key) {
  return REGISTRY_MAP.get(key);
}
function listSettingEntries() {
  return SETTINGS_REGISTRY.map((item) => cloneValue(item));
}
function buildDefaultConfig() {
  const config3 = {};
  for (const item of SETTINGS_REGISTRY) {
    setNestedValue(config3, item.key, cloneValue(item.defaultValue));
  }
  return config3;
}
function buildRegistryDocument() {
  return {
    version: 1,
    generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    settings: listSettingEntries()
  };
}
function buildSchemaDocument() {
  const rootProperties = {};
  for (const item of SETTINGS_REGISTRY) {
    setSchemaAtPath(rootProperties, item.key, leafSchema(item));
  }
  return {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    title: "Miya Config",
    type: "object",
    additionalProperties: true,
    properties: rootProperties
  };
}
var SETTINGS_REGISTRY, REGISTRY_MAP;
var init_registry = __esm({
  "src/settings/registry.ts"() {
    "use strict";
    SETTINGS_REGISTRY = [
      entry({
        key: "ui.language",
        type: "enum",
        enumValues: ["zh-CN"],
        defaultValue: "zh-CN",
        risk: "LOW",
        description: "\u63A7\u5236\u53F0\u8BED\u8A00\u3002"
      }),
      entry({
        key: "ui.theme",
        type: "enum",
        enumValues: ["dark", "light", "system"],
        defaultValue: "dark",
        risk: "LOW",
        description: "\u63A7\u5236\u53F0\u4E3B\u9898\u3002"
      }),
      entry({
        key: "ui.dashboard.openOnStart",
        type: "boolean",
        defaultValue: true,
        risk: "LOW",
        description: "\u542F\u52A8\u65F6\u81EA\u52A8\u6253\u5F00\u63A7\u5236\u53F0\u3002"
      }),
      entry({
        key: "ui.dashboard.dockAutoLaunch",
        type: "boolean",
        defaultValue: false,
        risk: "LOW",
        description: "\u542F\u52A8\u65F6\u81EA\u52A8\u62C9\u8D77 Windows Dock\uFF08\u9ED8\u8BA4\u5173\u95ED\uFF0C\u907F\u514D\u53CD\u590D\u62C9\u8D77\uFF09\u3002"
      }),
      entry({
        key: "ui.dashboard.autoOpenCooldownMs",
        type: "integer",
        minimum: 1e4,
        maximum: 144e4,
        defaultValue: 12e4,
        risk: "LOW",
        description: "\u81EA\u52A8\u6253\u5F00\u63A7\u5236\u53F0\u7684\u8DE8\u8FDB\u7A0B\u51B7\u5374\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09\u3002"
      }),
      entry({
        key: "ui.dashboard.startPage",
        type: "enum",
        enumValues: [
          "overview",
          "autopilot",
          "approvals",
          "intake",
          "runtime",
          "jobs",
          "skills",
          "killswitch"
        ],
        defaultValue: "overview",
        risk: "LOW",
        description: "\u63A7\u5236\u53F0\u9ED8\u8BA4\u9996\u9875\u3002"
      }),
      entry({
        key: "ui.dashboard.refreshMs",
        type: "integer",
        minimum: 200,
        maximum: 5e3,
        defaultValue: 800,
        risk: "LOW",
        description: "\u63A7\u5236\u53F0\u81EA\u52A8\u5237\u65B0\u95F4\u9694\uFF08\u6BEB\u79D2\uFF09\u3002"
      }),
      entry({
        key: "autopilot.enabled",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u662F\u5426\u542F\u7528\u81EA\u52A8\u5FAA\u73AF\u6267\u884C\u3002"
      }),
      entry({
        key: "autopilot.maxCycles",
        type: "integer",
        minimum: 1,
        maximum: 20,
        defaultValue: 8,
        risk: "MED",
        description: "\u5355\u7A97\u53E3\u6700\u5927\u5FAA\u73AF\u8F6E\u6B21\uFF08\u8FDB\u5C55\u9A71\u52A8+\u4E0A\u9650\u7EA6\u675F\uFF09\u3002"
      }),
      entry({
        key: "autopilot.noInterruptChat",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u81EA\u52A8\u6267\u884C\u65F6\u5C3D\u91CF\u4E0D\u6253\u65AD\u4E3B\u5BF9\u8BDD\u3002"
      }),
      entry({
        key: "autopilot.stallDetection.enabled",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u542F\u7528\u505C\u6EDE\u68C0\u6D4B\u3002"
      }),
      entry({
        key: "autopilot.stallDetection.maxNoImprovementCycles",
        type: "integer",
        minimum: 1,
        maximum: 10,
        defaultValue: 3,
        risk: "MED",
        description: "\u8FDE\u7EED\u65E0\u6539\u8FDB\u8F6E\u6B21\u9608\u503C\u3002"
      }),
      entry({
        key: "autopilot.iterationDoneRequired",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u6BCF\u8F6E\u5FC5\u987B\u5199\u5165\u8FED\u4EE3\u5B8C\u6210\u8BB0\u5F55\u3002"
      }),
      entry({
        key: "approval.mode",
        type: "enum",
        enumValues: ["self"],
        defaultValue: "self",
        risk: "MED",
        description: "\u5BA1\u6279\u6A21\u5F0F\u3002"
      }),
      entry({
        key: "approval.requireEvidence",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u662F\u5426\u5F3A\u5236\u8BC1\u636E\u94FE\u3002"
      }),
      entry({
        key: "approval.signers",
        type: "object",
        defaultValue: {
          executor: true,
          verifier: true
        },
        risk: "MED",
        description: "\u5BA1\u6279\u7B7E\u5B57\u4EBA\u914D\u7F6E\u3002"
      }),
      entry({
        key: "approval.tier.default",
        type: "enum",
        enumValues: ["LIGHT", "STANDARD", "THOROUGH"],
        defaultValue: "STANDARD",
        risk: "MED",
        description: "\u9ED8\u8BA4\u9A8C\u8BC1\u7B49\u7EA7\u3002"
      }),
      entry({
        key: "approval.tier.irreversible",
        type: "enum",
        enumValues: ["THOROUGH"],
        defaultValue: "THOROUGH",
        risk: "HIGH",
        description: "\u4E0D\u53EF\u9006\u52A8\u4F5C\u5FC5\u987B\u9A8C\u8BC1\u7B49\u7EA7\u3002"
      }),
      entry({
        key: "approval.onDeny.activateKillSwitch",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u5BA1\u6279\u62D2\u7EDD\u540E\u662F\u5426\u89E6\u53D1\u6025\u505C\u3002"
      }),
      entry({
        key: "intake.enabled",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u4FE1\u606F\u95F8\u95E8\u603B\u5F00\u5173\u3002"
      }),
      entry({
        key: "intake.triggers.configChange",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u914D\u7F6E\u53D8\u66F4\u662F\u5426\u5F3A\u5236\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
      }),
      entry({
        key: "intake.triggers.skillOrToolchainChange",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u65B0\u589E/\u542F\u7528 skill \u6216\u5DE5\u5177\u94FE\u662F\u5426\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
      }),
      entry({
        key: "intake.triggers.highRiskAction",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u9AD8\u98CE\u9669\u52A8\u4F5C\u524D\u7F6E\u5B66\u4E60\u662F\u5426\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
      }),
      entry({
        key: "intake.triggers.directiveContent",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u7F51\u9875\u6307\u4EE4\u578B\u5185\u5BB9\u662F\u5426\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
      }),
      entry({
        key: "intake.policy.silentAuditTrustScoreMin",
        type: "integer",
        minimum: 0,
        maximum: 100,
        defaultValue: 85,
        risk: "MED",
        description: "\u53EA\u8BFB\u7814\u7A76\u6765\u6E90\u8FBE\u5230\u8BE5\u4FE1\u4EFB\u5206\u540E\u6539\u4E3A\u9759\u9ED8\u5BA1\u8BA1\u3002"
      }),
      entry({
        key: "intake.policy.autoWhitelistOnApprove",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u5BA1\u6279\u540C\u610F\u540E\u81EA\u52A8\u52A0\u5165\u767D\u540D\u5355\u3002"
      }),
      entry({
        key: "intake.policy.autoBlacklistOnReject",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u5BA1\u6279\u62D2\u7EDD\u540E\u81EA\u52A8\u52A0\u5165\u9ED1\u540D\u5355\u3002"
      }),
      entry({
        key: "intake.policy.defaultRejectScope",
        type: "enum",
        enumValues: ["CONTENT_FINGERPRINT", "PAGE", "PATH_PREFIX", "DOMAIN"],
        defaultValue: "CONTENT_FINGERPRINT",
        risk: "MED",
        description: "\u62D2\u7EDD\u65F6\u9ED8\u8BA4\u52A0\u5165\u9ED1\u540D\u5355\u7684\u7C92\u5EA6\u3002"
      }),
      entry({
        key: "intake.policy.allowTrialRunOption",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u5BA1\u6279\u9009\u9879\u4E2D\u5141\u8BB8\u201C\u4EC5\u8BD5\u8FD0\u884C\u4E00\u6B21\u201D\u3002"
      }),
      entry({
        key: "intake.stats.windowN",
        type: "integer",
        minimum: 3,
        maximum: 50,
        defaultValue: 10,
        risk: "MED",
        description: "\u6765\u6E90\u7EDF\u8BA1\u6ED1\u52A8\u7A97\u53E3\u5927\u5C0F N\uFF08\u6309\u5BA1\u6279\u4E8B\u4EF6\uFF09\u3002"
      }),
      entry({
        key: "intake.stats.hardDenyWhenUsefulLessThanRejected",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u5F53 U<R \u65F6\u9ED8\u8BA4\u5426\u51B3\u8BE5\u6765\u6E90\u3002"
      }),
      entry({
        key: "intake.stats.downrankThresholdRatioX100",
        type: "integer",
        minimum: 100,
        maximum: 500,
        defaultValue: 150,
        risk: "MED",
        description: "\u964D\u6743\u9608\u503C\u6BD4\u7387\uFF08X100\uFF0C\u9ED8\u8BA4 150 \u8868\u793A 1.5 \u500D\uFF09\u3002"
      }),
      entry({
        key: "intake.stats.downrankExplorePercent",
        type: "integer",
        minimum: 0,
        maximum: 100,
        defaultValue: 30,
        risk: "MED",
        description: "\u6765\u6E90\u964D\u6743\u540E\u63A2\u7D22\u6982\u7387\u767E\u5206\u6BD4\u3002"
      }),
      entry({
        key: "intake.stats.sourceUnit",
        type: "enum",
        enumValues: ["DOMAIN_PATH_PREFIX", "DOMAIN", "PATH_PREFIX"],
        defaultValue: "DOMAIN_PATH_PREFIX",
        risk: "MED",
        description: "\u6765\u6E90\u7EDF\u8BA1\u5355\u5143\u3002"
      }),
      entry({
        key: "killswitch.active",
        type: "boolean",
        defaultValue: false,
        risk: "HIGH",
        description: "\u6025\u505C\u603B\u5F00\u5173\u72B6\u6001\u3002"
      }),
      entry({
        key: "killswitch.lockdownOnHighRisk",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u9AD8\u98CE\u9669\u62D2\u7EDD\u540E\u8FDB\u5165\u9501\u5B9A\u3002"
      }),
      entry({
        key: "killswitch.unlockPolicy",
        type: "enum",
        enumValues: ["explicit"],
        defaultValue: "explicit",
        risk: "HIGH",
        description: "\u6025\u505C\u89E3\u9501\u7B56\u7565\u3002"
      }),
      entry({
        key: "killswitch.stopTargets",
        type: "object",
        defaultValue: {
          desktop: true,
          outbound: true,
          exec: true,
          browser: true,
          voice: false
        },
        risk: "HIGH",
        description: "\u6025\u505C\u9700\u8981\u505C\u6B62\u7684\u76EE\u6807\u6A21\u5757\u3002"
      }),
      entry({
        key: "gateway.bindHost",
        type: "string",
        defaultValue: "127.0.0.1",
        risk: "MED",
        description: "Gateway \u7ED1\u5B9A\u5730\u5740\u3002"
      }),
      entry({
        key: "gateway.port",
        type: "integer",
        minimum: 1024,
        maximum: 65535,
        defaultValue: 17321,
        risk: "MED",
        description: "Gateway \u76D1\u542C\u7AEF\u53E3\u3002"
      }),
      entry({
        key: "gateway.baseUrl",
        type: "string",
        defaultValue: "http://127.0.0.1:17321",
        risk: "MED",
        description: "Gateway \u57FA\u7840 URL\u3002"
      }),
      entry({
        key: "gateway.wsPath",
        type: "string",
        defaultValue: "/ws",
        risk: "MED",
        description: "Gateway WebSocket \u8DEF\u5F84\u3002"
      }),
      entry({
        key: "gateway.staticSpa.enabled",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u662F\u5426\u542F\u7528\u9759\u6001\u7F51\u9875\u63A7\u5236\u53F0\u3002"
      }),
      entry({
        key: "gateway.auth.mode",
        type: "enum",
        enumValues: ["localToken", "none"],
        defaultValue: "localToken",
        risk: "HIGH",
        description: "Gateway \u9274\u6743\u6A21\u5F0F\u3002"
      }),
      entry({
        key: "runtime.backpressure.max_in_flight",
        type: "integer",
        minimum: 1,
        maximum: 128,
        defaultValue: 8,
        risk: "MED",
        description: "Gateway \u6700\u5927\u5E76\u53D1\u6267\u884C\u6570\u3002"
      }),
      entry({
        key: "runtime.backpressure.max_queued",
        type: "integer",
        minimum: 1,
        maximum: 1024,
        defaultValue: 64,
        risk: "MED",
        description: "Gateway \u6700\u5927\u6392\u961F\u8BF7\u6C42\u6570\u3002"
      }),
      entry({
        key: "runtime.backpressure.queue_timeout_ms",
        type: "integer",
        minimum: 100,
        maximum: 12e4,
        defaultValue: 15e3,
        risk: "MED",
        description: "Gateway \u6392\u961F\u8D85\u65F6\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09\u3002"
      }),
      entry({
        key: "runtime.backpressure.daemon_max_pending_requests",
        type: "integer",
        minimum: 4,
        maximum: 1024,
        defaultValue: 64,
        risk: "MED",
        description: "Daemon Launcher \u6700\u5927\u6302\u8D77\u8BF7\u6C42\u6570\u3002"
      }),
      entry({
        key: "runtime.notifications.job_toast",
        type: "boolean",
        defaultValue: true,
        risk: "LOW",
        description: "\u4EFB\u52A1\u5B8C\u6210/\u5931\u8D25\u65F6\u662F\u5426\u63A8\u9001 toast \u901A\u77E5\u3002"
      }),
      entry({
        key: "runtime.multimodal.test_mode",
        type: "boolean",
        defaultValue: true,
        risk: "LOW",
        description: "\u591A\u6A21\u6001\u5355\u5143\u6D4B\u8BD5\u6A21\u5F0F\uFF08\u4F7F\u7528\u53EF\u8FFD\u6EAF\u964D\u7EA7\u8D44\u4EA7\uFF09\u3002"
      }),
      entry({
        key: "security.voiceprint.strict",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u58F0\u7EB9\u6821\u9A8C\u4E25\u683C\u6A21\u5F0F\u5F00\u5173\u3002"
      }),
      entry({
        key: "skills.enabled",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u662F\u5426\u542F\u7528\u6280\u80FD\u7CFB\u7EDF\u3002"
      }),
      entry({
        key: "skills.packages",
        type: "array",
        defaultValue: [],
        risk: "MED",
        description: "\u5DF2\u542F\u7528\u6280\u80FD\u5305\u5217\u8868\u3002"
      }),
      entry({
        key: "skills.versionLock.enabled",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u6280\u80FD\u5305\u7248\u672C\u9501\u5B9A\u3002"
      }),
      entry({
        key: "skills.compat.openCodeNative",
        type: "boolean",
        defaultValue: true,
        risk: "LOW",
        description: "\u517C\u5BB9 OpenCode \u539F\u751F\u6280\u80FD\u3002"
      }),
      entry({
        key: "desktop.enabled",
        type: "boolean",
        defaultValue: false,
        risk: "HIGH",
        description: "\u684C\u9762\u81EA\u52A8\u5316\u5F00\u5173\u3002"
      }),
      entry({
        key: "desktop.preferUia",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u4F18\u5148 UIA \u81EA\u52A8\u5316\u3002"
      }),
      entry({
        key: "desktop.requirePreSendScreenshotVerify",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u53D1\u9001\u524D\u622A\u56FE\u6838\u9A8C\u3002"
      }),
      entry({
        key: "desktop.requirePostActionVerify",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u52A8\u4F5C\u540E\u72B6\u6001\u6838\u9A8C\u3002"
      }),
      entry({
        key: "desktop.focusPolicy",
        type: "enum",
        enumValues: ["strict", "relaxed"],
        defaultValue: "strict",
        risk: "HIGH",
        description: "\u684C\u9762\u7126\u70B9\u7B56\u7565\u3002"
      }),
      entry({
        key: "outbound.enabled",
        type: "boolean",
        defaultValue: false,
        risk: "HIGH",
        description: "\u5916\u53D1\u6D88\u606F\u603B\u5F00\u5173\u3002"
      }),
      entry({
        key: "outbound.channels",
        type: "object",
        defaultValue: {
          qq: true,
          wechat: true
        },
        risk: "HIGH",
        description: "\u5916\u53D1\u6E20\u9053\u914D\u7F6E\uFF08\u4EC5 QQ/\u5FAE\u4FE1\uFF09\u3002"
      }),
      entry({
        key: "outbound.requireDraftInChat",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u5916\u53D1\u524D\u5148\u5728\u5BF9\u8BDD\u4E2D\u751F\u6210\u8349\u7A3F\u3002"
      }),
      entry({
        key: "outbound.requireVerifierSign",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u5916\u53D1\u524D\u5F3A\u5236 verifier \u7B7E\u5B57\u3002"
      }),
      entry({
        key: "voice.enabled",
        type: "boolean",
        defaultValue: false,
        risk: "HIGH",
        description: "\u8BED\u97F3\u80FD\u529B\u603B\u5F00\u5173\u3002"
      }),
      entry({
        key: "voice.input.stt",
        type: "enum",
        enumValues: ["local", "off"],
        defaultValue: "local",
        risk: "MED",
        description: "\u8BED\u97F3\u8F93\u5165 STT \u6A21\u5F0F\u3002"
      }),
      entry({
        key: "voice.output.tts",
        type: "enum",
        enumValues: ["local", "off"],
        defaultValue: "local",
        risk: "MED",
        description: "\u8BED\u97F3\u8F93\u51FA TTS \u6A21\u5F0F\u3002"
      }),
      entry({
        key: "voice.wakeWord.enabled",
        type: "boolean",
        defaultValue: false,
        risk: "MED",
        description: "\u5524\u9192\u8BCD\u5F00\u5173\u3002"
      }),
      entry({
        key: "voice.oneShotMode",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u4E00\u53E5\u8BDD\u89E6\u53D1\u6A21\u5F0F\u3002"
      }),
      entry({
        key: "voice.routeToChat",
        type: "boolean",
        defaultValue: true,
        risk: "MED",
        description: "\u8BED\u97F3\u8F93\u5165\u7EDF\u4E00\u5199\u5165\u4F1A\u8BDD\u3002"
      }),
      entry({
        key: "git.autoPush.enabled",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u81EA\u52A8\u63A8\u9001\u5F00\u5173\u3002"
      }),
      entry({
        key: "git.autoPush.remote",
        type: "string",
        defaultValue: "https://github.com/mmy4shadow/miya-for-opencode.git",
        risk: "HIGH",
        description: "\u81EA\u52A8\u63A8\u9001\u8FDC\u7AEF\u4ED3\u5E93\u3002"
      }),
      entry({
        key: "git.autoPush.branchPattern",
        type: "string",
        defaultValue: "refs/heads/miya/<session-id>",
        risk: "HIGH",
        description: "\u81EA\u52A8\u63A8\u9001\u5206\u652F\u7B56\u7565\u3002"
      }),
      entry({
        key: "git.autoPush.maxFileSizeMB",
        type: "integer",
        minimum: 1,
        maximum: 50,
        defaultValue: 2,
        risk: "HIGH",
        description: "\u81EA\u52A8\u63A8\u9001\u5355\u6587\u4EF6\u5927\u5C0F\u4E0A\u9650\u3002"
      }),
      entry({
        key: "git.autoPush.blockWhenKillSwitchActive",
        type: "boolean",
        defaultValue: true,
        risk: "HIGH",
        description: "\u6025\u505C\u65F6\u963B\u65AD\u81EA\u52A8\u63A8\u9001\u3002"
      }),
      entry({
        key: "git.autoPush.excludeGlobs",
        type: "array",
        defaultValue: [
          ".opencode/**",
          ".venv/**",
          "node_modules/**",
          "**/*.pem",
          "**/*.key",
          "**/.env*"
        ],
        risk: "HIGH",
        description: "\u81EA\u52A8\u63A8\u9001\u6392\u9664\u5217\u8868\u3002"
      })
    ];
    REGISTRY_MAP = new Map(
      SETTINGS_REGISTRY.map((item) => [item.key, item])
    );
  }
});

// src/settings/store.ts
import * as fs5 from "node:fs";
import * as path5 from "node:path";
function runtimeFile(projectDir, fileName) {
  return path5.join(getMiyaRuntimeDir(projectDir), fileName);
}
function ensureDir(file3) {
  fs5.mkdirSync(path5.dirname(file3), { recursive: true });
}
function cloneValue2(value) {
  return JSON.parse(JSON.stringify(value));
}
function writeJson(file3, value) {
  ensureDir(file3);
  fs5.writeFileSync(file3, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function readJsonObject(file3) {
  if (!fs5.existsSync(file3)) return {};
  try {
    const parsed = JSON.parse(fs5.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return {};
    }
    return parsed;
  } catch {
    return {};
  }
}
function riskRank(risk) {
  if (risk === "HIGH") return 3;
  if (risk === "MED") return 2;
  return 1;
}
function maxRisk(current, next) {
  return riskRank(next) > riskRank(current) ? next : current;
}
function deepEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}
function normalizePathToKey(input) {
  const trimmed = input.trim();
  if (!trimmed) return "";
  if (trimmed.startsWith("/")) {
    return trimmed.split("/").map((segment) => segment.trim()).filter((segment) => segment.length > 0).join(".");
  }
  return trimmed;
}
function normalizePatchObject(input) {
  if ("jsonPatch" in input && Array.isArray(input.jsonPatch)) {
    return normalizePatchInput(input.jsonPatch);
  }
  if ("patch" in input && input.patch !== void 0) {
    return normalizePatchInput(input.patch);
  }
  const setRaw = "set" in input && input.set && typeof input.set === "object" ? input.set : null;
  const unsetRaw = "unset" in input && Array.isArray(input.unset) ? input.unset : "reset" in input && Array.isArray(input.reset) ? input.reset : null;
  if (setRaw || unsetRaw) {
    const patch2 = {
      set: {},
      unset: []
    };
    const errors = [];
    if (setRaw) {
      for (const [key, value] of Object.entries(setRaw)) {
        const normalizedKey = normalizePathToKey(key);
        if (!normalizedKey) {
          errors.push(`Invalid set key: ${key}`);
          continue;
        }
        patch2.set[normalizedKey] = value;
      }
    }
    if (unsetRaw) {
      for (const key of unsetRaw) {
        const normalizedKey = normalizePathToKey(String(key));
        if (!normalizedKey) {
          errors.push(`Invalid unset key: ${String(key)}`);
          continue;
        }
        patch2.unset.push(normalizedKey);
      }
    }
    patch2.unset = [...new Set(patch2.unset)];
    return { patch: patch2, errors };
  }
  const patch = { set: {}, unset: [] };
  for (const [key, value] of Object.entries(input)) {
    const normalizedKey = normalizePathToKey(key);
    if (!normalizedKey) continue;
    patch.set[normalizedKey] = value;
  }
  return { patch, errors: [] };
}
function normalizeJsonPatchArray(input) {
  const patch = { set: {}, unset: [] };
  const errors = [];
  for (const item of input) {
    if (!item || typeof item !== "object" || Array.isArray(item)) {
      errors.push("JSON Patch item must be an object.");
      continue;
    }
    const op = String(item.op ?? "").toLowerCase();
    const pathValue = String(item.path ?? "");
    const key = normalizePathToKey(pathValue);
    if (!key) {
      errors.push(`JSON Patch path is invalid: ${pathValue}`);
      continue;
    }
    if (op === "remove") {
      patch.unset.push(key);
      continue;
    }
    if (op === "add" || op === "replace" || op === "set") {
      patch.set[key] = item.value;
      continue;
    }
    errors.push(`Unsupported JSON Patch operation: ${op}`);
  }
  patch.unset = [...new Set(patch.unset)];
  return { patch, errors };
}
function validateValueType(entryValue, value) {
  const valueType = entryValue.type;
  if (valueType === "boolean") {
    return typeof value === "boolean" ? null : `Expected boolean for ${entryValue.key}.`;
  }
  if (valueType === "integer") {
    if (typeof value !== "number" || !Number.isInteger(value)) {
      return `Expected integer for ${entryValue.key}.`;
    }
    if (typeof entryValue.minimum === "number" && value < entryValue.minimum) {
      return `${entryValue.key} must be >= ${entryValue.minimum}.`;
    }
    if (typeof entryValue.maximum === "number" && value > entryValue.maximum) {
      return `${entryValue.key} must be <= ${entryValue.maximum}.`;
    }
    return null;
  }
  if (valueType === "string") {
    return typeof value === "string" ? null : `Expected string for ${entryValue.key}.`;
  }
  if (valueType === "enum") {
    if (typeof value !== "string") {
      return `Expected enum string for ${entryValue.key}.`;
    }
    const options = entryValue.enumValues ?? [];
    if (!options.includes(value)) {
      return `${entryValue.key} must be one of: ${options.join(", ")}.`;
    }
    return null;
  }
  if (valueType === "object") {
    return value && typeof value === "object" && !Array.isArray(value) ? null : `Expected object for ${entryValue.key}.`;
  }
  if (valueType === "array") {
    return Array.isArray(value) ? null : `Expected array for ${entryValue.key}.`;
  }
  return `Unsupported type for ${entryValue.key}.`;
}
function mergeConfigWithDefaults(raw) {
  const merged = cloneValue2(raw);
  for (const item of listSettingEntries()) {
    const current = getNestedValue(merged, item.key);
    if (current === void 0) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
      continue;
    }
    const issue3 = validateValueType(item, current);
    if (issue3) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
    }
  }
  return merged;
}
function ensureSettingsFiles(projectDir) {
  const registryPath = runtimeFile(projectDir, "registry.json");
  const schemaPath = runtimeFile(projectDir, "schema.json");
  const configPath = runtimeFile(projectDir, "config.json");
  writeJson(registryPath, buildRegistryDocument());
  writeJson(schemaPath, buildSchemaDocument());
  if (!fs5.existsSync(configPath)) {
    writeJson(configPath, buildDefaultConfig());
    return;
  }
  const raw = readJsonObject(configPath);
  const normalized = mergeConfigWithDefaults(raw);
  writeJson(configPath, normalized);
}
function readConfig(projectDir) {
  ensureSettingsFiles(projectDir);
  const raw = readJsonObject(runtimeFile(projectDir, "config.json"));
  return mergeConfigWithDefaults(raw);
}
function writeConfig2(projectDir, config3) {
  ensureSettingsFiles(projectDir);
  writeJson(runtimeFile(projectDir, "config.json"), mergeConfigWithDefaults(config3));
}
function normalizePatchInput(input) {
  if (!input) {
    return { patch: cloneValue2(EMPTY_PATCH), errors: ["Patch payload is empty."] };
  }
  if (Array.isArray(input)) {
    return normalizeJsonPatchArray(input);
  }
  if (typeof input !== "object") {
    return {
      patch: cloneValue2(EMPTY_PATCH),
      errors: ["Patch payload must be an object or JSON Patch array."]
    };
  }
  return normalizePatchObject(input);
}
function validateConfigPatch(projectDir, patchInput) {
  const currentConfig = readConfig(projectDir);
  const normalized = normalizePatchInput(patchInput);
  const errors = [...normalized.errors];
  const warnings = [];
  const changes = [];
  const keysToCheck = [
    ...Object.keys(normalized.patch.set),
    ...normalized.patch.unset
  ];
  const uniqueKeys = [...new Set(keysToCheck)];
  for (const key of uniqueKeys) {
    const setting = getSettingEntry(key);
    if (!setting) {
      errors.push(`Unknown setting key: ${key}`);
      continue;
    }
    const isReset = normalized.patch.unset.includes(key);
    const nextValue = isReset ? cloneValue2(setting.defaultValue) : normalized.patch.set[key];
    const previousValue = getNestedValue(currentConfig, key);
    const issue3 = validateValueType(setting, nextValue);
    if (issue3) {
      errors.push(issue3);
      continue;
    }
    if (deepEqual(previousValue, nextValue)) {
      warnings.push(`${key} is unchanged.`);
      continue;
    }
    changes.push({
      key,
      operation: isReset ? "reset" : "set",
      risk: setting.risk,
      description: setting.description,
      previousValue,
      nextValue,
      requiresEvidence: setting.requiresEvidence
    });
  }
  let highestRisk = "LOW";
  for (const change of changes) {
    highestRisk = maxRisk(highestRisk, change.risk);
  }
  if (normalized.patch.set["outbound.enabled"] === true && normalized.patch.set["desktop.requirePreSendScreenshotVerify"] === false) {
    errors.push(
      "outbound.enabled=true \u65F6\u4E0D\u5141\u8BB8\u5C06 desktop.requirePreSendScreenshotVerify \u8BBE\u4E3A false\u3002"
    );
  }
  if (changes.length === 0 && errors.length === 0) {
    warnings.push("Patch has no effective changes.");
  }
  const requiredSafetyTier = highestRisk === "HIGH" ? "THOROUGH" : highestRisk === "MED" ? "STANDARD" : "LIGHT";
  return {
    ok: errors.length === 0 && changes.length > 0,
    errors,
    warnings,
    normalizedPatch: normalized.patch,
    changes,
    maxRisk: highestRisk,
    requiresEvidence: changes.some((change) => change.requiresEvidence),
    requiredSafetyTier
  };
}
function applyConfigPatch(projectDir, validation) {
  const config3 = readConfig(projectDir);
  for (const change of validation.changes) {
    setNestedValue(config3, change.key, cloneValue2(change.nextValue));
  }
  writeConfig2(projectDir, config3);
  return {
    updatedConfig: readConfig(projectDir),
    applied: validation.changes
  };
}
var EMPTY_PATCH;
var init_store = __esm({
  "src/settings/store.ts"() {
    "use strict";
    init_workflow();
    init_registry();
    EMPTY_PATCH = { set: {}, unset: [] };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor2(name, initializer5, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer5(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
var NEVER2, $brand2, $ZodAsyncError2, $ZodEncodeError2, globalConfig2;
var init_core3 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/core.js"() {
    NEVER2 = Object.freeze({
      status: "aborted"
    });
    $brand2 = Symbol("zod_brand");
    $ZodAsyncError2 = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    $ZodEncodeError2 = class extends Error {
      constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
      }
    };
    globalConfig2 = {};
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/util.js
var util_exports2 = {};
__export(util_exports2, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2,
  Class: () => Class2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  aborted: () => aborted2,
  allowsEval: () => allowsEval2,
  assert: () => assert2,
  assertEqual: () => assertEqual2,
  assertIs: () => assertIs2,
  assertNever: () => assertNever2,
  assertNotEqual: () => assertNotEqual2,
  assignProp: () => assignProp2,
  base64ToUint8Array: () => base64ToUint8Array2,
  base64urlToUint8Array: () => base64urlToUint8Array2,
  cached: () => cached2,
  captureStackTrace: () => captureStackTrace2,
  cleanEnum: () => cleanEnum2,
  cleanRegex: () => cleanRegex2,
  clone: () => clone2,
  cloneDef: () => cloneDef2,
  createTransparentProxy: () => createTransparentProxy2,
  defineLazy: () => defineLazy2,
  esc: () => esc2,
  escapeRegex: () => escapeRegex2,
  extend: () => extend2,
  finalizeIssue: () => finalizeIssue2,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath2,
  getEnumValues: () => getEnumValues2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin2,
  hexToUint8Array: () => hexToUint8Array2,
  isObject: () => isObject3,
  isPlainObject: () => isPlainObject2,
  issue: () => issue2,
  joinValues: () => joinValues2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  merge: () => merge2,
  mergeDefs: () => mergeDefs2,
  normalizeParams: () => normalizeParams2,
  nullish: () => nullish3,
  numKeys: () => numKeys2,
  objectClone: () => objectClone2,
  omit: () => omit2,
  optionalKeys: () => optionalKeys2,
  partial: () => partial2,
  pick: () => pick2,
  prefixIssues: () => prefixIssues2,
  primitiveTypes: () => primitiveTypes2,
  promiseAllObject: () => promiseAllObject2,
  propertyKeyTypes: () => propertyKeyTypes2,
  randomString: () => randomString2,
  required: () => required2,
  safeExtend: () => safeExtend2,
  shallowClone: () => shallowClone2,
  stringifyPrimitive: () => stringifyPrimitive2,
  uint8ArrayToBase64: () => uint8ArrayToBase642,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url2,
  uint8ArrayToHex: () => uint8ArrayToHex2,
  unwrapMessage: () => unwrapMessage2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {
}
function assertNever2(_x) {
  throw new Error();
}
function assert2(_) {
}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === void 0;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy2(object3, key, getter) {
  let value = void 0;
  Object.defineProperty(object3, key, {
    get() {
      if (value === EVALUATING2) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING2;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone2(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs2(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef2(schema) {
  return mergeDefs2(schema._zod.def);
}
function getElementAtPath2(obj, path45) {
  if (!path45)
    return obj;
  return path45.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc2(str) {
  return JSON.stringify(str);
}
function isObject3(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject2(o) {
  if (isObject3(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject3(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone2(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function omit2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function safeExtend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone2(schema, def);
}
function merge2(a, b) {
  const def = mergeDefs2(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone2(a, def);
}
function partial2(Class3, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function required2(Class3, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function aborted2(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues2(path45, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path45);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config3.customError?.(iss)) ?? unwrapMessage2(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array2(base645) {
  const binaryString = atob(base645);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase642(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array2(base64url5) {
  const base645 = base64url5.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base645.length % 4) % 4);
  return base64ToUint8Array2(base645 + padding);
}
function uint8ArrayToBase64url2(bytes) {
  return uint8ArrayToBase642(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array2(hex5) {
  const cleanHex = hex5.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex2(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var EVALUATING2, captureStackTrace2, allowsEval2, getParsedType2, propertyKeyTypes2, primitiveTypes2, NUMBER_FORMAT_RANGES2, BIGINT_FORMAT_RANGES2, Class2;
var init_util2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/util.js"() {
    EVALUATING2 = Symbol("evaluating");
    captureStackTrace2 = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
    };
    allowsEval2 = cached2(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    getParsedType2 = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    propertyKeyTypes2 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes2 = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    NUMBER_FORMAT_RANGES2 = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES2 = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    Class2 = class {
      constructor(..._args) {
      }
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/errors.js
function flattenError2(error92, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error92.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error92, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error93) => {
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error92);
  return fieldErrors;
}
function treeifyError2(error92, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = (error93, path45 = []) => {
    var _a2, _b;
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path45, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error92);
  return result;
}
function toDotPath2(_path) {
  const segs = [];
  const path45 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path45) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error92) {
  const lines = [];
  const issues = [...error92.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath2(issue3.path)}`);
  }
  return lines.join("\n");
}
var initializer3, $ZodError2, $ZodRealError2;
var init_errors3 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/errors.js"() {
    init_core3();
    init_util2();
    initializer3 = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    $ZodError2 = $constructor2("$ZodError", initializer3);
    $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/parse.js
var _parse2, parse3, _parseAsync2, parseAsync3, _safeParse2, safeParse3, _safeParseAsync2, safeParseAsync3, _encode2, encode3, _decode2, decode3, _encodeAsync2, encodeAsync3, _decodeAsync2, decodeAsync3, _safeEncode2, safeEncode3, _safeDecode2, safeDecode3, _safeEncodeAsync2, safeEncodeAsync3, _safeDecodeAsync2, safeDecodeAsync3;
var init_parse3 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/parse.js"() {
    init_core3();
    init_errors3();
    init_util2();
    _parse2 = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError2();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
        captureStackTrace2(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    parse3 = /* @__PURE__ */ _parse2($ZodRealError2);
    _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
        captureStackTrace2(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    parseAsync3 = /* @__PURE__ */ _parseAsync2($ZodRealError2);
    _safeParse2 = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError2();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
      } : { success: true, data: result.value };
    };
    safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
    _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
      } : { success: true, data: result.value };
    };
    safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
    _encode2 = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parse2(_Err)(schema, value, ctx);
    };
    encode3 = /* @__PURE__ */ _encode2($ZodRealError2);
    _decode2 = (_Err) => (schema, value, _ctx) => {
      return _parse2(_Err)(schema, value, _ctx);
    };
    decode3 = /* @__PURE__ */ _decode2($ZodRealError2);
    _encodeAsync2 = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parseAsync2(_Err)(schema, value, ctx);
    };
    encodeAsync3 = /* @__PURE__ */ _encodeAsync2($ZodRealError2);
    _decodeAsync2 = (_Err) => async (schema, value, _ctx) => {
      return _parseAsync2(_Err)(schema, value, _ctx);
    };
    decodeAsync3 = /* @__PURE__ */ _decodeAsync2($ZodRealError2);
    _safeEncode2 = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParse2(_Err)(schema, value, ctx);
    };
    safeEncode3 = /* @__PURE__ */ _safeEncode2($ZodRealError2);
    _safeDecode2 = (_Err) => (schema, value, _ctx) => {
      return _safeParse2(_Err)(schema, value, _ctx);
    };
    safeDecode3 = /* @__PURE__ */ _safeDecode2($ZodRealError2);
    _safeEncodeAsync2 = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParseAsync2(_Err)(schema, value, ctx);
    };
    safeEncodeAsync3 = /* @__PURE__ */ _safeEncodeAsync2($ZodRealError2);
    _safeDecodeAsync2 = (_Err) => async (schema, value, _ctx) => {
      return _safeParseAsync2(_Err)(schema, value, _ctx);
    };
    safeDecodeAsync3 = /* @__PURE__ */ _safeDecodeAsync2($ZodRealError2);
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/regexes.js
var regexes_exports2 = {};
__export(regexes_exports2, {
  base64: () => base643,
  base64url: () => base64url3,
  bigint: () => bigint4,
  boolean: () => boolean4,
  browserEmail: () => browserEmail2,
  cidrv4: () => cidrv43,
  cidrv6: () => cidrv63,
  cuid: () => cuid4,
  cuid2: () => cuid23,
  date: () => date5,
  datetime: () => datetime3,
  domain: () => domain2,
  duration: () => duration3,
  e164: () => e1643,
  email: () => email3,
  emoji: () => emoji3,
  extendedDuration: () => extendedDuration2,
  guid: () => guid3,
  hex: () => hex3,
  hostname: () => hostname3,
  html5Email: () => html5Email2,
  idnEmail: () => idnEmail2,
  integer: () => integer2,
  ipv4: () => ipv43,
  ipv6: () => ipv63,
  ksuid: () => ksuid3,
  lowercase: () => lowercase2,
  md5_base64: () => md5_base642,
  md5_base64url: () => md5_base64url2,
  md5_hex: () => md5_hex2,
  nanoid: () => nanoid3,
  null: () => _null4,
  number: () => number4,
  rfc5322Email: () => rfc5322Email2,
  sha1_base64: () => sha1_base642,
  sha1_base64url: () => sha1_base64url2,
  sha1_hex: () => sha1_hex2,
  sha256_base64: () => sha256_base642,
  sha256_base64url: () => sha256_base64url2,
  sha256_hex: () => sha256_hex2,
  sha384_base64: () => sha384_base642,
  sha384_base64url: () => sha384_base64url2,
  sha384_hex: () => sha384_hex2,
  sha512_base64: () => sha512_base642,
  sha512_base64url: () => sha512_base64url2,
  sha512_hex: () => sha512_hex2,
  string: () => string4,
  time: () => time3,
  ulid: () => ulid3,
  undefined: () => _undefined4,
  unicodeEmail: () => unicodeEmail2,
  uppercase: () => uppercase2,
  uuid: () => uuid3,
  uuid4: () => uuid42,
  uuid6: () => uuid62,
  uuid7: () => uuid72,
  xid: () => xid3
});
function emoji3() {
  return new RegExp(_emoji3, "u");
}
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time5 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
function fixedBase642(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url2(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid4, cuid23, ulid3, xid3, ksuid3, nanoid3, duration3, extendedDuration2, guid3, uuid3, uuid42, uuid62, uuid72, email3, html5Email2, rfc5322Email2, unicodeEmail2, idnEmail2, browserEmail2, _emoji3, ipv43, ipv63, cidrv43, cidrv63, base643, base64url3, hostname3, domain2, e1643, dateSource2, date5, string4, bigint4, integer2, number4, boolean4, _null4, _undefined4, lowercase2, uppercase2, hex3, md5_hex2, md5_base642, md5_base64url2, sha1_hex2, sha1_base642, sha1_base64url2, sha256_hex2, sha256_base642, sha256_base64url2, sha384_hex2, sha384_base642, sha384_base64url2, sha512_hex2, sha512_base642, sha512_base64url2;
var init_regexes2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/regexes.js"() {
    cuid4 = /^[cC][^\s-]{8,}$/;
    cuid23 = /^[0-9a-z]+$/;
    ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid3 = /^[0-9a-vA-V]{20}$/;
    ksuid3 = /^[A-Za-z0-9]{27}$/;
    nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
    duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid3 = (version3) => {
      if (!version3)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    uuid42 = /* @__PURE__ */ uuid3(4);
    uuid62 = /* @__PURE__ */ uuid3(6);
    uuid72 = /* @__PURE__ */ uuid3(7);
    email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    idnEmail2 = unicodeEmail2;
    browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
    cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url3 = /^[A-Za-z0-9_-]*$/;
    hostname3 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
    domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e1643 = /^\+(?:[0-9]){6,14}[0-9]$/;
    dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
    string4 = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    bigint4 = /^-?\d+n?$/;
    integer2 = /^-?\d+$/;
    number4 = /^-?\d+(?:\.\d+)?/;
    boolean4 = /^(?:true|false)$/i;
    _null4 = /^null$/i;
    _undefined4 = /^undefined$/i;
    lowercase2 = /^[^A-Z]*$/;
    uppercase2 = /^[^a-z]*$/;
    hex3 = /^[0-9a-fA-F]*$/;
    md5_hex2 = /^[0-9a-fA-F]{32}$/;
    md5_base642 = /* @__PURE__ */ fixedBase642(22, "==");
    md5_base64url2 = /* @__PURE__ */ fixedBase64url2(22);
    sha1_hex2 = /^[0-9a-fA-F]{40}$/;
    sha1_base642 = /* @__PURE__ */ fixedBase642(27, "=");
    sha1_base64url2 = /* @__PURE__ */ fixedBase64url2(27);
    sha256_hex2 = /^[0-9a-fA-F]{64}$/;
    sha256_base642 = /* @__PURE__ */ fixedBase642(43, "=");
    sha256_base64url2 = /* @__PURE__ */ fixedBase64url2(43);
    sha384_hex2 = /^[0-9a-fA-F]{96}$/;
    sha384_base642 = /* @__PURE__ */ fixedBase642(64, "");
    sha384_base64url2 = /* @__PURE__ */ fixedBase64url2(64);
    sha512_hex2 = /^[0-9a-fA-F]{128}$/;
    sha512_base642 = /* @__PURE__ */ fixedBase642(86, "==");
    sha512_base64url2 = /* @__PURE__ */ fixedBase64url2(86);
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
var $ZodCheck2, numericOriginMap2, $ZodCheckLessThan2, $ZodCheckGreaterThan2, $ZodCheckMultipleOf2, $ZodCheckNumberFormat2, $ZodCheckBigIntFormat2, $ZodCheckMaxSize2, $ZodCheckMinSize2, $ZodCheckSizeEquals2, $ZodCheckMaxLength2, $ZodCheckMinLength2, $ZodCheckLengthEquals2, $ZodCheckStringFormat2, $ZodCheckRegex2, $ZodCheckLowerCase2, $ZodCheckUpperCase2, $ZodCheckIncludes2, $ZodCheckStartsWith2, $ZodCheckEndsWith2, $ZodCheckProperty2, $ZodCheckMimeType2, $ZodCheckOverwrite2;
var init_checks3 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/checks.js"() {
    init_core3();
    init_regexes2();
    init_util2();
    $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
      var _a2;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
    });
    numericOriginMap2 = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck2.init(inst, def);
      const origin = numericOriginMap2[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck2.init(inst, def);
      const origin = numericOriginMap2[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck2.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a2;
        (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck2.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = integer2;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              continue: false,
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck2.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckMaxSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxSize", (inst, def) => {
      var _a2;
      $ZodCheck2.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin2(input),
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMinSize", (inst, def) => {
      var _a2;
      $ZodCheck2.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin2(input),
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckSizeEquals", (inst, def) => {
      var _a2;
      $ZodCheck2.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin2(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
      var _a2;
      $ZodCheck2.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin2(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
      var _a2;
      $ZodCheck2.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin2(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
      var _a2;
      $ZodCheck2.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin2(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
      var _a2, _b;
      $ZodCheck2.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat2.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase2);
      $ZodCheckStringFormat2.init(inst, def);
    });
    $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase2);
      $ZodCheckStringFormat2.init(inst, def);
    });
    $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck2.init(inst, def);
      const escapedRegex = escapeRegex2(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck2.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck2.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckProperty2 = /* @__PURE__ */ $constructor2("$ZodCheckProperty", (inst, def) => {
      $ZodCheck2.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
        }
        handleCheckPropertyResult2(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType2 = /* @__PURE__ */ $constructor2("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck2.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck2.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/doc.js
var Doc2;
var init_doc2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/doc.js"() {
    Doc2 = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/versions.js
var version2;
var init_versions2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/versions.js"() {
    version2 = {
      major: 4,
      minor: 1,
      patch: 8
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/schemas.js
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base645 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base645.padEnd(Math.ceil(base645.length / 4) * 4, "=");
  return isValidBase642(padded);
}
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult2(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef2(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall2(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
    } else {
      handlePropertyResult2(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted2(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult2(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
function handleDefaultResult2(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult2(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.out, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.in, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult2(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
var $ZodType2, $ZodString2, $ZodStringFormat2, $ZodGUID2, $ZodUUID2, $ZodEmail2, $ZodURL2, $ZodEmoji2, $ZodNanoID2, $ZodCUID3, $ZodCUID22, $ZodULID2, $ZodXID2, $ZodKSUID2, $ZodISODateTime2, $ZodISODate2, $ZodISOTime2, $ZodISODuration2, $ZodIPv42, $ZodIPv62, $ZodCIDRv42, $ZodCIDRv62, $ZodBase642, $ZodBase64URL2, $ZodE1642, $ZodJWT2, $ZodCustomStringFormat2, $ZodNumber2, $ZodNumberFormat2, $ZodBoolean2, $ZodBigInt2, $ZodBigIntFormat2, $ZodSymbol2, $ZodUndefined2, $ZodNull2, $ZodAny2, $ZodUnknown2, $ZodNever2, $ZodVoid2, $ZodDate2, $ZodArray2, $ZodObject2, $ZodObjectJIT2, $ZodUnion2, $ZodDiscriminatedUnion2, $ZodIntersection2, $ZodTuple2, $ZodRecord2, $ZodMap2, $ZodSet2, $ZodEnum2, $ZodLiteral2, $ZodFile2, $ZodTransform2, $ZodOptional2, $ZodNullable2, $ZodDefault2, $ZodPrefault2, $ZodNonOptional2, $ZodSuccess2, $ZodCatch2, $ZodNaN2, $ZodPipe2, $ZodCodec2, $ZodReadonly2, $ZodTemplateLiteral2, $ZodFunction2, $ZodPromise2, $ZodLazy2, $ZodCustom2;
var init_schemas3 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/schemas.js"() {
    init_checks3();
    init_core3();
    init_doc2();
    init_parse3();
    init_regexes2();
    init_util2();
    init_versions2();
    init_util2();
    $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
      var _a2;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version2;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted = aborted2(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError2();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = aborted2(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = aborted2(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        const handleCanaryResult = (canary, payload, ctx) => {
          if (aborted2(canary)) {
            canary.aborted = true;
            return canary;
          }
          const checkResult = runChecks(payload, checks, ctx);
          if (checkResult instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError2();
            return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
          }
          return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
          if (ctx.skipChecks) {
            return inst._zod.parse(payload, ctx);
          }
          if (ctx.direction === "backward") {
            const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
            if (canary instanceof Promise) {
              return canary.then((canary2) => {
                return handleCanaryResult(canary2, payload, ctx);
              });
            }
            return handleCanaryResult(canary, payload, ctx);
          }
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError2();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      inst["~standard"] = {
        validate: (value) => {
          try {
            const r = safeParse3(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      };
    });
    $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat2.init(inst, def);
      $ZodString2.init(inst, def);
    });
    $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid3);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid3(v));
      } else
        def.pattern ?? (def.pattern = uuid3());
      $ZodStringFormat2.init(inst, def);
    });
    $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email3);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
      $ZodStringFormat2.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const trimmed = payload.value.trim();
          const url3 = new URL(trimmed);
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url3.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: hostname3.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url3.protocol.endsWith(":") ? url3.protocol.slice(0, -1) : url3.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.normalize) {
            payload.value = url3.href;
          } else {
            payload.value = trimmed;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji3());
      $ZodStringFormat2.init(inst, def);
    });
    $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid3);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid4);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid23);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid3);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid3);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid3);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime3(def));
      $ZodStringFormat2.init(inst, def);
    });
    $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date5);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time3(def));
      $ZodStringFormat2.init(inst, def);
    });
    $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration3);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv43);
      $ZodStringFormat2.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv4`;
      });
    });
    $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv63);
      $ZodStringFormat2.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv43);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv63);
      $ZodStringFormat2.init(inst, def);
      inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
          if (parts.length !== 2)
            throw new Error();
          const [address, prefix] = parts;
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base643);
      $ZodStringFormat2.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
        if (isValidBase642(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url3);
      $ZodStringFormat2.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64URL2(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e1643);
      $ZodStringFormat2.init(inst, def);
    });
    $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
      $ZodStringFormat2.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT2(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat2.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number4;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
      $ZodCheckNumberFormat2.init(inst, def);
      $ZodNumber2.init(inst, def);
    });
    $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.pattern = boolean4;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.pattern = bigint4;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
      $ZodCheckBigIntFormat2.init(inst, def);
      $ZodBigInt2.init(inst, def);
    });
    $ZodSymbol2 = /* @__PURE__ */ $constructor2("$ZodSymbol", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined2 = /* @__PURE__ */ $constructor2("$ZodUndefined", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.pattern = _undefined4;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.pattern = _null4;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny2 = /* @__PURE__ */ $constructor2("$ZodAny", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid2 = /* @__PURE__ */ $constructor2("$ZodVoid", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate2 = /* @__PURE__ */ $constructor2("$ZodDate", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
          } else {
            handleArrayResult2(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
      $ZodType2.init(inst, def);
      const _normalized = cached2(() => normalizeDef2(def));
      defineLazy2(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const isObject4 = isObject3;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
          const el = shape[key];
          const r = el._zod.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
          } else {
            handlePropertyResult2(r, payload, key, input);
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall2(proms, input, payload, ctx, _normalized.value, inst);
      };
    });
    $ZodObjectJIT2 = /* @__PURE__ */ $constructor2("$ZodObjectJIT", (inst, def) => {
      $ZodObject2.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = cached2(() => normalizeDef2(def));
      const generateFastpass = (shape) => {
        const doc = new Doc2(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = esc2(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
          const id = ids[key];
          const k = esc2(key);
          doc.write(`const ${id} = ${parseStr(key)};`);
          doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject4 = isObject3;
      const jit = !globalConfig2.jitless;
      const allowsEval3 = allowsEval2;
      const fastEnabled = jit && allowsEval3.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject4(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
          if (!catchall)
            return payload;
          return handleCatchall2([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
      };
    });
    $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      defineLazy2(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy2(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
        }
        return void 0;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults2(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults2(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
      $ZodUnion2.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy2(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached2(() => {
        const opts = def.options;
        const map3 = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues?.[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map3.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map3.set(v, o);
          }
        }
        return map3;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject3(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          discriminator: def.discriminator,
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults2(payload, left2, right2);
          });
        }
        return handleIntersectionResults2(payload, left, right);
      };
    });
    $ZodTuple2 = /* @__PURE__ */ $constructor2("$ZodTuple", (inst, def) => {
      $ZodType2.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
              input,
              inst,
              origin: "array"
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
          } else {
            handleTupleResult2(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
            } else {
              handleTupleResult2(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject2(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
          const values = def.keyType._zod.values;
          payload.value = {};
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues2(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues2(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!values.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
                input: key,
                path: [key],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues2(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues2(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap2 = /* @__PURE__ */ $constructor2("$ZodMap", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodSet2 = /* @__PURE__ */ $constructor2("$ZodSet", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult2(result2, payload)));
          } else
            handleSetResult2(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
      $ZodType2.init(inst, def);
      const values = getEnumValues2(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
      $ZodType2.init(inst, def);
      if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
      }
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile2 = /* @__PURE__ */ $constructor2("$ZodFile", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError2(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError2();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy2(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy2(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise)
            return result.then((r) => handleOptionalResult2(r, payload.value));
          return handleOptionalResult2(result, payload.value);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy2(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : void 0;
      });
      defineLazy2(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult2(result2, def));
        }
        return handleDefaultResult2(result, def);
      };
    });
    $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult2(result2, inst));
        }
        return handleNonOptionalResult2(result, inst);
      };
    });
    $ZodSuccess2 = /* @__PURE__ */ $constructor2("$ZodSuccess", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError2("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN2 = /* @__PURE__ */ $constructor2("$ZodNaN", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "values", () => def.in._zod.values);
      defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handlePipeResult2(right2, def.in, ctx));
          }
          return handlePipeResult2(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult2(left2, def.out, ctx));
        }
        return handlePipeResult2(left, def.out, ctx);
      };
    });
    $ZodCodec2 = /* @__PURE__ */ $constructor2("$ZodCodec", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "values", () => def.in._zod.values);
      defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handleCodecAResult2(left2, def, ctx));
          }
          return handleCodecAResult2(left, def, ctx);
        } else {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handleCodecAResult2(right2, def, ctx));
          }
          return handleCodecAResult2(right, def, ctx);
        }
      };
    });
    $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult2);
        }
        return handleReadonlyResult2(result);
      };
    });
    $ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("$ZodTemplateLiteral", (inst, def) => {
      $ZodType2.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes2.has(typeof part)) {
          regexParts.push(escapeRegex2(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: def.format ?? "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodFunction2 = /* @__PURE__ */ $constructor2("$ZodFunction", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        return function(...args) {
          const parsedArgs = inst._def.input ? parse3(inst._def.input, args) : args;
          const result = Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return parse3(inst._def.output, result);
          }
          return result;
        };
      };
      inst.implementAsync = (func) => {
        if (typeof func !== "function") {
          throw new Error("implementAsync() must be called with a function");
        }
        return async function(...args) {
          const parsedArgs = inst._def.input ? await parseAsync3(inst._def.input, args) : args;
          const result = await Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return await parseAsync3(inst._def.output, result);
          }
          return result;
        };
      };
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
          payload.issues.push({
            code: "invalid_type",
            expected: "function",
            input: payload.value,
            inst
          });
          return payload;
        }
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
          payload.value = inst.implementAsync(payload.value);
        } else {
          payload.value = inst.implement(payload.value);
        }
        return payload;
      };
      inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple2({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: inst._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: inst._def.output
        });
      };
      inst.output = (output) => {
        const F = inst.constructor;
        return new F({
          type: "function",
          input: inst._def.input,
          output
        });
      };
      return inst;
    });
    $ZodPromise2 = /* @__PURE__ */ $constructor2("$ZodPromise", (inst, def) => {
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy2 = /* @__PURE__ */ $constructor2("$ZodLazy", (inst, def) => {
      $ZodType2.init(inst, def);
      defineLazy2(inst._zod, "innerType", () => def.getter());
      defineLazy2(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      defineLazy2(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
      defineLazy2(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
      defineLazy2(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
      $ZodCheck2.init(inst, def);
      $ZodType2.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
        }
        handleRefineResult2(r, payload, input, inst);
        return;
      };
    });
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ar.js
function ar_default2() {
  return {
    localeError: error48()
  };
}
var error48;
var init_ar2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ar.js"() {
    init_util2();
    error48 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/az.js
function az_default2() {
  return {
    localeError: error49()
  };
}
var error49;
var init_az2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/az.js"() {
    init_util2();
    error49 = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue3.expected}, daxil olan ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive2(issue3.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/be.js
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default2() {
  return {
    localeError: error50()
  };
}
var error50;
var init_be2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/be.js"() {
    init_util2();
    error50 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0456\u045E";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const maxValue = Number(issue3.maximum);
              const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const minValue = Number(issue3.minimum);
              const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ca.js
function ca_default2() {
  return {
    localeError: error51()
  };
}
var error51;
var init_ca2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ca.js"() {
    init_util2();
    error51 = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Tipus inv\xE0lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType8(issue3.input)}`;
          // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue3.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/cs.js
function cs_default2() {
  return {
    localeError: error52()
  };
}
var error52;
var init_cs2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/cs.js"() {
    init_util2();
    error52 = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
          }
          case "string": {
            return "\u0159et\u011Bzec";
          }
          case "boolean": {
            return "boolean";
          }
          case "bigint": {
            return "bigint";
          }
          case "function": {
            return "funkce";
          }
          case "symbol": {
            return "symbol";
          }
          case "undefined": {
            return "undefined";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "pole";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue3.expected}, obdr\u017Eeno ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive2(issue3.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue3.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/da.js
function da_default2() {
  return {
    localeError: error53()
  };
}
var error53;
var init_da2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/da.js"() {
    init_util2();
    error53 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "havde" },
        file: { unit: "bytes", verb: "havde" },
        array: { unit: "elementer", verb: "indeholdt" },
        set: { unit: "elementer", verb: "indeholdt" }
      };
      const TypeNames = {
        string: "streng",
        number: "tal",
        boolean: "boolean",
        array: "liste",
        object: "objekt",
        set: "s\xE6t",
        file: "fil"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type) {
        return TypeNames[type] ?? type;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
            return "objekt";
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-mailadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkesl\xE6t",
        date: "ISO-dato",
        time: "ISO-klokkesl\xE6t",
        duration: "ISO-varighed",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodet streng",
        base64url: "base64url-kodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ugyldigt input: forventede ${getTypeName(issue3.expected)}, fik ${getTypeName(parsedType8(issue3.input))}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive2(issue3.values[0])}`;
            return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            const origin = getTypeName(issue3.origin);
            if (sizing)
              return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            const origin = getTypeName(issue3.origin);
            if (sizing) {
              return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8gle i ${issue3.origin}`;
          case "invalid_union":
            return "Ugyldigt input: matcher ingen af de tilladte typer";
          case "invalid_element":
            return `Ugyldig v\xE6rdi i ${issue3.origin}`;
          default:
            return `Ugyldigt input`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/de.js
function de_default2() {
  return {
    localeError: error54()
  };
}
var error54;
var init_de2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/de.js"() {
    init_util2();
    error54 = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "Zahl";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "Array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ung\xFCltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue3.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/en.js
function en_default2() {
  return {
    localeError: error55()
  };
}
var parsedType2, error55;
var init_en2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/en.js"() {
    init_util2();
    parsedType2 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error55 = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Invalid input: expected ${issue3.expected}, received ${parsedType2(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
            return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue3.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue3.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/eo.js
function eo_default2() {
  return {
    localeError: error56()
  };
}
var parsedType3, error56;
var init_eo2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/eo.js"() {
    init_util2();
    parsedType3 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombro";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabelo";
          }
          if (data === null) {
            return "senvalora";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error56 = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Nevalida enigo: atendi\u011Dis ${issue3.expected}, ricevi\u011Dis ${parsedType3(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive2(issue3.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue3.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue3.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/es.js
function es_default2() {
  return {
    localeError: error57()
  };
}
var error57;
var init_es2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/es.js"() {
    init_util2();
    error57 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      const TypeNames = {
        string: "texto",
        number: "n\xFAmero",
        boolean: "booleano",
        array: "arreglo",
        object: "objeto",
        set: "conjunto",
        file: "archivo",
        date: "fecha",
        bigint: "n\xFAmero grande",
        symbol: "s\xEDmbolo",
        undefined: "indefinido",
        null: "nulo",
        function: "funci\xF3n",
        map: "mapa",
        record: "registro",
        tuple: "tupla",
        enum: "enumeraci\xF3n",
        union: "uni\xF3n",
        literal: "literal",
        promise: "promesa",
        void: "vac\xEDo",
        never: "nunca",
        unknown: "desconocido",
        any: "cualquiera"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type) {
        return TypeNames[type] ?? type;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype) {
              return data.constructor.name;
            }
            return "object";
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue3.expected)}, recibido ${getTypeName(parsedType8(issue3.input))}`;
          // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            const origin = getTypeName(issue3.origin);
            if (sizing)
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            const origin = getTypeName(issue3.origin);
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${getTypeName(issue3.origin)}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${getTypeName(issue3.origin)}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fa.js
function fa_default2() {
  return {
    localeError: error58()
  };
}
var error58;
var init_fa2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fa.js"() {
    init_util2();
    error58 = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u0627\u06CC\u0647";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType8(issue3.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          case "invalid_value":
            if (issue3.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive2(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues2(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fi.js
function fi_default2() {
  return {
    localeError: error59()
  };
}
var error59;
var init_fi2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fi.js"() {
    init_util2();
    error59 = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr.js
function fr_default2() {
  return {
    localeError: error60()
  };
}
var error60;
var init_fr2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr.js"() {
    init_util2();
    error60 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombre";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tableau";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : ${issue3.expected} attendu, ${parsedType8(issue3.input)} re\xE7u`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue3.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue3.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default2() {
  return {
    localeError: error61()
  };
}
var error61;
var init_fr_CA2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr-CA.js"() {
    init_util2();
    error61 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : attendu ${issue3.expected}, re\xE7u ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue3.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue3.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/he.js
function he_default2() {
  return {
    localeError: error62()
  };
}
var error62;
var init_he2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/he.js"() {
    init_util2();
    error62 = () => {
      const Sizable = {
        string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u05E7\u05DC\u05D8",
        email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
        url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
        emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
        date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
        time: "\u05D6\u05DE\u05DF ISO",
        duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
        ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
        ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
        cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
        cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
        base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
        base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
        json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
        e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
        jwt: "JWT",
        template_literal: "\u05E7\u05DC\u05D8"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType8(issue3.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element":
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/hu.js
function hu_default2() {
  return {
    localeError: error63()
  };
}
var error63;
var init_hu2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/hu.js"() {
    init_util2();
    error63 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "sz\xE1m";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "t\xF6mb";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue3.expected}, a kapott \xE9rt\xE9k ${parsedType8(issue3.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive2(issue3.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/id.js
function id_default2() {
  return {
    localeError: error64()
  };
}
var error64;
var init_id2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/id.js"() {
    init_util2();
    error64 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue3.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue3.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/is.js
function is_default2() {
  return {
    localeError: error65()
  };
}
var parsedType4, error65;
var init_is2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/is.js"() {
    init_util2();
    parsedType4 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "n\xFAmer";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "fylki";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error65 = () => {
      const Sizable = {
        string: { unit: "stafi", verb: "a\xF0 hafa" },
        file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
        array: { unit: "hluti", verb: "a\xF0 hafa" },
        set: { unit: "hluti", verb: "a\xF0 hafa" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "gildi",
        email: "netfang",
        url: "vefsl\xF3\xF0",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dagsetning og t\xEDmi",
        date: "ISO dagsetning",
        time: "ISO t\xEDmi",
        duration: "ISO t\xEDmalengd",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded strengur",
        base64url: "base64url-encoded strengur",
        json_string: "JSON strengur",
        e164: "E.164 t\xF6lugildi",
        jwt: "JWT",
        template_literal: "gildi"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue3.input)} \xFEar sem \xE1 a\xF0 vera ${issue3.expected}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive2(issue3.values[0])}`;
            return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
            return `Rangt ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Rangur lykill \xED ${issue3.origin}`;
          case "invalid_union":
            return "Rangt gildi";
          case "invalid_element":
            return `Rangt gildi \xED ${issue3.origin}`;
          default:
            return `Rangt gildi`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/it.js
function it_default2() {
  return {
    localeError: error66()
  };
}
var error66;
var init_it2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/it.js"() {
    init_util2();
    error66 = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "vettore";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType8(issue3.input)}`;
          // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue3.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue3.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ja.js
function ja_default2() {
  return {
    localeError: error67()
  };
}
var error67;
var init_ja2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ja.js"() {
    init_util2();
    error67 = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u914D\u5217";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u7121\u52B9\u306A\u5165\u529B: ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType8(issue3.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive2(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues2(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues2(issue3.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ka.js
function ka_default2() {
  return {
    localeError: error68()
  };
}
var parsedType5, error68;
var init_ka2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ka.js"() {
    init_util2();
    parsedType5 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      const typeMap = {
        string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
        undefined: "undefined",
        bigint: "bigint",
        symbol: "symbol",
        function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
      };
      return typeMap[t] ?? t;
    };
    error68 = () => {
      const Sizable = {
        string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
        email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        url: "URL",
        emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
        date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
        time: "\u10D3\u10E0\u10DD",
        duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
        ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
        jwt: "JWT",
        template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues2(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
            }
            if (_issue.format === "ends_with")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
            if (_issue.format === "includes")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
            if (_issue.format === "regex")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
          case "unrecognized_keys":
            return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
          case "invalid_union":
            return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
          case "invalid_element":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
          default:
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/km.js
function km_default2() {
  return {
    localeError: error69()
  };
}
var error69;
var init_km2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/km.js"() {
    init_util2();
    error69 = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u17A2\u17B6\u179A\u17C1 (Array)";
            }
            if (data === null) {
              return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/kh.js
function kh_default2() {
  return km_default2();
}
var init_kh2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/kh.js"() {
    init_km2();
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ko.js
function ko_default2() {
  return {
    localeError: error70()
  };
}
var error70;
var init_ko2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ko.js"() {
    init_util2();
    error70 = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType8(issue3.input)}\uC785\uB2C8\uB2E4`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive2(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues2(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue3.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue3.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber2(number7) {
  const abs = Math.abs(number7);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default2() {
  return {
    localeError: error71()
  };
}
var parsedType6, parsedTypeFromType, capitalizeFirstCharacter2, error71;
var init_lt2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/lt.js"() {
    init_util2();
    parsedType6 = (data) => {
      const t = typeof data;
      return parsedTypeFromType(t, data);
    };
    parsedTypeFromType = (t, data = void 0) => {
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
        }
        case "bigint": {
          return "sveikasis skai\u010Dius";
        }
        case "string": {
          return "eilut\u0117";
        }
        case "boolean": {
          return "login\u0117 reik\u0161m\u0117";
        }
        case "undefined":
        case "void": {
          return "neapibr\u0117\u017Eta reik\u0161m\u0117";
        }
        case "function": {
          return "funkcija";
        }
        case "symbol": {
          return "simbolis";
        }
        case "object": {
          if (data === void 0)
            return "ne\u017Einomas objektas";
          if (data === null)
            return "nulin\u0117 reik\u0161m\u0117";
          if (Array.isArray(data))
            return "masyvas";
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
          return "objektas";
        }
        //Zod types below
        case "null": {
          return "nulin\u0117 reik\u0161m\u0117";
        }
      }
      return t;
    };
    capitalizeFirstCharacter2 = (text) => {
      return text.charAt(0).toUpperCase() + text.slice(1);
    };
    error71 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "simbolis",
            few: "simboliai",
            many: "simboli\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
              notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
              notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
            }
          }
        },
        file: {
          unit: {
            one: "baitas",
            few: "baitai",
            many: "bait\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne didesnis kaip",
              notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
              notInclusive: "turi b\u016Bti didesnis kaip"
            }
          }
        },
        array: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        },
        set: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        }
      };
      function getSizing(origin, unitType, inclusive, targetShouldBe) {
        const result = Sizable[origin] ?? null;
        if (result === null)
          return result;
        return {
          unit: result.unit[unitType],
          verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
        };
      }
      const Nouns = {
        regex: "\u012Fvestis",
        email: "el. pa\u0161to adresas",
        url: "URL",
        emoji: "jaustukas",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO data ir laikas",
        date: "ISO data",
        time: "ISO laikas",
        duration: "ISO trukm\u0117",
        ipv4: "IPv4 adresas",
        ipv6: "IPv6 adresas",
        cidrv4: "IPv4 tinklo prefiksas (CIDR)",
        cidrv6: "IPv6 tinklo prefiksas (CIDR)",
        base64: "base64 u\u017Ekoduota eilut\u0117",
        base64url: "base64url u\u017Ekoduota eilut\u0117",
        json_string: "JSON eilut\u0117",
        e164: "E.164 numeris",
        jwt: "JWT",
        template_literal: "\u012Fvestis"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Gautas tipas ${parsedType6(issue3.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue3.expected)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Privalo b\u016Bti ${stringifyPrimitive2(issue3.values[0])}`;
            return `Privalo b\u016Bti vienas i\u0161 ${joinValues2(issue3.values, "|")} pasirinkim\u0173`;
          case "too_big": {
            const origin = parsedTypeFromType(issue3.origin);
            const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue3.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
            return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
          }
          case "too_small": {
            const origin = parsedTypeFromType(issue3.origin);
            const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue3.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
            return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
            return `Neteisingas ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
          case "unrecognized_keys":
            return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return "Rastas klaidingas raktas";
          case "invalid_union":
            return "Klaidinga \u012Fvestis";
          case "invalid_element": {
            const origin = parsedTypeFromType(issue3.origin);
            return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
          }
          default:
            return "Klaidinga \u012Fvestis";
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/mk.js
function mk_default2() {
  return {
    localeError: error72()
  };
}
var error72;
var init_mk2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/mk.js"() {
    init_util2();
    error72 = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043D\u0438\u0437\u0430";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType8(issue3.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ms.js
function ms_default2() {
  return {
    localeError: error73()
  };
}
var error73;
var init_ms2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ms.js"() {
    init_util2();
    error73 = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombor";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue3.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue3.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/nl.js
function nl_default2() {
  return {
    localeError: error74()
  };
}
var error74;
var init_nl2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/nl.js"() {
    init_util2();
    error74 = () => {
      const Sizable = {
        string: { unit: "tekens" },
        file: { unit: "bytes" },
        array: { unit: "elementen" },
        set: { unit: "elementen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "getal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
            return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
            }
            return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue3.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue3.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/no.js
function no_default2() {
  return {
    localeError: error75()
  };
}
var error75;
var init_no2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/no.js"() {
    init_util2();
    error75 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tall";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue3.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue3.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ota.js
function ota_default2() {
  return {
    localeError: error76()
  };
}
var error76;
var init_ota2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ota.js"() {
    init_util2();
    error76 = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numara";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "saf";
            }
            if (data === null) {
              return "gayb";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `F\xE2sit giren: umulan ${issue3.expected}, al\u0131nan ${parsedType8(issue3.input)}`;
          // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ps.js
function ps_default2() {
  return {
    localeError: error77()
  };
}
var error77;
var init_ps2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ps.js"() {
    init_util2();
    error77 = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0627\u0631\u06D0";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType8(issue3.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          case "invalid_value":
            if (issue3.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive2(issue3.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues2(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pl.js
function pl_default2() {
  return {
    localeError: error78()
  };
}
var error78;
var init_pl2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pl.js"() {
    init_util2();
    error78 = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "liczba";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tablica";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pt.js
function pt_default2() {
  return {
    localeError: error79()
  };
}
var error79;
var init_pt2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pt.js"() {
    init_util2();
    error79 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Tipo inv\xE1lido: esperado ${issue3.expected}, recebido ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue3.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue3.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ru.js
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default2() {
  return {
    localeError: error80()
  };
}
var error80;
var init_ru2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ru.js"() {
    init_util2();
    error80 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const maxValue = Number(issue3.maximum);
              const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              const minValue = Number(issue3.minimum);
              const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sl.js
function sl_default2() {
  return {
    localeError: error81()
  };
}
var error81;
var init_sl2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sl.js"() {
    init_util2();
    error81 = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tabela";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Neveljaven vnos: pri\u010Dakovano ${issue3.expected}, prejeto ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive2(issue3.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue3.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue3.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sv.js
function sv_default2() {
  return {
    localeError: error82()
  };
}
var error82;
var init_sv2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sv.js"() {
    init_util2();
    error82 = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "antal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "lista";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue3.expected}, fick ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive2(issue3.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
          case "unrecognized_keys":
            return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ta.js
function ta_default2() {
  return {
    localeError: error83()
  };
}
var error83;
var init_ta2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ta.js"() {
    init_util2();
    error83 = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0B85\u0BA3\u0BBF";
            }
            if (data === null) {
              return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues2(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/th.js
function th_default2() {
  return {
    localeError: error84()
  };
}
var error84;
var init_th2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/th.js"() {
    init_util2();
    error84 = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
            }
            if (data === null) {
              return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/tr.js
function tr_default2() {
  return {
    localeError: error85()
  };
}
var parsedType7, error85;
var init_tr2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/tr.js"() {
    init_util2();
    parsedType7 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    error85 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `Ge\xE7ersiz de\u011Fer: beklenen ${issue3.expected}, al\u0131nan ${parsedType7(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/uk.js
function uk_default2() {
  return {
    localeError: error86()
  };
}
var error86;
var init_uk2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/uk.js"() {
    init_util2();
    error86 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue3.input)}`;
          // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ua.js
function ua_default2() {
  return uk_default2();
}
var init_ua2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ua.js"() {
    init_uk2();
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ur.js
function ur_default2() {
  return {
    localeError: error87()
  };
}
var error87;
var init_ur2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ur.js"() {
    init_util2();
    error87 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u06D2";
            }
            if (data === null) {
              return "\u0646\u0644";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue3.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive2(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues2(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/vi.js
function vi_default2() {
  return {
    localeError: error88()
  };
}
var error88;
var init_vi2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/vi.js"() {
    init_util2();
    error88 = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "s\u1ED1";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "m\u1EA3ng";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive2(issue3.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default2() {
  return {
    localeError: error89()
  };
}
var error89;
var init_zh_CN2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-CN.js"() {
    init_util2();
    error89 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u6570\u7EC4";
            }
            if (data === null) {
              return "\u7A7A\u503C(null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default2() {
  return {
    localeError: error90()
  };
}
var error90;
var init_zh_TW2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-TW.js"() {
    init_util2();
    error90 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive2(issue3.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues2(issue3.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/yo.js
function yo_default2() {
  return {
    localeError: error91()
  };
}
var error91;
var init_yo2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/yo.js"() {
    init_util2();
    error91 = () => {
      const Sizable = {
        string: { unit: "\xE0mi", verb: "n\xED" },
        file: { unit: "bytes", verb: "n\xED" },
        array: { unit: "nkan", verb: "n\xED" },
        set: { unit: "nkan", verb: "n\xED" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "akop\u1ECD";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
        email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\xE0k\xF3k\xF2 ISO",
        date: "\u1ECDj\u1ECD\u0301 ISO",
        time: "\xE0k\xF3k\xF2 ISO",
        duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
        ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
        ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
        cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
        cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
        base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
        base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
        json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
        e164: "n\u1ECD\u0301mb\xE0 E.164",
        jwt: "JWT",
        template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
      };
      return (issue3) => {
        switch (issue3.code) {
          case "invalid_type":
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue3.input)}`;
          case "invalid_value":
            if (issue3.values.length === 1)
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive2(issue3.values[0])}`;
            return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues2(issue3.values, "|")}`;
          case "too_big": {
            const adj = issue3.inclusive ? "<=" : "<";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
          }
          case "too_small": {
            const adj = issue3.inclusive ? ">=" : ">";
            const sizing = getSizing(issue3.origin);
            if (sizing)
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
          }
          case "invalid_format": {
            const _issue = issue3;
            if (_issue.format === "starts_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
            return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue3.format}`;
          }
          case "not_multiple_of":
            return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
          case "unrecognized_keys":
            return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues2(issue3.keys, ", ")}`;
          case "invalid_key":
            return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
          case "invalid_union":
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          case "invalid_element":
            return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
          default:
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        }
      };
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/index.js
var locales_exports2 = {};
__export(locales_exports2, {
  ar: () => ar_default2,
  az: () => az_default2,
  be: () => be_default2,
  ca: () => ca_default2,
  cs: () => cs_default2,
  da: () => da_default2,
  de: () => de_default2,
  en: () => en_default2,
  eo: () => eo_default2,
  es: () => es_default2,
  fa: () => fa_default2,
  fi: () => fi_default2,
  fr: () => fr_default2,
  frCA: () => fr_CA_default2,
  he: () => he_default2,
  hu: () => hu_default2,
  id: () => id_default2,
  is: () => is_default2,
  it: () => it_default2,
  ja: () => ja_default2,
  ka: () => ka_default2,
  kh: () => kh_default2,
  km: () => km_default2,
  ko: () => ko_default2,
  lt: () => lt_default2,
  mk: () => mk_default2,
  ms: () => ms_default2,
  nl: () => nl_default2,
  no: () => no_default2,
  ota: () => ota_default2,
  pl: () => pl_default2,
  ps: () => ps_default2,
  pt: () => pt_default2,
  ru: () => ru_default2,
  sl: () => sl_default2,
  sv: () => sv_default2,
  ta: () => ta_default2,
  th: () => th_default2,
  tr: () => tr_default2,
  ua: () => ua_default2,
  uk: () => uk_default2,
  ur: () => ur_default2,
  vi: () => vi_default2,
  yo: () => yo_default2,
  zhCN: () => zh_CN_default2,
  zhTW: () => zh_TW_default2
});
var init_locales2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/index.js"() {
    init_ar2();
    init_az2();
    init_be2();
    init_ca2();
    init_cs2();
    init_da2();
    init_de2();
    init_en2();
    init_eo2();
    init_es2();
    init_fa2();
    init_fi2();
    init_fr2();
    init_fr_CA2();
    init_he2();
    init_hu2();
    init_id2();
    init_is2();
    init_it2();
    init_ja2();
    init_ka2();
    init_kh2();
    init_km2();
    init_ko2();
    init_lt2();
    init_mk2();
    init_ms2();
    init_nl2();
    init_no2();
    init_ota2();
    init_ps2();
    init_pl2();
    init_pt2();
    init_ru2();
    init_sl2();
    init_sv2();
    init_ta2();
    init_th2();
    init_tr2();
    init_ua2();
    init_uk2();
    init_ur2();
    init_vi2();
    init_zh_CN2();
    init_zh_TW2();
    init_yo2();
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/registries.js
function registry2() {
  return new $ZodRegistry2();
}
var $output2, $input2, $ZodRegistry2, globalRegistry2;
var init_registries2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/registries.js"() {
    $output2 = Symbol("ZodOutput");
    $input2 = Symbol("ZodInput");
    $ZodRegistry2 = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta3 = _meta[0];
        this._map.set(schema, meta3);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          if (this._idmap.has(meta3.id)) {
            throw new Error(`ID ${meta3.id} already exists in the registry`);
          }
          this._idmap.set(meta3.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta3 = this._map.get(schema);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.delete(meta3.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          const f = { ...pm, ...this._map.get(schema) };
          return Object.keys(f).length ? f : void 0;
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    globalRegistry2 = /* @__PURE__ */ registry2();
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
function _undefined5(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _void3(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _positive2(params) {
  return _gt2(0, params);
}
function _negative2(params) {
  return _lt2(0, params);
}
function _nonpositive2(params) {
  return _lte2(0, params);
}
function _nonnegative2(params) {
  return _gte2(0, params);
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _property2(property, schema, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema,
    ...normalizeParams2(params)
  });
}
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams2(params)
  });
}
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone2(defaultValue);
    }
  });
}
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch3(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
function _superRefine2(fn) {
  const ch = _check2((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue2(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check2(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec2;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec3 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec3,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec3;
}
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
var TimePrecision2;
var init_api2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/api.js"() {
    init_checks3();
    init_schemas3();
    init_util2();
    TimePrecision2 = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/to-json-schema.js
function toJSONSchema2(input, _params) {
  if (input instanceof $ZodRegistry2) {
    const gen2 = new JSONSchemaGenerator2(_params);
    const defs = {};
    for (const entry2 of input._idmap.entries()) {
      const [_, schema] = entry2;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry2 of input._idmap.entries()) {
      const [key, schema] = entry2;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator2(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming2(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming2(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming2(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming2(item, ctx))
          return true;
      }
      if (def.rest && isTransforming2(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "map": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "set": {
      return isTransforming2(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming2(def.innerType, ctx);
    case "lazy":
      return isTransforming2(def.getter(), ctx);
    case "default": {
      return isTransforming2(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming2(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
var JSONSchemaGenerator2;
var init_to_json_schema2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/to-json-schema.js"() {
    init_registries2();
    init_util2();
    JSONSchemaGenerator2 = class {
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? globalRegistry2;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => {
        });
        this.io = params?.io ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
        var _a2;
        const def = schema._zod.def;
        const formatMap2 = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: ""
          // do not set
        };
        const seen = this.seen.get(schema);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
        this.seen.set(schema, result);
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
          result.schema = overrideSchema;
        } else {
          const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema],
            path: _params.path
          };
          const parent = schema._zod.parent;
          if (parent) {
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
          } else {
            const _json = result.schema;
            switch (def.type) {
              case "string": {
                const json3 = _json;
                json3.type = "string";
                const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minLength = minimum;
                if (typeof maximum === "number")
                  json3.maxLength = maximum;
                if (format) {
                  json3.format = formatMap2[format] ?? format;
                  if (json3.format === "")
                    delete json3.format;
                }
                if (contentEncoding)
                  json3.contentEncoding = contentEncoding;
                if (patterns && patterns.size > 0) {
                  const regexes = [...patterns];
                  if (regexes.length === 1)
                    json3.pattern = regexes[0].source;
                  else if (regexes.length > 1) {
                    result.schema.allOf = [
                      ...regexes.map((regex) => ({
                        ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                        pattern: regex.source
                      }))
                    ];
                  }
                }
                break;
              }
              case "number": {
                const json3 = _json;
                const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                if (typeof format === "string" && format.includes("int"))
                  json3.type = "integer";
                else
                  json3.type = "number";
                if (typeof exclusiveMinimum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.minimum = exclusiveMinimum;
                    json3.exclusiveMinimum = true;
                  } else {
                    json3.exclusiveMinimum = exclusiveMinimum;
                  }
                }
                if (typeof minimum === "number") {
                  json3.minimum = minimum;
                  if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                    if (exclusiveMinimum >= minimum)
                      delete json3.minimum;
                    else
                      delete json3.exclusiveMinimum;
                  }
                }
                if (typeof exclusiveMaximum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.maximum = exclusiveMaximum;
                    json3.exclusiveMaximum = true;
                  } else {
                    json3.exclusiveMaximum = exclusiveMaximum;
                  }
                }
                if (typeof maximum === "number") {
                  json3.maximum = maximum;
                  if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                    if (exclusiveMaximum <= maximum)
                      delete json3.maximum;
                    else
                      delete json3.exclusiveMaximum;
                  }
                }
                if (typeof multipleOf === "number")
                  json3.multipleOf = multipleOf;
                break;
              }
              case "boolean": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt cannot be represented in JSON Schema");
                }
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Symbols cannot be represented in JSON Schema");
                }
                break;
              }
              case "null": {
                if (this.target === "openapi-3.0") {
                  _json.type = "string";
                  _json.nullable = true;
                  _json.enum = [null];
                } else
                  _json.type = "null";
                break;
              }
              case "any": {
                break;
              }
              case "unknown": {
                break;
              }
              case "undefined": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Undefined cannot be represented in JSON Schema");
                }
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Void cannot be represented in JSON Schema");
                }
                break;
              }
              case "never": {
                _json.not = {};
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Date cannot be represented in JSON Schema");
                }
                break;
              }
              case "array": {
                const json3 = _json;
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                json3.type = "array";
                json3.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                break;
              }
              case "object": {
                const json3 = _json;
                json3.type = "object";
                json3.properties = {};
                const shape = def.shape;
                for (const key in shape) {
                  json3.properties[key] = this.process(shape[key], {
                    ...params,
                    path: [...params.path, "properties", key]
                  });
                }
                const allKeys = new Set(Object.keys(shape));
                const requiredKeys = new Set([...allKeys].filter((key) => {
                  const v = def.shape[key]._zod;
                  if (this.io === "input") {
                    return v.optin === void 0;
                  } else {
                    return v.optout === void 0;
                  }
                }));
                if (requiredKeys.size > 0) {
                  json3.required = Array.from(requiredKeys);
                }
                if (def.catchall?._zod.def.type === "never") {
                  json3.additionalProperties = false;
                } else if (!def.catchall) {
                  if (this.io === "output")
                    json3.additionalProperties = false;
                } else if (def.catchall) {
                  json3.additionalProperties = this.process(def.catchall, {
                    ...params,
                    path: [...params.path, "additionalProperties"]
                  });
                }
                break;
              }
              case "union": {
                const json3 = _json;
                const options = def.options.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, "anyOf", i]
                }));
                json3.anyOf = options;
                break;
              }
              case "intersection": {
                const json3 = _json;
                const a = this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                });
                const b = this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                });
                const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                const allOf = [
                  ...isSimpleIntersection(a) ? a.allOf : [a],
                  ...isSimpleIntersection(b) ? b.allOf : [b]
                ];
                json3.allOf = allOf;
                break;
              }
              case "tuple": {
                const json3 = _json;
                json3.type = "array";
                const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                const prefixItems = def.items.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, prefixPath, i]
                }));
                const rest = def.rest ? this.process(def.rest, {
                  ...params,
                  path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
                }) : null;
                if (this.target === "draft-2020-12") {
                  json3.prefixItems = prefixItems;
                  if (rest) {
                    json3.items = rest;
                  }
                } else if (this.target === "openapi-3.0") {
                  json3.items = {
                    anyOf: prefixItems
                  };
                  if (rest) {
                    json3.items.anyOf.push(rest);
                  }
                  json3.minItems = prefixItems.length;
                  if (!rest) {
                    json3.maxItems = prefixItems.length;
                  }
                } else {
                  json3.items = prefixItems;
                  if (rest) {
                    json3.additionalItems = rest;
                  }
                }
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                break;
              }
              case "record": {
                const json3 = _json;
                json3.type = "object";
                if (this.target === "draft-7" || this.target === "draft-2020-12") {
                  json3.propertyNames = this.process(def.keyType, {
                    ...params,
                    path: [...params.path, "propertyNames"]
                  });
                }
                json3.additionalProperties = this.process(def.valueType, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Map cannot be represented in JSON Schema");
                }
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Set cannot be represented in JSON Schema");
                }
                break;
              }
              case "enum": {
                const json3 = _json;
                const values = getEnumValues2(def.entries);
                if (values.every((v) => typeof v === "number"))
                  json3.type = "number";
                if (values.every((v) => typeof v === "string"))
                  json3.type = "string";
                json3.enum = values;
                break;
              }
              case "literal": {
                const json3 = _json;
                const vals = [];
                for (const val of def.values) {
                  if (val === void 0) {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                    } else {
                    }
                  } else if (typeof val === "bigint") {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                    } else {
                      vals.push(Number(val));
                    }
                  } else {
                    vals.push(val);
                  }
                }
                if (vals.length === 0) {
                } else if (vals.length === 1) {
                  const val = vals[0];
                  json3.type = val === null ? "null" : typeof val;
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.enum = [val];
                  } else {
                    json3.const = val;
                  }
                } else {
                  if (vals.every((v) => typeof v === "number"))
                    json3.type = "number";
                  if (vals.every((v) => typeof v === "string"))
                    json3.type = "string";
                  if (vals.every((v) => typeof v === "boolean"))
                    json3.type = "string";
                  if (vals.every((v) => v === null))
                    json3.type = "null";
                  json3.enum = vals;
                }
                break;
              }
              case "file": {
                const json3 = _json;
                const file3 = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary"
                };
                const { minimum, maximum, mime } = schema._zod.bag;
                if (minimum !== void 0)
                  file3.minLength = minimum;
                if (maximum !== void 0)
                  file3.maxLength = maximum;
                if (mime) {
                  if (mime.length === 1) {
                    file3.contentMediaType = mime[0];
                    Object.assign(json3, file3);
                  } else {
                    json3.anyOf = mime.map((m) => {
                      const mFile = { ...file3, contentMediaType: m };
                      return mFile;
                    });
                  }
                } else {
                  Object.assign(json3, file3);
                }
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Transforms cannot be represented in JSON Schema");
                }
                break;
              }
              case "nullable": {
                const inner = this.process(def.innerType, params);
                if (this.target === "openapi-3.0") {
                  result.ref = def.innerType;
                  _json.nullable = true;
                } else {
                  _json.anyOf = [inner, { type: "null" }];
                }
                break;
              }
              case "nonoptional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "success": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "default": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "prefault": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                if (this.io === "input")
                  _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "catch": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                let catchValue;
                try {
                  catchValue = def.catchValue(void 0);
                } catch {
                  throw new Error("Dynamic catch values are not supported in JSON Schema");
                }
                _json.default = catchValue;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") {
                  throw new Error("NaN cannot be represented in JSON Schema");
                }
                break;
              }
              case "template_literal": {
                const json3 = _json;
                const pattern = schema._zod.pattern;
                if (!pattern)
                  throw new Error("Pattern not found in template literal");
                json3.type = "string";
                json3.pattern = pattern.source;
                break;
              }
              case "pipe": {
                const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "readonly": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.readOnly = true;
                break;
              }
              // passthrough types
              case "promise": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "optional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "lazy": {
                const innerType = schema._zod.innerType;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Custom types cannot be represented in JSON Schema");
                }
                break;
              }
              case "function": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Function types cannot be represented in JSON Schema");
                }
                break;
              }
              default: {
                def;
              }
            }
          }
        }
        const meta3 = this.metadataRegistry.get(schema);
        if (meta3)
          Object.assign(result.schema, meta3);
        if (this.io === "input" && isTransforming2(schema)) {
          delete result.schema.examples;
          delete result.schema.default;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema);
        return _result.schema;
      }
      emit(schema, _params) {
        const params = {
          cycles: _params?.cycles ?? "ref",
          reused: _params?.reused ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: _params?.external ?? void 0
        };
        const root = this.seen.get(schema);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = (entry2) => {
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = params.external.registry.get(entry2[0])?.id;
            const uriGenerator = params.external.uri ?? ((id2) => id2);
            if (externalId) {
              return { ref: uriGenerator(externalId) };
            }
            const id = entry2[1].defId ?? entry2[1].schema.id ?? `schema${this.counter++}`;
            entry2[1].defId = id;
            return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
          }
          if (entry2[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry2[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        };
        const extractToDef = (entry2) => {
          if (entry2[1].schema.$ref) {
            return;
          }
          const seen = entry2[1];
          const { ref, defId } = makeURI(entry2);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema2 = seen.schema;
          for (const key in schema2) {
            delete schema2[key];
          }
          schema2.$ref = ref;
        };
        if (params.cycles === "throw") {
          for (const entry2 of this.seen.entries()) {
            const seen = entry2[1];
            if (seen.cycle) {
              throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
          }
        }
        for (const entry2 of this.seen.entries()) {
          const seen = entry2[1];
          if (schema === entry2[0]) {
            extractToDef(entry2);
            continue;
          }
          if (params.external) {
            const ext = params.external.registry.get(entry2[0])?.id;
            if (schema !== entry2[0] && ext) {
              extractToDef(entry2);
              continue;
            }
          }
          const id = this.metadataRegistry.get(entry2[0])?.id;
          if (id) {
            extractToDef(entry2);
            continue;
          }
          if (seen.cycle) {
            extractToDef(entry2);
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry2);
              continue;
            }
          }
        }
        const flattenRef = (zodSchema, params2) => {
          const seen = this.seen.get(zodSchema);
          const schema2 = seen.def ?? seen.schema;
          const _cached = { ...schema2 };
          if (seen.ref === null) {
            return;
          }
          const ref = seen.ref;
          seen.ref = null;
          if (ref) {
            flattenRef(ref, params2);
            const refSchema = this.seen.get(ref).schema;
            if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
              schema2.allOf = schema2.allOf ?? [];
              schema2.allOf.push(refSchema);
            } else {
              Object.assign(schema2, refSchema);
              Object.assign(schema2, _cached);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema,
              jsonSchema: schema2,
              path: seen.path ?? []
            });
        };
        for (const entry2 of [...this.seen.entries()].reverse()) {
          flattenRef(entry2[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else if (this.target === "draft-4") {
          result.$schema = "http://json-schema.org/draft-04/schema#";
        } else if (this.target === "openapi-3.0") {
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
          const id = params.external.registry.get(schema)?.id;
          if (!id)
            throw new Error("Schema is missing an `id` property");
          result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        const defs = params.external?.defs ?? {};
        for (const entry2 of this.seen.entries()) {
          const seen = entry2[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (params.external) {
        } else {
          if (Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
              result.$defs = defs;
            } else {
              result.definitions = defs;
            }
          }
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    };
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/json-schema.js
var json_schema_exports2 = {};
var init_json_schema2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/json-schema.js"() {
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/index.js
var core_exports4 = {};
__export(core_exports4, {
  $ZodAny: () => $ZodAny2,
  $ZodArray: () => $ZodArray2,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodBase64: () => $ZodBase642,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCUID: () => $ZodCUID3,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCatch: () => $ZodCatch2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCodec: () => $ZodCodec2,
  $ZodCustom: () => $ZodCustom2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodDate: () => $ZodDate2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodE164: () => $ZodE1642,
  $ZodEmail: () => $ZodEmail2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEncodeError: () => $ZodEncodeError2,
  $ZodEnum: () => $ZodEnum2,
  $ZodError: () => $ZodError2,
  $ZodFile: () => $ZodFile2,
  $ZodFunction: () => $ZodFunction2,
  $ZodGUID: () => $ZodGUID2,
  $ZodIPv4: () => $ZodIPv42,
  $ZodIPv6: () => $ZodIPv62,
  $ZodISODate: () => $ZodISODate2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodJWT: () => $ZodJWT2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodLazy: () => $ZodLazy2,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodMap: () => $ZodMap2,
  $ZodNaN: () => $ZodNaN2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNever: () => $ZodNever2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNull: () => $ZodNull2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodObject: () => $ZodObject2,
  $ZodObjectJIT: () => $ZodObjectJIT2,
  $ZodOptional: () => $ZodOptional2,
  $ZodPipe: () => $ZodPipe2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPromise: () => $ZodPromise2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodRealError: () => $ZodRealError2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodSet: () => $ZodSet2,
  $ZodString: () => $ZodString2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTuple: () => $ZodTuple2,
  $ZodType: () => $ZodType2,
  $ZodULID: () => $ZodULID2,
  $ZodURL: () => $ZodURL2,
  $ZodUUID: () => $ZodUUID2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodVoid: () => $ZodVoid2,
  $ZodXID: () => $ZodXID2,
  $brand: () => $brand2,
  $constructor: () => $constructor2,
  $input: () => $input2,
  $output: () => $output2,
  Doc: () => Doc2,
  JSONSchema: () => json_schema_exports2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  NEVER: () => NEVER2,
  TimePrecision: () => TimePrecision2,
  _any: () => _any2,
  _array: () => _array2,
  _base64: () => _base642,
  _base64url: () => _base64url2,
  _bigint: () => _bigint2,
  _boolean: () => _boolean2,
  _catch: () => _catch3,
  _check: () => _check2,
  _cidrv4: () => _cidrv42,
  _cidrv6: () => _cidrv62,
  _coercedBigint: () => _coercedBigint2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedDate: () => _coercedDate2,
  _coercedNumber: () => _coercedNumber2,
  _coercedString: () => _coercedString2,
  _cuid: () => _cuid3,
  _cuid2: () => _cuid22,
  _custom: () => _custom2,
  _date: () => _date2,
  _decode: () => _decode2,
  _decodeAsync: () => _decodeAsync2,
  _default: () => _default3,
  _discriminatedUnion: () => _discriminatedUnion2,
  _e164: () => _e1642,
  _email: () => _email2,
  _emoji: () => _emoji4,
  _encode: () => _encode2,
  _encodeAsync: () => _encodeAsync2,
  _endsWith: () => _endsWith2,
  _enum: () => _enum3,
  _file: () => _file2,
  _float32: () => _float322,
  _float64: () => _float642,
  _gt: () => _gt2,
  _gte: () => _gte2,
  _guid: () => _guid2,
  _includes: () => _includes2,
  _int: () => _int2,
  _int32: () => _int322,
  _int64: () => _int642,
  _intersection: () => _intersection2,
  _ipv4: () => _ipv42,
  _ipv6: () => _ipv62,
  _isoDate: () => _isoDate2,
  _isoDateTime: () => _isoDateTime2,
  _isoDuration: () => _isoDuration2,
  _isoTime: () => _isoTime2,
  _jwt: () => _jwt2,
  _ksuid: () => _ksuid2,
  _lazy: () => _lazy2,
  _length: () => _length2,
  _literal: () => _literal2,
  _lowercase: () => _lowercase2,
  _lt: () => _lt2,
  _lte: () => _lte2,
  _map: () => _map2,
  _max: () => _lte2,
  _maxLength: () => _maxLength2,
  _maxSize: () => _maxSize2,
  _mime: () => _mime2,
  _min: () => _gte2,
  _minLength: () => _minLength2,
  _minSize: () => _minSize2,
  _multipleOf: () => _multipleOf2,
  _nan: () => _nan2,
  _nanoid: () => _nanoid2,
  _nativeEnum: () => _nativeEnum2,
  _negative: () => _negative2,
  _never: () => _never2,
  _nonnegative: () => _nonnegative2,
  _nonoptional: () => _nonoptional2,
  _nonpositive: () => _nonpositive2,
  _normalize: () => _normalize2,
  _null: () => _null5,
  _nullable: () => _nullable2,
  _number: () => _number2,
  _optional: () => _optional2,
  _overwrite: () => _overwrite2,
  _parse: () => _parse2,
  _parseAsync: () => _parseAsync2,
  _pipe: () => _pipe2,
  _positive: () => _positive2,
  _promise: () => _promise2,
  _property: () => _property2,
  _readonly: () => _readonly2,
  _record: () => _record2,
  _refine: () => _refine2,
  _regex: () => _regex2,
  _safeDecode: () => _safeDecode2,
  _safeDecodeAsync: () => _safeDecodeAsync2,
  _safeEncode: () => _safeEncode2,
  _safeEncodeAsync: () => _safeEncodeAsync2,
  _safeParse: () => _safeParse2,
  _safeParseAsync: () => _safeParseAsync2,
  _set: () => _set2,
  _size: () => _size2,
  _startsWith: () => _startsWith2,
  _string: () => _string2,
  _stringFormat: () => _stringFormat2,
  _stringbool: () => _stringbool2,
  _success: () => _success2,
  _superRefine: () => _superRefine2,
  _symbol: () => _symbol2,
  _templateLiteral: () => _templateLiteral2,
  _toLowerCase: () => _toLowerCase2,
  _toUpperCase: () => _toUpperCase2,
  _transform: () => _transform2,
  _trim: () => _trim2,
  _tuple: () => _tuple2,
  _uint32: () => _uint322,
  _uint64: () => _uint642,
  _ulid: () => _ulid2,
  _undefined: () => _undefined5,
  _union: () => _union2,
  _unknown: () => _unknown2,
  _uppercase: () => _uppercase2,
  _url: () => _url2,
  _uuid: () => _uuid2,
  _uuidv4: () => _uuidv42,
  _uuidv6: () => _uuidv62,
  _uuidv7: () => _uuidv72,
  _void: () => _void3,
  _xid: () => _xid2,
  clone: () => clone2,
  config: () => config2,
  decode: () => decode3,
  decodeAsync: () => decodeAsync3,
  encode: () => encode3,
  encodeAsync: () => encodeAsync3,
  flattenError: () => flattenError2,
  formatError: () => formatError2,
  globalConfig: () => globalConfig2,
  globalRegistry: () => globalRegistry2,
  isValidBase64: () => isValidBase642,
  isValidBase64URL: () => isValidBase64URL2,
  isValidJWT: () => isValidJWT2,
  locales: () => locales_exports2,
  parse: () => parse3,
  parseAsync: () => parseAsync3,
  prettifyError: () => prettifyError2,
  regexes: () => regexes_exports2,
  registry: () => registry2,
  safeDecode: () => safeDecode3,
  safeDecodeAsync: () => safeDecodeAsync3,
  safeEncode: () => safeEncode3,
  safeEncodeAsync: () => safeEncodeAsync3,
  safeParse: () => safeParse3,
  safeParseAsync: () => safeParseAsync3,
  toDotPath: () => toDotPath2,
  toJSONSchema: () => toJSONSchema2,
  treeifyError: () => treeifyError2,
  util: () => util_exports2,
  version: () => version2
});
var init_core4 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/index.js"() {
    init_core3();
    init_parse3();
    init_errors3();
    init_schemas3();
    init_checks3();
    init_versions2();
    init_util2();
    init_regexes2();
    init_locales2();
    init_registries2();
    init_doc2();
    init_api2();
    init_to_json_schema2();
    init_json_schema2();
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/checks.js
var init_checks4 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/checks.js"() {
    init_core4();
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISOTime: () => ZodISOTime2,
  date: () => date6,
  datetime: () => datetime4,
  duration: () => duration4,
  time: () => time4
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}
var ZodISODateTime2, ZodISODate2, ZodISOTime2, ZodISODuration2;
var init_iso2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/iso.js"() {
    init_core4();
    init_schemas4();
    ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
      $ZodISODateTime2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
      $ZodISODate2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
      $ZodISOTime2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
      $ZodISODuration2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/errors.js
var initializer4, ZodError2, ZodRealError2;
var init_errors4 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/errors.js"() {
    init_core4();
    init_core4();
    init_util2();
    initializer4 = (inst, issues) => {
      $ZodError2.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError2(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError2(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue3) => {
            inst.issues.push(issue3);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
          }
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => {
            inst.issues.push(...issues2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
          }
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    ZodError2 = $constructor2("ZodError", initializer4);
    ZodRealError2 = $constructor2("ZodError", initializer4, {
      Parent: Error
    });
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/parse.js
var parse4, parseAsync4, safeParse4, safeParseAsync4, encode4, decode4, encodeAsync4, decodeAsync4, safeEncode4, safeDecode4, safeEncodeAsync4, safeDecodeAsync4;
var init_parse4 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/parse.js"() {
    init_core4();
    init_errors4();
    parse4 = /* @__PURE__ */ _parse2(ZodRealError2);
    parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
    safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
    safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
    encode4 = /* @__PURE__ */ _encode2(ZodRealError2);
    decode4 = /* @__PURE__ */ _decode2(ZodRealError2);
    encodeAsync4 = /* @__PURE__ */ _encodeAsync2(ZodRealError2);
    decodeAsync4 = /* @__PURE__ */ _decodeAsync2(ZodRealError2);
    safeEncode4 = /* @__PURE__ */ _safeEncode2(ZodRealError2);
    safeDecode4 = /* @__PURE__ */ _safeDecode2(ZodRealError2);
    safeEncodeAsync4 = /* @__PURE__ */ _safeEncodeAsync2(ZodRealError2);
    safeDecodeAsync4 = /* @__PURE__ */ _safeDecodeAsync2(ZodRealError2);
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/schemas.js
function string5(params) {
  return _string2(ZodString2, params);
}
function email4(params) {
  return _email2(ZodEmail2, params);
}
function guid4(params) {
  return _guid2(ZodGUID2, params);
}
function uuid5(params) {
  return _uuid2(ZodUUID2, params);
}
function uuidv42(params) {
  return _uuidv42(ZodUUID2, params);
}
function uuidv62(params) {
  return _uuidv62(ZodUUID2, params);
}
function uuidv72(params) {
  return _uuidv72(ZodUUID2, params);
}
function url2(params) {
  return _url2(ZodURL2, params);
}
function httpUrl2(params) {
  return _url2(ZodURL2, {
    protocol: /^https?$/,
    hostname: regexes_exports2.domain,
    ...util_exports2.normalizeParams(params)
  });
}
function emoji4(params) {
  return _emoji4(ZodEmoji2, params);
}
function nanoid4(params) {
  return _nanoid2(ZodNanoID2, params);
}
function cuid5(params) {
  return _cuid3(ZodCUID3, params);
}
function cuid24(params) {
  return _cuid22(ZodCUID22, params);
}
function ulid4(params) {
  return _ulid2(ZodULID2, params);
}
function xid4(params) {
  return _xid2(ZodXID2, params);
}
function ksuid4(params) {
  return _ksuid2(ZodKSUID2, params);
}
function ipv44(params) {
  return _ipv42(ZodIPv42, params);
}
function ipv64(params) {
  return _ipv62(ZodIPv62, params);
}
function cidrv44(params) {
  return _cidrv42(ZodCIDRv42, params);
}
function cidrv64(params) {
  return _cidrv62(ZodCIDRv62, params);
}
function base644(params) {
  return _base642(ZodBase642, params);
}
function base64url4(params) {
  return _base64url2(ZodBase64URL2, params);
}
function e1644(params) {
  return _e1642(ZodE1642, params);
}
function jwt2(params) {
  return _jwt2(ZodJWT2, params);
}
function stringFormat2(format, fnOrRegex, _params = {}) {
  return _stringFormat2(ZodCustomStringFormat2, format, fnOrRegex, _params);
}
function hostname4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hostname", regexes_exports2.hostname, _params);
}
function hex4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hex", regexes_exports2.hex, _params);
}
function hash2(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports2[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat2(ZodCustomStringFormat2, format, regex, params);
}
function number5(params) {
  return _number2(ZodNumber2, params);
}
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
function float322(params) {
  return _float322(ZodNumberFormat2, params);
}
function float642(params) {
  return _float642(ZodNumberFormat2, params);
}
function int322(params) {
  return _int322(ZodNumberFormat2, params);
}
function uint322(params) {
  return _uint322(ZodNumberFormat2, params);
}
function boolean5(params) {
  return _boolean2(ZodBoolean2, params);
}
function bigint5(params) {
  return _bigint2(ZodBigInt2, params);
}
function int642(params) {
  return _int642(ZodBigIntFormat2, params);
}
function uint642(params) {
  return _uint642(ZodBigIntFormat2, params);
}
function symbol2(params) {
  return _symbol2(ZodSymbol2, params);
}
function _undefined6(params) {
  return _undefined5(ZodUndefined2, params);
}
function _null6(params) {
  return _null5(ZodNull2, params);
}
function any2() {
  return _any2(ZodAny2);
}
function unknown2() {
  return _unknown2(ZodUnknown2);
}
function never2(params) {
  return _never2(ZodNever2, params);
}
function _void4(params) {
  return _void3(ZodVoid2, params);
}
function date7(params) {
  return _date2(ZodDate2, params);
}
function array2(element, params) {
  return _array2(ZodArray2, element, params);
}
function keyof2(schema) {
  const shape = schema._zod.def.shape;
  return _enum4(Object.keys(shape));
}
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", shape ? util_exports2.objectClone(shape) : {});
      return this.shape;
    },
    ...util_exports2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", util_exports2.objectClone(shape));
      return this.shape;
    },
    catchall: never2(),
    ...util_exports2.normalizeParams(params)
  });
}
function looseObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", util_exports2.objectClone(shape));
      return this.shape;
    },
    catchall: unknown2(),
    ...util_exports2.normalizeParams(params)
  });
}
function union2(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports2.normalizeParams(params)
  });
}
function discriminatedUnion2(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports2.normalizeParams(params)
  });
}
function intersection2(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
function tuple2(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports2.normalizeParams(params)
  });
}
function record2(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
function partialRecord2(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = void 0;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
function map2(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
function set2(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
function nativeEnum2(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
function literal2(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports2.normalizeParams(params)
  });
}
function file2(params) {
  return _file2(ZodFile2, params);
}
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
function nullable2(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish4(innerType) {
  return optional2(nullable2(innerType));
}
function _default4(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...util_exports2.normalizeParams(params)
  });
}
function success2(innerType) {
  return new ZodSuccess2({
    type: "success",
    innerType
  });
}
function _catch4(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan2(params) {
  return _nan2(ZodNaN2, params);
}
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function codec2(in_, out, params) {
  return new ZodCodec2({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly2(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
function templateLiteral2(parts, params) {
  return new ZodTemplateLiteral2({
    type: "template_literal",
    parts,
    ...util_exports2.normalizeParams(params)
  });
}
function lazy2(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
function promise2(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
function _function2(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple2(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  return _superRefine2(fn);
}
function _instanceof2(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom2({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
function json2(params) {
  const jsonSchema = lazy2(() => {
    return union2([string5(params), number5(), boolean5(), _null6(), array2(jsonSchema), record2(string5(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess2(fn, schema) {
  return pipe2(transform2(fn), schema);
}
var ZodType2, _ZodString2, ZodString2, ZodStringFormat2, ZodEmail2, ZodGUID2, ZodUUID2, ZodURL2, ZodEmoji2, ZodNanoID2, ZodCUID3, ZodCUID22, ZodULID2, ZodXID2, ZodKSUID2, ZodIPv42, ZodIPv62, ZodCIDRv42, ZodCIDRv62, ZodBase642, ZodBase64URL2, ZodE1642, ZodJWT2, ZodCustomStringFormat2, ZodNumber2, ZodNumberFormat2, ZodBoolean2, ZodBigInt2, ZodBigIntFormat2, ZodSymbol2, ZodUndefined2, ZodNull2, ZodAny2, ZodUnknown2, ZodNever2, ZodVoid2, ZodDate2, ZodArray2, ZodObject2, ZodUnion2, ZodDiscriminatedUnion2, ZodIntersection2, ZodTuple2, ZodRecord2, ZodMap2, ZodSet2, ZodEnum2, ZodLiteral2, ZodFile2, ZodTransform2, ZodOptional2, ZodNullable2, ZodDefault2, ZodPrefault2, ZodNonOptional2, ZodSuccess2, ZodCatch2, ZodNaN2, ZodPipe2, ZodCodec2, ZodReadonly2, ZodTemplateLiteral2, ZodLazy2, ZodPromise2, ZodFunction2, ZodCustom2, stringbool2;
var init_schemas4 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/schemas.js"() {
    init_core4();
    init_core4();
    init_checks4();
    init_iso2();
    init_parse4();
    ZodType2 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
      $ZodType2.init(inst, def);
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(
          {
            ...def,
            checks: [
              ...def.checks ?? [],
              ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
            ]
          }
          // { parent: true }
        );
      };
      inst.clone = (def2, params) => clone2(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta3) => {
        reg.add(inst, meta3);
        return inst;
      });
      inst.parse = (data, params) => parse4(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse4(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.encode = (data, params) => encode4(inst, data, params);
      inst.decode = (data, params) => decode4(inst, data, params);
      inst.encodeAsync = async (data, params) => encodeAsync4(inst, data, params);
      inst.decodeAsync = async (data, params) => decodeAsync4(inst, data, params);
      inst.safeEncode = (data, params) => safeEncode4(inst, data, params);
      inst.safeDecode = (data, params) => safeDecode4(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => safeEncodeAsync4(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => safeDecodeAsync4(inst, data, params);
      inst.refine = (check3, params) => inst.check(refine2(check3, params));
      inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite2(fn));
      inst.optional = () => optional2(inst);
      inst.nullable = () => nullable2(inst);
      inst.nullish = () => optional2(nullable2(inst));
      inst.nonoptional = (params) => nonoptional2(inst, params);
      inst.array = () => array2(inst);
      inst.or = (arg) => union2([inst, arg]);
      inst.and = (arg) => intersection2(inst, arg);
      inst.transform = (tx) => pipe2(inst, transform2(tx));
      inst.default = (def2) => _default4(inst, def2);
      inst.prefault = (def2) => prefault2(inst, def2);
      inst.catch = (params) => _catch4(inst, params);
      inst.pipe = (target) => pipe2(inst, target);
      inst.readonly = () => readonly2(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry2.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry2.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry2.get(inst);
        }
        const cl = inst.clone();
        globalRegistry2.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
      $ZodString2.init(inst, def);
      ZodType2.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex2(...args));
      inst.includes = (...args) => inst.check(_includes2(...args));
      inst.startsWith = (...args) => inst.check(_startsWith2(...args));
      inst.endsWith = (...args) => inst.check(_endsWith2(...args));
      inst.min = (...args) => inst.check(_minLength2(...args));
      inst.max = (...args) => inst.check(_maxLength2(...args));
      inst.length = (...args) => inst.check(_length2(...args));
      inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase2(params));
      inst.uppercase = (params) => inst.check(_uppercase2(params));
      inst.trim = () => inst.check(_trim2());
      inst.normalize = (...args) => inst.check(_normalize2(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase2());
      inst.toUpperCase = () => inst.check(_toUpperCase2());
    });
    ZodString2 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
      $ZodString2.init(inst, def);
      _ZodString2.init(inst, def);
      inst.email = (params) => inst.check(_email2(ZodEmail2, params));
      inst.url = (params) => inst.check(_url2(ZodURL2, params));
      inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
      inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
      inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
      inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
      inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
      inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
      inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
      inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
      inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
      inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
      inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
      inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
      inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
      inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
      inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
      inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
      inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
      inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
      inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
      inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
      inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
      inst.datetime = (params) => inst.check(datetime4(params));
      inst.date = (params) => inst.check(date6(params));
      inst.time = (params) => inst.check(time4(params));
      inst.duration = (params) => inst.check(duration4(params));
    });
    ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
      $ZodStringFormat2.init(inst, def);
      _ZodString2.init(inst, def);
    });
    ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
      $ZodEmail2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
      $ZodGUID2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
      $ZodUUID2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
      $ZodURL2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
      $ZodEmoji2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
      $ZodNanoID2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
      $ZodCUID3.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
      $ZodCUID22.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
      $ZodULID2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
      $ZodXID2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
      $ZodKSUID2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
      $ZodIPv42.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
      $ZodIPv62.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv42.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv62.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
      $ZodBase642.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
      $ZodBase64URL2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
      $ZodE1642.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
      $ZodJWT2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat2.init(inst, def);
      ZodStringFormat2.init(inst, def);
    });
    ZodNumber2 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
      $ZodNumber2.init(inst, def);
      ZodType2.init(inst, def);
      inst.gt = (value, params) => inst.check(_gt2(value, params));
      inst.gte = (value, params) => inst.check(_gte2(value, params));
      inst.min = (value, params) => inst.check(_gte2(value, params));
      inst.lt = (value, params) => inst.check(_lt2(value, params));
      inst.lte = (value, params) => inst.check(_lte2(value, params));
      inst.max = (value, params) => inst.check(_lte2(value, params));
      inst.int = (params) => inst.check(int2(params));
      inst.safe = (params) => inst.check(int2(params));
      inst.positive = (params) => inst.check(_gt2(0, params));
      inst.nonnegative = (params) => inst.check(_gte2(0, params));
      inst.negative = (params) => inst.check(_lt2(0, params));
      inst.nonpositive = (params) => inst.check(_lte2(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
      inst.step = (value, params) => inst.check(_multipleOf2(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat2.init(inst, def);
      ZodNumber2.init(inst, def);
    });
    ZodBoolean2 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
      $ZodBoolean2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodBigInt2 = /* @__PURE__ */ $constructor2("ZodBigInt", (inst, def) => {
      $ZodBigInt2.init(inst, def);
      ZodType2.init(inst, def);
      inst.gte = (value, params) => inst.check(_gte2(value, params));
      inst.min = (value, params) => inst.check(_gte2(value, params));
      inst.gt = (value, params) => inst.check(_gt2(value, params));
      inst.gte = (value, params) => inst.check(_gte2(value, params));
      inst.min = (value, params) => inst.check(_gte2(value, params));
      inst.lt = (value, params) => inst.check(_lt2(value, params));
      inst.lte = (value, params) => inst.check(_lte2(value, params));
      inst.max = (value, params) => inst.check(_lte2(value, params));
      inst.positive = (params) => inst.check(_gt2(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt2(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte2(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte2(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat2.init(inst, def);
      ZodBigInt2.init(inst, def);
    });
    ZodSymbol2 = /* @__PURE__ */ $constructor2("ZodSymbol", (inst, def) => {
      $ZodSymbol2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodUndefined2 = /* @__PURE__ */ $constructor2("ZodUndefined", (inst, def) => {
      $ZodUndefined2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodNull2 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
      $ZodNull2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodAny2 = /* @__PURE__ */ $constructor2("ZodAny", (inst, def) => {
      $ZodAny2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodUnknown2 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
      $ZodUnknown2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodNever2 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
      $ZodNever2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodVoid2 = /* @__PURE__ */ $constructor2("ZodVoid", (inst, def) => {
      $ZodVoid2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodDate2 = /* @__PURE__ */ $constructor2("ZodDate", (inst, def) => {
      $ZodDate2.init(inst, def);
      ZodType2.init(inst, def);
      inst.min = (value, params) => inst.check(_gte2(value, params));
      inst.max = (value, params) => inst.check(_lte2(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    ZodArray2 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
      $ZodArray2.init(inst, def);
      ZodType2.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength2(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
      inst.length = (len, params) => inst.check(_length2(len, params));
      inst.unwrap = () => inst.element;
    });
    ZodObject2 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
      $ZodObjectJIT2.init(inst, def);
      ZodType2.init(inst, def);
      util_exports2.defineLazy(inst, "shape", () => def.shape);
      inst.keyof = () => _enum4(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports2.extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
        return util_exports2.safeExtend(inst, incoming);
      };
      inst.merge = (other) => util_exports2.merge(inst, other);
      inst.pick = (mask) => util_exports2.pick(inst, mask);
      inst.omit = (mask) => util_exports2.omit(inst, mask);
      inst.partial = (...args) => util_exports2.partial(ZodOptional2, inst, args[0]);
      inst.required = (...args) => util_exports2.required(ZodNonOptional2, inst, args[0]);
    });
    ZodUnion2 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
      $ZodUnion2.init(inst, def);
      ZodType2.init(inst, def);
      inst.options = def.options;
    });
    ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion2.init(inst, def);
      $ZodDiscriminatedUnion2.init(inst, def);
    });
    ZodIntersection2 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
      $ZodIntersection2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodTuple2 = /* @__PURE__ */ $constructor2("ZodTuple", (inst, def) => {
      $ZodTuple2.init(inst, def);
      ZodType2.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    ZodRecord2 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
      $ZodRecord2.init(inst, def);
      ZodType2.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodMap2 = /* @__PURE__ */ $constructor2("ZodMap", (inst, def) => {
      $ZodMap2.init(inst, def);
      ZodType2.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodSet2 = /* @__PURE__ */ $constructor2("ZodSet", (inst, def) => {
      $ZodSet2.init(inst, def);
      ZodType2.init(inst, def);
      inst.min = (...args) => inst.check(_minSize2(...args));
      inst.nonempty = (params) => inst.check(_minSize2(1, params));
      inst.max = (...args) => inst.check(_maxSize2(...args));
      inst.size = (...args) => inst.check(_size2(...args));
    });
    ZodEnum2 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
      $ZodEnum2.init(inst, def);
      ZodType2.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum2({
          ...def,
          checks: [],
          ...util_exports2.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum2({
          ...def,
          checks: [],
          ...util_exports2.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    ZodLiteral2 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
      $ZodLiteral2.init(inst, def);
      ZodType2.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    ZodFile2 = /* @__PURE__ */ $constructor2("ZodFile", (inst, def) => {
      $ZodFile2.init(inst, def);
      ZodType2.init(inst, def);
      inst.min = (size, params) => inst.check(_minSize2(size, params));
      inst.max = (size, params) => inst.check(_maxSize2(size, params));
      inst.mime = (types, params) => inst.check(_mime2(Array.isArray(types) ? types : [types], params));
    });
    ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
      $ZodTransform2.init(inst, def);
      ZodType2.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
          throw new $ZodEncodeError2(inst.constructor.name);
        }
        payload.addIssue = (issue3) => {
          if (typeof issue3 === "string") {
            payload.issues.push(util_exports2.issue(issue3, payload.value, def));
          } else {
            const _issue = issue3;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            payload.issues.push(util_exports2.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    ZodOptional2 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
      $ZodOptional2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNullable2 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
      $ZodNullable2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodDefault2 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
      $ZodDefault2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
      $ZodPrefault2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
      $ZodNonOptional2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodSuccess2 = /* @__PURE__ */ $constructor2("ZodSuccess", (inst, def) => {
      $ZodSuccess2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCatch2 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
      $ZodCatch2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    ZodNaN2 = /* @__PURE__ */ $constructor2("ZodNaN", (inst, def) => {
      $ZodNaN2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
      $ZodPipe2.init(inst, def);
      ZodType2.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    ZodCodec2 = /* @__PURE__ */ $constructor2("ZodCodec", (inst, def) => {
      ZodPipe2.init(inst, def);
      $ZodCodec2.init(inst, def);
    });
    ZodReadonly2 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
      $ZodReadonly2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodLazy2 = /* @__PURE__ */ $constructor2("ZodLazy", (inst, def) => {
      $ZodLazy2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    ZodPromise2 = /* @__PURE__ */ $constructor2("ZodPromise", (inst, def) => {
      $ZodPromise2.init(inst, def);
      ZodType2.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodFunction2 = /* @__PURE__ */ $constructor2("ZodFunction", (inst, def) => {
      $ZodFunction2.init(inst, def);
      ZodType2.init(inst, def);
    });
    ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
      $ZodCustom2.init(inst, def);
      ZodType2.init(inst, def);
    });
    stringbool2 = (...args) => _stringbool2({
      Codec: ZodCodec2,
      Boolean: ZodBoolean2,
      String: ZodString2
    }, ...args);
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/compat.js
function setErrorMap2(map3) {
  config2({
    customError: map3
  });
}
function getErrorMap2() {
  return config2().customError;
}
var ZodIssueCode2, ZodFirstPartyTypeKind2;
var init_compat2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/compat.js"() {
    init_core4();
    init_core4();
    ZodIssueCode2 = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    /* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
    })(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/coerce.js
var coerce_exports2 = {};
__export(coerce_exports2, {
  bigint: () => bigint6,
  boolean: () => boolean6,
  date: () => date8,
  number: () => number6,
  string: () => string6
});
function string6(params) {
  return _coercedString2(ZodString2, params);
}
function number6(params) {
  return _coercedNumber2(ZodNumber2, params);
}
function boolean6(params) {
  return _coercedBoolean2(ZodBoolean2, params);
}
function bigint6(params) {
  return _coercedBigint2(ZodBigInt2, params);
}
function date8(params) {
  return _coercedDate2(ZodDate2, params);
}
var init_coerce2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/coerce.js"() {
    init_core4();
    init_schemas4();
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
var external_exports2 = {};
__export(external_exports2, {
  $brand: () => $brand2,
  $input: () => $input2,
  $output: () => $output2,
  NEVER: () => NEVER2,
  TimePrecision: () => TimePrecision2,
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase642,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCUID: () => ZodCUID3,
  ZodCUID2: () => ZodCUID22,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec2,
  ZodCustom: () => ZodCustom2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE1642,
  ZodEmail: () => ZodEmail2,
  ZodEmoji: () => ZodEmoji2,
  ZodEnum: () => ZodEnum2,
  ZodError: () => ZodError2,
  ZodFile: () => ZodFile2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID2,
  ZodIPv4: () => ZodIPv42,
  ZodIPv6: () => ZodIPv62,
  ZodISODate: () => ZodISODate2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISOTime: () => ZodISOTime2,
  ZodIntersection: () => ZodIntersection2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodJWT: () => ZodJWT2,
  ZodKSUID: () => ZodKSUID2,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID2,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe2,
  ZodPrefault: () => ZodPrefault2,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRealError: () => ZodRealError2,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat2,
  ZodSuccess: () => ZodSuccess2,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodTransform: () => ZodTransform2,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID2,
  ZodURL: () => ZodURL2,
  ZodUUID: () => ZodUUID2,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID2,
  _ZodString: () => _ZodString2,
  _default: () => _default4,
  _function: () => _function2,
  any: () => any2,
  array: () => array2,
  base64: () => base644,
  base64url: () => base64url4,
  bigint: () => bigint5,
  boolean: () => boolean5,
  catch: () => _catch4,
  check: () => check2,
  cidrv4: () => cidrv44,
  cidrv6: () => cidrv64,
  clone: () => clone2,
  codec: () => codec2,
  coerce: () => coerce_exports2,
  config: () => config2,
  core: () => core_exports4,
  cuid: () => cuid5,
  cuid2: () => cuid24,
  custom: () => custom2,
  date: () => date7,
  decode: () => decode4,
  decodeAsync: () => decodeAsync4,
  discriminatedUnion: () => discriminatedUnion2,
  e164: () => e1644,
  email: () => email4,
  emoji: () => emoji4,
  encode: () => encode4,
  encodeAsync: () => encodeAsync4,
  endsWith: () => _endsWith2,
  enum: () => _enum4,
  file: () => file2,
  flattenError: () => flattenError2,
  float32: () => float322,
  float64: () => float642,
  formatError: () => formatError2,
  function: () => _function2,
  getErrorMap: () => getErrorMap2,
  globalRegistry: () => globalRegistry2,
  gt: () => _gt2,
  gte: () => _gte2,
  guid: () => guid4,
  hash: () => hash2,
  hex: () => hex4,
  hostname: () => hostname4,
  httpUrl: () => httpUrl2,
  includes: () => _includes2,
  instanceof: () => _instanceof2,
  int: () => int2,
  int32: () => int322,
  int64: () => int642,
  intersection: () => intersection2,
  ipv4: () => ipv44,
  ipv6: () => ipv64,
  iso: () => iso_exports2,
  json: () => json2,
  jwt: () => jwt2,
  keyof: () => keyof2,
  ksuid: () => ksuid4,
  lazy: () => lazy2,
  length: () => _length2,
  literal: () => literal2,
  locales: () => locales_exports2,
  looseObject: () => looseObject2,
  lowercase: () => _lowercase2,
  lt: () => _lt2,
  lte: () => _lte2,
  map: () => map2,
  maxLength: () => _maxLength2,
  maxSize: () => _maxSize2,
  mime: () => _mime2,
  minLength: () => _minLength2,
  minSize: () => _minSize2,
  multipleOf: () => _multipleOf2,
  nan: () => nan2,
  nanoid: () => nanoid4,
  nativeEnum: () => nativeEnum2,
  negative: () => _negative2,
  never: () => never2,
  nonnegative: () => _nonnegative2,
  nonoptional: () => nonoptional2,
  nonpositive: () => _nonpositive2,
  normalize: () => _normalize2,
  null: () => _null6,
  nullable: () => nullable2,
  nullish: () => nullish4,
  number: () => number5,
  object: () => object2,
  optional: () => optional2,
  overwrite: () => _overwrite2,
  parse: () => parse4,
  parseAsync: () => parseAsync4,
  partialRecord: () => partialRecord2,
  pipe: () => pipe2,
  positive: () => _positive2,
  prefault: () => prefault2,
  preprocess: () => preprocess2,
  prettifyError: () => prettifyError2,
  promise: () => promise2,
  property: () => _property2,
  readonly: () => readonly2,
  record: () => record2,
  refine: () => refine2,
  regex: () => _regex2,
  regexes: () => regexes_exports2,
  registry: () => registry2,
  safeDecode: () => safeDecode4,
  safeDecodeAsync: () => safeDecodeAsync4,
  safeEncode: () => safeEncode4,
  safeEncodeAsync: () => safeEncodeAsync4,
  safeParse: () => safeParse4,
  safeParseAsync: () => safeParseAsync4,
  set: () => set2,
  setErrorMap: () => setErrorMap2,
  size: () => _size2,
  startsWith: () => _startsWith2,
  strictObject: () => strictObject2,
  string: () => string5,
  stringFormat: () => stringFormat2,
  stringbool: () => stringbool2,
  success: () => success2,
  superRefine: () => superRefine2,
  symbol: () => symbol2,
  templateLiteral: () => templateLiteral2,
  toJSONSchema: () => toJSONSchema2,
  toLowerCase: () => _toLowerCase2,
  toUpperCase: () => _toUpperCase2,
  transform: () => transform2,
  treeifyError: () => treeifyError2,
  trim: () => _trim2,
  tuple: () => tuple2,
  uint32: () => uint322,
  uint64: () => uint642,
  ulid: () => ulid4,
  undefined: () => _undefined6,
  union: () => union2,
  unknown: () => unknown2,
  uppercase: () => _uppercase2,
  url: () => url2,
  util: () => util_exports2,
  uuid: () => uuid5,
  uuidv4: () => uuidv42,
  uuidv6: () => uuidv62,
  uuidv7: () => uuidv72,
  void: () => _void4,
  xid: () => xid4
});
var init_external2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js"() {
    init_core4();
    init_schemas4();
    init_checks4();
    init_errors4();
    init_parse4();
    init_compat2();
    init_core4();
    init_en2();
    init_core4();
    init_locales2();
    init_iso2();
    init_iso2();
    init_coerce2();
    config2(en_default2());
  }
});

// node_modules/@opencode-ai/plugin/node_modules/zod/index.js
var init_zod2 = __esm({
  "node_modules/@opencode-ai/plugin/node_modules/zod/index.js"() {
    init_external2();
    init_external2();
  }
});

// node_modules/@opencode-ai/plugin/dist/tool.js
function tool(input) {
  return input;
}
var init_tool = __esm({
  "node_modules/@opencode-ai/plugin/dist/tool.js"() {
    init_zod2();
    tool.schema = external_exports2;
  }
});

// node_modules/@opencode-ai/plugin/dist/index.js
var init_dist = __esm({
  "node_modules/@opencode-ai/plugin/dist/index.js"() {
    init_tool();
  }
});

// src/model/paths.ts
import * as path6 from "node:path";
function normalizeModelRoot(projectDir, root) {
  const trimmed = root.trim();
  if (!trimmed) return path6.join(getMiyaDataRootDir(projectDir), "model");
  if (path6.isAbsolute(trimmed)) return path6.normalize(trimmed);
  return path6.normalize(path6.join(projectDir, trimmed));
}
function getMiyaDataRootDir(projectDir) {
  return path6.join(projectDir, ...MIYA_ROOT_SEGMENTS);
}
function getMiyaModelRootDir(projectDir) {
  const envRoot = process.env[MODEL_ROOT_ENV];
  if (typeof envRoot === "string" && envRoot.trim()) {
    return normalizeModelRoot(projectDir, envRoot);
  }
  return path6.join(getMiyaDataRootDir(projectDir), "model");
}
function getMiyaModelPath(projectDir, ...segments) {
  return path6.join(getMiyaModelRootDir(projectDir), ...segments);
}
function getMiyaVisionTempDir(projectDir, ...segments) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.vision, "lin shi", ...segments);
}
function getMiyaImageTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.image, "lin shi");
}
function getMiyaVoiceTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voice, "lin shi");
}
function getMiyaVoiceprintModelDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, MIYA_MODEL_NAME.eres2net);
}
function getMiyaVoiceprintSampleDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, "ben ren");
}
var MODEL_ROOT_ENV, MIYA_ROOT_SEGMENTS, MIYA_MODEL_BRANCH, MIYA_MODEL_NAME;
var init_paths2 = __esm({
  "src/model/paths.ts"() {
    "use strict";
    MODEL_ROOT_ENV = "MIYA_MODEL_ROOT_DIR";
    MIYA_ROOT_SEGMENTS = [".opencode", "miya"];
    MIYA_MODEL_BRANCH = {
      vision: "shi jue",
      image: "tu pian",
      voiceprint: "shi bie",
      voice: "sheng yin"
    };
    MIYA_MODEL_NAME = {
      fluxSchnell: "FLUX.1 schnell",
      fluxKlein: "FLUX.2 [klein] 4B\uFF08Apache-2.0\uFF09",
      eres2net: "eres2net",
      sovits: "GPT-SoVITS-v2pro-20250604"
    };
  }
});

// src/utils/logger.ts
import * as fs6 from "node:fs";
import * as os2 from "node:os";
import * as path7 from "node:path";
function sanitizeLogValue(value) {
  if (value instanceof Error) {
    return {
      name: value.name,
      message: value.message,
      stack: value.stack
    };
  }
  if (typeof value === "bigint") return value.toString();
  if (typeof value === "symbol") return String(value);
  return value;
}
function stringifyLogData(data) {
  if (typeof data === "undefined") return "";
  const seen = /* @__PURE__ */ new WeakSet();
  try {
    return JSON.stringify(data, (_key, value) => {
      const sanitized = sanitizeLogValue(value);
      if (sanitized && typeof sanitized === "object") {
        if (seen.has(sanitized)) return "[circular]";
        seen.add(sanitized);
      }
      return sanitized;
    });
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    return JSON.stringify({
      logger_error: "log_serialize_failed",
      message
    });
  }
}
function log(message, data) {
  try {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const payload = stringifyLogData(data);
    const logEntry = `[${timestamp}] ${message}${payload ? ` ${payload}` : ""}
`;
    fs6.appendFileSync(logFile, logEntry);
  } catch {
  }
}
var logFile;
var init_logger = __esm({
  "src/utils/logger.ts"() {
    "use strict";
    logFile = path7.join(os2.tmpdir(), "miya.log");
  }
});

// src/utils/agent-variant.ts
var init_agent_variant = __esm({
  "src/utils/agent-variant.ts"() {
    "use strict";
    init_logger();
  }
});

// src/utils/polling.ts
var init_polling = __esm({
  "src/utils/polling.ts"() {
    "use strict";
    init_config();
  }
});

// src/utils/process.ts
import {
  spawn as spawn2,
  spawnSync as spawnSync2
} from "node:child_process";
async function runProcess(command, args, options = {}) {
  return new Promise((resolve4, reject) => {
    const child = spawn2(command, args, {
      ...options,
      stdio: ["ignore", "pipe", "pipe"]
    });
    let stdout = "";
    let stderr = "";
    let settled = false;
    let timedOut = false;
    const timeoutMs = typeof options.timeoutMs === "number" && Number.isFinite(options.timeoutMs) ? Math.max(1, Math.floor(options.timeoutMs)) : void 0;
    const timer = timeoutMs !== void 0 ? setTimeout(() => {
      timedOut = true;
      try {
        child.kill("SIGTERM");
      } catch {
      }
    }, timeoutMs) : void 0;
    child.stdout?.setEncoding("utf8");
    child.stderr?.setEncoding("utf8");
    child.stdout?.on("data", (chunk) => {
      stdout += chunk;
    });
    child.stderr?.on("data", (chunk) => {
      stderr += chunk;
    });
    child.on("error", (error92) => {
      if (settled) return;
      settled = true;
      if (timer) clearTimeout(timer);
      reject(error92);
    });
    child.on("close", (code) => {
      if (settled) return;
      settled = true;
      if (timer) clearTimeout(timer);
      resolve4({
        exitCode: code ?? -1,
        stdout,
        stderr,
        timedOut
      });
    });
  });
}
function runProcessSync(command, args, options = {}) {
  const result = spawnSync2(command, args, {
    ...options,
    encoding: "utf8",
    stdio: ["ignore", "pipe", "pipe"]
  });
  return {
    exitCode: result.status ?? -1,
    stdout: result.stdout ?? "",
    stderr: result.stderr ?? "",
    timedOut: Boolean(result.error?.name === "ETIMEDOUT")
  };
}
var init_process = __esm({
  "src/utils/process.ts"() {
    "use strict";
  }
});

// src/utils/tmux.ts
var init_tmux = __esm({
  "src/utils/tmux.ts"() {
    "use strict";
    init_process();
    init_logger();
  }
});

// src/utils/zip-extractor.ts
var init_zip_extractor = __esm({
  "src/utils/zip-extractor.ts"() {
    "use strict";
    init_process();
  }
});

// src/utils/index.ts
var init_utils2 = __esm({
  "src/utils/index.ts"() {
    "use strict";
    init_agent_variant();
    init_logger();
    init_polling();
    init_process();
    init_tmux();
    init_zip_extractor();
  }
});

// src/channel/outbound/shared.ts
import { createHash, randomUUID } from "node:crypto";
import * as fs7 from "node:fs";
function safeValueFromSignal(signal, key) {
  const matched = new RegExp(`${key}=([^|]*)`).exec(signal)?.[1];
  if (matched == null) return void 0;
  const text = matched.trim();
  return text.length > 0 ? text : void 0;
}
function deriveDesktopFailureDetail(input) {
  return safeValueFromSignal(input.signal, "error") ?? (input.stderr.trim() || void 0) ?? (input.stdout.trim() || void 0) ?? (input.timedOut ? "timeout" : `exit_${input.exitCode}`);
}
function buildEvidenceDir(projectDir, channel) {
  const root = getMiyaVisionTempDir(projectDir, channel);
  fs7.mkdirSync(root, { recursive: true });
  return root;
}
async function sendDesktopOutbound(input) {
  const destination = input.destination.trim();
  const text = (input.text ?? "").trim();
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = createHash("sha256").update(`${text}||${mediaPath}`).digest("hex");
  const traceID = `desktop_${randomUUID()}`;
  const evidenceDir = buildEvidenceDir(input.projectDir, input.channel);
  if (process.platform !== "win32") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_windows_only",
      receiptStatus: "uncertain",
      failureStep: "preflight.platform",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (process.env.MIYA_UI_AUTOMATION_ENABLED !== "1") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_disabled:set MIYA_UI_AUTOMATION_ENABLED=1",
      receiptStatus: "uncertain",
      failureStep: "preflight.runtime_switch",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (!destination || !text && !mediaPath) {
    return Promise.resolve({
      sent: false,
      message: "invalid_desktop_send_args",
      receiptStatus: "uncertain",
      failureStep: "preflight.args",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  const script = `
$ErrorActionPreference = 'Stop'
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
Add-Type @"
using System;
using System.Runtime.InteropServices;
public static class MiyaInputProbe {
  [StructLayout(LayoutKind.Sequential)]
  public struct POINT { public int X; public int Y; }
  [DllImport("user32.dll")]
  public static extern bool GetCursorPos(out POINT point);
  [DllImport("user32.dll")]
  public static extern short GetAsyncKeyState(int vKey);
}
"@

$destination = $env:MIYA_DESTINATION
$payload = $env:MIYA_MESSAGE
$mediaPath = $env:MIYA_MEDIA_PATH
$appName = $env:MIYA_APP_NAME
$payloadHash = $env:MIYA_PAYLOAD_HASH
$traceId = $env:MIYA_TRACE_ID
$evidenceDir = $env:MIYA_EVIDENCE_DIR
$shell = New-Object -ComObject WScript.Shell

$step = "bootstrap"
$precheck = "unavailable"
$postcheck = "unavailable"
$receipt = "uncertain"
$recipientCheck = "uncertain"
$preShot = ""
$postShot = ""
$windowFingerprint = ""

function Save-Screenshot {
  param([string]$TargetPath)
  try {
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing
    $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
    $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
    $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
    $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)
    $bitmap.Save($TargetPath, [System.Drawing.Imaging.ImageFormat]::Png)
    $graphics.Dispose()
    $bitmap.Dispose()
  } catch {}
}

function Get-CursorPoint {
  $point = New-Object MiyaInputProbe+POINT
  [void][MiyaInputProbe]::GetCursorPos([ref]$point)
  return @{ X = [int]$point.X; Y = [int]$point.Y }
}

function Test-KeyboardActivity {
  $keys = @(0x08,0x09,0x0D,0x10,0x11,0x12,0x1B,0x20,0x25,0x26,0x27,0x28,0x2E,0x5B,0x5C)
  foreach ($vk in $keys) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  for ($vk = 0x30; $vk -le 0x5A; $vk++) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  return $false
}

function Wait-UserInputIdle {
  param([int]$TimeoutMs = 1200, [int]$StableMs = 350, [int]$SampleMs = 60)
  $deadline = (Get-Date).AddMilliseconds($TimeoutMs)
  $idleSince = Get-Date
  $last = Get-CursorPoint
  while ((Get-Date) -lt $deadline) {
    Start-Sleep -Milliseconds $SampleMs
    $curr = Get-CursorPoint
    $moved = ([Math]::Abs($curr.X - $last.X) + [Math]::Abs($curr.Y - $last.Y)) -gt 2
    $typing = Test-KeyboardActivity
    if ($moved -or $typing) {
      $idleSince = Get-Date
      $last = $curr
      continue
    }
    if (((Get-Date) - $idleSince).TotalMilliseconds -ge $StableMs) {
      return $curr
    }
    $last = $curr
  }
  throw "input_mutex_timeout:user_active"
}

function Assert-NoUserInterference {
  param($LockPoint)
  $curr = Get-CursorPoint
  $moved = ([Math]::Abs($curr.X - $LockPoint.X) + [Math]::Abs($curr.Y - $LockPoint.Y)) -gt 6
  if ($moved -or (Test-KeyboardActivity)) {
    throw "input_mutex_timeout:user_interference"
  }
}

try {
  if (-not (Test-Path -LiteralPath $evidenceDir)) {
    New-Item -ItemType Directory -Path $evidenceDir -Force | Out-Null
  }

  $step = "bootstrap.process"
  $lockPoint = Wait-UserInputIdle
$proc = Get-Process -Name $appName -ErrorAction SilentlyContinue | Select-Object -First 1
if (-not $proc) {
  Start-Process -FilePath $appName | Out-Null
  Start-Sleep -Milliseconds 1200
}

$step = "precheck.activate_window"
$activated = $shell.AppActivate($destination)
if (-not $activated) {
  $activated = $shell.AppActivate($appName)
}
if (-not $activated) {
  throw "window_not_found:$destination"
}
$precheck = "window_activated"
Assert-NoUserInterference -LockPoint $lockPoint

$step = "precheck.capture"
$preShot = Join-Path $evidenceDir ($traceId + "_pre.png")
Save-Screenshot -TargetPath $preShot

$activeByDestination = $shell.AppActivate($destination)
if (-not $activeByDestination) {
  $activeByDestination = $false
}
$windowProc = Get-Process -Name $appName -ErrorAction SilentlyContinue | Select-Object -First 1
$windowTitle = ""
if ($windowProc -and $windowProc.MainWindowTitle) {
  $windowTitle = $windowProc.MainWindowTitle
}
$windowFingerprint = ($appName + ":" + [string]($windowProc.Id) + ":" + $windowTitle.Replace('|', '/'))
if ($windowTitle -like ("*" + $destination + "*")) {
  $recipientCheck = "matched"
} elseif ($activeByDestination) {
  $recipientCheck = "matched"
} else {
  $recipientCheck = "uncertain"
}

if ($mediaPath) {
  Assert-NoUserInterference -LockPoint $lockPoint
  $step = "send.media_prepare"
  if (-not (Test-Path -LiteralPath $mediaPath)) {
    throw "media_not_found:$mediaPath"
  }
  $list = New-Object System.Collections.Specialized.StringCollection
  $list.Add($mediaPath) | Out-Null
  $data = New-Object System.Windows.Forms.DataObject
  $data.SetFileDropList($list)
  [System.Windows.Forms.Clipboard]::SetDataObject($data, $true)
  Start-Sleep -Milliseconds 220
  [System.Windows.Forms.SendKeys]::SendWait('^v')
  $step = "send.media_commit"
  Start-Sleep -Milliseconds 220
  [System.Windows.Forms.SendKeys]::SendWait('{ENTER}')
  Start-Sleep -Milliseconds 240
}

if ($payload) {
  Assert-NoUserInterference -LockPoint $lockPoint
  $step = "send.text_prepare"
  Set-Clipboard -Value $payload
  Start-Sleep -Milliseconds 180
  [System.Windows.Forms.SendKeys]::SendWait('^v')
  $step = "send.text_commit"
  Start-Sleep -Milliseconds 120
  [System.Windows.Forms.SendKeys]::SendWait('{ENTER}')
}

$step = "postcheck.activate"
if (-not $shell.AppActivate($appName)) {
  throw "postcheck_window_not_active:$appName"
}
$postcheck = "window_active_after_send"
$receipt = "confirmed"
$step = "postcheck.capture"
$postShot = Join-Path $evidenceDir ($traceId + "_post.png")
Save-Screenshot -TargetPath $postShot

Write-Output ("desktop_send_ok|step=" + $step + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFingerprint.Replace('|', '/') + "|pre_shot=" + $preShot.Replace('|', '/') + "|post_shot=" + $postShot.Replace('|', '/') + "|payload=" + $payloadHash)
exit 0
} catch {
  $err = $_.Exception.Message.Replace('|', '/')
  Write-Output ("desktop_send_fail|step=" + $step + "|error=" + $err + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFingerprint.Replace('|', '/') + "|pre_shot=" + $preShot.Replace('|', '/') + "|post_shot=" + $postShot.Replace('|', '/') + "|payload=" + $payloadHash)
  exit 2
}
`.trim();
  const result = await runProcess(
    "powershell",
    [
      "-NoProfile",
      "-NonInteractive",
      "-ExecutionPolicy",
      "Bypass",
      "-Command",
      script
    ],
    {
      env: {
        ...process.env,
        MIYA_DESTINATION: destination,
        MIYA_MESSAGE: text,
        MIYA_MEDIA_PATH: mediaPath,
        MIYA_APP_NAME: input.appName,
        MIYA_PAYLOAD_HASH: payloadHash,
        MIYA_TRACE_ID: traceID,
        MIYA_EVIDENCE_DIR: evidenceDir
      },
      windowsHide: true,
      timeoutMs: 15e3
    }
  );
  const timedOut = result.timedOut;
  const exitCode = result.exitCode;
  const stdout = result.stdout.trim();
  const stderr = result.stderr.trim();
  const signal = stdout || stderr;
  const precheck = safeValueFromSignal(signal, "pre") ?? "failed";
  const postcheck = safeValueFromSignal(signal, "post") ?? "failed";
  const receipt = safeValueFromSignal(signal, "receipt") === "confirmed" ? "confirmed" : "uncertain";
  const failureStep = safeValueFromSignal(signal, "step") ?? "send.unknown";
  const windowFingerprint = safeValueFromSignal(signal, "window_fp");
  const recipientTextCheckRaw = safeValueFromSignal(signal, "recipient");
  const recipientTextCheck = recipientTextCheckRaw === "matched" || recipientTextCheckRaw === "mismatch" ? recipientTextCheckRaw : "uncertain";
  const preSendScreenshotPath = safeValueFromSignal(signal, "pre_shot");
  const postSendScreenshotPath = safeValueFromSignal(signal, "post_shot");
  const payloadFromSignal = safeValueFromSignal(signal, "payload") ?? payloadHash;
  if (exitCode === 0 && stdout.includes("desktop_send_ok") && !timedOut) {
    return {
      sent: true,
      message: `${input.channel}_desktop_sent`,
      visualPrecheck: precheck,
      visualPostcheck: postcheck,
      receiptStatus: receipt,
      payloadHash: payloadFromSignal,
      windowFingerprint,
      recipientTextCheck,
      preSendScreenshotPath,
      postSendScreenshotPath,
      failureStep
    };
  }
  const detail = deriveDesktopFailureDetail({
    signal,
    stdout,
    stderr,
    timedOut,
    exitCode
  });
  return {
    sent: false,
    message: `${input.channel}_desktop_send_failed:${detail}`,
    visualPrecheck: precheck,
    visualPostcheck: postcheck,
    receiptStatus: receipt,
    failureStep,
    payloadHash: payloadFromSignal,
    windowFingerprint,
    recipientTextCheck,
    preSendScreenshotPath,
    postSendScreenshotPath
  };
}
var init_shared = __esm({
  "src/channel/outbound/shared.ts"() {
    "use strict";
    init_paths2();
    init_utils2();
  }
});

// src/channel/outbound/qq.ts
async function sendQqDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "QQ",
    channel: "qq",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath
  });
}
var init_qq = __esm({
  "src/channel/outbound/qq.ts"() {
    "use strict";
    init_shared();
  }
});

// src/channel/outbound/wechat.ts
async function sendWechatDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "WeChat",
    channel: "wechat",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath
  });
}
var init_wechat = __esm({
  "src/channel/outbound/wechat.ts"() {
    "use strict";
    init_shared();
  }
});

// src/security/system-keyring.ts
import { createCipheriv, createDecipheriv, createHash as createHash2, randomBytes } from "node:crypto";
import { spawnSync as spawnSync3 } from "node:child_process";
import * as fs8 from "node:fs";
import * as path8 from "node:path";
function keyFile(projectDir) {
  return path8.join(getMiyaRuntimeDir(projectDir), "security", "master.key");
}
function ensureDir2(file3) {
  fs8.mkdirSync(path8.dirname(file3), { recursive: true });
}
function toBase64(text) {
  return Buffer.from(text, "utf-8").toString("base64");
}
function fromBase64(base645) {
  return Buffer.from(base645, "base64").toString("utf-8");
}
function hasPowerShell() {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const result = spawnSync3(shell, ["-NoProfile", "-NonInteractive", "-Command", "$PSVersionTable.PSVersion.ToString()"], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 1500
  });
  return result.status === 0;
}
function encryptWithDpapi(plainText) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const script = [
    `$plain = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('${toBase64(plainText)}'))`,
    "$secure = ConvertTo-SecureString -String $plain -AsPlainText -Force",
    "ConvertFrom-SecureString -SecureString $secure"
  ].join("; ");
  const result = spawnSync3(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2e3
  });
  if (result.status !== 0) return null;
  const out = result.stdout.trim();
  return out.length > 0 ? out : null;
}
function decryptWithDpapi(blob) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const escaped = blob.replace(/'/g, "''");
  const script = [
    `$secure = ConvertTo-SecureString '${escaped}'`,
    "$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secure)",
    "$plain = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)",
    "[Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)",
    "[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($plain))"
  ].join("; ");
  const result = spawnSync3(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2e3
  });
  if (result.status !== 0) return null;
  const out = result.stdout.trim();
  if (!out) return null;
  try {
    return fromBase64(out);
  } catch {
    return null;
  }
}
function deriveFallbackKey(projectDir) {
  const file3 = keyFile(projectDir);
  if (fs8.existsSync(file3)) {
    return fs8.readFileSync(file3);
  }
  const entropy = randomBytes(32);
  ensureDir2(file3);
  fs8.writeFileSync(file3, entropy);
  return entropy;
}
function encryptFallback(projectDir, plainText) {
  const key = deriveFallbackKey(projectDir);
  const iv = randomBytes(12);
  const cipher = createCipheriv("aes-256-gcm", createHash2("sha256").update(key).digest(), iv);
  const payload = Buffer.concat([cipher.update(plainText, "utf-8"), cipher.final()]);
  return {
    version: 1,
    alg: "aes256gcm",
    payload: payload.toString("base64"),
    iv: iv.toString("base64"),
    tag: cipher.getAuthTag().toString("base64")
  };
}
function decryptFallback(projectDir, envelope) {
  if (!envelope.iv || !envelope.tag) return null;
  try {
    const key = deriveFallbackKey(projectDir);
    const decipher = createDecipheriv(
      "aes-256-gcm",
      createHash2("sha256").update(key).digest(),
      Buffer.from(envelope.iv, "base64")
    );
    decipher.setAuthTag(Buffer.from(envelope.tag, "base64"));
    const plain = Buffer.concat([
      decipher.update(Buffer.from(envelope.payload, "base64")),
      decipher.final()
    ]);
    return plain.toString("utf-8");
  } catch {
    return null;
  }
}
function encodeEnvelope(envelope) {
  return `miya-sec:${Buffer.from(JSON.stringify(envelope), "utf-8").toString("base64")}`;
}
function decodeEnvelope(raw) {
  if (!raw.startsWith("miya-sec:")) return null;
  const body = raw.slice("miya-sec:".length);
  try {
    const parsed = JSON.parse(Buffer.from(body, "base64").toString("utf-8"));
    if (!parsed || parsed.version !== 1) return null;
    return parsed;
  } catch {
    return null;
  }
}
function encryptSensitiveValue(projectDir, plainText) {
  const normalized = String(plainText ?? "");
  if (!normalized) return normalized;
  if (process.platform === "win32" && hasPowerShell()) {
    const dpapi = encryptWithDpapi(normalized);
    if (dpapi) {
      return encodeEnvelope({
        version: 1,
        alg: "dpapi",
        payload: dpapi
      });
    }
  }
  return encodeEnvelope(encryptFallback(projectDir, normalized));
}
function decryptSensitiveValue(projectDir, rawValue) {
  const raw = String(rawValue ?? "");
  if (!raw.startsWith("miya-sec:")) return raw;
  const envelope = decodeEnvelope(raw);
  if (!envelope) return raw;
  if (envelope.alg === "dpapi") {
    const decoded = decryptWithDpapi(envelope.payload);
    return decoded ?? raw;
  }
  const fallback = decryptFallback(projectDir, envelope);
  return fallback ?? raw;
}
var init_system_keyring = __esm({
  "src/security/system-keyring.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/media/store.ts
import * as fs9 from "node:fs";
import * as path9 from "node:path";
import { randomUUID as randomUUID2 } from "node:crypto";
function nowIso() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function mediaDir(projectDir) {
  return path9.join(getMiyaRuntimeDir(projectDir), "media");
}
function mediaIndexFile(projectDir) {
  return path9.join(mediaDir(projectDir), "index.json");
}
function ensureDir3(dirPath) {
  fs9.mkdirSync(dirPath, { recursive: true });
}
function decodeMetadata(projectDir, metadata) {
  if (!metadata || typeof metadata !== "object") return metadata;
  if (typeof metadata.secure === "string") {
    try {
      const plain = decryptSensitiveValue(projectDir, metadata.secure);
      const parsed = JSON.parse(plain);
      return parsed;
    } catch {
      return metadata;
    }
  }
  return metadata;
}
function readStore(projectDir) {
  const file3 = mediaIndexFile(projectDir);
  if (!fs9.existsSync(file3)) {
    return { items: {} };
  }
  try {
    const parsed = JSON.parse(fs9.readFileSync(file3, "utf-8"));
    const items = {};
    for (const [id, item] of Object.entries(parsed.items ?? {})) {
      items[id] = {
        ...item,
        source: decryptSensitiveValue(projectDir, String(item.source ?? "")),
        fileName: decryptSensitiveValue(projectDir, String(item.fileName ?? "")),
        localPath: typeof item.localPath === "string" ? decryptSensitiveValue(projectDir, item.localPath) : item.localPath,
        metadata: decodeMetadata(projectDir, item.metadata)
      };
    }
    return { items };
  } catch {
    return { items: {} };
  }
}
function writeStore(projectDir, store) {
  ensureDir3(mediaDir(projectDir));
  const encrypted = { items: {} };
  for (const [id, item] of Object.entries(store.items)) {
    encrypted.items[id] = {
      ...item,
      source: encryptSensitiveValue(projectDir, item.source),
      fileName: encryptSensitiveValue(projectDir, item.fileName),
      localPath: item.localPath ? encryptSensitiveValue(projectDir, item.localPath) : item.localPath,
      metadata: item.metadata ? {
        secure: encryptSensitiveValue(projectDir, JSON.stringify(item.metadata))
      } : item.metadata
    };
  }
  fs9.writeFileSync(
    mediaIndexFile(projectDir),
    `${JSON.stringify(encrypted, null, 2)}
`,
    "utf-8"
  );
}
function buildExpiration(ttlHours) {
  const expires = new Date(Date.now() + ttlHours * 3600 * 1e3);
  return expires.toISOString();
}
function ingestMedia(projectDir, input) {
  const ttlHours = Math.max(1, input.ttlHours ?? DEFAULT_TTL_HOURS);
  const store = readStore(projectDir);
  const id = `media_${randomUUID2()}`;
  let localPath;
  if (input.contentBase64) {
    const dir = mediaDir(projectDir);
    ensureDir3(dir);
    const ext = path9.extname(input.fileName) || ".bin";
    const filePath12 = path9.join(dir, `${id}${ext}`);
    fs9.writeFileSync(filePath12, Buffer.from(input.contentBase64, "base64"));
    localPath = filePath12;
  }
  const item = {
    id,
    source: input.source,
    kind: input.kind,
    mimeType: input.mimeType,
    fileName: input.fileName,
    localPath,
    sizeBytes: input.sizeBytes,
    createdAt: nowIso(),
    expiresAt: buildExpiration(ttlHours),
    metadata: input.metadata
  };
  store.items[id] = item;
  writeStore(projectDir, store);
  return item;
}
function getMediaItem(projectDir, mediaID) {
  const store = readStore(projectDir);
  return store.items[mediaID] ?? null;
}
function listMediaItems(projectDir, limit = 100) {
  const store = readStore(projectDir);
  return Object.values(store.items).sort((a, b) => Date.parse(b.createdAt) - Date.parse(a.createdAt)).slice(0, Math.max(1, limit));
}
function runMediaGc(projectDir) {
  const store = readStore(projectDir);
  const now = Date.now();
  let removed = 0;
  for (const [id, item] of Object.entries(store.items)) {
    const expired = Date.parse(item.expiresAt) <= now;
    if (!expired) continue;
    if (item.localPath && fs9.existsSync(item.localPath)) {
      try {
        fs9.unlinkSync(item.localPath);
      } catch {
      }
    }
    delete store.items[id];
    removed += 1;
  }
  writeStore(projectDir, store);
  return {
    removed,
    kept: Object.keys(store.items).length
  };
}
var DEFAULT_TTL_HOURS;
var init_store2 = __esm({
  "src/media/store.ts"() {
    "use strict";
    init_workflow();
    init_system_keyring();
    DEFAULT_TTL_HOURS = 24;
  }
});

// src/multimodal/ocr-cache.ts
var init_ocr_cache = __esm({
  "src/multimodal/ocr-cache.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/multimodal/vision.ts
import * as fs10 from "node:fs";
async function commandExists(command) {
  const probe = process.platform === "win32" ? ["where", command] : ["which", command];
  const result = await runProcess(probe[0], probe.slice(1), { timeoutMs: 3e3 });
  return !result.timedOut && result.exitCode === 0;
}
async function runTesseractOcr(imagePath) {
  if (!await commandExists("tesseract")) return "";
  const args = process.platform === "win32" ? ["tesseract", imagePath, "stdout", "--psm", "6"] : ["tesseract", imagePath, "stdout", "--psm", "6"];
  const result = await runProcess(args[0], args.slice(1), { timeoutMs: 8e3 });
  if (result.timedOut || result.exitCode !== 0) return "";
  return result.stdout.trim();
}
async function runRemoteVisionInference(imagePath, question) {
  const endpoint = process.env.MIYA_VISION_OCR_ENDPOINT?.trim();
  if (!endpoint) return { text: "" };
  if (!fs10.existsSync(imagePath)) return { text: "" };
  const image = fs10.readFileSync(imagePath);
  const mimeType = imagePath.endsWith(".png") ? "image/png" : imagePath.endsWith(".jpg") || imagePath.endsWith(".jpeg") ? "image/jpeg" : "application/octet-stream";
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        imageBase64: image.toString("base64"),
        mimeType,
        question: question ?? ""
      })
    });
    if (!response.ok) return { text: "" };
    const payload = await response.json();
    const text = String(payload.text ?? payload.ocr_text ?? "").trim();
    return {
      text,
      summary: payload.summary ? String(payload.summary) : void 0,
      boxes: Array.isArray(payload.boxes) ? payload.boxes : void 0
    };
  } catch {
    return { text: "" };
  }
}
async function readTextFromImage(imagePath, question) {
  const remote = await runRemoteVisionInference(imagePath, question);
  if (remote.text) {
    return {
      source: "remote_vlm",
      text: remote.text,
      summary: remote.summary,
      boxes: remote.boxes
    };
  }
  const tesseractText = await runTesseractOcr(imagePath);
  if (tesseractText) {
    return {
      source: "tesseract",
      text: tesseractText
    };
  }
  return {
    source: "none",
    text: ""
  };
}
function normalizeCaptureMethod(input) {
  const raw = String(input ?? "").trim().toLowerCase();
  if (!raw) return null;
  if (raw === "wgc" || raw === "wgc_hwnd") return "wgc_hwnd";
  if (raw === "printwindow" || raw === "print_window") return "print_window";
  if (raw === "dxgi" || raw === "dxgi_duplication") return "dxgi_duplication";
  if (raw === "uia" || raw === "uia_only") return "uia_only";
  if (raw === "unknown") return "unknown";
  return null;
}
function parseCaptureMethods(input) {
  const raw = String(input ?? "").trim();
  if (!raw) return [...CAPTURE_PRIORITY];
  const methods = raw.split(",").map((item) => normalizeCaptureMethod(item)).filter((item) => Boolean(item) && item !== "unknown");
  if (methods.length === 0) return [...CAPTURE_PRIORITY];
  return [...new Set(methods)];
}
function inferCaptureProbeLimitations(input) {
  const signal = `${input.visualPrecheck ?? ""}|${input.visualPostcheck ?? ""}`.toLowerCase();
  const result = [];
  if (!signal.trim()) return result;
  if (signal.includes("black")) result.push("capture_probe_black_screen");
  if (signal.includes("timeout")) result.push("capture_probe_timeout");
  if (signal.includes("error") || signal.includes("failed")) result.push("capture_probe_error");
  if (signal.includes("occluded")) result.push("capture_probe_occluded");
  return [...new Set(result)];
}
function compactOcrText(text) {
  return (text || "").replace(/\s+/g, "").toLowerCase();
}
function parseDesktopOcrSignals(ocrText, expectedRecipient) {
  const normalized = (ocrText || "").replace(/\s+/g, " ").trim();
  const recipient = expectedRecipient.trim();
  const lowered = normalized.toLowerCase();
  const compactNormalized = compactOcrText(normalized);
  const compactRecipient = compactOcrText(recipient);
  const recipientDetected = recipient && (normalized.includes(recipient) || lowered.includes(recipient.toLowerCase()) || compactRecipient.length > 0 && compactNormalized.includes(compactRecipient)) ? recipient : "";
  const sentHints = [
    "\u53D1\u9001\u6210\u529F",
    "\u5DF2\u53D1\u9001",
    "sent",
    "delivered",
    "\u53D1\u9001",
    "\u5DF2\u53D1\u51FA"
  ];
  const failHints = [
    "\u53D1\u9001\u5931\u8D25",
    "failed",
    "\u5931\u8D25",
    "retry",
    "\u91CD\u8BD5",
    "\u672A\u53D1\u9001"
  ];
  const hasSent = sentHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const hasFail = failHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const sendStatusDetected = hasFail ? "failed" : hasSent ? "sent" : "uncertain";
  let recipientMatch = "uncertain";
  if (recipientDetected) {
    recipientMatch = "matched";
  } else if (recipient && normalized.length > 0) {
    recipientMatch = "mismatch";
  }
  return {
    recipientDetected,
    recipientMatch,
    sendStatusDetected
  };
}
async function analyzeDesktopOutboundEvidence(input) {
  const capture = resolveCaptureCapability(input);
  const candidates = [
    input.postSendScreenshotPath,
    input.preSendScreenshotPath
  ].filter((item) => typeof item === "string" && fs10.existsSync(item));
  if (candidates.length === 0) {
    const recipientMatch = input.recipientTextCheck ?? "uncertain";
    const sendStatusDetected = input.receiptStatus === "confirmed" ? "sent" : "uncertain";
    return {
      recipientMatch,
      sendStatusDetected,
      ocrSource: "none",
      ocrPreview: "",
      uiStyleMismatch: true,
      retries: 0,
      lowConfidenceAttempts: 1,
      capture: {
        method: capture.method,
        confidence: capture.confidence,
        limitations: mergeCaptureLimitations(capture.limitations, {
          uiStyleMismatch: true,
          recipientMatch,
          sendStatusDetected
        })
      }
    };
  }
  const isLowConfidenceText = (text) => {
    const trimmed = (text || "").replace(/\s+/g, "");
    if (trimmed.length < 8) return true;
    const meaningful = trimmed.replace(/[a-zA-Z0-9\u4e00-\u9fa5]/g, "");
    const noiseRatio = meaningful.length / Math.max(1, trimmed.length);
    return noiseRatio > 0.6;
  };
  let inferred = await readTextFromImage(candidates[0], "\u8BC6\u522B\u804A\u5929\u754C\u9762\u6536\u4EF6\u4EBA\u4E0E\u53D1\u9001\u72B6\u6001");
  let signals = parseDesktopOcrSignals(inferred.text, input.destination);
  let retries = 0;
  let lowConfidenceAttempts = inferred.source === "none" || isLowConfidenceText(inferred.text) ? 1 : 0;
  let uiStyleMismatch = inferred.source === "none" || signals.recipientMatch !== "matched" && isLowConfidenceText(inferred.text);
  if (candidates.length > 1 && (signals.recipientMatch === "mismatch" || uiStyleMismatch)) {
    const retryInferred = await readTextFromImage(
      candidates[1],
      "DPI\u6837\u5F0F\u517C\u5BB9\u91CD\u8BD5\uFF1A\u8BC6\u522B\u804A\u5929\u754C\u9762\u6536\u4EF6\u4EBA\u4E0E\u53D1\u9001\u72B6\u6001"
    );
    const retrySignals = parseDesktopOcrSignals(retryInferred.text, input.destination);
    retries = 1;
    if (retryInferred.source === "none" || isLowConfidenceText(retryInferred.text)) {
      lowConfidenceAttempts += 1;
    }
    const retryBetter = retrySignals.recipientMatch === "matched" || retrySignals.sendStatusDetected !== "uncertain" && signals.sendStatusDetected === "uncertain" || !isLowConfidenceText(retryInferred.text) && isLowConfidenceText(inferred.text);
    if (retryBetter) {
      inferred = retryInferred;
      signals = retrySignals;
    }
    uiStyleMismatch = (inferred.source === "none" || isLowConfidenceText(inferred.text)) && signals.recipientMatch !== "matched";
  }
  const mergedRecipient = signals.recipientMatch === "mismatch" && input.recipientTextCheck === "matched" ? "matched" : signals.recipientMatch === "uncertain" ? input.recipientTextCheck ?? "uncertain" : signals.recipientMatch;
  const mergedStatus = signals.sendStatusDetected === "uncertain" ? input.receiptStatus === "confirmed" ? "sent" : "uncertain" : signals.sendStatusDetected;
  const stableRecipient = uiStyleMismatch && mergedRecipient === "mismatch" ? "uncertain" : mergedRecipient;
  const confidence = estimateEvidenceConfidence({
    ocrSource: inferred.source,
    uiStyleMismatch,
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    retries
  });
  const mergedConfidence = Number(Math.min(confidence, capture.confidence).toFixed(2));
  if (mergedConfidence < 0.45 || lowConfidenceAttempts >= 2) {
    uiStyleMismatch = true;
  }
  return {
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    ocrSource: inferred.source,
    ocrPreview: inferred.text.slice(0, 300),
    uiStyleMismatch,
    retries,
    lowConfidenceAttempts,
    capture: {
      method: capture.method,
      confidence: mergedConfidence,
      limitations: mergeCaptureLimitations(capture.limitations, {
        uiStyleMismatch,
        recipientMatch: stableRecipient,
        sendStatusDetected: mergedStatus
      })
    }
  };
}
function resolveCaptureCapability(input) {
  const hasScreenshots = typeof input.preSendScreenshotPath === "string" && input.preSendScreenshotPath.length > 0 && fs10.existsSync(input.preSendScreenshotPath) || typeof input.postSendScreenshotPath === "string" && input.postSendScreenshotPath.length > 0 && fs10.existsSync(input.postSendScreenshotPath);
  const supported = parseCaptureMethods(process.env.MIYA_CAPTURE_CAPABILITIES);
  const preferred = CAPTURE_PRIORITY.find((item) => supported.includes(item));
  const requested = normalizeCaptureMethod(process.env.MIYA_CAPTURE_METHOD);
  let method = "unknown";
  if (hasScreenshots) {
    if (requested && supported.includes(requested)) {
      method = requested;
    } else if (preferred) {
      method = preferred;
    } else {
      method = "unknown";
    }
  } else {
    method = supported.includes("uia_only") ? "uia_only" : "unknown";
  }
  const limitations = [];
  limitations.push(...inferCaptureProbeLimitations(input));
  if (!hasScreenshots) {
    limitations.push("no_desktop_screenshot");
  }
  if (requested && requested !== "unknown" && !supported.includes(requested)) {
    limitations.push(`capture_method_not_supported:${requested}`);
  }
  if (hasScreenshots && preferred && method !== "unknown" && method !== preferred) {
    limitations.push(`capture_fallback:${preferred}->${method}`);
  }
  if (!hasScreenshots && preferred && preferred !== "uia_only") {
    limitations.push(`capture_tree_exhausted:${preferred}`);
  }
  if (method === "unknown") limitations.push("capture_method_unspecified");
  if (method === "uia_only") limitations.push("pixel_evidence_unavailable");
  const baseByMethod = {
    wgc_hwnd: 0.92,
    print_window: 0.84,
    dxgi_duplication: 0.76,
    uia_only: 0.4,
    unknown: 0.24
  };
  let confidence = baseByMethod[method];
  if (!hasScreenshots) {
    confidence = Math.min(confidence, method === "uia_only" ? 0.34 : 0.24);
  }
  if (limitations.includes("capture_probe_black_screen")) {
    confidence = Math.min(confidence, 0.28);
  }
  if (limitations.includes("capture_probe_timeout")) {
    confidence = Math.min(confidence, 0.3);
  }
  if (limitations.includes("capture_probe_error")) {
    confidence = Math.min(confidence, 0.3);
  }
  return {
    method,
    confidence: Number(confidence.toFixed(2)),
    limitations
  };
}
function estimateEvidenceConfidence(input) {
  let score = input.ocrSource === "remote_vlm" ? 0.86 : input.ocrSource === "tesseract" ? 0.72 : 0.35;
  if (input.uiStyleMismatch) score -= 0.32;
  if (input.recipientMatch === "matched") score += 0.08;
  if (input.sendStatusDetected === "sent" || input.sendStatusDetected === "failed") score += 0.04;
  if (input.retries > 0) score -= 0.05;
  if (score < 0) return 0;
  if (score > 1) return 1;
  return Number(score.toFixed(2));
}
function mergeCaptureLimitations(base, input) {
  const result = [...base];
  if (input.uiStyleMismatch) result.push("ui_style_mismatch");
  if (input.recipientMatch === "uncertain") result.push("recipient_unverified");
  if (input.sendStatusDetected === "uncertain") result.push("delivery_unverified");
  return [...new Set(result)];
}
var CAPTURE_PRIORITY;
var init_vision = __esm({
  "src/multimodal/vision.ts"() {
    "use strict";
    init_store2();
    init_utils2();
    init_ocr_cache();
    CAPTURE_PRIORITY = [
      "wgc_hwnd",
      "print_window",
      "dxgi_duplication",
      "uia_only"
    ];
  }
});

// src/channels/policy.ts
function getChannelDirection(channel) {
  return OUTBOUND_ALLOWLIST_CHANNELS.has(channel) ? "OUTBOUND_ALLOWLIST" : "INBOUND_ONLY";
}
function canChannelSend(channel) {
  return getChannelDirection(channel) === "OUTBOUND_ALLOWLIST";
}
function assertChannelCanSend(channel) {
  if (canChannelSend(channel)) return;
  throw new Error(
    `channel_send_blocked:${channel}:INBOUND_ONLY channels are receive-only`
  );
}
var OUTBOUND_ALLOWLIST_CHANNELS;
var init_policy = __esm({
  "src/channels/policy.ts"() {
    "use strict";
    OUTBOUND_ALLOWLIST_CHANNELS = /* @__PURE__ */ new Set(["qq", "wechat"]);
  }
});

// src/channels/types.ts
function isChannelName(value) {
  return typeof value === "string" && CHANNEL_NAMES.includes(value);
}
var CHANNEL_NAMES;
var init_types = __esm({
  "src/channels/types.ts"() {
    "use strict";
    CHANNEL_NAMES = [
      "qq",
      "wechat",
      "telegram",
      "slack",
      "discord",
      "whatsapp",
      "google_chat",
      "signal",
      "imessage",
      "teams",
      "webchat"
    ];
  }
});

// src/channels/pairing-store.ts
import * as fs11 from "node:fs";
import * as path10 from "node:path";
function nowIso2() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath2(projectDir) {
  return path10.join(getMiyaRuntimeDir(projectDir), "channels.json");
}
function ensureDir4(file3) {
  fs11.mkdirSync(path10.dirname(file3), { recursive: true });
}
function defaultChannelState(name) {
  return {
    name,
    enabled: name === "webchat",
    connected: name === "webchat",
    updatedAt: nowIso2(),
    allowlist: [],
    contactTiers: {}
  };
}
function defaultStore() {
  const channels = {};
  for (const name of CHANNEL_NAMES) {
    channels[name] = defaultChannelState(name);
  }
  return { channels, pairs: [] };
}
function readChannelStore(projectDir) {
  const file3 = filePath2(projectDir);
  if (!fs11.existsSync(file3)) {
    return defaultStore();
  }
  try {
    const parsed = JSON.parse(fs11.readFileSync(file3, "utf-8"));
    const fallback = defaultStore();
    const mergedChannels = {};
    for (const name of CHANNEL_NAMES) {
      const channel = {
        ...fallback.channels[name],
        ...parsed.channels?.[name] ?? {}
      };
      const allowlist = Array.isArray(channel.allowlist) ? channel.allowlist.map((item) => decryptSensitiveValue(projectDir, String(item))) : [];
      const contactTiersRaw = channel.contactTiers && typeof channel.contactTiers === "object" ? channel.contactTiers : {};
      const contactTiers = {};
      for (const [senderID, tier] of Object.entries(contactTiersRaw)) {
        const decoded = decryptSensitiveValue(projectDir, senderID);
        if (tier === "owner" || tier === "friend") {
          contactTiers[decoded] = tier;
        }
      }
      mergedChannels[name] = {
        ...channel,
        allowlist,
        contactTiers
      };
    }
    const pairs = Array.isArray(parsed.pairs) ? parsed.pairs : [];
    return {
      channels: mergedChannels,
      pairs: pairs.map((pair) => ({
        ...pair,
        senderID: decryptSensitiveValue(projectDir, pair.senderID),
        displayName: pair.displayName ? decryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
        messagePreview: pair.messagePreview ? decryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
      }))
    };
  } catch {
    return defaultStore();
  }
}
function writeChannelStore(projectDir, store) {
  const file3 = filePath2(projectDir);
  ensureDir4(file3);
  const encrypted = {
    channels: Object.fromEntries(
      Object.entries(store.channels).map(([name, state]) => {
        const contactTiers = {};
        for (const [senderID, tier] of Object.entries(state.contactTiers ?? {})) {
          contactTiers[encryptSensitiveValue(projectDir, senderID)] = tier;
        }
        return [
          name,
          {
            ...state,
            allowlist: state.allowlist.map(
              (item) => encryptSensitiveValue(projectDir, item)
            ),
            contactTiers
          }
        ];
      })
    ),
    pairs: store.pairs.map((pair) => ({
      ...pair,
      senderID: encryptSensitiveValue(projectDir, pair.senderID),
      displayName: pair.displayName ? encryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
      messagePreview: pair.messagePreview ? encryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
    }))
  };
  fs11.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function listChannelStates(projectDir) {
  const store = readChannelStore(projectDir);
  return Object.values(store.channels).sort((a, b) => a.name.localeCompare(b.name));
}
function upsertChannelState(projectDir, name, patch) {
  const store = readChannelStore(projectDir);
  const next = {
    ...store.channels[name],
    ...patch,
    name,
    updatedAt: nowIso2()
  };
  store.channels[name] = next;
  writeChannelStore(projectDir, store);
  return next;
}
function ensurePairRequest(projectDir, input) {
  const store = readChannelStore(projectDir);
  const existing = store.pairs.find(
    (item) => item.channel === input.channel && item.senderID === input.senderID && item.status === "pending"
  );
  if (existing) return existing;
  const next = {
    id: `pair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    channel: input.channel,
    senderID: input.senderID,
    displayName: input.displayName,
    messagePreview: input.messagePreview,
    status: "pending",
    requestedAt: nowIso2()
  };
  store.pairs = [next, ...store.pairs].slice(0, 1e3);
  writeChannelStore(projectDir, store);
  return next;
}
function resolvePairRequest(projectDir, pairID, status) {
  const store = readChannelStore(projectDir);
  const pair = store.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending") return null;
  pair.status = status;
  pair.resolvedAt = nowIso2();
  if (status === "approved") {
    const channel = store.channels[pair.channel];
    const ownerByEnv = new Set(
      String(process.env.MIYA_OWNER_IDS ?? "").split(",").map((item) => item.trim()).filter(Boolean)
    );
    if (!channel.allowlist.includes(pair.senderID)) {
      channel.allowlist = [...channel.allowlist, pair.senderID].sort();
    }
    const currentTier = channel.contactTiers?.[pair.senderID];
    const resolvedTier = currentTier ?? (ownerByEnv.has(pair.senderID) ? "owner" : "friend");
    channel.contactTiers = {
      ...channel.contactTiers ?? {},
      [pair.senderID]: resolvedTier
    };
    channel.updatedAt = nowIso2();
  }
  writeChannelStore(projectDir, store);
  return pair;
}
function listPairRequests(projectDir, status) {
  const store = readChannelStore(projectDir);
  const pairs = status ? store.pairs.filter((item) => item.status === status) : store.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function isSenderAllowed(projectDir, channel, senderID) {
  const store = readChannelStore(projectDir);
  const allowed = store.channels[channel].allowlist;
  return allowed.includes(senderID);
}
function getContactTier(projectDir, channel, senderID) {
  const store = readChannelStore(projectDir);
  const state = store.channels[channel];
  if (!state.allowlist.includes(senderID)) return null;
  return state.contactTiers?.[senderID] ?? "friend";
}
function setContactTier(projectDir, channel, senderID, tier) {
  const store = readChannelStore(projectDir);
  const state = store.channels[channel];
  const allowlist = state.allowlist.includes(senderID) ? state.allowlist : [...state.allowlist, senderID].sort();
  const next = {
    ...state,
    allowlist,
    contactTiers: {
      ...state.contactTiers ?? {},
      [senderID]: tier
    },
    updatedAt: nowIso2()
  };
  store.channels[channel] = next;
  writeChannelStore(projectDir, store);
  return next;
}
function listContactTiers(projectDir, channel) {
  const store = readChannelStore(projectDir);
  const channels = channel ? [channel] : [...CHANNEL_NAMES];
  const rows = [];
  for (const name of channels) {
    const state = store.channels[name];
    const mapping = state.contactTiers ?? {};
    for (const senderID of state.allowlist) {
      rows.push({
        channel: name,
        senderID,
        tier: mapping[senderID] ?? "friend"
      });
    }
  }
  return rows.sort(
    (a, b) => `${a.channel}:${a.senderID}`.localeCompare(`${b.channel}:${b.senderID}`)
  );
}
var init_pairing_store = __esm({
  "src/channels/pairing-store.ts"() {
    "use strict";
    init_workflow();
    init_system_keyring();
    init_types();
  }
});

// src/policy/index.ts
import { createHash as createHash3 } from "node:crypto";
import * as fs12 from "node:fs";
import * as path11 from "node:path";
function nowIso3() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function policyFile(projectDir) {
  return path11.join(getMiyaRuntimeDir(projectDir), "policy.json");
}
function defaultPolicy() {
  return {
    version: 1,
    updatedAt: nowIso3(),
    domains: {
      outbound_send: "running",
      desktop_control: "running",
      shell_exec: "running",
      fs_write: "running",
      memory_read: "running",
      memory_write: "running",
      memory_delete: "running",
      training: "running",
      media_generate: "running",
      read_only_research: "running",
      local_build: "running"
    },
    outbound: {
      allowedChannels: ["qq", "wechat"],
      requireArchAdvisorApproval: true,
      requireAllowlist: true,
      minIntervalMs: 4e3,
      burstWindowMs: 6e4,
      burstLimit: 3,
      duplicateWindowMs: 6e4
    }
  };
}
function readPolicy(projectDir) {
  const file3 = policyFile(projectDir);
  if (!fs12.existsSync(file3)) {
    const base = defaultPolicy();
    fs12.mkdirSync(path11.dirname(file3), { recursive: true });
    fs12.writeFileSync(file3, `${JSON.stringify(base, null, 2)}
`, "utf-8");
    return base;
  }
  try {
    const parsed = JSON.parse(fs12.readFileSync(file3, "utf-8"));
    const base = defaultPolicy();
    const parsedDomains = parsed.domains && typeof parsed.domains === "object" ? parsed.domains : {};
    return {
      ...base,
      ...parsed,
      domains: {
        ...base.domains,
        ...parsedDomains
      },
      outbound: {
        ...base.outbound,
        ...parsed.outbound ?? {}
      }
    };
  } catch {
    return defaultPolicy();
  }
}
function writePolicy(projectDir, patch) {
  const file3 = policyFile(projectDir);
  const current = readPolicy(projectDir);
  const next = {
    ...current,
    ...patch,
    outbound: {
      ...current.outbound,
      ...patch.outbound ?? {}
    },
    updatedAt: nowIso3()
  };
  fs12.mkdirSync(path11.dirname(file3), { recursive: true });
  fs12.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function hashPolicy(policy) {
  return createHash3("sha256").update(
    JSON.stringify({
      version: policy.version,
      domains: policy.domains,
      outbound: policy.outbound
    })
  ).digest("hex");
}
function currentPolicyHash(projectDir) {
  return hashPolicy(readPolicy(projectDir));
}
function assertPolicyHash(projectDir, providedHash) {
  const hash3 = currentPolicyHash(projectDir);
  if (!providedHash) {
    return { ok: false, hash: hash3, reason: "missing_policy_hash" };
  }
  if (providedHash !== hash3) {
    return { ok: false, hash: hash3, reason: "policy_hash_mismatch" };
  }
  return { ok: true, hash: hash3 };
}
function isDomainRunning(projectDir, domain3) {
  const policy = readPolicy(projectDir);
  return policy.domains[domain3] === "running";
}
function isPolicyDomain(value) {
  return typeof value === "string" && POLICY_DOMAINS.includes(value);
}
var POLICY_DOMAINS;
var init_policy2 = __esm({
  "src/policy/index.ts"() {
    "use strict";
    init_workflow();
    POLICY_DOMAINS = [
      "outbound_send",
      "desktop_control",
      "shell_exec",
      "fs_write",
      "memory_read",
      "memory_write",
      "memory_delete",
      "training",
      "media_generate",
      "read_only_research",
      "local_build"
    ];
  }
});

// src/policy/semantic-tags.ts
function isSemanticTag(value) {
  return typeof value === "string" && SEMANTIC_TAGS.includes(value);
}
function normalizeSemanticTags(value) {
  if (!Array.isArray(value)) return [];
  return value.map((item) => String(item)).filter((item) => isSemanticTag(item));
}
function assertSemanticTags(value) {
  if (!Array.isArray(value)) return;
  for (const item of value) {
    if (!isSemanticTag(item)) {
      throw new Error(`invalid_semantic_tag:${String(item)}`);
    }
  }
}
var SEMANTIC_TAGS;
var init_semantic_tags = __esm({
  "src/policy/semantic-tags.ts"() {
    "use strict";
    SEMANTIC_TAGS = [
      "window_not_found",
      "window_occluded",
      "recipient_mismatch",
      "input_mutex_timeout",
      "receipt_uncertain",
      "privilege_barrier",
      "ui_style_mismatch"
    ];
  }
});

// src/channels/service.ts
import * as fs13 from "node:fs";
import * as path12 from "node:path";
import { createHash as createHash4, randomUUID as randomUUID3 } from "node:crypto";
function parseEnvList(input) {
  if (!input) return [];
  return input.split(",").map((value) => value.trim()).filter(Boolean);
}
function outboundAuditFile(projectDir) {
  return path12.join(getMiyaRuntimeDir(projectDir), "channels-outbound.jsonl");
}
function appendOutboundAudit(projectDir, row) {
  const file3 = outboundAuditFile(projectDir);
  fs13.mkdirSync(path12.dirname(file3), { recursive: true });
  fs13.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
function semanticTagsForOutboundMessage(message) {
  if (message.includes("target_not_in_allowlist")) return ["recipient_mismatch"];
  if (message.includes("recipient_text_mismatch")) return ["recipient_mismatch"];
  if (message.includes("arch_advisor_denied")) return ["privilege_barrier"];
  if (message.includes("input_mutex_timeout")) return ["input_mutex_timeout"];
  if (message.includes("receipt_uncertain")) return ["receipt_uncertain"];
  if (message.includes("blocked_by_privilege") || message.includes("privilege")) {
    return ["privilege_barrier"];
  }
  if (message.includes("window_not_found")) return ["window_not_found"];
  if (message.includes("window_occluded")) return ["window_occluded"];
  if (message.includes("ui_style_mismatch")) return ["ui_style_mismatch"];
  return [];
}
function parsePositiveIntEnv(name, fallback) {
  const raw = process.env[name];
  if (!raw) return fallback;
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return fallback;
  return Math.floor(parsed);
}
function acquireInputMutex(sessionID, timeoutMs = INPUT_MUTEX_TIMEOUT_MS) {
  return new Promise((resolve4, reject) => {
    let released = false;
    const makeLease = () => ({
      release: () => {
        if (released) return;
        released = true;
        if (inputMutexOwner === sessionID) {
          inputMutexOwner = null;
        }
        while (inputMutexQueue.length > 0 && !inputMutexOwner) {
          const next = inputMutexQueue.shift();
          if (!next) break;
          if (!next.active) continue;
          next.grant();
        }
      }
    });
    const pending = {
      sessionID,
      active: true,
      grant: () => {
      }
    };
    const timer = setTimeout(() => {
      pending.active = false;
      const idx = inputMutexQueue.indexOf(pending);
      if (idx >= 0) inputMutexQueue.splice(idx, 1);
      reject(new Error("input_mutex_timeout"));
    }, timeoutMs);
    const grant = () => {
      if (!pending.active) return;
      pending.active = false;
      clearTimeout(timer);
      inputMutexOwner = sessionID;
      resolve4(makeLease());
    };
    pending.grant = grant;
    if (!inputMutexOwner) {
      grant();
      return;
    }
    inputMutexQueue.push(pending);
  });
}
function buildSemanticSummary(row) {
  if (row.sent) {
    return {
      conclusion: "Outbound send completed with verifiable desktop evidence.",
      keyAssertion: `recipient_check=${row.recipientTextCheck ?? "uncertain"}, send_status=${row.sendStatusCheck ?? "uncertain"}`,
      recovery: "No recovery needed."
    };
  }
  if (row.message.includes("arch_advisor_denied")) {
    return {
      conclusion: "Outbound send blocked by Arch Advisor approval gate.",
      keyAssertion: "Arch Advisor approval flag was false, so outbound flow was denied before desktop execution.",
      recovery: "Re-issue approval ticket via Arch Advisor and retry only after policy checks pass."
    };
  }
  if (row.message.includes("input_mutex_timeout")) {
    return {
      conclusion: "Outbound send blocked by input mutex timeout.",
      keyAssertion: "Desktop control was denied because user input mutex could not be acquired in time.",
      recovery: "Wait for user idle state and retry with renewed approval tickets."
    };
  }
  if (row.message.includes("ui_style_mismatch")) {
    return {
      conclusion: "Outbound send degraded due to unstable UI/OCR style mismatch.",
      keyAssertion: "Visual confirmation confidence was too low after retry, so send was treated as failed.",
      recovery: "Adjust DPI/theme/window state, then retry with refreshed evidence."
    };
  }
  return {
    conclusion: row.sent ? "Outbound send completed." : "Outbound send blocked or uncertain.",
    keyAssertion: `message=${row.message}`,
    recovery: row.sent ? "No recovery needed." : "Review desktop evidence and retry only after policy/approval checks pass."
  };
}
function buildEvidenceBundle(row) {
  if (row.channel !== "qq" && row.channel !== "wechat") return void 0;
  const screenshots = [row.preSendScreenshotPath, row.postSendScreenshotPath].filter((item) => typeof item === "string" && item.length > 0);
  const ticketTraceIds = [
    row.ticketSummary?.outboundSendTraceId,
    row.ticketSummary?.desktopControlTraceId
  ].filter((item) => typeof item === "string" && item.length > 0);
  return {
    kind: "desktop_outbound",
    version: "v5",
    destination: row.destination,
    payloadHash: row.payloadHash,
    ticketTraceIds: ticketTraceIds.length > 0 ? ticketTraceIds : void 0,
    screenshots,
    checks: {
      recipientTextCheck: row.recipientTextCheck,
      sendStatusCheck: row.sendStatusCheck,
      receiptStatus: row.receiptStatus
    },
    diagnostics: {
      windowFingerprint: row.windowFingerprint,
      failureStep: row.failureStep,
      ocrSource: row.ocrSource,
      ocrPreview: row.ocrPreview
    },
    meta: {
      captureMethod: row.captureMethod ?? "unknown",
      confidence: Number.isFinite(row.evidenceConfidence) ? Number(row.evidenceConfidence) : 0,
      limitations: row.evidenceLimitations ?? [],
      policyHash: row.policyHash
    },
    simulation: screenshots.length > 0 ? {
      status: "captured",
      clickTargets: []
    } : {
      status: "not_available",
      reason: "desktop_screenshots_missing"
    }
  };
}
function listOutboundAudit(projectDir, limit = 50) {
  const file3 = outboundAuditFile(projectDir);
  if (!fs13.existsSync(file3)) return [];
  const rows = fs13.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}
var INPUT_MUTEX_TIMEOUT_MS, INPUT_MUTEX_STRIKE_LIMIT, INPUT_MUTEX_COOLDOWN_MS, inputMutexOwner, inputMutexQueue, ChannelRuntime;
var init_service = __esm({
  "src/channels/service.ts"() {
    "use strict";
    init_qq();
    init_wechat();
    init_vision();
    init_policy();
    init_pairing_store();
    init_workflow();
    init_policy2();
    init_semantic_tags();
    INPUT_MUTEX_TIMEOUT_MS = parsePositiveIntEnv("MIYA_INPUT_MUTEX_TIMEOUT_MS", 2e4);
    INPUT_MUTEX_STRIKE_LIMIT = 3;
    INPUT_MUTEX_COOLDOWN_MS = 15 * 60 * 1e3;
    inputMutexOwner = null;
    inputMutexQueue = [];
    ChannelRuntime = class {
      projectDir;
      callbacks;
      sendQqDesktopMessageImpl;
      sendWechatDesktopMessageImpl;
      analyzeDesktopOutboundEvidenceImpl;
      telegramPolling = false;
      telegramOffset = 0;
      slackSocketModeRunning = false;
      slackSocket;
      slackReconnectTimer;
      outboundThrottle = /* @__PURE__ */ new Map();
      outboundPayloadHistory = /* @__PURE__ */ new Map();
      inputMutexStrike = /* @__PURE__ */ new Map();
      inputMutexCooldownUntil = /* @__PURE__ */ new Map();
      sendFingerprintHistory = /* @__PURE__ */ new Map();
      constructor(projectDir, callbacks, deps = {}) {
        this.projectDir = projectDir;
        this.callbacks = callbacks;
        this.sendQqDesktopMessageImpl = deps.sendQqDesktopMessage ?? sendQqDesktopMessage;
        this.sendWechatDesktopMessageImpl = deps.sendWechatDesktopMessage ?? sendWechatDesktopMessage;
        this.analyzeDesktopOutboundEvidenceImpl = deps.analyzeDesktopOutboundEvidence ?? analyzeDesktopOutboundEvidence;
      }
      listChannels() {
        return listChannelStates(this.projectDir);
      }
      listPairs(status) {
        return listPairRequests(this.projectDir, status);
      }
      approvePair(pairID) {
        return resolvePairRequest(this.projectDir, pairID, "approved");
      }
      rejectPair(pairID) {
        return resolvePairRequest(this.projectDir, pairID, "rejected");
      }
      markChannelEnabled(channel, enabled) {
        upsertChannelState(this.projectDir, channel, { enabled, connected: enabled });
      }
      async start() {
        upsertChannelState(this.projectDir, "webchat", { enabled: true, connected: true });
        await this.startTelegramPolling();
        this.syncPassiveChannelStates();
        await this.startSlackSocketMode();
      }
      syncPassiveChannelStates() {
        upsertChannelState(this.projectDir, "qq", {
          enabled: false,
          connected: false,
          lastError: "QQ outbound requires desktop UI automation runtime"
        });
        upsertChannelState(this.projectDir, "wechat", {
          enabled: false,
          connected: false,
          lastError: "WeChat outbound requires desktop UI automation runtime"
        });
        const hasSlack = !!process.env.MIYA_SLACK_BOT_TOKEN;
        upsertChannelState(this.projectDir, "slack", {
          enabled: hasSlack,
          connected: hasSlack,
          lastError: hasSlack ? void 0 : "Missing MIYA_SLACK_BOT_TOKEN"
        });
        const hasDiscord = !!process.env.MIYA_DISCORD_BOT_TOKEN;
        upsertChannelState(this.projectDir, "discord", {
          enabled: hasDiscord,
          connected: hasDiscord,
          lastError: hasDiscord ? void 0 : "Missing MIYA_DISCORD_BOT_TOKEN"
        });
        const hasWhatsApp = !!process.env.MIYA_WHATSAPP_TOKEN && !!process.env.MIYA_WHATSAPP_PHONE_NUMBER_ID;
        upsertChannelState(this.projectDir, "whatsapp", {
          enabled: hasWhatsApp,
          connected: hasWhatsApp,
          lastError: hasWhatsApp ? void 0 : "Missing MIYA_WHATSAPP_TOKEN or MIYA_WHATSAPP_PHONE_NUMBER_ID"
        });
        const hasGoogleChat = !!process.env.MIYA_GOOGLE_CHAT_WEBHOOK_URL;
        upsertChannelState(this.projectDir, "google_chat", {
          enabled: hasGoogleChat,
          connected: hasGoogleChat,
          lastError: hasGoogleChat ? void 0 : "Missing MIYA_GOOGLE_CHAT_WEBHOOK_URL"
        });
        const hasSignal = !!process.env.MIYA_SIGNAL_REST_URL;
        upsertChannelState(this.projectDir, "signal", {
          enabled: hasSignal,
          connected: hasSignal,
          lastError: hasSignal ? void 0 : "Missing MIYA_SIGNAL_REST_URL"
        });
        const hasIMessage = !!process.env.MIYA_BLUEBUBBLES_URL;
        upsertChannelState(this.projectDir, "imessage", {
          enabled: hasIMessage,
          connected: hasIMessage,
          lastError: hasIMessage ? void 0 : "Missing MIYA_BLUEBUBBLES_URL"
        });
        const hasTeams = !!process.env.MIYA_TEAMS_WEBHOOK_URL;
        upsertChannelState(this.projectDir, "teams", {
          enabled: hasTeams,
          connected: hasTeams,
          lastError: hasTeams ? void 0 : "Missing MIYA_TEAMS_WEBHOOK_URL"
        });
      }
      async startSlackSocketMode() {
        const appToken = process.env.MIYA_SLACK_APP_TOKEN;
        const botToken = process.env.MIYA_SLACK_BOT_TOKEN;
        if (!appToken || !botToken || this.slackSocketModeRunning) return;
        this.slackSocketModeRunning = true;
        const connect = async () => {
          if (!this.slackSocketModeRunning) return;
          try {
            const openRes = await fetch("https://slack.com/api/apps.connections.open", {
              method: "POST",
              headers: {
                authorization: `Bearer ${appToken}`,
                "content-type": "application/json"
              },
              body: "{}"
            });
            const openBody = await openRes.json();
            if (!openBody.ok || !openBody.url) {
              throw new Error(openBody.error ?? "slack_socket_open_failed");
            }
            const socket = new WebSocket(openBody.url);
            this.slackSocket = socket;
            socket.onopen = () => {
              upsertChannelState(this.projectDir, "slack", {
                enabled: true,
                connected: true,
                lastError: void 0
              });
            };
            socket.onmessage = (event) => {
              void this.handleSlackSocketMessage(String(event.data));
            };
            socket.onerror = () => {
              upsertChannelState(this.projectDir, "slack", {
                connected: false,
                lastError: "slack_socket_error"
              });
            };
            socket.onclose = () => {
              if (!this.slackSocketModeRunning) return;
              upsertChannelState(this.projectDir, "slack", {
                connected: false,
                lastError: "slack_socket_closed"
              });
              this.scheduleSlackReconnect(connect);
            };
          } catch (error92) {
            upsertChannelState(this.projectDir, "slack", {
              connected: false,
              lastError: error92 instanceof Error ? error92.message : String(error92)
            });
            this.scheduleSlackReconnect(connect);
          }
        };
        await connect();
      }
      scheduleSlackReconnect(connect) {
        if (!this.slackSocketModeRunning) return;
        if (this.slackReconnectTimer) clearTimeout(this.slackReconnectTimer);
        this.slackReconnectTimer = setTimeout(() => {
          void connect();
        }, 3e3);
      }
      async handleSlackSocketMessage(messageText) {
        if (!messageText.trim()) return;
        const payload = JSON.parse(messageText);
        if (payload.envelope_id && this.slackSocket?.readyState === WebSocket.OPEN) {
          this.slackSocket.send(JSON.stringify({ envelope_id: payload.envelope_id }));
        }
        if (payload.type !== "events_api") return;
        const event = payload.payload?.event;
        if (!event) return;
        if (event.type !== "message") return;
        if (!event.user || !event.text || !event.channel) return;
        if (event.bot_id) return;
        await this.handleInbound({
          channel: "slack",
          senderID: event.user,
          displayName: event.user,
          conversationID: event.channel,
          text: event.text,
          raw: payload
        });
      }
      async startTelegramPolling() {
        const token = process.env.MIYA_TELEGRAM_BOT_TOKEN;
        if (!token) {
          upsertChannelState(this.projectDir, "telegram", {
            enabled: false,
            connected: false,
            lastError: "Missing MIYA_TELEGRAM_BOT_TOKEN"
          });
          return;
        }
        if (this.telegramPolling) return;
        this.telegramPolling = true;
        upsertChannelState(this.projectDir, "telegram", {
          enabled: true,
          connected: true,
          lastError: void 0
        });
        const poll = async () => {
          if (!this.telegramPolling) return;
          try {
            const url3 = `https://api.telegram.org/bot${token}/getUpdates?timeout=20&offset=${this.telegramOffset}`;
            const response = await fetch(url3);
            const body = await response.json();
            if (!body.ok) {
              throw new Error(body.description ?? "telegram_get_updates_failed");
            }
            for (const update of body.result ?? []) {
              this.telegramOffset = Math.max(this.telegramOffset, Number(update.update_id) + 1);
              const message = update.message;
              if (!message?.text || !message.chat?.id || !message.from?.id) {
                continue;
              }
              await this.handleInbound({
                channel: "telegram",
                senderID: String(message.from.id),
                displayName: message.from.username ?? message.from.first_name ?? String(message.from.id),
                conversationID: String(message.chat.id),
                text: message.text,
                raw: update
              });
            }
            upsertChannelState(this.projectDir, "telegram", {
              connected: true,
              lastError: void 0
            });
          } catch (error92) {
            upsertChannelState(this.projectDir, "telegram", {
              connected: false,
              lastError: error92 instanceof Error ? error92.message : String(error92)
            });
          } finally {
            if (this.telegramPolling) {
              setTimeout(() => {
                void poll();
              }, 500);
            }
          }
        };
        void poll();
      }
      stop() {
        this.telegramPolling = false;
        this.slackSocketModeRunning = false;
        if (this.slackReconnectTimer) {
          clearTimeout(this.slackReconnectTimer);
          this.slackReconnectTimer = void 0;
        }
        if (this.slackSocket) {
          try {
            this.slackSocket.close();
          } catch {
          }
          this.slackSocket = void 0;
        }
      }
      async handleInbound(message) {
        const allowByEnv = parseEnvList(process.env.MIYA_ALLOWED_SENDERS);
        const isAllowed = allowByEnv.length > 0 ? allowByEnv.includes(message.senderID) : isSenderAllowed(this.projectDir, message.channel, message.senderID);
        if (!isAllowed) {
          const pair = ensurePairRequest(this.projectDir, {
            channel: message.channel,
            senderID: message.senderID,
            displayName: message.displayName,
            messagePreview: message.text.slice(0, 120)
          });
          await this.callbacks.onPairRequested(pair);
          await this.sendPairingMessage(message.channel, message.conversationID);
          return;
        }
        await this.callbacks.onInbound(message);
      }
      recordOutboundAttempt(row) {
        const semanticTags = normalizeSemanticTags(
          row.semanticTags ?? semanticTagsForOutboundMessage(row.message)
        );
        assertSemanticTags(semanticTags);
        const payload = {
          id: row.id ?? `out_${randomUUID3()}`,
          at: row.at ?? (/* @__PURE__ */ new Date()).toISOString(),
          channel: row.channel,
          destination: row.destination,
          textPreview: row.textPreview,
          sent: row.sent,
          message: row.message,
          mediaPath: row.mediaPath,
          reason: row.reason,
          riskLevel: row.riskLevel,
          archAdvisorApproved: row.archAdvisorApproved,
          targetInAllowlist: row.targetInAllowlist,
          contactTier: row.contactTier,
          intent: row.intent,
          containsSensitive: row.containsSensitive,
          policyHash: row.policyHash,
          sendFingerprint: row.sendFingerprint,
          ticketSummary: row.ticketSummary,
          visualPrecheck: row.visualPrecheck,
          visualPostcheck: row.visualPostcheck,
          receiptStatus: row.receiptStatus,
          payloadHash: row.payloadHash,
          windowFingerprint: row.windowFingerprint,
          recipientTextCheck: row.recipientTextCheck,
          sendStatusCheck: row.sendStatusCheck,
          preSendScreenshotPath: row.preSendScreenshotPath,
          postSendScreenshotPath: row.postSendScreenshotPath,
          failureStep: row.failureStep,
          ocrSource: row.ocrSource,
          ocrPreview: row.ocrPreview,
          captureMethod: row.captureMethod,
          evidenceConfidence: row.evidenceConfidence,
          evidenceLimitations: row.evidenceLimitations,
          evidenceBundle: buildEvidenceBundle(row),
          semanticSummary: buildSemanticSummary(row),
          semanticTags
        };
        appendOutboundAudit(this.projectDir, payload);
        return payload;
      }
      checkThrottle(channel, destination) {
        const now = Date.now();
        const key = `${channel}:${destination}`;
        const policy = readPolicy(this.projectDir);
        const windowMs = Math.max(1e3, Number(policy.outbound.burstWindowMs || 6e4));
        const minIntervalMs = Math.max(500, Number(policy.outbound.minIntervalMs || 4e3));
        const burstLimit = Math.max(1, Number(policy.outbound.burstLimit || 3));
        const list = (this.outboundThrottle.get(key) ?? []).filter(
          (ts) => now - ts <= windowMs
        );
        if (list.length > 0 && now - list[list.length - 1] < minIntervalMs) {
          this.outboundThrottle.set(key, list);
          return `throttled:min_interval_${minIntervalMs}ms`;
        }
        if (list.length >= burstLimit) {
          this.outboundThrottle.set(key, list);
          return `throttled:burst_limit_${burstLimit}_per_${windowMs}ms`;
        }
        list.push(now);
        this.outboundThrottle.set(key, list);
        return null;
      }
      checkDuplicatePayload(channel, destination, text) {
        const now = Date.now();
        const policy = readPolicy(this.projectDir);
        const duplicateWindowMs = Math.max(
          1e3,
          Number(policy.outbound.duplicateWindowMs || 6e4)
        );
        const key = `${channel}:${destination}`;
        const payloadHash = createHash4("sha256").update(text).digest("hex").slice(0, 24);
        const recent = (this.outboundPayloadHistory.get(key) ?? []).filter(
          (item) => now - item.at <= duplicateWindowMs
        );
        const duplicated = recent.some((item) => item.hash === payloadHash);
        if (!duplicated) {
          recent.push({ at: now, hash: payloadHash });
          this.outboundPayloadHistory.set(key, recent);
          return null;
        }
        this.outboundPayloadHistory.set(key, recent);
        return `duplicate_payload_within_${duplicateWindowMs}ms`;
      }
      isDesktopChannel(channel) {
        return channel === "qq" || channel === "wechat";
      }
      inMutexCooldown(sessionID) {
        const until = this.inputMutexCooldownUntil.get(sessionID) ?? 0;
        return until > Date.now();
      }
      markMutexTimeout(sessionID) {
        const strikes = (this.inputMutexStrike.get(sessionID) ?? 0) + 1;
        this.inputMutexStrike.set(sessionID, strikes);
        if (strikes >= INPUT_MUTEX_STRIKE_LIMIT) {
          this.inputMutexCooldownUntil.set(sessionID, Date.now() + INPUT_MUTEX_COOLDOWN_MS);
          this.inputMutexStrike.set(sessionID, 0);
        }
      }
      clearMutexStrike(sessionID) {
        this.inputMutexStrike.set(sessionID, 0);
      }
      checkSendFingerprint(sendFingerprint) {
        const now = Date.now();
        const windowMs = 6e4;
        for (const [fingerprint, ts] of this.sendFingerprintHistory.entries()) {
          if (now - ts > windowMs) {
            this.sendFingerprintHistory.delete(fingerprint);
          }
        }
        if (this.sendFingerprintHistory.has(sendFingerprint)) {
          return "duplicate_send_fingerprint";
        }
        this.sendFingerprintHistory.set(sendFingerprint, now);
        return null;
      }
      normalizeDesktopRuntimeError(error92) {
        const raw = error92 instanceof Error ? error92.message : typeof error92 === "string" ? error92 : "unknown";
        return raw.trim().toLowerCase().replace(/[^a-z0-9:_-]+/g, "_").slice(0, 120) || "unknown";
      }
      recordDesktopRuntimeFailure(input) {
        const detail = this.normalizeDesktopRuntimeError(input.error);
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: input.textPreview,
          sent: false,
          message: `outbound_degraded:desktop_runtime_exception:${detail}`,
          reason: "desktop_send_failed",
          archAdvisorApproved: input.archAdvisorApproved,
          targetInAllowlist: input.targetInAllowlist,
          contactTier: input.contactTier,
          intent: input.intent,
          containsSensitive: input.containsSensitive,
          riskLevel: input.riskLevel,
          policyHash: input.policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary: input.ticketSummary,
          payloadHash: input.payloadHash,
          failureStep: "desktop.runtime"
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
      writeDesktopFallbackDraft(input) {
        const dir = path12.join(getMiyaRuntimeDir(this.projectDir), "channels-draft");
        fs13.mkdirSync(dir, { recursive: true });
        const safeTarget = input.destination.replace(/[\\/:*?"<>|]/g, "_").slice(0, 40) || "unknown";
        const file3 = path12.join(
          dir,
          `${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-")}_${input.channel}_${safeTarget}.json`
        );
        fs13.writeFileSync(
          file3,
          `${JSON.stringify(
            {
              at: (/* @__PURE__ */ new Date()).toISOString(),
              channel: input.channel,
              destination: input.destination,
              text: input.text,
              mediaPath: input.mediaPath,
              payloadHash: input.payloadHash,
              note: "desktop_control_fallback_manual_send"
            },
            null,
            2
          )}
`,
          "utf-8"
        );
        return file3;
      }
      async sendMessage(input) {
        const text = (input.text ?? "").trim();
        const mediaPath = (input.mediaPath ?? "").trim();
        const payloadHash = (input.payloadHash ?? createHash4("sha256").update(`${text}||${mediaPath}`).digest("hex")).trim();
        if (!text && !mediaPath) {
          return { sent: false, message: "invalid_outbound_payload_empty" };
        }
        try {
          assertChannelCanSend(input.channel);
        } catch (error92) {
          const audit = this.recordOutboundAttempt({
            channel: input.channel,
            destination: input.destination,
            textPreview: text.slice(0, 200),
            sent: false,
            message: error92 instanceof Error ? error92.message : String(error92),
            reason: "channel_blocked",
            payloadHash
          });
          return {
            sent: false,
            message: audit.message,
            auditID: audit.id
          };
        }
        const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
        const riskLevel = input.outboundCheck?.riskLevel ?? "HIGH";
        const intent = input.outboundCheck?.intent ?? "initiate";
        const containsSensitive = Boolean(input.outboundCheck?.containsSensitive);
        const policyHash = input.outboundCheck?.policyHash;
        const sessionID = (input.sessionID ?? "main").trim() || "main";
        const ticketSummary = input.approvalTickets?.outboundSend && input.approvalTickets.desktopControl ? {
          outboundSendTraceId: input.approvalTickets.outboundSend.traceID,
          desktopControlTraceId: input.approvalTickets.desktopControl.traceID,
          expiresAt: Date.parse(input.approvalTickets.outboundSend.expiresAt) < Date.parse(input.approvalTickets.desktopControl.expiresAt) ? input.approvalTickets.outboundSend.expiresAt : input.approvalTickets.desktopControl.expiresAt
        } : void 0;
        if (!archAdvisorApproved) {
          const audit = this.recordOutboundAttempt({
            channel: input.channel,
            destination: input.destination,
            textPreview: text.slice(0, 200),
            sent: false,
            message: "outbound_blocked:arch_advisor_denied",
            reason: "arch_advisor_denied",
            archAdvisorApproved,
            riskLevel,
            intent,
            containsSensitive,
            policyHash,
            payloadHash
          });
          return { sent: false, message: audit.message, auditID: audit.id };
        }
        const targetInAllowlist = input.outboundCheck?.bypassAllowlist === true ? true : isSenderAllowed(this.projectDir, input.channel, input.destination);
        if (!targetInAllowlist) {
          const audit = this.recordOutboundAttempt({
            channel: input.channel,
            destination: input.destination,
            textPreview: text.slice(0, 200),
            sent: false,
            message: `outbound_blocked:target_not_in_allowlist:${input.channel}`,
            reason: "allowlist_denied",
            archAdvisorApproved,
            targetInAllowlist,
            riskLevel,
            intent,
            containsSensitive,
            policyHash,
            payloadHash
          });
          return { sent: false, message: audit.message, auditID: audit.id };
        }
        const tier = input.outboundCheck?.bypassAllowlist === true ? "owner" : getContactTier(this.projectDir, input.channel, input.destination);
        if (tier === "friend") {
          if (intent !== "reply") {
            const audit = this.recordOutboundAttempt({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: false,
              message: "outbound_blocked:friend_tier_can_only_reply",
              reason: "allowlist_denied",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              payloadHash
            });
            return { sent: false, message: audit.message, auditID: audit.id };
          }
          if (containsSensitive) {
            const audit = this.recordOutboundAttempt({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: false,
              message: "outbound_blocked:friend_tier_sensitive_content_denied",
              reason: "allowlist_denied",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              payloadHash
            });
            return { sent: false, message: audit.message, auditID: audit.id };
          }
        }
        if (input.outboundCheck?.bypassThrottle !== true) {
          const throttle = this.checkThrottle(input.channel, input.destination);
          if (throttle) {
            const audit = this.recordOutboundAttempt({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: false,
              message: `outbound_blocked:${throttle}`,
              reason: "throttled",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              payloadHash
            });
            return { sent: false, message: audit.message, auditID: audit.id };
          }
        }
        if (input.outboundCheck?.bypassDuplicateGuard !== true) {
          const duplicate = this.checkDuplicatePayload(
            input.channel,
            input.destination,
            `${text}||${mediaPath}`
          );
          if (duplicate) {
            const audit = this.recordOutboundAttempt({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: false,
              message: `outbound_blocked:${duplicate}`,
              reason: "duplicate_payload",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              payloadHash
            });
            return { sent: false, message: audit.message, auditID: audit.id };
          }
        }
        if (input.sendFingerprint) {
          const fingerprintDup = this.checkSendFingerprint(input.sendFingerprint);
          if (fingerprintDup) {
            const audit = this.recordOutboundAttempt({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: false,
              message: `outbound_blocked:${fingerprintDup}`,
              reason: "duplicate_payload",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              sendFingerprint: input.sendFingerprint,
              ticketSummary,
              payloadHash
            });
            return { sent: false, message: audit.message, auditID: audit.id };
          }
        }
        let mutexLease = null;
        if (this.isDesktopChannel(input.channel)) {
          if (this.inMutexCooldown(sessionID)) {
            const audit = this.recordOutboundAttempt({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: false,
              message: "outbound_degraded:input_mutex_cooldown:draft_only",
              reason: "desktop_send_failed",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              sendFingerprint: input.sendFingerprint,
              ticketSummary,
              payloadHash
            });
            return { sent: false, message: audit.message, auditID: audit.id };
          }
          try {
            mutexLease = await acquireInputMutex(sessionID, INPUT_MUTEX_TIMEOUT_MS);
          } catch {
            this.markMutexTimeout(sessionID);
            const audit = this.recordOutboundAttempt({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: false,
              message: "outbound_degraded:input_mutex_timeout:draft_only",
              reason: "desktop_send_failed",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              sendFingerprint: input.sendFingerprint,
              ticketSummary,
              payloadHash
            });
            return { sent: false, message: audit.message, auditID: audit.id };
          }
        }
        if (input.channel === "qq" || input.channel === "wechat") {
          try {
            if (input.channel === "qq") {
              const result2 = await this.sendQqDesktopMessageImpl({
                projectDir: this.projectDir,
                destination: input.destination,
                text,
                mediaPath
              });
              const visionCheck2 = await this.analyzeDesktopOutboundEvidenceImpl({
                destination: input.destination,
                preSendScreenshotPath: result2.preSendScreenshotPath,
                postSendScreenshotPath: result2.postSendScreenshotPath,
                visualPrecheck: result2.visualPrecheck,
                visualPostcheck: result2.visualPostcheck,
                receiptStatus: result2.receiptStatus,
                recipientTextCheck: result2.recipientTextCheck
              });
              if (visionCheck2.recipientMatch === "mismatch") {
                result2.sent = false;
                result2.message = "outbound_blocked:recipient_text_mismatch";
              }
              if (visionCheck2.sendStatusDetected === "failed") {
                result2.sent = false;
                result2.message = "outbound_blocked:receipt_uncertain";
              }
              if (visionCheck2.uiStyleMismatch) {
                result2.sent = false;
                result2.message = "outbound_degraded:ui_style_mismatch:draft_only";
              }
              if (visionCheck2.lowConfidenceAttempts >= 2) {
                result2.sent = false;
                const draftPath = this.writeDesktopFallbackDraft({
                  channel: "qq",
                  destination: input.destination,
                  text,
                  mediaPath: mediaPath || void 0,
                  payloadHash: result2.payloadHash ?? payloadHash
                });
                result2.message = `outbound_degraded:vision_low_confidence_twice:draft_only:path=${draftPath}`;
              }
              if (result2.sent && result2.receiptStatus !== "confirmed") {
                result2.sent = false;
                result2.message = "outbound_blocked:receipt_uncertain";
              }
              const audit2 = this.recordOutboundAttempt({
                channel: "qq",
                destination: input.destination,
                textPreview: text.slice(0, 200),
                sent: result2.sent,
                message: result2.message,
                mediaPath: mediaPath || void 0,
                reason: result2.sent ? "sent" : "desktop_send_failed",
                archAdvisorApproved,
                targetInAllowlist,
                contactTier: tier,
                intent,
                containsSensitive,
                riskLevel,
                policyHash,
                sendFingerprint: input.sendFingerprint,
                ticketSummary,
                payloadHash: result2.payloadHash ?? payloadHash,
                windowFingerprint: result2.windowFingerprint,
                recipientTextCheck: visionCheck2.recipientMatch === "matched" || visionCheck2.recipientMatch === "mismatch" ? visionCheck2.recipientMatch : result2.recipientTextCheck,
                sendStatusCheck: visionCheck2.sendStatusDetected,
                preSendScreenshotPath: result2.preSendScreenshotPath,
                postSendScreenshotPath: result2.postSendScreenshotPath,
                failureStep: result2.failureStep,
                ocrSource: visionCheck2.ocrSource,
                ocrPreview: visionCheck2.ocrPreview,
                captureMethod: visionCheck2.capture.method,
                evidenceConfidence: visionCheck2.capture.confidence,
                evidenceLimitations: visionCheck2.capture.limitations,
                visualPrecheck: result2.visualPrecheck,
                visualPostcheck: result2.visualPostcheck,
                receiptStatus: result2.receiptStatus
              });
              if (result2.sent) {
                this.clearMutexStrike(sessionID);
              }
              if (!audit2.evidenceBundle || !audit2.semanticSummary) {
                return {
                  sent: false,
                  message: "outbound_blocked:missing_evidence_bundle",
                  auditID: audit2.id
                };
              }
              return { ...result2, auditID: audit2.id };
            }
            const result = await this.sendWechatDesktopMessageImpl({
              projectDir: this.projectDir,
              destination: input.destination,
              text,
              mediaPath
            });
            const visionCheck = await this.analyzeDesktopOutboundEvidenceImpl({
              destination: input.destination,
              preSendScreenshotPath: result.preSendScreenshotPath,
              postSendScreenshotPath: result.postSendScreenshotPath,
              visualPrecheck: result.visualPrecheck,
              visualPostcheck: result.visualPostcheck,
              receiptStatus: result.receiptStatus,
              recipientTextCheck: result.recipientTextCheck
            });
            if (visionCheck.recipientMatch === "mismatch") {
              result.sent = false;
              result.message = "outbound_blocked:recipient_text_mismatch";
            }
            if (visionCheck.sendStatusDetected === "failed") {
              result.sent = false;
              result.message = "outbound_blocked:receipt_uncertain";
            }
            if (visionCheck.uiStyleMismatch) {
              result.sent = false;
              result.message = "outbound_degraded:ui_style_mismatch:draft_only";
            }
            if (visionCheck.lowConfidenceAttempts >= 2) {
              result.sent = false;
              const draftPath = this.writeDesktopFallbackDraft({
                channel: "wechat",
                destination: input.destination,
                text,
                mediaPath: mediaPath || void 0,
                payloadHash: result.payloadHash ?? payloadHash
              });
              result.message = `outbound_degraded:vision_low_confidence_twice:draft_only:path=${draftPath}`;
            }
            if (result.sent && result.receiptStatus !== "confirmed") {
              result.sent = false;
              result.message = "outbound_blocked:receipt_uncertain";
            }
            const audit = this.recordOutboundAttempt({
              channel: "wechat",
              destination: input.destination,
              textPreview: text.slice(0, 200),
              sent: result.sent,
              message: result.message,
              mediaPath: mediaPath || void 0,
              reason: result.sent ? "sent" : "desktop_send_failed",
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              sendFingerprint: input.sendFingerprint,
              ticketSummary,
              payloadHash: result.payloadHash ?? payloadHash,
              windowFingerprint: result.windowFingerprint,
              recipientTextCheck: visionCheck.recipientMatch === "matched" || visionCheck.recipientMatch === "mismatch" ? visionCheck.recipientMatch : result.recipientTextCheck,
              sendStatusCheck: visionCheck.sendStatusDetected,
              preSendScreenshotPath: result.preSendScreenshotPath,
              postSendScreenshotPath: result.postSendScreenshotPath,
              failureStep: result.failureStep,
              ocrSource: visionCheck.ocrSource,
              ocrPreview: visionCheck.ocrPreview,
              captureMethod: visionCheck.capture.method,
              evidenceConfidence: visionCheck.capture.confidence,
              evidenceLimitations: visionCheck.capture.limitations,
              visualPrecheck: result.visualPrecheck,
              visualPostcheck: result.visualPostcheck,
              receiptStatus: result.receiptStatus
            });
            if (result.sent) {
              this.clearMutexStrike(sessionID);
            }
            if (!audit.evidenceBundle || !audit.semanticSummary) {
              return {
                sent: false,
                message: "outbound_blocked:missing_evidence_bundle",
                auditID: audit.id
              };
            }
            return { ...result, auditID: audit.id };
          } catch (error92) {
            return this.recordDesktopRuntimeFailure({
              channel: input.channel,
              destination: input.destination,
              textPreview: text.slice(0, 200),
              archAdvisorApproved,
              targetInAllowlist,
              contactTier: tier,
              intent,
              containsSensitive,
              riskLevel,
              policyHash,
              sendFingerprint: input.sendFingerprint,
              ticketSummary,
              payloadHash,
              error: error92
            });
          } finally {
            mutexLease?.release();
          }
        }
        mutexLease?.release();
        return {
          sent: false,
          message: `channel_send_blocked:${input.channel}:INBOUND_ONLY channels are receive-only`
        };
      }
      async sendPairingMessage(channel, destination) {
        if (channel !== "qq" && channel !== "wechat") {
          return;
        }
        const pairingText = "Miya security: your account is not paired yet. Ask admin to approve pairing in Miya control panel.";
        await this.sendMessage({
          channel,
          destination,
          text: pairingText,
          outboundCheck: {
            archAdvisorApproved: true,
            riskLevel: "LOW",
            bypassAllowlist: true,
            bypassThrottle: true,
            bypassDuplicateGuard: true
          }
        });
      }
    };
  }
});

// src/channel/router.ts
var init_router = __esm({
  "src/channel/router.ts"() {
    "use strict";
    init_policy();
  }
});

// src/channel/types.ts
var init_types2 = __esm({
  "src/channel/types.ts"() {
    "use strict";
    init_types();
  }
});

// src/channel/inbound/telegram.ts
var init_telegram = __esm({
  "src/channel/inbound/telegram.ts"() {
    "use strict";
  }
});

// src/channel/inbound/slack.ts
var init_slack = __esm({
  "src/channel/inbound/slack.ts"() {
    "use strict";
  }
});

// src/channel/inbound/discord.ts
var init_discord = __esm({
  "src/channel/inbound/discord.ts"() {
    "use strict";
  }
});

// src/channel/inbound/whatsapp.ts
var init_whatsapp = __esm({
  "src/channel/inbound/whatsapp.ts"() {
    "use strict";
  }
});

// src/channel/inbound/google-chat.ts
var init_google_chat = __esm({
  "src/channel/inbound/google-chat.ts"() {
    "use strict";
  }
});

// src/channel/inbound/signal.ts
var init_signal = __esm({
  "src/channel/inbound/signal.ts"() {
    "use strict";
  }
});

// src/channel/inbound/imessage.ts
var init_imessage = __esm({
  "src/channel/inbound/imessage.ts"() {
    "use strict";
  }
});

// src/channel/inbound/teams.ts
var init_teams = __esm({
  "src/channel/inbound/teams.ts"() {
    "use strict";
  }
});

// src/channel/index.ts
var init_channel = __esm({
  "src/channel/index.ts"() {
    "use strict";
    init_service();
    init_pairing_store();
    init_router();
    init_types2();
    init_telegram();
    init_slack();
    init_discord();
    init_whatsapp();
    init_google_chat();
    init_signal();
    init_imessage();
    init_teams();
    init_qq();
    init_wechat();
  }
});

// src/safety/tier.ts
function tierAtLeast(current, required3) {
  return SAFETY_RANK[current] >= SAFETY_RANK[required3];
}
var SAFETY_RANK;
var init_tier = __esm({
  "src/safety/tier.ts"() {
    "use strict";
    SAFETY_RANK = {
      LIGHT: 1,
      STANDARD: 2,
      THOROUGH: 3
    };
  }
});

// src/safety/state-machine.ts
import * as fs14 from "node:fs";
import * as path13 from "node:path";
function nowIso4() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function stateFile(projectDir) {
  return path13.join(getMiyaRuntimeDir(projectDir), "safety-state.json");
}
function auditFile(projectDir) {
  return path13.join(getMiyaRuntimeDir(projectDir), "safety-state-audit.jsonl");
}
function ensureDir5(filePath12) {
  fs14.mkdirSync(path13.dirname(filePath12), { recursive: true });
}
function defaultState() {
  return {
    version: 1,
    updatedAt: nowIso4(),
    globalState: "running",
    domains: Object.fromEntries(
      POLICY_DOMAINS.map((domain3) => [domain3, "running"])
    )
  };
}
function writeState(projectDir, state) {
  const file3 = stateFile(projectDir);
  const next = {
    ...state,
    updatedAt: nowIso4()
  };
  ensureDir5(file3);
  fs14.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function readSafetyState(projectDir) {
  const file3 = stateFile(projectDir);
  if (!fs14.existsSync(file3)) {
    const created = defaultState();
    return writeState(projectDir, created);
  }
  try {
    const parsed = JSON.parse(fs14.readFileSync(file3, "utf-8"));
    const base = defaultState();
    const domains = {
      ...base.domains,
      ...parsed.domains ?? {}
    };
    return {
      ...base,
      ...parsed,
      domains
    };
  } catch {
    return defaultState();
  }
}
function appendAudit(projectDir, row) {
  const file3 = auditFile(projectDir);
  ensureDir5(file3);
  fs14.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
function syncPolicyDomain(projectDir, domain3, state) {
  const policy = readPolicy(projectDir);
  const mapped = state === "running" ? "running" : "paused";
  if (policy.domains[domain3] === mapped) return;
  writePolicy(projectDir, {
    domains: {
      ...policy.domains,
      [domain3]: mapped
    }
  });
}
function transitionSafetyState(projectDir, input) {
  const current = readSafetyState(projectDir);
  const next = {
    ...current,
    globalState: input.globalState ?? current.globalState,
    reason: input.reason,
    traceID: input.traceID ?? current.traceID,
    domains: {
      ...current.domains,
      ...input.domains ?? {}
    }
  };
  const written = writeState(projectDir, next);
  for (const domain3 of POLICY_DOMAINS) {
    syncPolicyDomain(projectDir, domain3, written.domains[domain3]);
  }
  appendAudit(projectDir, {
    id: `safety_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    at: nowIso4(),
    source: input.source,
    reason: input.reason,
    traceID: input.traceID,
    policyHash: input.policyHash,
    globalState: written.globalState,
    domains: input.domains ?? {}
  });
  return written;
}
function isDomainExecutionAllowed(projectDir, domain3) {
  const state = readSafetyState(projectDir);
  if (state.globalState === "killed") return false;
  return state.domains[domain3] === "running";
}
var init_state_machine = __esm({
  "src/safety/state-machine.ts"() {
    "use strict";
    init_policy2();
    init_workflow();
  }
});

// src/safety/store.ts
import * as fs15 from "node:fs";
import * as path14 from "node:path";
function runtimeFile2(projectDir, name) {
  return path14.join(getMiyaRuntimeDir(projectDir), name);
}
function ensureDir6(file3) {
  fs15.mkdirSync(path14.dirname(file3), { recursive: true });
}
function readJson(file3, fallback) {
  if (!fs15.existsSync(file3)) return fallback;
  try {
    return JSON.parse(fs15.readFileSync(file3, "utf-8"));
  } catch {
    return fallback;
  }
}
function writeJson2(file3, value) {
  ensureDir6(file3);
  fs15.writeFileSync(file3, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function nowIso5() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function syncGatewayStatus(projectDir, status) {
  const file3 = runtimeFile2(projectDir, "gateway.json");
  if (!fs15.existsSync(file3)) return;
  const current = readJson(file3, {});
  if (!current || typeof current !== "object") return;
  writeJson2(file3, { ...current, status });
}
function listRecentSelfApprovalRecords(projectDir, limit = 10) {
  const file3 = runtimeFile2(projectDir, "self-approval.json");
  const current = readJson(file3, { records: [] });
  return current.records.slice(0, Math.max(1, limit));
}
function readTokenStore(projectDir) {
  const file3 = runtimeFile2(projectDir, "approval-tokens.json");
  const store = readJson(file3, { tokens: {} });
  const decoded = { tokens: {} };
  for (const [sessionID, tokens] of Object.entries(store.tokens ?? {})) {
    const plainSession = decryptSensitiveValue(projectDir, sessionID);
    decoded.tokens[plainSession] = {};
    for (const [hash3, token] of Object.entries(tokens ?? {})) {
      const plainHash = decryptSensitiveValue(projectDir, hash3);
      decoded.tokens[plainSession][plainHash] = {
        ...token,
        request_hash: decryptSensitiveValue(projectDir, token.request_hash),
        action: decryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  return decoded;
}
function writeTokenStore(projectDir, store) {
  const file3 = runtimeFile2(projectDir, "approval-tokens.json");
  const encoded = { tokens: {} };
  for (const [sessionID, tokens] of Object.entries(store.tokens ?? {})) {
    const safeSession = encryptSensitiveValue(projectDir, sessionID);
    encoded.tokens[safeSession] = {};
    for (const [hash3, token] of Object.entries(tokens ?? {})) {
      const safeHash = encryptSensitiveValue(projectDir, hash3);
      encoded.tokens[safeSession][safeHash] = {
        ...token,
        request_hash: encryptSensitiveValue(projectDir, token.request_hash),
        action: encryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  writeJson2(file3, encoded);
}
function saveApprovalToken(projectDir, sessionID, token, ttlMs = TOKEN_TTL_MS) {
  const store = readTokenStore(projectDir);
  const created = /* @__PURE__ */ new Date();
  const expires = new Date(created.getTime() + ttlMs);
  const next = {
    ...token,
    created_at: created.toISOString(),
    expires_at: expires.toISOString()
  };
  const sessionTokens = store.tokens[sessionID] ?? {};
  sessionTokens[token.request_hash] = next;
  const normalized = Object.values(sessionTokens).sort((a, b) => Date.parse(b.created_at) - Date.parse(a.created_at)).slice(0, TOKEN_LIMIT_PER_SESSION);
  store.tokens[sessionID] = Object.fromEntries(
    normalized.map((entry2) => [entry2.request_hash, entry2])
  );
  writeTokenStore(projectDir, store);
  return next;
}
function findApprovalToken(projectDir, sessionID, requestHashes, requiredTier) {
  const store = readTokenStore(projectDir);
  const sessionTokens = store.tokens[sessionID] ?? {};
  const now = Date.now();
  for (const hash3 of requestHashes) {
    const token = sessionTokens[hash3];
    if (!token) continue;
    const expiresAt = Date.parse(token.expires_at);
    if (!Number.isFinite(expiresAt) || expiresAt < now) continue;
    if (!tierAtLeast(token.tier, requiredTier)) continue;
    return token;
  }
  return null;
}
function readKillSwitch(projectDir) {
  return readJson(runtimeFile2(projectDir, "kill-switch.json"), {
    active: false
  });
}
function activateKillSwitch(projectDir, reason, traceID) {
  const next = {
    active: true,
    reason,
    trace_id: traceID,
    activated_at: nowIso5()
  };
  writeJson2(runtimeFile2(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_activate",
    reason,
    traceID,
    globalState: "killed",
    domains: {}
  });
  syncGatewayStatus(projectDir, "killswitch");
  return next;
}
function releaseKillSwitch(projectDir) {
  const next = { active: false };
  writeJson2(runtimeFile2(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_release",
    reason: "manual_release",
    globalState: "running",
    domains: {}
  });
  syncGatewayStatus(projectDir, "running");
  return next;
}
var TOKEN_TTL_MS, TOKEN_LIMIT_PER_SESSION;
var init_store3 = __esm({
  "src/safety/store.ts"() {
    "use strict";
    init_workflow();
    init_tier();
    init_state_machine();
    init_system_keyring();
    TOKEN_TTL_MS = 12e4;
    TOKEN_LIMIT_PER_SESSION = 200;
  }
});

// src/safety/risk.ts
import { createHash as createHash5 } from "node:crypto";
function normalizePattern(pattern) {
  return pattern.trim().replaceAll("\\", "/");
}
function hasIrreversiblePattern(patterns) {
  return patterns.some(
    (pattern) => IRREVERSIBLE_BASH_PATTERNS.some((rule) => rule.test(pattern))
  );
}
function isReadOnlyShellPattern(patterns) {
  if (patterns.length === 0) return false;
  return patterns.every(
    (pattern) => READ_ONLY_BASH_PATTERNS.some((rule) => rule.test(pattern.trim()))
  );
}
function hasSensitivePath(patterns) {
  return patterns.some(
    (pattern) => SENSITIVE_PATH_PATTERNS.some((rule) => rule.test(pattern))
  );
}
function hasIrreversibleEditPattern(patterns) {
  return patterns.some(
    (pattern) => /\b(delete|remove|overwrite|truncate|destroy|wipe)\b/i.test(pattern) || pattern.endsWith(".env") || pattern.includes("/.env")
  );
}
function isSideEffectPermission(permission) {
  return permission === "edit" || permission === "bash" || permission === "external_directory" || permission === "external_message" || permission === "desktop_control" || permission === "node_invoke" || permission === "skills_install" || permission === "webhook_outbound";
}
function classifySideEffect(request) {
  if (!isSideEffectPermission(request.permission)) {
    return { sideEffect: false, reversibility: "none" };
  }
  const patterns = request.patterns.map(normalizePattern);
  if (request.permission === "bash") {
    if (isReadOnlyShellPattern(patterns)) {
      return { sideEffect: true, reversibility: "reversible" };
    }
    return {
      sideEffect: true,
      reversibility: hasIrreversiblePattern(patterns) ? "irreversible" : "reversible"
    };
  }
  if (request.permission === "edit") {
    return {
      sideEffect: true,
      reversibility: hasIrreversibleEditPattern(patterns) ? "irreversible" : "reversible"
    };
  }
  return { sideEffect: true, reversibility: "irreversible" };
}
function requiredTierForRequest(request) {
  const patterns = request.patterns.map(normalizePattern);
  const sideEffect = classifySideEffect(request);
  if (request.permission === "external_directory") return "THOROUGH";
  if (request.permission === "external_message") return "THOROUGH";
  if (request.permission === "desktop_control") return "THOROUGH";
  if (request.permission === "node_invoke") {
    const patterns2 = request.patterns.map(normalizePattern).join(" ");
    if (/\b(system\.run|camera\.capture|canvas\.open|canvas\.render|voice\.)\b/i.test(
      patterns2
    )) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  if (request.permission === "skills_install") return "THOROUGH";
  if (request.permission === "webhook_outbound") return "THOROUGH";
  if (request.permission === "bash") {
    return sideEffect.reversibility === "irreversible" ? "THOROUGH" : "STANDARD";
  }
  if (request.permission === "edit") {
    if (hasSensitivePath(patterns) || hasIrreversibleEditPattern(patterns)) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  return "STANDARD";
}
function buildRequestHash(request, includeMessageContext = true) {
  const payload = {
    permission: request.permission,
    patterns: [...request.patterns].map(normalizePattern).sort(),
    toolCallID: includeMessageContext ? request.toolCallID ?? "" : "",
    messageID: includeMessageContext ? request.messageID ?? "" : ""
  };
  return createHash5("sha256").update(JSON.stringify(payload)).digest("hex");
}
var IRREVERSIBLE_BASH_PATTERNS, SENSITIVE_PATH_PATTERNS, READ_ONLY_BASH_PATTERNS;
var init_risk = __esm({
  "src/safety/risk.ts"() {
    "use strict";
    IRREVERSIBLE_BASH_PATTERNS = [
      /\bgit\s+push\b/i,
      /\bgit\s+remote\s+set-url\b/i,
      /\bgit\s+reset\s+--hard\b/i,
      /\bgit\s+clean\b[^\n]*\b-f\b/i,
      /\bgit\s+branch\b[^\n]*\b-D\b/i,
      /\brm\s+-[^\n]*\br\b/i,
      /\brm\s+-[^\n]*\bf\b/i,
      /\brm\s+(-rf|-fr)\b/i,
      /\bdel\s+\/[sfpq]/i,
      /\berase\s+\/[sfpq]/i,
      /\bRemove-Item\b[^\n]*\b(-Recurse|-Force)\b/i,
      /\btruncate\b/i,
      /\bcp\b[^\n]*\b-f\b/i,
      />\s*\.env(\.|$)/i,
      /\b(overwrite|truncate)\b/i
    ];
    SENSITIVE_PATH_PATTERNS = [
      /\.env(\.|$)/i,
      /\.pem$/i,
      /\.key$/i,
      /cookie/i,
      /credential/i,
      /secret/i,
      /token/i
    ];
    READ_ONLY_BASH_PATTERNS = [
      /^\s*(ls|dir)\b/i,
      /^\s*(cat|type)\b/i,
      /^\s*(grep|rg|findstr)\b/i,
      /^\s*(pwd|cd)\b/i,
      /^\s*(echo)\b/i,
      /^\s*git\s+(status|log|show|diff)\b/i
    ];
  }
});

// src/policy/decision-fusion.ts
function normalizeConfidence(value) {
  if (!Number.isFinite(value)) return 0;
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
}
function normalizeTrustScore(value) {
  if (!Number.isFinite(value)) return 50;
  if (value < 0) return 0;
  if (value > 100) return 100;
  return Math.round(value);
}
function normalizeTrustMode(input) {
  let silentMin = Math.max(
    0,
    Math.min(100, Math.round(input?.silentMin ?? 90))
  );
  let modalMax = Math.max(
    0,
    Math.min(100, Math.round(input?.modalMax ?? 50))
  );
  if (silentMin <= modalMax) {
    const pivot = Math.round((silentMin + modalMax) / 2);
    silentMin = Math.min(100, pivot + 1);
    modalMax = Math.max(0, pivot - 1);
  }
  if (silentMin - modalMax < 2) {
    if (silentMin < 100) silentMin += 1;
    else if (modalMax > 0) modalMax -= 1;
  }
  if (silentMin <= modalMax) {
    return { silentMin: 90, modalMax: 50 };
  }
  return { silentMin, modalMax };
}
function resolveApprovalMode(input) {
  if (input.action !== "allow") return "modal_approval";
  const thresholds = normalizeTrustMode(input.trustMode);
  const silentMin = thresholds.silentMin;
  const modalMax = thresholds.modalMax;
  if (input.trustScore >= silentMin) return "silent_audit";
  if (input.trustScore <= modalMax) return "modal_approval";
  return "toast_gate";
}
function evaluateOutboundDecisionFusion(input) {
  const conf = normalizeConfidence(input.confidenceIntent);
  const evidenceConf = normalizeConfidence(input.evidenceConfidence ?? input.confidenceIntent);
  const trustScore = normalizeTrustScore(input.trustMinScore);
  const expressionMatched = input.factorTextSensitive && !input.factorRecipientIsMe || input.factorTextSensitive && input.factorIntentSuspicious;
  if (evidenceConf < 0.35) {
    const action2 = expressionMatched ? conf < 0.5 ? "hard_fuse" : "soft_fuse" : "allow";
    return {
      expressionMatched,
      zone: action2 === "hard_fuse" ? "danger" : "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: action2 === "hard_fuse" ? "decision_fusion_danger_low_evidence" : action2 === "soft_fuse" ? "decision_fusion_gray_low_evidence" : "decision_fusion_low_evidence_confirmation_required"
    };
  }
  if (!expressionMatched) {
    const action2 = "allow";
    return {
      expressionMatched: false,
      zone: "safe",
      action: action2,
      approvalMode: resolveApprovalMode({
        action: action2,
        trustScore,
        trustMode: input.trustMode
      }),
      reason: "decision_fusion_clear"
    };
  }
  if (conf < 0.5) {
    const action2 = "hard_fuse";
    return {
      expressionMatched: true,
      zone: "danger",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_danger"
    };
  }
  if (conf <= 0.85) {
    const action2 = "soft_fuse";
    return {
      expressionMatched: true,
      zone: "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_gray"
    };
  }
  const action = "allow";
  return {
    expressionMatched: true,
    zone: "safe",
    action,
    approvalMode: resolveApprovalMode({
      action,
      trustScore,
      trustMode: input.trustMode
    }),
    reason: "decision_fusion_safe_by_confidence"
  };
}
var init_decision_fusion = __esm({
  "src/policy/decision-fusion.ts"() {
    "use strict";
  }
});

// src/policy/incident.ts
import * as fs16 from "node:fs";
import * as path15 from "node:path";
import { randomUUID as randomUUID4 } from "node:crypto";
function incidentFile(projectDir) {
  return path15.join(getMiyaRuntimeDir(projectDir), "policy-incidents.jsonl");
}
function appendPolicyIncident(projectDir, incident) {
  assertSemanticTags(incident.semanticTags);
  const semanticTags = normalizeSemanticTags(incident.semanticTags);
  const payload = {
    id: incident.id ?? `incident_${randomUUID4()}`,
    at: incident.at ?? (/* @__PURE__ */ new Date()).toISOString(),
    type: incident.type,
    reason: incident.reason,
    channel: incident.channel,
    destination: incident.destination,
    auditID: incident.auditID,
    policyHash: incident.policyHash,
    pausedDomains: incident.pausedDomains,
    statusByDomain: incident.statusByDomain,
    semanticSummary: incident.semanticSummary,
    semanticTags,
    details: incident.details
  };
  const file3 = incidentFile(projectDir);
  fs16.mkdirSync(path15.dirname(file3), { recursive: true });
  fs16.appendFileSync(file3, `${JSON.stringify(payload)}
`, "utf-8");
  return payload;
}
function listPolicyIncidents(projectDir, limit = 50) {
  const file3 = incidentFile(projectDir);
  if (!fs16.existsSync(file3)) return [];
  const rows = fs16.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}
var init_incident = __esm({
  "src/policy/incident.ts"() {
    "use strict";
    init_workflow();
    init_semantic_tags();
  }
});

// src/nodes/index.ts
import * as fs17 from "node:fs";
import * as path16 from "node:path";
import { createHash as createHash6, randomBytes as randomBytes2, randomUUID as randomUUID5, timingSafeEqual } from "node:crypto";
function nowIso6() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function hashToken(token) {
  return createHash6("sha256").update(token).digest("hex");
}
function defaultNodePermissions() {
  return {
    screenRecording: false,
    accessibility: false,
    filesystem: "none",
    network: false
  };
}
function inferPermissionsFromCapabilities(capabilities, base) {
  const inferred = defaultNodePermissions();
  for (const capability of capabilities) {
    if (capability === "perm.screenRecording") inferred.screenRecording = true;
    if (capability === "perm.accessibility") inferred.accessibility = true;
    if (capability === "perm.network") inferred.network = true;
    if (capability.startsWith("perm.filesystem.")) {
      const suffix = capability.slice("perm.filesystem.".length);
      if (suffix === "none" || suffix === "read" || suffix === "full") {
        inferred.filesystem = suffix;
      }
    }
  }
  return {
    ...inferred,
    ...base ?? {}
  };
}
function normalizeNodeRecord(partial3) {
  const capabilityList = Array.isArray(partial3.capabilities) ? partial3.capabilities.map((item) => String(item)).filter(Boolean).sort() : [];
  const fallbackHeartbeat = String(partial3.lastSeenAt ?? nowIso6());
  const permissions = inferPermissionsFromCapabilities(capabilityList, partial3.permissions);
  const status = partial3.connected ? "online" : "offline";
  return {
    nodeID: String(partial3.nodeID ?? ""),
    deviceID: String(partial3.deviceID ?? ""),
    type: partial3.type === "cli" || partial3.type === "desktop" || partial3.type === "mobile" || partial3.type === "browser" ? partial3.type : "cli",
    role: "node",
    platform: String(partial3.platform ?? process.platform),
    permissions,
    capabilities: capabilityList,
    connected: Boolean(partial3.connected),
    paired: Boolean(partial3.paired),
    status: partial3.status === "online" || partial3.status === "offline" || partial3.status === "error" ? partial3.status : status,
    tokenHash: typeof partial3.tokenHash === "string" ? partial3.tokenHash : void 0,
    tokenIssuedAt: typeof partial3.tokenIssuedAt === "string" ? partial3.tokenIssuedAt : void 0,
    tokenLastUsedAt: typeof partial3.tokenLastUsedAt === "string" ? partial3.tokenLastUsedAt : void 0,
    lastHeartbeatAt: typeof partial3.lastHeartbeatAt === "string" ? partial3.lastHeartbeatAt : fallbackHeartbeat,
    lastSeenAt: String(partial3.lastSeenAt ?? fallbackHeartbeat),
    createdAt: String(partial3.createdAt ?? nowIso6()),
    updatedAt: String(partial3.updatedAt ?? nowIso6())
  };
}
function applyHeartbeatHealth(store) {
  const now = Date.now();
  let changed = false;
  for (const node of Object.values(store.nodes)) {
    const heartbeatAt = Date.parse(node.lastHeartbeatAt || node.lastSeenAt);
    if (Number.isNaN(heartbeatAt)) continue;
    const stale = now - heartbeatAt > HEARTBEAT_STALE_MS;
    if (stale && (node.connected || node.status === "online")) {
      node.connected = false;
      node.status = "offline";
      node.updatedAt = nowIso6();
      changed = true;
    }
  }
  return changed;
}
function filePath3(projectDir) {
  return path16.join(getMiyaRuntimeDir(projectDir), "nodes.json");
}
function ensureDir7(file3) {
  fs17.mkdirSync(path16.dirname(file3), { recursive: true });
}
function readStore2(projectDir) {
  const file3 = filePath3(projectDir);
  if (!fs17.existsSync(file3)) {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
  try {
    const parsed = JSON.parse(fs17.readFileSync(file3, "utf-8"));
    const rawNodes = parsed.nodes ?? {};
    const nodes = {};
    for (const [nodeID, node] of Object.entries(rawNodes)) {
      const normalized = normalizeNodeRecord({
        ...node,
        nodeID: nodeID || node?.nodeID
      });
      if (!normalized.nodeID) continue;
      nodes[normalized.nodeID] = normalized;
    }
    return {
      nodes,
      devices: parsed.devices ?? {},
      pairs: Array.isArray(parsed.pairs) ? parsed.pairs : [],
      invokes: parsed.invokes ?? {}
    };
  } catch {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
}
function writeStore2(projectDir, store) {
  const file3 = filePath3(projectDir);
  ensureDir7(file3);
  fs17.writeFileSync(file3, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function readStoreWithHealth(projectDir) {
  const store = readStore2(projectDir);
  if (applyHeartbeatHealth(store)) {
    writeStore2(projectDir, store);
  }
  return store;
}
function verifyNodeToken(node, token) {
  if (!node.tokenHash) return true;
  if (!token) return false;
  const expected = Buffer.from(node.tokenHash, "hex");
  const actual = Buffer.from(hashToken(token), "hex");
  if (expected.length !== actual.length) return false;
  return timingSafeEqual(expected, actual);
}
function registerNode(projectDir, input) {
  const store = readStoreWithHealth(projectDir);
  const existing = store.nodes[input.nodeID];
  if (existing && !verifyNodeToken(existing, input.token)) {
    throw new Error("node_token_invalid");
  }
  const nextCapabilities = [...new Set(input.capabilities)].sort();
  const now = nowIso6();
  const createdAt = store.nodes[input.nodeID]?.createdAt ?? nowIso6();
  const lastHeartbeatAt = now;
  const tokenLastUsedAt = existing?.tokenHash ? now : existing?.tokenLastUsedAt;
  const node = {
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    type: input.type ?? existing?.type ?? "cli",
    role: "node",
    platform: input.platform,
    permissions: inferPermissionsFromCapabilities(nextCapabilities, {
      ...existing?.permissions,
      ...input.permissions ?? {}
    }),
    capabilities: nextCapabilities,
    connected: true,
    paired: existing?.paired ?? false,
    status: "online",
    tokenHash: existing?.tokenHash,
    tokenIssuedAt: existing?.tokenIssuedAt,
    tokenLastUsedAt,
    lastHeartbeatAt,
    lastSeenAt: now,
    createdAt,
    updatedAt: now
  };
  store.nodes[input.nodeID] = node;
  const device = {
    deviceID: input.deviceID,
    label: store.devices[input.deviceID]?.label,
    approved: store.devices[input.deviceID]?.approved ?? false,
    createdAt: store.devices[input.deviceID]?.createdAt ?? now,
    updatedAt: now
  };
  store.devices[input.deviceID] = device;
  writeStore2(projectDir, store);
  return node;
}
function touchNodeHeartbeat(projectDir, nodeID) {
  const store = readStore2(projectDir);
  const node = store.nodes[nodeID];
  if (!node) return null;
  const now = nowIso6();
  node.connected = true;
  node.status = "online";
  node.lastHeartbeatAt = now;
  node.lastSeenAt = now;
  node.updatedAt = now;
  writeStore2(projectDir, store);
  return node;
}
function markNodeDisconnected(projectDir, nodeID) {
  const store = readStore2(projectDir);
  const node = store.nodes[nodeID];
  if (!node) return;
  node.connected = false;
  node.status = "offline";
  node.updatedAt = nowIso6();
  writeStore2(projectDir, store);
}
function listNodes(projectDir) {
  const store = readStoreWithHealth(projectDir);
  return Object.values(store.nodes).sort(
    (a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)
  );
}
function listDevices(projectDir) {
  const store = readStoreWithHealth(projectDir);
  return Object.values(store.devices).sort(
    (a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)
  );
}
function describeNode(projectDir, nodeID) {
  const store = readStoreWithHealth(projectDir);
  return store.nodes[nodeID] ?? null;
}
function issueNodeToken(projectDir, nodeID) {
  const store = readStoreWithHealth(projectDir);
  const node = store.nodes[nodeID];
  if (!node) return null;
  const token = `nkt_${randomBytes2(24).toString("hex")}`;
  const issuedAt = nowIso6();
  node.tokenHash = hashToken(token);
  node.tokenIssuedAt = issuedAt;
  node.tokenLastUsedAt = issuedAt;
  node.updatedAt = issuedAt;
  store.nodes[nodeID] = node;
  writeStore2(projectDir, store);
  return { nodeID, token, issuedAt };
}
function createNodePairRequest(projectDir, input) {
  const store = readStore2(projectDir);
  const pending = store.pairs.find(
    (item) => item.nodeID === input.nodeID && item.status === "pending"
  );
  if (pending) return pending;
  const pair = {
    id: `npair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    status: "pending",
    requestedAt: nowIso6()
  };
  store.pairs = [pair, ...store.pairs].slice(0, 1e3);
  writeStore2(projectDir, store);
  return pair;
}
function listNodePairs(projectDir, status) {
  const store = readStore2(projectDir);
  const pairs = status ? store.pairs.filter((item) => item.status === status) : store.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function resolveNodePair(projectDir, pairID, status) {
  const store = readStore2(projectDir);
  const pair = store.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending") return null;
  pair.status = status;
  pair.resolvedAt = nowIso6();
  if (status === "approved") {
    const node = store.nodes[pair.nodeID];
    if (node) {
      node.paired = true;
      node.updatedAt = nowIso6();
    }
    const device = store.devices[pair.deviceID];
    if (device) {
      device.approved = true;
      device.updatedAt = nowIso6();
    }
  }
  writeStore2(projectDir, store);
  return pair;
}
function createInvokeRequest(projectDir, input) {
  const store = readStore2(projectDir);
  const invoke = {
    id: `invoke_${randomUUID5()}`,
    nodeID: input.nodeID,
    capability: input.capability,
    args: input.args,
    status: "pending",
    createdAt: nowIso6(),
    updatedAt: nowIso6()
  };
  store.invokes[invoke.id] = invoke;
  writeStore2(projectDir, store);
  return invoke;
}
function markInvokeSent(projectDir, invokeID) {
  const store = readStore2(projectDir);
  const invoke = store.invokes[invokeID];
  if (!invoke) return null;
  invoke.status = "sent";
  invoke.updatedAt = nowIso6();
  writeStore2(projectDir, store);
  return invoke;
}
function resolveInvokeResult(projectDir, invokeID, input) {
  const store = readStore2(projectDir);
  const invoke = store.invokes[invokeID];
  if (!invoke) return null;
  invoke.status = input.ok ? "completed" : "failed";
  invoke.result = input.result;
  invoke.error = input.error;
  invoke.updatedAt = nowIso6();
  writeStore2(projectDir, store);
  return invoke;
}
function listInvokeRequests(projectDir, limit = 50) {
  const store = readStore2(projectDir);
  return Object.values(store.invokes).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, limit));
}
var HEARTBEAT_STALE_MS;
var init_nodes = __esm({
  "src/nodes/index.ts"() {
    "use strict";
    init_workflow();
    HEARTBEAT_STALE_MS = 2 * 60 * 1e3;
  }
});

// src/security/owner-identity.ts
import { createHash as createHash7, randomUUID as randomUUID6 } from "node:crypto";
import * as fs18 from "node:fs";
import * as path17 from "node:path";
function nowIso7() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath4(projectDir) {
  return path17.join(getMiyaRuntimeDir(projectDir), "security", "owner-identity.json");
}
function guestAuditPath(projectDir) {
  return path17.join(getMiyaRuntimeDir(projectDir), "security", "guest-conversations.jsonl");
}
function clamp(input, min, max) {
  if (!Number.isFinite(input)) return min;
  return Math.min(max, Math.max(min, input));
}
function defaultVoiceprintThresholds() {
  return {
    ownerMinScore: 0.78,
    guestMaxScore: 0.62,
    ownerMinLiveness: 0.65,
    guestMaxLiveness: 0.55,
    ownerMinDiarizationRatio: 0.7,
    minSampleDurationSec: 2,
    farTarget: 0.01,
    frrTarget: 0.03
  };
}
function normalizeVoiceprintThresholds(input) {
  const base = defaultVoiceprintThresholds();
  const normalized = {
    ownerMinScore: typeof input?.ownerMinScore === "number" ? clamp(input.ownerMinScore, 0.5, 0.99) : base.ownerMinScore,
    guestMaxScore: typeof input?.guestMaxScore === "number" ? clamp(input.guestMaxScore, 0.01, 0.9) : base.guestMaxScore,
    ownerMinLiveness: typeof input?.ownerMinLiveness === "number" ? clamp(input.ownerMinLiveness, 0.1, 0.99) : base.ownerMinLiveness,
    guestMaxLiveness: typeof input?.guestMaxLiveness === "number" ? clamp(input.guestMaxLiveness, 0.01, 0.9) : base.guestMaxLiveness,
    ownerMinDiarizationRatio: typeof input?.ownerMinDiarizationRatio === "number" ? clamp(input.ownerMinDiarizationRatio, 0.1, 1) : base.ownerMinDiarizationRatio,
    minSampleDurationSec: typeof input?.minSampleDurationSec === "number" ? clamp(input.minSampleDurationSec, 0.5, 20) : base.minSampleDurationSec,
    farTarget: typeof input?.farTarget === "number" ? clamp(input.farTarget, 1e-4, 0.5) : base.farTarget,
    frrTarget: typeof input?.frrTarget === "number" ? clamp(input.frrTarget, 1e-4, 0.5) : base.frrTarget
  };
  if (normalized.guestMaxScore >= normalized.ownerMinScore) {
    normalized.guestMaxScore = Math.max(0.01, normalized.ownerMinScore - 0.05);
  }
  return normalized;
}
function defaultState2() {
  return {
    initialized: false,
    mode: "unknown",
    voiceprintModelPath: "",
    voiceprintSampleDir: "",
    voiceprintThresholds: defaultVoiceprintThresholds(),
    updatedAt: nowIso7()
  };
}
function hashSecret(input) {
  return createHash7("sha256").update(input).digest("hex");
}
function defaultVoiceprintModelPath(projectDir) {
  return process.env.MIYA_VOICEPRINT_MODEL_PATH || getMiyaVoiceprintModelDir(projectDir);
}
function defaultVoiceprintSampleDir(projectDir) {
  return process.env.MIYA_VOICEPRINT_SAMPLE_DIR || getMiyaVoiceprintSampleDir(projectDir);
}
function readOwnerIdentityState(projectDir) {
  const file3 = filePath4(projectDir);
  if (!fs18.existsSync(file3)) {
    return {
      ...defaultState2(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
  try {
    const parsed = JSON.parse(fs18.readFileSync(file3, "utf-8"));
    return {
      ...defaultState2(),
      ...parsed,
      voiceprintModelPath: typeof parsed.voiceprintModelPath === "string" ? parsed.voiceprintModelPath : defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: typeof parsed.voiceprintSampleDir === "string" ? parsed.voiceprintSampleDir : defaultVoiceprintSampleDir(projectDir),
      voiceprintThresholds: normalizeVoiceprintThresholds(parsed.voiceprintThresholds),
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso7()
    };
  } catch {
    return {
      ...defaultState2(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
}
function writeOwnerIdentityState(projectDir, state) {
  const file3 = filePath4(projectDir);
  fs18.mkdirSync(path17.dirname(file3), { recursive: true });
  const next = {
    ...state,
    voiceprintThresholds: normalizeVoiceprintThresholds(state.voiceprintThresholds),
    updatedAt: nowIso7()
  };
  fs18.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function initOwnerIdentity(projectDir, input) {
  const current = readOwnerIdentityState(projectDir);
  const next = {
    ...current,
    initialized: true,
    passwordHash: hashSecret(input.password),
    passphraseHash: hashSecret(input.passphrase),
    voiceprintEmbeddingID: input.voiceprintEmbeddingID || current.voiceprintEmbeddingID || `owner_${randomUUID6()}`,
    voiceprintModelPath: input.voiceprintModelPath || current.voiceprintModelPath || defaultVoiceprintModelPath(projectDir),
    voiceprintSampleDir: input.voiceprintSampleDir || current.voiceprintSampleDir || defaultVoiceprintSampleDir(projectDir),
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...input.voiceprintThresholds ?? {}
    }),
    mode: "owner",
    lastSpeakerAt: nowIso7(),
    updatedAt: nowIso7()
  };
  return writeOwnerIdentityState(projectDir, next);
}
function verifyOwnerSecrets(projectDir, input) {
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized || !state.passwordHash || !state.passphraseHash) return false;
  const passOk = typeof input.password === "string" && hashSecret(input.password) === state.passwordHash;
  const phraseOk = typeof input.passphrase === "string" && hashSecret(input.passphrase) === state.passphraseHash;
  return passOk || phraseOk;
}
function verifyOwnerPasswordOnly(projectDir, password) {
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized || !state.passwordHash) return false;
  if (typeof password !== "string" || !password) return false;
  return hashSecret(password) === state.passwordHash;
}
function rotateOwnerSecrets(projectDir, input) {
  if (!verifyOwnerSecrets(projectDir, {
    password: input.currentPassword,
    passphrase: input.currentPassphrase
  })) {
    throw new Error("owner_secret_verification_failed");
  }
  const state = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...state,
    initialized: true,
    passwordHash: hashSecret(input.newPassword),
    passphraseHash: hashSecret(input.newPassphrase),
    mode: "owner",
    lastSpeakerAt: nowIso7(),
    updatedAt: nowIso7()
  });
}
function updateVoiceprintThresholds(projectDir, patch) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...patch
    }),
    updatedAt: nowIso7()
  });
}
function resolveInteractionMode(projectDir, input) {
  const hint = (input.speakerHint || "").trim().toLowerCase();
  if (hint === "owner" || hint === "guest" || hint === "unknown") {
    return hint;
  }
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized) return "unknown";
  if (typeof input.speakerScore === "number") {
    if (input.speakerScore >= state.voiceprintThresholds.ownerMinScore) return "owner";
    if (input.speakerScore < state.voiceprintThresholds.guestMaxScore) return "guest";
  }
  return state.mode === "owner" ? "owner" : "unknown";
}
function setInteractionMode(projectDir, mode) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    mode,
    lastSpeakerAt: nowIso7(),
    updatedAt: nowIso7()
  });
}
function appendGuestConversation(projectDir, input) {
  const file3 = guestAuditPath(projectDir);
  fs18.mkdirSync(path17.dirname(file3), { recursive: true });
  const row = {
    id: `guest_${randomUUID6()}`,
    at: nowIso7(),
    source: input.source,
    sessionID: input.sessionID,
    text: input.text
  };
  fs18.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
var init_owner_identity = __esm({
  "src/security/owner-identity.ts"() {
    "use strict";
    init_paths2();
    init_workflow();
  }
});

// src/security/owner-sync.ts
import { randomUUID as randomUUID7 } from "node:crypto";
import * as fs19 from "node:fs";
import * as path18 from "node:path";
function nowIso8() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function storeFile(projectDir) {
  return path18.join(getMiyaRuntimeDir(projectDir), "security", "owner-sync.json");
}
function readStore3(projectDir) {
  const file3 = storeFile(projectDir);
  if (!fs19.existsSync(file3)) return { tokens: [] };
  try {
    const parsed = JSON.parse(fs19.readFileSync(file3, "utf-8"));
    return Array.isArray(parsed.tokens) ? parsed : { tokens: [] };
  } catch {
    return { tokens: [] };
  }
}
function writeStore3(projectDir, store) {
  const file3 = storeFile(projectDir);
  fs19.mkdirSync(path18.dirname(file3), { recursive: true });
  fs19.writeFileSync(file3, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function purgeExpired(tokens) {
  const now = Date.now();
  return tokens.filter((item) => {
    const expiresAt = Date.parse(item.expiresAt);
    if (!Number.isFinite(expiresAt)) return false;
    if (expiresAt < now && item.status === "pending") return false;
    return true;
  });
}
function normalizeToken(input) {
  return input.trim().toUpperCase();
}
function createToken() {
  return `OS${randomUUID7().replaceAll("-", "").slice(0, 10).toUpperCase()}`;
}
function issueOwnerSyncToken(projectDir, input) {
  const ttlMs = Math.max(6e4, Number(input.ttlMs ?? 10 * 6e4));
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const now = Date.now();
  const existing = store.tokens.find(
    (item) => item.status === "pending" && item.action === input.action && item.payloadHash === input.payloadHash && Date.parse(item.expiresAt) > now
  );
  if (existing) {
    writeStore3(projectDir, store);
    return existing;
  }
  const createdAt = nowIso8();
  const record3 = {
    token: createToken(),
    action: input.action,
    payloadHash: input.payloadHash,
    status: "pending",
    createdAt,
    expiresAt: new Date(now + ttlMs).toISOString()
  };
  store.tokens.unshift(record3);
  store.tokens = store.tokens.slice(0, 500);
  writeStore3(projectDir, store);
  return record3;
}
function approveOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token) return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "pending") {
    writeStore3(projectDir, store);
    return { ok: false, reason: `owner_sync_token_not_pending:${found.status}` };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  found.status = "approved";
  found.approvedAt = nowIso8();
  found.approvedBy = { channel: input.channel, senderID: input.senderID };
  writeStore3(projectDir, store);
  return { ok: true, record: found };
}
function verifyOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token) return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore3(projectDir, store);
    return { ok: false, reason: `owner_sync_token_not_approved:${found.status}` };
  }
  if (found.action !== input.action) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_action_mismatch" };
  }
  if (found.payloadHash !== input.payloadHash) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_payload_mismatch" };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  writeStore3(projectDir, store);
  return { ok: true, record: found };
}
function consumeOwnerSyncToken(projectDir, tokenInput) {
  const token = normalizeToken(tokenInput);
  if (!token) return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore3(projectDir, store);
    return { ok: false, reason: `owner_sync_token_not_approved:${found.status}` };
  }
  found.status = "consumed";
  found.consumedAt = nowIso8();
  writeStore3(projectDir, store);
  return { ok: true };
}
function detectOwnerSyncTokenFromText(text) {
  const normalized = text.trim();
  if (!normalized) return null;
  const matched = /(?:||approve|confirm|ok)\s*[:#]?\s*([a-z0-9_-]{6,64})/i.exec(normalized) ?? /(?:\/miya\s+confirm)\s+([a-z0-9_-]{6,64})/i.exec(normalized);
  if (!matched?.[1]) return null;
  return normalizeToken(matched[1]);
}
var init_owner_sync = __esm({
  "src/security/owner-sync.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/voice/state.ts
import * as fs20 from "node:fs";
import * as path19 from "node:path";
import { randomUUID as randomUUID8 } from "node:crypto";
function nowIso9() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath5(projectDir) {
  return path19.join(getMiyaRuntimeDir(projectDir), "voice.json");
}
function ensureDir8(file3) {
  fs20.mkdirSync(path19.dirname(file3), { recursive: true });
}
function defaultState3() {
  return {
    enabled: false,
    wakeWordEnabled: false,
    talkMode: false,
    routeSessionID: "main",
    sttProvider: "local",
    ttsProvider: "local",
    history: []
  };
}
function readVoiceState(projectDir) {
  const file3 = filePath5(projectDir);
  if (!fs20.existsSync(file3)) return defaultState3();
  try {
    const parsed = JSON.parse(fs20.readFileSync(file3, "utf-8"));
    return {
      ...defaultState3(),
      ...parsed,
      history: Array.isArray(parsed.history) ? parsed.history : []
    };
  } catch {
    return defaultState3();
  }
}
function writeVoiceState(projectDir, state) {
  const file3 = filePath5(projectDir);
  ensureDir8(file3);
  fs20.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
  return state;
}
function patchVoiceState(projectDir, patch) {
  const current = readVoiceState(projectDir);
  const next = {
    ...current,
    ...patch
  };
  return writeVoiceState(projectDir, next);
}
function appendVoiceHistory(projectDir, input) {
  const state = readVoiceState(projectDir);
  const item = {
    id: `voice_${randomUUID8()}`,
    text: input.text,
    source: input.source,
    language: input.language,
    mediaID: input.mediaID,
    createdAt: nowIso9()
  };
  const next = {
    ...state,
    lastInputAt: item.createdAt,
    lastTranscript: item.text,
    history: [item, ...state.history].slice(0, 200)
  };
  writeVoiceState(projectDir, next);
  return item;
}
function clearVoiceHistory(projectDir) {
  const state = readVoiceState(projectDir);
  return writeVoiceState(projectDir, {
    ...state,
    history: [],
    lastInputAt: void 0,
    lastTranscript: void 0
  });
}
var init_state2 = __esm({
  "src/voice/state.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/config/provider-override-audit.ts
import * as fs21 from "node:fs";
import * as path20 from "node:path";
function providerOverrideAuditFile(projectDir) {
  return path20.join(getMiyaRuntimeDir(projectDir), "audit", "provider-overrides.jsonl");
}
function listProviderOverrideAudits(projectDir, limit = 50) {
  const file3 = providerOverrideAuditFile(projectDir);
  if (!fs21.existsSync(file3)) return [];
  const safeLimit = Math.max(1, Math.min(500, Math.floor(limit)));
  const lines = fs21.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean);
  return lines.slice(-safeLimit).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => item !== null).reverse();
}
var init_provider_override_audit = __esm({
  "src/config/provider-override-audit.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/gateway/agent-model-api.ts
var AgentModelRuntimeApi;
var init_agent_model_api = __esm({
  "src/gateway/agent-model-api.ts"() {
    "use strict";
    init_constants();
    init_model_health();
    init_agent_model_persistence();
    AgentModelRuntimeApi = class {
      constructor(projectDir) {
        this.projectDir = projectDir;
      }
      list() {
        const runtime = readPersistedAgentRuntime(this.projectDir);
        const agents = [];
        for (const agentName of ALL_AGENT_NAMES) {
          const entry2 = runtime.agents[agentName];
          const model = entry2?.model ?? DEFAULT_MODELS[agentName];
          const source = entry2?.model ? "runtime" : "default";
          agents.push({
            agentName,
            model,
            providerID: entry2?.providerID,
            variant: entry2?.variant,
            updatedAt: entry2?.updatedAt ?? "",
            source,
            active: runtime.activeAgentId === agentName,
            healthStatus: this.resolveHealthStatus(model)
          });
        }
        return {
          activeAgentId: runtime.activeAgentId,
          revision: runtime.revision,
          agents
        };
      }
      set(input) {
        const agentName = normalizeAgentName(input.agentName);
        if (!agentName) {
          throw new Error("invalid_agent_name");
        }
        if (!normalizeModelRef(input.model)) {
          throw new Error("invalid_model_ref");
        }
        const changed = persistAgentRuntimeSelection(this.projectDir, {
          agentName,
          model: input.model,
          variant: input.variant,
          providerID: input.providerID,
          options: input.options,
          apiKey: input.apiKey,
          baseURL: input.baseURL,
          activeAgentId: input.activate === false ? void 0 : agentName
        });
        return { changed };
      }
      reset(input) {
        const changed = removePersistedAgentRuntimeSelection(
          this.projectDir,
          input.agentName,
          {
            clearActive: input.clearActive ?? true,
            activeAgentId: input.activeAgentId
          }
        );
        return { changed };
      }
      resolveHealthStatus(model) {
        if (!model) return "unavailable";
        return isModelLikelyAvailable(model) ? "healthy" : "degraded";
      }
    };
  }
});

// src/canvas/state.ts
import { randomUUID as randomUUID9 } from "node:crypto";
import * as fs22 from "node:fs";
import * as path21 from "node:path";
function nowIso10() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath6(projectDir) {
  return path21.join(getMiyaRuntimeDir(projectDir), "canvas.json");
}
function ensureDir9(file3) {
  fs22.mkdirSync(path21.dirname(file3), { recursive: true });
}
function defaultState4() {
  return {
    activeDocID: void 0,
    docs: {},
    events: []
  };
}
function readCanvasState(projectDir) {
  const file3 = filePath6(projectDir);
  if (!fs22.existsSync(file3)) return defaultState4();
  try {
    const parsed = JSON.parse(fs22.readFileSync(file3, "utf-8"));
    return {
      activeDocID: parsed.activeDocID,
      docs: parsed.docs ?? {},
      events: Array.isArray(parsed.events) ? parsed.events : []
    };
  } catch {
    return defaultState4();
  }
}
function writeCanvasState(projectDir, state) {
  const file3 = filePath6(projectDir);
  ensureDir9(file3);
  fs22.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
  return state;
}
function pushEvent(state, input) {
  state.events = [
    {
      id: `canvas_evt_${randomUUID9()}`,
      kind: input.kind,
      docID: input.docID,
      at: nowIso10(),
      actor: input.actor
    },
    ...state.events
  ].slice(0, 400);
}
function openCanvasDoc(projectDir, input) {
  const state = readCanvasState(projectDir);
  const id = `canvas_${randomUUID9()}`;
  const now = nowIso10();
  const doc = {
    id,
    title: input.title,
    type: input.type ?? "markdown",
    content: input.content ?? "",
    createdAt: now,
    updatedAt: now
  };
  state.docs[id] = doc;
  state.activeDocID = id;
  pushEvent(state, { kind: "open", docID: id, actor: input.actor ?? "gateway" });
  writeCanvasState(projectDir, state);
  return doc;
}
function renderCanvasDoc(projectDir, input) {
  const state = readCanvasState(projectDir);
  const doc = state.docs[input.docID];
  if (!doc) return null;
  doc.content = input.merge ? `${doc.content}
${input.content}` : input.content;
  doc.updatedAt = nowIso10();
  state.activeDocID = doc.id;
  pushEvent(state, { kind: "render", docID: doc.id, actor: input.actor ?? "gateway" });
  writeCanvasState(projectDir, state);
  return doc;
}
function closeCanvasDoc(projectDir, docID, actor = "gateway") {
  const state = readCanvasState(projectDir);
  const doc = state.docs[docID];
  if (!doc) return null;
  if (state.activeDocID === docID) {
    state.activeDocID = void 0;
  }
  pushEvent(state, { kind: "close", docID, actor });
  writeCanvasState(projectDir, state);
  return doc;
}
function listCanvasDocs(projectDir) {
  const state = readCanvasState(projectDir);
  return Object.values(state.docs).sort(
    (a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)
  );
}
function getCanvasDoc(projectDir, docID) {
  const state = readCanvasState(projectDir);
  return state.docs[docID] ?? null;
}
var init_state3 = __esm({
  "src/canvas/state.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/companion/memory-sqlite.ts
import * as fs23 from "node:fs";
import { createRequire } from "node:module";
import * as path22 from "node:path";
function createSqlDatabase(file3) {
  try {
    const nodeSqlite = require2("node:sqlite");
    const nodeDb = new nodeSqlite.DatabaseSync(file3);
    const tx = (fn) => ((...args) => {
      nodeDb.exec("BEGIN");
      try {
        const result = fn(...args);
        nodeDb.exec("COMMIT");
        return result;
      } catch (error92) {
        try {
          nodeDb.exec("ROLLBACK");
        } catch {
        }
        throw error92;
      }
    });
    return {
      exec: (sql) => nodeDb.exec(sql),
      query: (sql) => {
        const stmt = nodeDb.prepare(sql);
        return {
          run: (...params) => stmt.run(...params),
          get: (...params) => stmt.get(...params),
          all: (...params) => stmt.all(...params)
        };
      },
      transaction: tx,
      close: () => nodeDb.close()
    };
  } catch {
  }
  throw new Error("sqlite_runtime_unavailable:requires_node_sqlite");
}
function nowIso11() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function normalizeText(text) {
  return text.trim().replace(/\s+/g, " ");
}
function textToEmbeddingLite(text, dims = 96) {
  const vec = new Array(dims).fill(0);
  const parts = normalizeText(text).toLowerCase().split(/[^\p{L}\p{N}]+/u).filter(Boolean);
  if (parts.length === 0) return vec;
  for (const part of parts) {
    let hash3 = 0;
    for (let i = 0; i < part.length; i += 1) {
      hash3 = hash3 * 31 + part.charCodeAt(i) >>> 0;
    }
    for (let i = 0; i < 8; i += 1) {
      const idx = (hash3 + i * 17) % dims;
      vec[idx] += 1 + (hash3 >>> i % 16 & 3);
    }
  }
  const norm = Math.sqrt(vec.reduce((sum, value) => sum + value * value, 0));
  if (norm <= 0) return vec;
  return vec.map((value) => value / norm);
}
function memoryDir(projectDir) {
  return path22.join(getMiyaRuntimeDir(projectDir), "memory");
}
function sqlitePath(projectDir) {
  return path22.join(memoryDir(projectDir), "memories.sqlite");
}
function safeJsonParse(value, fallback) {
  if (typeof value !== "string" || !value.trim()) return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}
function ensureSchema(db) {
  db.exec("PRAGMA journal_mode=WAL;");
  db.exec("PRAGMA synchronous=NORMAL;");
  db.exec("PRAGMA foreign_keys=ON;");
  db.exec("PRAGMA busy_timeout=5000;");
  db.exec(`
    CREATE TABLE IF NOT EXISTS mem_cells (
      id TEXT PRIMARY KEY,
      domain TEXT NOT NULL DEFAULT 'work',
      kind TEXT NOT NULL DEFAULT 'Fact',
      subject TEXT NOT NULL DEFAULT 'User',
      predicate TEXT NOT NULL DEFAULT 'fact',
      object TEXT NOT NULL DEFAULT '',
      text TEXT NOT NULL,
      polarity TEXT NOT NULL DEFAULT 'neutral',
      confidence REAL NOT NULL DEFAULT 0.5,
      tier TEXT NOT NULL DEFAULT 'L1',
      status TEXT NOT NULL DEFAULT 'candidate',
      conflict_key TEXT,
      source TEXT NOT NULL DEFAULT 'manual',
      source_type TEXT NOT NULL DEFAULT 'manual',
      source_message_id TEXT,
      evidence_ref_json TEXT,
      score REAL NOT NULL DEFAULT 1,
      embedding_json TEXT NOT NULL,
      access_count INTEGER NOT NULL DEFAULT 0,
      is_archived INTEGER NOT NULL DEFAULT 0,
      conflict_wizard_id TEXT,
      superseded_by TEXT,
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL,
      last_accessed_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memory_corrections (
      id TEXT PRIMARY KEY,
      conflict_key TEXT NOT NULL,
      candidate_memory_id TEXT NOT NULL,
      existing_memory_ids_json TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS raw_logs (
      id TEXT PRIMARY KEY,
      session_id TEXT NOT NULL,
      sender TEXT NOT NULL,
      text TEXT NOT NULL,
      at TEXT NOT NULL,
      message_hash TEXT NOT NULL UNIQUE,
      processed_at TEXT,
      processed_job_id TEXT
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS evidence_packs (
      audit_id TEXT PRIMARY KEY,
      meta_json TEXT NOT NULL,
      payload_json TEXT NOT NULL,
      created_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memory_events (
      seq INTEGER PRIMARY KEY AUTOINCREMENT,
      event_id TEXT NOT NULL UNIQUE,
      event_type TEXT NOT NULL,
      entity_type TEXT NOT NULL,
      entity_id TEXT NOT NULL,
      payload_json TEXT NOT NULL,
      policy_hash TEXT,
      created_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS mem_scenes (
      scene_id TEXT PRIMARY KEY,
      domain TEXT NOT NULL DEFAULT 'work',
      title TEXT NOT NULL,
      summary_l0 TEXT NOT NULL DEFAULT '[]',
      summary_l1 TEXT NOT NULL DEFAULT '',
      vec_json TEXT NOT NULL DEFAULT '[]',
      updated_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memscene_cells (
      scene_id TEXT NOT NULL,
      cell_id TEXT NOT NULL,
      weight REAL NOT NULL DEFAULT 1,
      PRIMARY KEY(scene_id, cell_id),
      FOREIGN KEY(scene_id) REFERENCES mem_scenes(scene_id) ON DELETE CASCADE,
      FOREIGN KEY(cell_id) REFERENCES mem_cells(id) ON DELETE CASCADE
    );
  `);
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_mem_cells_status_domain ON mem_cells(status, domain);"
  );
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_mem_cells_conflict_key ON mem_cells(conflict_key);"
  );
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_raw_logs_processed ON raw_logs(processed_at, at);"
  );
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_memory_events_created ON memory_events(created_at);"
  );
  try {
    db.exec(`
      CREATE VIRTUAL TABLE IF NOT EXISTS mem_cells_fts USING fts5(
        text,
        content='mem_cells',
        content_rowid='rowid'
      );
    `);
    db.exec(`
      CREATE TRIGGER IF NOT EXISTS mem_cells_ai AFTER INSERT ON mem_cells BEGIN
        INSERT INTO mem_cells_fts(rowid, text) VALUES (new.rowid, new.text);
      END;
    `);
    db.exec(`
      CREATE TRIGGER IF NOT EXISTS mem_cells_ad AFTER DELETE ON mem_cells BEGIN
        INSERT INTO mem_cells_fts(mem_cells_fts, rowid, text) VALUES('delete', old.rowid, old.text);
      END;
    `);
    db.exec(`
      CREATE TRIGGER IF NOT EXISTS mem_cells_au AFTER UPDATE ON mem_cells BEGIN
        INSERT INTO mem_cells_fts(mem_cells_fts, rowid, text) VALUES('delete', old.rowid, old.text);
        INSERT INTO mem_cells_fts(rowid, text) VALUES (new.rowid, new.text);
      END;
    `);
  } catch {
  }
}
function openDatabase(projectDir) {
  fs23.mkdirSync(memoryDir(projectDir), { recursive: true });
  const db = createSqlDatabase(sqlitePath(projectDir));
  ensureSchema(db);
  return db;
}
function rowToMemory(row) {
  return {
    id: String(row.id ?? ""),
    text: String(row.text ?? ""),
    memoryKind: row.kind === "Fact" || row.kind === "Insight" || row.kind === "UserPreference" ? row.kind : void 0,
    source: String(row.source ?? "manual"),
    embedding: safeJsonParse(row.embedding_json, []),
    score: Number(row.score ?? 1),
    confidence: Number(row.confidence ?? 0.5),
    tier: String(row.tier ?? "L1"),
    domain: row.domain === "work" || row.domain === "relationship" || row.domain === "personal" || row.domain === "system" ? row.domain : "work",
    subject: String(row.subject ?? "User"),
    predicate: String(row.predicate ?? "fact"),
    object: String(row.object ?? ""),
    polarity: row.polarity === "positive" || row.polarity === "negative" || row.polarity === "neutral" ? row.polarity : "neutral",
    sourceMessageID: typeof row.source_message_id === "string" && row.source_message_id.trim() ? String(row.source_message_id) : void 0,
    sourceType: row.source_type === "manual" || row.source_type === "conversation" || row.source_type === "reflect" || row.source_type === "direct_correction" ? row.source_type : "manual",
    status: String(
      row.status ?? "candidate"
    ),
    conflictKey: typeof row.conflict_key === "string" && row.conflict_key.trim() ? String(row.conflict_key) : void 0,
    conflictWizardID: typeof row.conflict_wizard_id === "string" && row.conflict_wizard_id.trim() ? String(row.conflict_wizard_id) : void 0,
    supersededBy: typeof row.superseded_by === "string" && row.superseded_by.trim() ? String(row.superseded_by) : void 0,
    evidenceRef: safeJsonParse(
      row.evidence_ref_json,
      void 0
    ),
    accessCount: Number(row.access_count ?? 0),
    isArchived: Number(row.is_archived ?? 0) === 1,
    createdAt: String(row.created_at ?? nowIso11()),
    updatedAt: String(row.updated_at ?? nowIso11()),
    lastAccessedAt: String(row.last_accessed_at ?? nowIso11())
  };
}
function rowToCorrection(row) {
  return {
    id: String(row.id ?? ""),
    conflictKey: String(row.conflict_key ?? ""),
    candidateMemoryID: String(row.candidate_memory_id ?? ""),
    existingMemoryIDs: safeJsonParse(
      row.existing_memory_ids_json,
      []
    ),
    status: row.status === "resolved" || row.status === "rejected" ? row.status : "pending",
    createdAt: String(row.created_at ?? nowIso11()),
    updatedAt: String(row.updated_at ?? nowIso11())
  };
}
function withMemoryDb(projectDir, fn) {
  let db = null;
  try {
    db = openDatabase(projectDir);
    return fn(db);
  } finally {
    try {
      db?.close();
    } catch {
    }
  }
}
function listMemoryCells(projectDir) {
  return withMemoryDb(projectDir, (db) => {
    const rows = db.query(
      "SELECT * FROM mem_cells ORDER BY datetime(updated_at) DESC, id DESC"
    ).all();
    return rows.map(rowToMemory);
  });
}
function getMemoryCell(projectDir, id) {
  return withMemoryDb(projectDir, (db) => {
    const row = db.query("SELECT * FROM mem_cells WHERE id = ?").get(id);
    return row ? rowToMemory(row) : null;
  });
}
function upsertMemoryCell(projectDir, item) {
  return withMemoryDb(projectDir, (db) => {
    db.query(`
      INSERT INTO mem_cells (
        id, domain, kind, subject, predicate, object, text, polarity, confidence, tier, status,
        conflict_key, source, source_type, source_message_id, evidence_ref_json, score, embedding_json,
        access_count, is_archived, conflict_wizard_id, superseded_by, created_at, updated_at, last_accessed_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(id) DO UPDATE SET
        domain=excluded.domain,
        kind=excluded.kind,
        subject=excluded.subject,
        predicate=excluded.predicate,
        object=excluded.object,
        text=excluded.text,
        polarity=excluded.polarity,
        confidence=excluded.confidence,
        tier=excluded.tier,
        status=excluded.status,
        conflict_key=excluded.conflict_key,
        source=excluded.source,
        source_type=excluded.source_type,
        source_message_id=excluded.source_message_id,
        evidence_ref_json=excluded.evidence_ref_json,
        score=excluded.score,
        embedding_json=excluded.embedding_json,
        access_count=excluded.access_count,
        is_archived=excluded.is_archived,
        conflict_wizard_id=excluded.conflict_wizard_id,
        superseded_by=excluded.superseded_by,
        created_at=excluded.created_at,
        updated_at=excluded.updated_at,
        last_accessed_at=excluded.last_accessed_at
    `).run(
      item.id,
      item.domain ?? "work",
      item.memoryKind ?? "Fact",
      item.subject ?? "User",
      item.predicate ?? "fact",
      item.object ?? "",
      item.text,
      item.polarity ?? "neutral",
      item.confidence,
      item.tier,
      item.status,
      item.conflictKey ?? null,
      item.source,
      item.sourceType ?? "manual",
      item.sourceMessageID ?? null,
      item.evidenceRef ? JSON.stringify(item.evidenceRef) : null,
      item.score,
      JSON.stringify(item.embedding),
      item.accessCount,
      item.isArchived ? 1 : 0,
      item.conflictWizardID ?? null,
      item.supersededBy ?? null,
      item.createdAt,
      item.updatedAt,
      item.lastAccessedAt
    );
    return getMemoryCell(projectDir, item.id) ?? item;
  });
}
function upsertMemoryCells(projectDir, items) {
  withMemoryDb(projectDir, (db) => {
    const run = db.transaction(() => {
      const stmt = db.query(`
        INSERT INTO mem_cells (
          id, domain, kind, subject, predicate, object, text, polarity, confidence, tier, status,
          conflict_key, source, source_type, source_message_id, evidence_ref_json, score, embedding_json,
          access_count, is_archived, conflict_wizard_id, superseded_by, created_at, updated_at, last_accessed_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(id) DO UPDATE SET
          domain=excluded.domain,
          kind=excluded.kind,
          subject=excluded.subject,
          predicate=excluded.predicate,
          object=excluded.object,
          text=excluded.text,
          polarity=excluded.polarity,
          confidence=excluded.confidence,
          tier=excluded.tier,
          status=excluded.status,
          conflict_key=excluded.conflict_key,
          source=excluded.source,
          source_type=excluded.source_type,
          source_message_id=excluded.source_message_id,
          evidence_ref_json=excluded.evidence_ref_json,
          score=excluded.score,
          embedding_json=excluded.embedding_json,
          access_count=excluded.access_count,
          is_archived=excluded.is_archived,
          conflict_wizard_id=excluded.conflict_wizard_id,
          superseded_by=excluded.superseded_by,
          created_at=excluded.created_at,
          updated_at=excluded.updated_at,
          last_accessed_at=excluded.last_accessed_at
      `);
      for (const item of items) {
        stmt.run(
          item.id,
          item.domain ?? "work",
          item.memoryKind ?? "Fact",
          item.subject ?? "User",
          item.predicate ?? "fact",
          item.object ?? "",
          item.text,
          item.polarity ?? "neutral",
          item.confidence,
          item.tier,
          item.status,
          item.conflictKey ?? null,
          item.source,
          item.sourceType ?? "manual",
          item.sourceMessageID ?? null,
          item.evidenceRef ? JSON.stringify(item.evidenceRef) : null,
          item.score,
          JSON.stringify(item.embedding),
          item.accessCount,
          item.isArchived ? 1 : 0,
          item.conflictWizardID ?? null,
          item.supersededBy ?? null,
          item.createdAt,
          item.updatedAt,
          item.lastAccessedAt
        );
      }
    });
    run();
  });
}
function listMemoryCorrections(projectDir) {
  return withMemoryDb(projectDir, (db) => {
    const rows = db.query(
      "SELECT * FROM memory_corrections ORDER BY datetime(updated_at) DESC, id DESC"
    ).all();
    return rows.map(rowToCorrection);
  });
}
function upsertMemoryCorrection(projectDir, correction) {
  return withMemoryDb(projectDir, (db) => {
    db.query(`
      INSERT INTO memory_corrections (
        id, conflict_key, candidate_memory_id, existing_memory_ids_json, status, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(id) DO UPDATE SET
        conflict_key=excluded.conflict_key,
        candidate_memory_id=excluded.candidate_memory_id,
        existing_memory_ids_json=excluded.existing_memory_ids_json,
        status=excluded.status,
        created_at=excluded.created_at,
        updated_at=excluded.updated_at
    `).run(
      correction.id,
      correction.conflictKey,
      correction.candidateMemoryID,
      JSON.stringify(correction.existingMemoryIDs),
      correction.status,
      correction.createdAt,
      correction.updatedAt
    );
    const row = db.query("SELECT * FROM memory_corrections WHERE id = ?").get(correction.id);
    return row ? rowToCorrection(row) : correction;
  });
}
function appendRawMemoryLog(projectDir, row) {
  return withMemoryDb(projectDir, (db) => {
    try {
      db.query(`
        INSERT INTO raw_logs (id, session_id, sender, text, at, message_hash, processed_at, processed_job_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        row.id,
        row.sessionID,
        row.sender,
        row.text,
        row.at,
        row.messageHash,
        row.processedAt ?? null,
        null
      );
      return row;
    } catch {
      const existing = db.query("SELECT * FROM raw_logs WHERE message_hash = ? LIMIT 1").get(row.messageHash);
      if (!existing) return null;
      return null;
    }
  });
}
function listRawMemoryLogs(projectDir, options) {
  return withMemoryDb(projectDir, (db) => {
    const limit = Math.max(1, Math.min(1e3, options?.limit ?? 200));
    const sql = options?.pendingOnly ? "SELECT * FROM raw_logs WHERE processed_at IS NULL ORDER BY datetime(at) ASC LIMIT ?" : "SELECT * FROM raw_logs ORDER BY datetime(at) DESC LIMIT ?";
    const rows = db.query(sql).all(limit);
    return rows.map((row) => ({
      id: String(row.id ?? ""),
      sessionID: String(row.session_id ?? "main"),
      sender: row.sender === "assistant" || row.sender === "system" ? row.sender : "user",
      text: String(row.text ?? ""),
      at: String(row.at ?? nowIso11()),
      messageHash: String(row.message_hash ?? ""),
      processedAt: typeof row.processed_at === "string" && row.processed_at.trim() ? String(row.processed_at) : void 0
    }));
  });
}
function appendMemoryEvent(projectDir, input) {
  withMemoryDb(projectDir, (db) => {
    db.query(`
      INSERT OR IGNORE INTO memory_events (
        event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(
      input.eventID,
      input.eventType,
      input.entityType,
      input.entityID,
      JSON.stringify(input.payload ?? {}),
      input.policyHash ?? null,
      input.createdAt ?? nowIso11()
    );
  });
}
function listMemoryEvents(projectDir, options) {
  return withMemoryDb(projectDir, (db) => {
    const limit = Math.max(1, Math.min(2e3, options?.limit ?? 200));
    let rows;
    if (options?.since) {
      rows = db.query(
        `SELECT event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
           FROM memory_events
           WHERE datetime(created_at) >= datetime(?)
           ORDER BY seq ASC
           LIMIT ?`
      ).all(options.since, limit);
    } else {
      rows = db.query(
        `SELECT event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
           FROM memory_events
           ORDER BY seq DESC
           LIMIT ?`
      ).all(limit);
      rows.reverse();
    }
    return rows.map((row) => ({
      eventID: String(row.event_id ?? ""),
      eventType: String(row.event_type ?? ""),
      entityType: String(row.entity_type ?? ""),
      entityID: String(row.entity_id ?? ""),
      payload: safeJsonParse(row.payload_json, {}),
      policyHash: typeof row.policy_hash === "string" && row.policy_hash.trim() ? String(row.policy_hash) : void 0,
      createdAt: String(row.created_at ?? nowIso11())
    }));
  });
}
function constructReflectBatch(projectDir, input) {
  return withMemoryDb(projectDir, (db) => {
    const createdMemories = [];
    const tx = db.transaction(() => {
      db.query(`
        INSERT INTO evidence_packs (audit_id, meta_json, payload_json, created_at)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(audit_id) DO UPDATE SET
          meta_json=excluded.meta_json,
          payload_json=excluded.payload_json,
          created_at=excluded.created_at
      `).run(
        input.auditID,
        JSON.stringify(input.evidenceMeta ?? {}),
        JSON.stringify(input.evidencePayload ?? {}),
        input.processedAt
      );
      const memoryInsert = db.query(`
        INSERT INTO mem_cells (
          id, domain, kind, subject, predicate, object, text, polarity, confidence, tier, status,
          conflict_key, source, source_type, source_message_id, evidence_ref_json, score, embedding_json,
          access_count, is_archived, conflict_wizard_id, superseded_by, created_at, updated_at, last_accessed_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
      const eventInsert = db.query(`
        INSERT OR IGNORE INTO memory_events (
          event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `);
      for (const triplet of input.triplets) {
        const id = `mem_${Math.random().toString(36).slice(2, 10)}_${Math.random().toString(36).slice(2, 10)}`;
        const text = `${triplet.subject} ${triplet.predicate} ${triplet.object}`.trim();
        const embedding = textToEmbeddingLite(text);
        const evidenceRef = {
          auditID: input.auditID,
          sourceLogIDs: [triplet.sourceLogID],
          quoteSpans: triplet.quotes
        };
        const record3 = {
          id,
          text,
          memoryKind: triplet.kind,
          source: "reflect",
          embedding,
          score: 1,
          confidence: triplet.confidence,
          tier: triplet.tier,
          domain: triplet.domain,
          subject: triplet.subject,
          predicate: triplet.predicate,
          object: triplet.object,
          polarity: "neutral",
          sourceMessageID: triplet.sourceLogID,
          sourceType: "reflect",
          status: "candidate",
          conflictKey: void 0,
          conflictWizardID: void 0,
          supersededBy: void 0,
          evidenceRef,
          accessCount: 0,
          isArchived: false,
          createdAt: input.processedAt,
          updatedAt: input.processedAt,
          lastAccessedAt: input.processedAt
        };
        memoryInsert.run(
          record3.id,
          record3.domain ?? "work",
          record3.memoryKind ?? "Fact",
          record3.subject ?? "User",
          record3.predicate ?? "fact",
          record3.object ?? "",
          record3.text,
          record3.polarity ?? "neutral",
          record3.confidence,
          record3.tier,
          record3.status,
          null,
          record3.source,
          record3.sourceType ?? "reflect",
          record3.sourceMessageID ?? null,
          JSON.stringify(record3.evidenceRef),
          record3.score,
          JSON.stringify(record3.embedding),
          record3.accessCount,
          record3.isArchived ? 1 : 0,
          null,
          null,
          record3.createdAt,
          record3.updatedAt,
          record3.lastAccessedAt
        );
        eventInsert.run(
          `evt_${record3.id}`,
          "memory_candidate_created",
          "mem_cell",
          record3.id,
          JSON.stringify({
            status: record3.status,
            sourceType: record3.sourceType,
            source: "reflect",
            hasEvidence: true
          }),
          input.policyHash ?? null,
          input.processedAt
        );
        createdMemories.push(record3);
      }
      const markStmt = db.query(
        "UPDATE raw_logs SET processed_at = ?, processed_job_id = ? WHERE id = ?"
      );
      for (const row of input.pickedLogs) {
        markStmt.run(input.processedAt, input.jobID, row.id);
      }
      eventInsert.run(
        `evt_${input.jobID}`,
        "reflect_completed",
        "reflect_job",
        input.jobID,
        JSON.stringify({
          auditID: input.auditID,
          processedLogs: input.pickedLogs.length,
          generatedTriplets: input.triplets.length,
          generatedFacts: input.reflectStats?.generatedFacts ?? 0,
          generatedInsights: input.reflectStats?.generatedInsights ?? 0,
          generatedPreferences: input.reflectStats?.generatedPreferences ?? 0
        }),
        input.policyHash ?? null,
        input.processedAt
      );
    });
    tx();
    return {
      createdMemories,
      processedLogs: input.pickedLogs.length
    };
  });
}
function getEvidencePack(projectDir, auditID) {
  return withMemoryDb(projectDir, (db) => {
    const row = db.query(
      "SELECT audit_id, meta_json, payload_json, created_at FROM evidence_packs WHERE audit_id = ?"
    ).get(auditID);
    if (!row) return null;
    return {
      auditID: String(row.audit_id ?? ""),
      meta: safeJsonParse(row.meta_json, {}),
      payload: safeJsonParse(row.payload_json, {}),
      createdAt: String(row.created_at ?? nowIso11())
    };
  });
}
function buildMemoryPack(projectDir, input) {
  const domain3 = input.domain ?? "work";
  const mode = input.mode ?? "execution";
  const l0Limit = Math.max(1, Math.min(20, input.l0Limit ?? 10));
  const l1Limit = Math.max(1, Math.min(30, input.l1Limit ?? 12));
  return withMemoryDb(projectDir, (db) => {
    const queryText = input.query.trim();
    const candidates = db.query(
      `SELECT id, text, confidence, tier, updated_at, evidence_ref_json
         FROM mem_cells
         WHERE status = 'active' AND is_archived = 0 AND domain = ?
         ORDER BY datetime(last_accessed_at) DESC, score DESC
         LIMIT 100`
    ).all(domain3);
    const filtered = queryText ? candidates.filter(
      (row) => String(row.text ?? "").toLowerCase().includes(queryText.toLowerCase())
    ) : candidates;
    const base = (filtered.length > 0 ? filtered : candidates).slice(0, 100);
    const l0 = base.filter((row) => String(row.tier ?? "L1") === "L0").slice(0, l0Limit).map((row) => String(row.text ?? ""));
    const l1 = base.filter((row) => String(row.tier ?? "L1") !== "L0").slice(0, l1Limit).map((row) => ({
      text: String(row.text ?? ""),
      confidence: Number(row.confidence ?? 0.5),
      at: String(row.updated_at ?? nowIso11())
    }));
    const l2 = base.map(
      (row) => safeJsonParse(
        row.evidence_ref_json,
        void 0
      )
    ).filter((item) => Boolean(item?.auditID)).map((item) => `miya://audit/evidence/${item.auditID}`);
    const uniqueL2 = Array.from(new Set(l2));
    if (mode === "execution") {
      return { l0, l1: [], l2: [] };
    }
    if (mode === "response") {
      return { l0, l1, l2: uniqueL2.slice(0, 6) };
    }
    return { l0, l1, l2: uniqueL2 };
  });
}
function buildMemoryProfile(projectDir, domain3) {
  const rows = listMemoryCells(projectDir).filter(
    (row) => domain3 ? row.domain === domain3 : true
  );
  const active = rows.filter(
    (row) => row.status === "active" && !row.isArchived
  );
  const candidates = rows.filter(
    (row) => row.status === "candidate" || row.status === "pending"
  );
  const topConstraints = active.filter((row) => row.tier === "L0").slice(0, 12).map((row) => row.text);
  return {
    activeCount: active.length,
    candidateCount: candidates.length,
    topConstraints
  };
}
function resolveContextFsUri(projectDir, uri) {
  const target = String(uri || "").trim();
  if (!target.startsWith("miya://")) return null;
  if (target.startsWith("miya://mem/cell/")) {
    const id = target.slice("miya://mem/cell/".length);
    const cell = getMemoryCell(projectDir, id);
    return cell ? { uri: target, data: cell } : null;
  }
  if (target.startsWith("miya://audit/evidence/")) {
    const auditID = target.slice("miya://audit/evidence/".length);
    const pack = getEvidencePack(projectDir, auditID);
    return pack ? { uri: target, data: pack } : null;
  }
  if (target.startsWith("miya://audit/events")) {
    const question = target.split("?")[1] ?? "";
    const params = new URLSearchParams(question);
    const since = params.get("since") || void 0;
    const limitValue = Number(params.get("limit") ?? "200");
    const limit = Number.isFinite(limitValue) ? Math.max(1, Math.min(2e3, limitValue)) : 200;
    return {
      uri: target,
      data: listMemoryEvents(projectDir, { since, limit })
    };
  }
  if (target.startsWith("miya://mem/query")) {
    const question = target.split("?")[1] ?? "";
    const params = new URLSearchParams(question);
    const domain3 = params.get("domain") || void 0;
    const status = params.get("status") || void 0;
    const tier = params.get("tier") || void 0;
    const rows = listMemoryCells(projectDir).filter((item) => {
      if (domain3 && item.domain !== domain3) return false;
      if (status && item.status !== status) return false;
      if (tier && item.tier !== tier) return false;
      return true;
    });
    return { uri: target, data: rows };
  }
  if (target.startsWith("miya://mem/profile")) {
    const question = target.split("?")[1] ?? "";
    const params = new URLSearchParams(question);
    const domainRaw = params.get("domain");
    const domain3 = domainRaw === "work" || domainRaw === "relationship" || domainRaw === "personal" || domainRaw === "system" ? domainRaw : void 0;
    return {
      uri: target,
      data: buildMemoryProfile(projectDir, domain3)
    };
  }
  if (target.startsWith("miya://mem/scenes/")) {
    const sceneID = target.slice("miya://mem/scenes/".length).trim();
    if (!sceneID) return null;
    return withMemoryDb(projectDir, (db) => {
      const scene = db.query(
        "SELECT scene_id, domain, title, summary_l0, summary_l1, updated_at FROM mem_scenes WHERE scene_id = ?"
      ).get(sceneID);
      if (!scene) return null;
      const cells = db.query(
        `SELECT c.* FROM memscene_cells mc
           JOIN mem_cells c ON c.id = mc.cell_id
           WHERE mc.scene_id = ?
           ORDER BY mc.weight DESC, datetime(c.updated_at) DESC`
      ).all(sceneID);
      return {
        uri: target,
        data: {
          sceneID: String(scene.scene_id ?? ""),
          domain: String(scene.domain ?? "work"),
          title: String(scene.title ?? ""),
          summaryL0: safeJsonParse(scene.summary_l0, []),
          summaryL1: String(scene.summary_l1 ?? ""),
          updatedAt: String(scene.updated_at ?? nowIso11()),
          cells: cells.map(rowToMemory)
        }
      };
    });
  }
  return null;
}
function getCompanionMemorySqliteStats(projectDir) {
  const dbPath = sqlitePath(projectDir);
  return withMemoryDb(projectDir, (db) => {
    const memoryCount = Number(
      db.query("SELECT COUNT(1) AS c FROM mem_cells").get()?.c ?? 0
    );
    const candidateCount = Number(
      db.query(
        "SELECT COUNT(1) AS c FROM mem_cells WHERE status IN ('candidate','pending')"
      ).get()?.c ?? 0
    );
    const activeCount = Number(
      db.query("SELECT COUNT(1) AS c FROM mem_cells WHERE status = 'active'").get()?.c ?? 0
    );
    const rawLogCount = Number(
      db.query("SELECT COUNT(1) AS c FROM raw_logs").get()?.c ?? 0
    );
    const pendingRawLogCount = Number(
      db.query(
        "SELECT COUNT(1) AS c FROM raw_logs WHERE processed_at IS NULL"
      ).get()?.c ?? 0
    );
    const evidenceCount = Number(
      db.query("SELECT COUNT(1) AS c FROM evidence_packs").get()?.c ?? 0
    );
    const eventCount = Number(
      db.query("SELECT COUNT(1) AS c FROM memory_events").get()?.c ?? 0
    );
    return {
      sqlitePath: dbPath,
      memoryCount,
      candidateCount,
      activeCount,
      vectorCount: memoryCount,
      graphCount: memoryCount,
      rawLogCount,
      pendingRawLogCount,
      evidenceCount,
      eventCount
    };
  });
}
var require2;
var init_memory_sqlite = __esm({
  "src/companion/memory-sqlite.ts"() {
    "use strict";
    init_workflow();
    require2 = createRequire(import.meta.url);
  }
});

// src/companion/memory-vector.ts
import { createHash as createHash8, randomUUID as randomUUID10 } from "node:crypto";
function nowIso12() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function normalizeText2(text) {
  return text.trim().replace(/\s+/g, " ");
}
function textToEmbedding(text, dims = 96) {
  const vec = new Array(dims).fill(0);
  const parts = normalizeText2(text).toLowerCase().split(/[^\p{L}\p{N}]+/u).filter(Boolean);
  if (parts.length === 0) return vec;
  for (const part of parts) {
    const hash3 = createHash8("sha256").update(part).digest();
    for (let i = 0; i < 12; i += 1) {
      const idx = hash3[i] % dims;
      vec[idx] += 1 + hash3[i + 12] % 3;
    }
  }
  const norm = Math.sqrt(vec.reduce((sum, value) => sum + value * value, 0));
  if (norm <= 0) return vec;
  return vec.map((value) => value / norm);
}
function cosine(a, b) {
  if (a.length !== b.length || a.length === 0) return 0;
  let sum = 0;
  for (let i = 0; i < a.length; i += 1) sum += a[i] * b[i];
  return sum;
}
function extractConflictKey(text) {
  const negative = text.match(
    /(?:||||)\s*([^!?]+)/
  );
  if (negative?.[1])
    return { key: normalizeText2(negative[1]), polarity: "negative" };
  const positive = text.match(/(?:||||)\s*([^!?]+)/);
  if (positive?.[1])
    return { key: normalizeText2(positive[1]), polarity: "positive" };
  return { polarity: "neutral" };
}
function parseTriplet(text) {
  const parts = normalizeText2(text).split(/\s+/).filter(Boolean);
  if (parts.length >= 3) {
    return {
      subject: parts[0] ?? "User",
      predicate: parts[1] ?? "fact",
      object: parts.slice(2).join(" ")
    };
  }
  return {
    subject: "User",
    predicate: "stated",
    object: normalizeText2(text)
  };
}
function asPending(status) {
  return status === "pending" || status === "candidate";
}
function lexicalScore(query, text) {
  const q = normalizeText2(query).toLowerCase();
  const t = normalizeText2(text).toLowerCase();
  if (!q || !t) return 0;
  if (t.includes(q)) return 1;
  const qTokens = q.split(/[^\p{L}\p{N}]+/u).filter(Boolean);
  if (qTokens.length === 0) return 0;
  let hit = 0;
  for (const token of qTokens) if (t.includes(token)) hit += 1;
  return hit / qTokens.length;
}
function graphRelationScore(query, item) {
  const triplet = parseTriplet(query);
  const subjectHit = lexicalScore(triplet.subject, item.subject ?? "");
  const predicateHit = lexicalScore(triplet.predicate, item.predicate ?? "");
  const objectHit = lexicalScore(triplet.object, item.object ?? item.text);
  const directTripletHit = lexicalScore(
    query,
    `${item.subject ?? ""} ${item.predicate ?? ""} ${item.object ?? ""}`
  );
  return Math.max(
    directTripletHit,
    subjectHit * 0.2 + predicateHit * 0.4 + objectHit * 0.4
  );
}
function rrfScore(rank, k = 60) {
  return 1 / (k + rank + 1);
}
function qualityScore(item) {
  const tierWeight = item.tier === "L0" ? 1 : item.tier === "L1" ? 0.8 : item.tier === "L2" ? 0.55 : 0.35;
  const evidenceBoost = item.evidenceRef?.auditID ? 0.08 : 0;
  const archivedPenalty = item.isArchived || item.status === "archived" ? 0.5 : 1;
  const statusPenalty = item.status === "active" ? 1 : asPending(item.status) ? 0.75 : 0.4;
  return Math.max(
    0,
    Math.min(
      1.5,
      (item.confidence * 0.45 + item.score * 0.35 + tierWeight * 0.2 + evidenceBoost) * archivedPenalty * statusPenalty
    )
  );
}
function appendMutationEvent(projectDir, eventType, memoryID, payload) {
  appendMemoryEvent(projectDir, {
    eventID: `evt_${randomUUID10()}`,
    eventType,
    entityType: "mem_cell",
    entityID: memoryID,
    payload
  });
}
function decayCompanionMemoryVectors(projectDir, halfLifeDays = 30) {
  const items = listMemoryCells(projectDir);
  const safeHalfLife = Math.max(1, halfLifeDays);
  const lambda = Math.log(2) / safeHalfLife;
  const nowMs = Date.now();
  let updated = 0;
  const touched = [];
  for (const item of items) {
    if (item.status !== "active") continue;
    const ageDays = Math.max(
      0,
      (nowMs - Date.parse(item.updatedAt)) / (24 * 3600 * 1e3)
    );
    const nextScore = Math.max(0.05, item.score * Math.exp(-lambda * ageDays));
    if (Math.abs(nextScore - item.score) <= 1e-4) continue;
    item.score = Number(nextScore.toFixed(4));
    if (item.score < 0.08) item.isArchived = true;
    item.updatedAt = nowIso12();
    touched.push(item);
    updated += 1;
  }
  if (touched.length > 0) {
    upsertMemoryCells(projectDir, touched);
  }
  autoCleanupCompanionMemoryVectors(projectDir);
  return { updated, items: listMemoryCells(projectDir) };
}
function autoCleanupCompanionMemoryVectors(projectDir, input) {
  const maxActive = Math.max(100, Math.floor(input?.maxActive ?? 600));
  const maxPendingAgeDays = Math.max(
    1,
    Math.floor(input?.maxPendingAgeDays ?? 45)
  );
  const minQualityToKeep = Math.max(
    0.05,
    Math.min(1.5, Number(input?.minQualityToKeep ?? 0.18))
  );
  const nowMs = Date.now();
  const cells = listMemoryCells(projectDir);
  const touched = [];
  let archived = 0;
  let superseded = 0;
  for (const cell of cells) {
    const ageDays = Math.max(
      0,
      (nowMs - Date.parse(cell.updatedAt)) / (24 * 3600 * 1e3)
    );
    if (asPending(cell.status) && ageDays > maxPendingAgeDays) {
      cell.status = "superseded";
      cell.updatedAt = nowIso12();
      touched.push(cell);
      superseded += 1;
      appendMutationEvent(
        projectDir,
        "memory_auto_cleanup_pending_expired",
        cell.id,
        {
          ageDays: Number(ageDays.toFixed(2))
        }
      );
      continue;
    }
    if (cell.status === "active" && qualityScore(cell) < minQualityToKeep && ageDays > 14) {
      cell.isArchived = true;
      cell.status = "archived";
      cell.updatedAt = nowIso12();
      touched.push(cell);
      archived += 1;
      appendMutationEvent(
        projectDir,
        "memory_auto_cleanup_low_quality",
        cell.id,
        {
          quality: Number(qualityScore(cell).toFixed(4)),
          ageDays: Number(ageDays.toFixed(2))
        }
      );
    }
  }
  const active = cells.filter(
    (item) => item.status === "active" && !item.isArchived
  );
  if (active.length > maxActive) {
    const overflow = active.map((item) => ({
      item,
      q: qualityScore(item),
      age: Date.parse(item.updatedAt)
    })).sort((a, b) => a.q - b.q || a.age - b.age).slice(0, active.length - maxActive);
    for (const row of overflow) {
      row.item.isArchived = true;
      row.item.status = "archived";
      row.item.updatedAt = nowIso12();
      touched.push(row.item);
      archived += 1;
      appendMutationEvent(
        projectDir,
        "memory_auto_cleanup_capacity",
        row.item.id,
        {
          quality: Number(row.q.toFixed(4))
        }
      );
    }
  }
  if (touched.length > 0) {
    upsertMemoryCells(projectDir, touched);
  }
  const retained = listMemoryCells(projectDir).filter(
    (item) => item.status === "active" && !item.isArchived
  ).length;
  return { archived, superseded, retained };
}
function upsertCompanionMemoryVector(projectDir, input) {
  const text = normalizeText2(input.text);
  if (!text) throw new Error("invalid_memory_text");
  decayCompanionMemoryVectors(projectDir);
  const items = listMemoryCells(projectDir);
  const embedding = textToEmbedding(text);
  const now = nowIso12();
  const near = items.filter((item) => item.status === "active").map((item) => ({ item, sim: cosine(item.embedding, embedding) })).sort((a, b) => b.sim - a.sim)[0];
  if (near && near.sim >= 0.95) {
    near.item.score = Math.min(1.5, near.item.score + 0.15);
    near.item.accessCount += 1;
    near.item.isArchived = false;
    near.item.lastAccessedAt = now;
    near.item.updatedAt = now;
    upsertMemoryCell(projectDir, near.item);
    appendMutationEvent(projectDir, "memory_reinforced", near.item.id, {
      similarity: near.sim,
      sourceType: input.sourceType ?? "manual"
    });
    return near.item;
  }
  const preference = extractConflictKey(text);
  const confidenceInput = typeof input.confidence === "number" && Number.isFinite(input.confidence) ? input.confidence : input.tier === "L0" ? 1 : input.tier === "L3" ? 0.4 : 0.7;
  const confidence = Math.max(0, Math.min(1, confidenceInput));
  const tier = input.tier ?? (confidence >= 0.95 ? "L0" : confidence >= 0.6 ? "L1" : "L2");
  const triplet = parseTriplet(text);
  const created = {
    id: `mem_${randomUUID10()}`,
    text,
    source: input.source?.trim() || "manual",
    embedding,
    score: 1,
    confidence,
    tier,
    domain: input.domain ?? "work",
    subject: triplet.subject,
    predicate: triplet.predicate,
    object: triplet.object,
    polarity: preference.polarity,
    sourceMessageID: input.sourceMessageID,
    sourceType: input.sourceType ?? "manual",
    memoryKind: input.memoryKind,
    status: input.activate ? "active" : "pending",
    conflictKey: preference.key,
    evidenceRef: input.evidenceRef,
    accessCount: 0,
    isArchived: false,
    createdAt: now,
    updatedAt: now,
    lastAccessedAt: now
  };
  if (preference.key && preference.polarity !== "neutral") {
    const conflicting = [];
    for (const item of items) {
      if (item.status === "superseded" || item.status === "archived") continue;
      const other = extractConflictKey(item.text);
      if (!other.key || other.key !== preference.key || other.polarity === "neutral")
        continue;
      if (other.polarity !== preference.polarity) conflicting.push(item);
    }
    if (conflicting.length > 0) {
      const lambda = Math.log(2) / 30;
      const newScore = created.confidence;
      const scored = conflicting.map((item) => {
        const ageDays = Math.max(
          0,
          (Date.now() - Date.parse(item.lastAccessedAt)) / (24 * 3600 * 1e3)
        );
        const score = item.confidence * Math.exp(-lambda * ageDays);
        return { item, score };
      });
      const strongestOld = scored.sort((a, b) => b.score - a.score)[0];
      const threshold = 0.1;
      const forceOverride = created.sourceType === "direct_correction";
      const shouldOverwrite = forceOverride || (strongestOld ? newScore > strongestOld.score + threshold : false);
      if (shouldOverwrite) {
        created.status = "active";
        for (const other of conflicting) {
          other.status = "superseded";
          other.supersededBy = created.id;
          other.updatedAt = now;
        }
        upsertMemoryCells(projectDir, conflicting);
      } else {
        const wizard = {
          id: `mcw_${randomUUID10()}`,
          conflictKey: preference.key,
          candidateMemoryID: created.id,
          existingMemoryIDs: conflicting.map((item) => item.id),
          status: "pending",
          createdAt: now,
          updatedAt: now
        };
        upsertMemoryCorrection(projectDir, wizard);
        created.conflictWizardID = wizard.id;
        created.status = "pending";
      }
    }
  }
  const saved = upsertMemoryCell(projectDir, created);
  appendMutationEvent(projectDir, "memory_candidate_created", saved.id, {
    status: saved.status,
    sourceType: saved.sourceType,
    conflictKey: saved.conflictKey ?? null,
    hasEvidence: Boolean(saved.evidenceRef?.auditID)
  });
  return saved;
}
function searchCompanionMemoryVectors(projectDir, query, limit = 5, options) {
  const q = normalizeText2(query);
  if (!q) return [];
  const qEmb = textToEmbedding(q);
  const items = listMemoryCells(projectDir).filter(
    (item) => item.status === "active" && !item.isArchived && (!options?.domain || (item.domain ?? "work") === options.domain)
  );
  if (items.length === 0) return [];
  const nowMs = Date.now();
  const recencyHalfLifeDays = Math.max(1, options?.recencyHalfLifeDays ?? 30);
  const alpha = options?.alpha ?? 0.6;
  const beta = options?.beta ?? 0.2;
  const gamma = options?.gamma ?? 0.2;
  const threshold = Math.max(0, options?.threshold ?? 0.15);
  const importanceFromTier = (tier) => tier === "L0" ? 1 : tier === "L1" ? 0.7 : 0.4;
  const recency = (at) => {
    const deltaDays = Math.max(
      0,
      (nowMs - Date.parse(at)) / (24 * 3600 * 1e3)
    );
    const lambda = Math.log(2) / recencyHalfLifeDays;
    return Math.exp(-lambda * deltaDays);
  };
  const vectorRanked = items.map((item) => ({ item, score: cosine(item.embedding, qEmb) })).sort((a, b) => b.score - a.score);
  const lexicalRanked = items.map((item) => ({ item, score: lexicalScore(q, item.text) })).sort((a, b) => b.score - a.score);
  const relationRanked = items.map((item) => ({ item, score: graphRelationScore(q, item) })).sort((a, b) => b.score - a.score);
  const vectorIndex = /* @__PURE__ */ new Map();
  const lexicalIndex = /* @__PURE__ */ new Map();
  const relationIndex = /* @__PURE__ */ new Map();
  vectorRanked.forEach((entry2, index) => vectorIndex.set(entry2.item.id, index));
  lexicalRanked.forEach(
    (entry2, index) => lexicalIndex.set(entry2.item.id, index)
  );
  relationRanked.forEach(
    (entry2, index) => relationIndex.set(entry2.item.id, index)
  );
  const ranked = items.map((item) => {
    const similarity = cosine(item.embedding, qEmb);
    const lexical = lexicalScore(q, item.text);
    const relation = graphRelationScore(q, item);
    const quality = qualityScore(item);
    const importance = importanceFromTier(item.tier) * quality;
    const vectorRrf = rrfScore(vectorIndex.get(item.id) ?? 999);
    const lexicalRrf = rrfScore(lexicalIndex.get(item.id) ?? 999);
    const relationRrf = rrfScore(relationIndex.get(item.id) ?? 999);
    const mode = options?.mode ?? "hybrid";
    const fusedRecall = mode === "vector" ? vectorRrf : mode === "keyword" ? lexicalRrf + relationRrf * 0.5 : vectorRrf + lexicalRrf + relationRrf;
    const rankScore = alpha * fusedRecall + beta * recency(item.lastAccessedAt) + gamma * importance;
    return {
      ...item,
      similarity,
      rankScore,
      quality,
      vectorScore: similarity,
      lexicalScore: lexical,
      relationScore: relation
    };
  }).filter((item) => item.rankScore >= threshold).sort((a, b) => b.rankScore - a.rankScore).slice(0, Math.max(1, limit));
  if (ranked.length > 0) {
    const touched = /* @__PURE__ */ new Map();
    for (const item of ranked) {
      item.accessCount += 1;
      item.lastAccessedAt = nowIso12();
      touched.set(item.id, item);
    }
    upsertMemoryCells(projectDir, Array.from(touched.values()));
  }
  autoCleanupCompanionMemoryVectors(projectDir);
  return ranked;
}
function listCompanionMemoryVectors(projectDir) {
  return listMemoryCells(projectDir);
}
function listPendingCompanionMemoryVectors(projectDir) {
  return listMemoryCells(projectDir).filter((item) => asPending(item.status));
}
function listCompanionMemoryCorrections(projectDir) {
  return listMemoryCorrections(projectDir);
}
function updateCompanionMemoryVector(projectDir, input) {
  const target = listMemoryCells(projectDir).find(
    (item) => item.id === input.memoryID
  );
  if (!target) return null;
  const nextText = typeof input.text === "string" && input.text.trim() ? normalizeText2(input.text) : target.text;
  const confidenceInput = typeof input.confidence === "number" && Number.isFinite(input.confidence) ? Math.max(0, Math.min(1, Number(input.confidence))) : target.confidence;
  target.text = nextText;
  target.embedding = textToEmbedding(nextText);
  const conflict = extractConflictKey(nextText);
  target.conflictKey = conflict.key;
  target.polarity = conflict.polarity;
  target.confidence = confidenceInput;
  target.tier = input.tier ?? (confidenceInput >= 0.95 ? "L0" : confidenceInput >= 0.6 ? "L1" : "L2");
  target.memoryKind = input.memoryKind === "Fact" || input.memoryKind === "Insight" || input.memoryKind === "UserPreference" ? input.memoryKind : target.memoryKind;
  if (input.status) target.status = input.status;
  target.updatedAt = nowIso12();
  if (target.status === "active") target.lastAccessedAt = target.updatedAt;
  const saved = upsertMemoryCell(projectDir, target);
  appendMutationEvent(projectDir, "memory_updated", saved.id, {
    status: saved.status,
    tier: saved.tier
  });
  return saved;
}
function archiveCompanionMemoryVector(projectDir, input) {
  const target = listMemoryCells(projectDir).find(
    (item) => item.id === input.memoryID
  );
  if (!target) return null;
  target.isArchived = Boolean(input.archived);
  target.status = target.isArchived ? "archived" : target.status === "archived" ? "active" : target.status;
  target.updatedAt = nowIso12();
  const saved = upsertMemoryCell(projectDir, target);
  appendMutationEvent(projectDir, "memory_archive_toggled", saved.id, {
    archived: saved.isArchived
  });
  return saved;
}
function confirmCompanionMemoryVector(projectDir, input) {
  const all = listMemoryCells(projectDir);
  const target = all.find((item) => item.id === input.memoryID);
  if (!target) return null;
  const now = nowIso12();
  if (!input.confirm) {
    target.status = "superseded";
    target.updatedAt = now;
  } else {
    target.status = "active";
    target.updatedAt = now;
    target.lastAccessedAt = now;
    if (input.supersedeConflicts && target.conflictKey) {
      const sourcePolarity = extractConflictKey(target.text).polarity;
      const touched = [];
      for (const item of all) {
        if (item.id === target.id || item.status === "superseded") continue;
        if (item.conflictKey !== target.conflictKey) continue;
        const itemPolarity = extractConflictKey(item.text).polarity;
        if (sourcePolarity !== "neutral" && itemPolarity !== "neutral" && sourcePolarity !== itemPolarity) {
          item.status = "superseded";
          item.supersededBy = target.id;
          item.updatedAt = now;
          touched.push(item);
        }
      }
      if (touched.length > 0) upsertMemoryCells(projectDir, touched);
    }
  }
  const saved = upsertMemoryCell(projectDir, target);
  if (target.conflictWizardID) {
    const correction = listMemoryCorrections(projectDir).find(
      (item) => item.id === target.conflictWizardID
    );
    if (correction) {
      correction.status = input.confirm ? "resolved" : "rejected";
      correction.updatedAt = now;
      upsertMemoryCorrection(projectDir, correction);
    }
  }
  appendMutationEvent(projectDir, "memory_confirmed", saved.id, {
    confirm: input.confirm,
    supersedeConflicts: Boolean(input.supersedeConflicts)
  });
  return saved;
}
var init_memory_vector = __esm({
  "src/companion/memory-vector.ts"() {
    "use strict";
    init_memory_sqlite();
  }
});

// src/companion/store.ts
import { randomUUID as randomUUID11 } from "node:crypto";
import * as fs24 from "node:fs";
import * as path23 from "node:path";
function nowIso13() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath7(projectDir) {
  return path23.join(getMiyaRuntimeDir(projectDir), "companion.json");
}
function ensureDir10(file3) {
  fs24.mkdirSync(path23.dirname(file3), { recursive: true });
}
function defaultProfile() {
  return {
    enabled: false,
    onboardingCompleted: false,
    name: "Miya",
    persona: "calm, supportive, and proactive",
    relationship: "companion",
    style: "warm and concise",
    memoryFacts: [],
    assets: [],
    updatedAt: nowIso13()
  };
}
function deriveActiveMemoryFacts(projectDir) {
  try {
    return listCompanionMemoryVectors(projectDir).filter((item) => item.status === "active" && !item.isArchived).map((item) => item.text).slice(0, 300);
  } catch {
    return [];
  }
}
function readCompanionProfile(projectDir) {
  const file3 = filePath7(projectDir);
  if (!fs24.existsSync(file3)) {
    return {
      ...defaultProfile(),
      memoryFacts: deriveActiveMemoryFacts(projectDir)
    };
  }
  try {
    const parsed = JSON.parse(fs24.readFileSync(file3, "utf-8"));
    return {
      ...defaultProfile(),
      ...parsed,
      // Runtime memory truth source is SQLite (mem_cells), not JSON profile blobs.
      memoryFacts: deriveActiveMemoryFacts(projectDir),
      assets: Array.isArray(parsed.assets) ? parsed.assets : [],
      updatedAt: parsed.updatedAt ?? nowIso13()
    };
  } catch {
    return {
      ...defaultProfile(),
      memoryFacts: deriveActiveMemoryFacts(projectDir)
    };
  }
}
function writeCompanionProfile(projectDir, profile) {
  const file3 = filePath7(projectDir);
  ensureDir10(file3);
  const next = {
    ...profile,
    memoryFacts: deriveActiveMemoryFacts(projectDir),
    updatedAt: nowIso13()
  };
  fs24.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function patchCompanionProfile(projectDir, patch) {
  const current = readCompanionProfile(projectDir);
  return writeCompanionProfile(projectDir, {
    ...current,
    ...patch
  });
}
function addCompanionAsset(projectDir, input) {
  const current = readCompanionProfile(projectDir);
  const asset = {
    id: `asset_${randomUUID11()}`,
    type: input.type,
    pathOrUrl: input.pathOrUrl,
    label: input.label,
    createdAt: nowIso13()
  };
  return writeCompanionProfile(projectDir, {
    ...current,
    assets: [asset, ...current.assets].slice(0, 200)
  });
}
function resetCompanionProfile(projectDir) {
  const allMemories = listCompanionMemoryVectors(projectDir);
  for (const item of allMemories) {
    if (item.isArchived) continue;
    archiveCompanionMemoryVector(projectDir, {
      memoryID: item.id,
      archived: true
    });
  }
  return writeCompanionProfile(projectDir, defaultProfile());
}
function syncCompanionProfileMemoryFacts(projectDir) {
  const current = readCompanionProfile(projectDir);
  return writeCompanionProfile(projectDir, {
    ...current,
    memoryFacts: deriveActiveMemoryFacts(projectDir)
  });
}
var init_store4 = __esm({
  "src/companion/store.ts"() {
    "use strict";
    init_workflow();
    init_memory_vector();
  }
});

// src/learning/skill-drafts.ts
import { createHash as createHash9, randomUUID as randomUUID12 } from "node:crypto";
import * as fs25 from "node:fs";
import * as path24 from "node:path";
function nowIso14() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath8(projectDir) {
  return path24.join(getMiyaRuntimeDir(projectDir), "learning-skill-drafts.json");
}
function normalizeText3(text) {
  return String(text ?? "").replace(/\s+/g, " ").trim();
}
function tokenize(text) {
  return Array.from(
    new Set(
      normalizeText3(text).toLowerCase().split(/[^a-z0-9_\-\u4e00-\u9fff]+/i).map((item) => item.trim()).filter((item) => item.length >= 2)
    )
  );
}
function hashText(text) {
  return createHash9("sha256").update(text).digest("hex").slice(0, 16);
}
function ensureDir11(projectDir) {
  fs25.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp2(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeDraft(raw) {
  const now = nowIso14();
  return {
    id: String(raw.id ?? `draft_${randomUUID12()}`),
    source: raw.source === "reflect" ? "reflect" : "ralph",
    status: raw.status === "accepted" || raw.status === "rejected" || raw.status === "recommended" || raw.status === "draft" ? raw.status : "draft",
    title: normalizeText3(String(raw.title ?? "")),
    problemPattern: normalizeText3(String(raw.problemPattern ?? "")),
    solutionPattern: normalizeText3(String(raw.solutionPattern ?? "")),
    commands: Array.isArray(raw.commands) ? raw.commands.map(String).map(normalizeText3).filter(Boolean) : [],
    tags: Array.isArray(raw.tags) ? raw.tags.map(String).map((item) => item.trim().toLowerCase()).filter(Boolean) : [],
    confidence: clamp2(Number(raw.confidence ?? 0.5), 0.1, 0.99),
    uses: clamp2(Number(raw.uses ?? 0), 0, 1e6),
    hits: clamp2(Number(raw.hits ?? 0), 0, 1e6),
    misses: clamp2(Number(raw.misses ?? 0), 0, 1e6),
    createdAt: raw.createdAt ? String(raw.createdAt) : now,
    updatedAt: raw.updatedAt ? String(raw.updatedAt) : now
  };
}
function readStore4(projectDir) {
  const file3 = filePath8(projectDir);
  if (!fs25.existsSync(file3)) return { drafts: [] };
  try {
    const parsed = JSON.parse(fs25.readFileSync(file3, "utf-8"));
    const drafts = Array.isArray(parsed?.drafts) ? parsed.drafts.map((item) => normalizeDraft(item)) : [];
    return { drafts };
  } catch {
    return { drafts: [] };
  }
}
function writeStore4(projectDir, store) {
  ensureDir11(projectDir);
  fs25.writeFileSync(filePath8(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function findSimilarDraftIndex(drafts, candidate) {
  const signature = hashText(
    `${candidate.source}|${candidate.problemPattern}|${candidate.solutionPattern}|${candidate.commands.join("|")}`
  );
  return drafts.findIndex((item) => {
    const current = hashText(
      `${item.source}|${item.problemPattern}|${item.solutionPattern}|${item.commands.join("|")}`
    );
    return current === signature;
  });
}
function upsertDraft(projectDir, draft) {
  const store = readStore4(projectDir);
  const index = findSimilarDraftIndex(store.drafts, draft);
  if (index >= 0) {
    const current = store.drafts[index];
    const merged = normalizeDraft({
      ...current,
      ...draft,
      id: current.id,
      createdAt: current.createdAt,
      confidence: current.confidence * 0.7 + draft.confidence * 0.3,
      status: current.status === "accepted" || current.status === "rejected" ? current.status : draft.status,
      tags: Array.from(/* @__PURE__ */ new Set([...current.tags, ...draft.tags])).slice(0, 12),
      updatedAt: nowIso14()
    });
    store.drafts[index] = merged;
    writeStore4(projectDir, store);
    return merged;
  }
  const next = normalizeDraft(draft);
  store.drafts = [next, ...store.drafts].slice(0, 500);
  writeStore4(projectDir, store);
  return next;
}
function draftScoreForQuery(draft, query) {
  const queryTokens = tokenize(query);
  if (queryTokens.length === 0) return 0;
  const targetTokens = new Set(
    tokenize(`${draft.title} ${draft.problemPattern} ${draft.solutionPattern} ${draft.tags.join(" ")}`)
  );
  let overlap = 0;
  for (const token of queryTokens) {
    if (targetTokens.has(token)) overlap += 1;
  }
  const overlapScore = overlap / queryTokens.length;
  const quality = draft.confidence;
  const statusBoost = draft.status === "accepted" ? 0.12 : draft.status === "recommended" ? 0.06 : 0;
  return clamp2(overlapScore * 0.75 + quality * 0.25 + statusBoost, 0, 1);
}
function matchDrafts(projectDir, query, threshold, limit) {
  const store = readStore4(projectDir);
  return store.drafts.filter((draft) => draft.status !== "rejected").map((draft) => ({ draft, score: draftScoreForQuery(draft, query) })).filter((item) => item.score >= threshold).sort((a, b) => b.score - a.score).slice(0, Math.max(1, limit));
}
function listSkillDrafts(projectDir, input) {
  const limit = Math.max(1, Math.min(200, Math.floor(Number(input?.limit ?? 50))));
  const store = readStore4(projectDir);
  return store.drafts.filter((draft) => input?.status ? draft.status === input.status : true).slice(0, limit);
}
function setSkillDraftStatus(projectDir, draftID, status, usage) {
  const store = readStore4(projectDir);
  const index = store.drafts.findIndex((item) => item.id === draftID);
  if (index < 0) return null;
  const current = store.drafts[index];
  const next = normalizeDraft({
    ...current,
    status: status ?? current.status,
    uses: usage ? current.uses + 1 : current.uses,
    hits: usage ? current.hits + (usage.hit ? 1 : 0) : current.hits,
    misses: usage ? current.misses + (usage.hit ? 0 : 1) : current.misses,
    updatedAt: nowIso14()
  });
  store.drafts[index] = next;
  writeStore4(projectDir, store);
  return next;
}
function getLearningStats(projectDir) {
  const drafts = readStore4(projectDir).drafts;
  const byStatus = {
    draft: 0,
    recommended: 0,
    accepted: 0,
    rejected: 0
  };
  let totalUses = 0;
  let totalHits = 0;
  for (const draft of drafts) {
    byStatus[draft.status] += 1;
    totalUses += draft.uses;
    totalHits += draft.hits;
  }
  return {
    total: drafts.length,
    byStatus,
    totalUses,
    hitRate: totalUses > 0 ? Number((totalHits / totalUses).toFixed(4)) : 0
  };
}
function buildLearningInjection(projectDir, query, input) {
  const threshold = clamp2(Number(input?.threshold ?? 0.64), 0.3, 0.98);
  const limit = Math.max(1, Math.min(3, Math.floor(Number(input?.limit ?? 2))));
  const matches = matchDrafts(projectDir, query, threshold, limit);
  if (matches.length === 0) return { snippet: void 0, matchedDraftIDs: [] };
  const lines = [
    "[MIYA_LEARNING_DRAFT_REUSE]",
    "Matched historical patterns (use as guidance, then verify):"
  ];
  for (const item of matches) {
    lines.push(`- draft=${item.draft.id} score=${item.score.toFixed(2)} title=${item.draft.title}`);
    lines.push(`  pattern=${item.draft.problemPattern}`);
    lines.push(`  fix=${item.draft.solutionPattern}`);
    if (item.draft.commands.length > 0) {
      lines.push(`  commands=${item.draft.commands.join(" ; ")}`);
    }
  }
  return {
    snippet: lines.join("\n"),
    matchedDraftIDs: matches.map((item) => item.draft.id)
  };
}
function createSkillDraftsFromReflect(projectDir, input) {
  const memories = Array.isArray(input.createdMemories) ? input.createdMemories : [];
  if (memories.length === 0) return [];
  const preferenceMemories = memories.filter((item) => item.memoryKind === "UserPreference").slice(0, 6);
  if (preferenceMemories.length === 0) return [];
  const pattern = preferenceMemories.map((item) => item.text).join(" | ");
  const draft = upsertDraft(projectDir, {
    id: `draft_${randomUUID12()}`,
    source: "reflect",
    status: "draft",
    title: "Reflect \u504F\u597D\u6267\u884C\u8349\u6848",
    problemPattern: "\u4EFB\u52A1\u6267\u884C\u6D89\u53CA\u7528\u6237\u4E60\u60EF\u6216\u504F\u597D\u5224\u65AD",
    solutionPattern: `\u4F18\u5148\u9075\u5FAA\u8FD1\u671F\u504F\u597D\u8BB0\u5FC6\uFF1A${pattern}`,
    commands: [],
    tags: ["reflect", "preference"],
    confidence: 0.62,
    uses: 0,
    hits: 0,
    misses: 0,
    createdAt: nowIso14(),
    updatedAt: nowIso14()
  });
  return [draft];
}
var init_skill_drafts = __esm({
  "src/learning/skill-drafts.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/learning/index.ts
var init_learning = __esm({
  "src/learning/index.ts"() {
    "use strict";
    init_skill_drafts();
  }
});

// src/companion/memory-reflect.ts
import { createHash as createHash10, randomUUID as randomUUID13 } from "node:crypto";
import * as fs26 from "node:fs";
import * as path25 from "node:path";
function nowIso15() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function memoryDir2(projectDir) {
  return path25.join(getMiyaRuntimeDir(projectDir), "memory");
}
function reflectJobPath(projectDir) {
  return path25.join(memoryDir2(projectDir), "reflect-jobs.jsonl");
}
function reflectStatePath(projectDir) {
  return path25.join(memoryDir2(projectDir), "reflect-state.json");
}
function ensureDir12(projectDir) {
  fs26.mkdirSync(memoryDir2(projectDir), { recursive: true });
}
function normalizeText4(input) {
  return input.trim().replace(/\s+/g, " ");
}
function hashMessage(input) {
  return createHash10("sha256").update(`${input.sender}
${input.at}
${normalizeText4(input.text)}`).digest("hex");
}
function readReflectState(projectDir) {
  const file3 = reflectStatePath(projectDir);
  if (!fs26.existsSync(file3)) return {};
  try {
    const parsed = JSON.parse(fs26.readFileSync(file3, "utf-8"));
    return parsed ?? {};
  } catch {
    return {};
  }
}
function writeReflectState(projectDir, patch) {
  ensureDir12(projectDir);
  const file3 = reflectStatePath(projectDir);
  const next = {
    ...readReflectState(projectDir),
    ...patch
  };
  fs26.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function quoteSpan(log2, raw) {
  const value = normalizeText4(raw);
  if (!value) return null;
  const start = log2.text.indexOf(value);
  if (start < 0) return null;
  return {
    logID: log2.id,
    exactText: value,
    charStart: start,
    charEnd: start + value.length
  };
}
function extractTriplets(log2) {
  if (log2.sender === "system") return [];
  const text = normalizeText4(log2.text);
  if (!text) return [];
  const triplets = [];
  const add = (kind, subject, predicate, object3, confidence, tier, quoteRaw) => {
    const value = normalizeText4(object3);
    const q = quoteSpan(log2, quoteRaw);
    if (!value || !q) return;
    triplets.push({
      kind,
      subject,
      predicate,
      object: value,
      confidence,
      tier,
      sourceLogID: log2.id,
      domain: "work",
      quotes: [q]
    });
  };
  const likes = text.match(/(?:)?([^!?.]+)/);
  if (likes?.[1])
    add("UserPreference", "User", "likes", likes[1], 0.86, "L1", likes[0]);
  const dislikes = text.match(/(?:|)?([^!?.]+)/);
  if (dislikes?.[1])
    add(
      "UserPreference",
      "User",
      "dislikes",
      dislikes[1],
      0.86,
      "L1",
      dislikes[0]
    );
  const prefers = text.match(
    /(?:||)?(?:|||)\s*([^!?.]+)/
  );
  if (prefers?.[1])
    add("UserPreference", "User", "prefers", prefers[1], 0.9, "L1", prefers[0]);
  const avoids = text.match(/(?:||)\s*([^!?.]+)/);
  if (avoids?.[1])
    add("UserPreference", "User", "avoids", avoids[1], 0.88, "L1", avoids[0]);
  const needs = text.match(/(?:||)([^!?.]+)/);
  if (needs?.[1])
    add("Fact", "User", "requires", needs[1], 0.7, "L1", needs[0]);
  const blocks = text.match(
    /(?:||)([^!?.]+)(?:|||)/
  );
  if (blocks?.[1])
    add(
      "Insight",
      "User",
      "is_blocking",
      `${blocks[1]}\u95EE\u9898`,
      0.75,
      "L2",
      blocks[0]
    );
  const anxiety = text.match(
    /(?:||||)([^!?.]*)/
  );
  if (anxiety)
    add(
      "Insight",
      "User",
      "emotion_signal",
      `\u8FDB\u5EA6\u538B\u529B ${anxiety[0]}`.trim(),
      0.72,
      "L2",
      anxiety[0]
    );
  const project = text.match(
    /(?:||repo|)\s*[:]?\s*([^!?.]+)/i
  );
  if (project?.[1])
    add("Fact", "User", "project", project[1], 0.68, "L1", project[0]);
  if (triplets.length === 0 && text.length <= 120) {
    add(
      "Fact",
      log2.sender === "assistant" ? "Miya" : "User",
      "stated",
      text,
      0.55,
      "L2",
      text
    );
  }
  return triplets;
}
function validateTripletQuotes(triplet, logsByID) {
  for (const quote of triplet.quotes) {
    const source = logsByID.get(quote.logID);
    if (!source) return false;
    if (quote.charStart < 0 || quote.charEnd <= quote.charStart) return false;
    const picked = source.text.slice(quote.charStart, quote.charEnd);
    if (normalizeText4(picked) !== normalizeText4(quote.exactText)) return false;
  }
  return true;
}
function appendShortTermMemoryLog(projectDir, input) {
  const text = normalizeText4(input.text);
  if (!text) return null;
  const at = input.at ?? nowIso15();
  const messageHash = input.messageID || hashMessage({ text, sender: input.sender, at });
  ensureDir12(projectDir);
  const row = {
    id: `st_${randomUUID13()}`,
    sessionID: input.sessionID?.trim() || "main",
    sender: input.sender,
    text,
    at,
    messageHash
  };
  const saved = appendRawMemoryLog(projectDir, row);
  if (!saved) return null;
  appendMemoryEvent(projectDir, {
    eventID: `evt_${randomUUID13()}`,
    eventType: "raw_log_appended",
    entityType: "raw_log",
    entityID: saved.id,
    payload: {
      sessionID: saved.sessionID,
      sender: saved.sender,
      at: saved.at
    }
  });
  writeReflectState(projectDir, { lastLogAt: at });
  return saved;
}
function getMemoryReflectStatus(projectDir) {
  const pendingLogs = listRawMemoryLogs(projectDir, {
    pendingOnly: true,
    limit: 5e3
  }).length;
  const state = readReflectState(projectDir);
  return {
    pendingLogs,
    lastLogAt: state.lastLogAt,
    lastReflectAt: state.lastReflectAt
  };
}
function reflectCompanionMemory(projectDir, input) {
  ensureDir12(projectDir);
  const state = readReflectState(projectDir);
  const now = nowIso15();
  if (input?.idempotencyKey && state.lastReflectIdempotencyKey === input.idempotencyKey) {
    if (state.lastReflectResult) return state.lastReflectResult;
  }
  const cooldownMinutes = Math.max(0, input?.cooldownMinutes ?? 0);
  if (cooldownMinutes > 0 && state.lastReflectAt) {
    const deltaMs = Date.now() - Date.parse(state.lastReflectAt);
    if (Number.isFinite(deltaMs) && deltaMs < cooldownMinutes * 60 * 1e3) {
      const blocked = {
        jobID: `reflect_${randomUUID13()}`,
        processedLogs: 0,
        generatedTriplets: 0,
        generatedFacts: 0,
        generatedInsights: 0,
        generatedPreferences: 0,
        createdMemories: [],
        archivedLogs: 0,
        auditID: `audit_${randomUUID13()}`
      };
      writeReflectState(projectDir, {
        lastReflectReason: `cooldown_blocked_${cooldownMinutes}m`
      });
      return blocked;
    }
  }
  const pending = listRawMemoryLogs(projectDir, {
    pendingOnly: true,
    limit: 2e3
  });
  const minLogs = Math.max(1, input?.minLogs ?? 1);
  if (!input?.force && pending.length < minLogs) {
    return {
      jobID: `reflect_${randomUUID13()}`,
      processedLogs: 0,
      generatedTriplets: 0,
      generatedFacts: 0,
      generatedInsights: 0,
      generatedPreferences: 0,
      createdMemories: [],
      archivedLogs: 0,
      auditID: `audit_${randomUUID13()}`
    };
  }
  const maxLogs = Math.max(1, input?.maxLogs ?? 50);
  const picked = pending.slice(0, maxLogs);
  const logsByID = new Map(picked.map((row) => [row.id, row]));
  const extracted = picked.flatMap((row) => extractTriplets(row));
  const triplets = extracted.filter(
    (item) => validateTripletQuotes(item, logsByID)
  );
  const generatedFacts = triplets.filter((item) => item.kind === "Fact").length;
  const generatedInsights = triplets.filter(
    (item) => item.kind === "Insight"
  ).length;
  const generatedPreferences = triplets.filter(
    (item) => item.kind === "UserPreference"
  ).length;
  const processedAt = nowIso15();
  const jobID = `reflect_${randomUUID13()}`;
  const auditID = `audit_${randomUUID13()}`;
  const constructed = constructReflectBatch(projectDir, {
    jobID,
    auditID,
    processedAt,
    policyHash: input?.policyHash,
    pickedLogs: picked,
    triplets,
    evidenceMeta: {
      schema_version: "EvidencePackV5",
      generated_at: processedAt,
      policy_hash: input?.policyHash ?? null,
      tool: "miya.memory.reflect",
      job_id: jobID,
      source: "memory_reflect"
    },
    evidencePayload: {
      logs: picked,
      extracted_triplets: triplets,
      dropped_triplets: extracted.length - triplets.length
    },
    reflectStats: {
      generatedFacts,
      generatedInsights,
      generatedPreferences
    }
  });
  const createdMemories = constructed.createdMemories;
  const result = {
    jobID,
    processedLogs: picked.length,
    generatedTriplets: triplets.length,
    generatedFacts,
    generatedInsights,
    generatedPreferences,
    createdMemories,
    archivedLogs: constructed.processedLogs,
    auditID
  };
  createSkillDraftsFromReflect(projectDir, {
    createdMemories
  });
  fs26.appendFileSync(
    reflectJobPath(projectDir),
    `${JSON.stringify({ ...result, at: processedAt })}
`,
    "utf-8"
  );
  writeReflectState(projectDir, {
    lastReflectAt: now,
    lastReflectIdempotencyKey: input?.idempotencyKey,
    lastReflectResult: result,
    lastReflectReason: "ok"
  });
  return result;
}
function maybeAutoReflectCompanionMemory(projectDir, input) {
  const idleMinutes = Math.max(1, input?.idleMinutes ?? 5);
  const minPendingLogs = Math.max(1, input?.minPendingLogs ?? 1);
  const cooldownMinutes = Math.max(1, input?.cooldownMinutes ?? 3);
  const status = getMemoryReflectStatus(projectDir);
  if (status.pendingLogs < minPendingLogs) return null;
  if (!status.lastLogAt) return null;
  const nowMs = Date.now();
  const idleMs = nowMs - Date.parse(status.lastLogAt);
  if (!Number.isFinite(idleMs) || idleMs < idleMinutes * 60 * 1e3) return null;
  if (status.lastReflectAt) {
    const cooldownMs = nowMs - Date.parse(status.lastReflectAt);
    if (Number.isFinite(cooldownMs) && cooldownMs < cooldownMinutes * 60 * 1e3)
      return null;
  }
  return reflectCompanionMemory(projectDir, {
    force: true,
    minLogs: minPendingLogs,
    maxLogs: input?.maxLogs ?? 50
  });
}
function maybeReflectOnSessionEnd(projectDir, input) {
  const minPendingLogs = Math.max(1, input?.minPendingLogs ?? 50);
  const status = getMemoryReflectStatus(projectDir);
  if (status.pendingLogs < minPendingLogs) return null;
  return reflectCompanionMemory(projectDir, {
    force: true,
    minLogs: minPendingLogs,
    maxLogs: input?.maxLogs ?? 100
  });
}
var init_memory_reflect = __esm({
  "src/companion/memory-reflect.ts"() {
    "use strict";
    init_learning();
    init_workflow();
    init_memory_sqlite();
  }
});

// src/companion/wizard.ts
import { createHash as createHash11, randomUUID as randomUUID14 } from "node:crypto";
import * as fs27 from "node:fs";
import * as path26 from "node:path";
function nowIso16() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function normalizeSessionId(sessionId) {
  const normalized = sessionId.trim().replace(/[^a-zA-Z0-9_-]+/g, "_");
  return normalized || "main";
}
function profilesRoot(projectDir) {
  return path26.join(getMiyaRuntimeDir(projectDir), "profiles", "companion");
}
function sessionRoot(projectDir, sessionId) {
  return path26.join(profilesRoot(projectDir), "sessions", normalizeSessionId(sessionId));
}
function currentProfileDir(projectDir, sessionId) {
  return path26.join(sessionRoot(projectDir, sessionId), "current");
}
function wizardFilePath(projectDir, sessionId) {
  return path26.join(currentProfileDir(projectDir, sessionId), "wizard-state.json");
}
function metadataPath(projectDir, sessionId) {
  return path26.join(currentProfileDir(projectDir, sessionId), "metadata.json");
}
function ensureProfileLayout(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  fs27.mkdirSync(path26.join(current, "photos"), { recursive: true });
  fs27.mkdirSync(path26.join(current, "embeddings"), { recursive: true });
  fs27.mkdirSync(path26.join(current, "lora"), { recursive: true });
  fs27.mkdirSync(path26.join(current, "voice"), { recursive: true });
  fs27.mkdirSync(path26.join(sessionRoot(projectDir, sessionId), "history"), { recursive: true });
}
function safeReadJson(filePath12) {
  if (!fs27.existsSync(filePath12)) return null;
  try {
    return JSON.parse(fs27.readFileSync(filePath12, "utf-8"));
  } catch {
    return null;
  }
}
function safeWriteJson(filePath12, value) {
  fs27.mkdirSync(path26.dirname(filePath12), { recursive: true });
  fs27.writeFileSync(filePath12, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function checksumFile(filePath12) {
  try {
    const data = fs27.readFileSync(filePath12);
    return `sha256:${createHash11("sha256").update(data).digest("hex")}`;
  } catch {
    return "sha256:unknown";
  }
}
function extensionForMime(mimeType, fallback = ".bin") {
  if (mimeType.includes("png")) return ".png";
  if (mimeType.includes("jpeg") || mimeType.includes("jpg")) return ".jpg";
  if (mimeType.includes("webp")) return ".webp";
  if (mimeType.includes("wav")) return ".wav";
  if (mimeType.includes("mpeg") || mimeType.includes("mp3")) return ".mp3";
  if (mimeType.includes("ogg")) return ".ogg";
  return fallback;
}
function defaultMetadata(sessionId) {
  const now = nowIso16();
  return {
    profileId: `companion-${now.replace(/[:.]/g, "-")}`,
    createdAt: now,
    updatedAt: now,
    version: "v1",
    assets: {
      photos: {
        count: 0,
        paths: [],
        checksums: []
      },
      voice: {
        hasSample: false,
        duration: 0,
        modelType: "gpt_sovits_v2"
      },
      persona: {
        sourceText: "",
        generatedPrompt: ""
      }
    },
    trainingStatus: {
      image: "pending",
      voice: "pending"
    },
    sessionBinding: {
      opencodeSessionId: sessionId,
      daemonSessionId: `daemon-${sessionId}`
    }
  };
}
function defaultState5(sessionId) {
  const now = nowIso16();
  return {
    sessionId: `wizard:companion:${normalizeSessionId(sessionId)}`,
    boundSessionId: sessionId || "main",
    state: "idle",
    startedAt: now,
    updatedAt: now,
    assets: {
      photos: [],
      voiceSample: "",
      personalityText: ""
    },
    trainingJobs: {},
    jobs: []
  };
}
function writeMetadata(projectDir, sessionId, metadata) {
  const next = { ...metadata, updatedAt: nowIso16() };
  safeWriteJson(metadataPath(projectDir, sessionId), next);
  return next;
}
function readMetadata(projectDir, sessionId) {
  ensureProfileLayout(projectDir, sessionId);
  const existing = safeReadJson(metadataPath(projectDir, sessionId));
  if (existing) return existing;
  const created = defaultMetadata(sessionId);
  writeMetadata(projectDir, sessionId, created);
  return created;
}
function writeState2(projectDir, sessionId, state) {
  ensureProfileLayout(projectDir, sessionId);
  const next = { ...state, updatedAt: nowIso16() };
  safeWriteJson(wizardFilePath(projectDir, sessionId), next);
  return next;
}
function moveCurrentToHistory(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  if (!fs27.existsSync(current)) return;
  const historyDir = path26.join(
    sessionRoot(projectDir, sessionId),
    "history",
    (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-")
  );
  fs27.mkdirSync(path26.dirname(historyDir), { recursive: true });
  fs27.cpSync(current, historyDir, { recursive: true });
  fs27.rmSync(current, { recursive: true, force: true });
}
function listSessionDirs(projectDir) {
  const root = path26.join(profilesRoot(projectDir), "sessions");
  if (!fs27.existsSync(root)) return [];
  return fs27.readdirSync(root, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => entry2.name);
}
function sessionHasWizardFile(projectDir, sessionDirName) {
  const file3 = path26.join(
    profilesRoot(projectDir),
    "sessions",
    sessionDirName,
    "current",
    "wizard-state.json"
  );
  return fs27.existsSync(file3);
}
function stateHasAssets(state) {
  return state.assets.photos.length > 0 || Boolean(state.assets.voiceSample) || Boolean(state.assets.personalityText);
}
function findSessionByJobId(projectDir, jobID) {
  for (const sid of listCompanionWizardSessions(projectDir)) {
    const state = readCompanionWizardState(projectDir, sid);
    if (state.jobs.some((job) => job.id === jobID)) return sid;
  }
  return null;
}
function resolveSessionForWrite(projectDir, requestedSessionId) {
  if (requestedSessionId?.trim()) {
    return normalizeSessionId(requestedSessionId);
  }
  const sessions = listCompanionWizardSessions(projectDir);
  if (sessions.length === 0) return "main";
  const active = sessions.filter((sid) => {
    const state = readCompanionWizardState(projectDir, sid);
    return state.state !== "idle" || stateHasAssets(state) || state.jobs.length > 0;
  });
  if (active.length === 1) return active[0];
  if (active.includes("main")) return "main";
  return active[0] ?? sessions[0] ?? "main";
}
function listCompanionWizardSessions(projectDir) {
  return listSessionDirs(projectDir).filter((name) => sessionHasWizardFile(projectDir, name)).map((name) => name || "main");
}
function readCompanionWizardState(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  const existing = safeReadJson(
    wizardFilePath(projectDir, effectiveSessionId)
  );
  if (existing) return existing;
  const created = defaultState5(effectiveSessionId);
  return writeState2(projectDir, effectiveSessionId, created);
}
function isCompanionWizardEmpty(projectDir, sessionId = "main") {
  const state = readCompanionWizardState(projectDir, sessionId);
  if (stateHasAssets(state)) return false;
  if (state.jobs.length > 0) return false;
  return state.state === "idle";
}
function startCompanionWizard(projectDir, input) {
  const sessionId = normalizeSessionId(input?.sessionId ?? "main");
  ensureProfileLayout(projectDir, sessionId);
  if (input?.forceReset) {
    moveCurrentToHistory(projectDir, sessionId);
    ensureProfileLayout(projectDir, sessionId);
  }
  const existing = readCompanionWizardState(projectDir, sessionId);
  if (!input?.forceReset && (stateHasAssets(existing) || existing.state !== "idle")) {
    return existing;
  }
  const state = writeState2(projectDir, sessionId, {
    ...defaultState5(sessionId),
    state: "awaiting_photos",
    startedAt: nowIso16()
  });
  writeMetadata(projectDir, sessionId, defaultMetadata(sessionId));
  return state;
}
function resetCompanionWizard(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  moveCurrentToHistory(projectDir, effectiveSessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  writeMetadata(projectDir, effectiveSessionId, defaultMetadata(effectiveSessionId));
  return writeState2(projectDir, effectiveSessionId, {
    ...defaultState5(effectiveSessionId),
    state: "idle"
  });
}
function copyMediaToProfile(projectDir, mediaIDs, targetDir) {
  const output = [];
  fs27.mkdirSync(targetDir, { recursive: true });
  for (const mediaID of mediaIDs) {
    const item = getMediaItem(projectDir, mediaID);
    if (!item?.localPath || !fs27.existsSync(item.localPath)) {
      throw new Error(`media_asset_not_found:${mediaID}`);
    }
    const ext = path26.extname(item.fileName) || extensionForMime(item.mimeType);
    const fileName = `${String(output.length + 1).padStart(2, "0")}_original${ext}`;
    const filePath12 = path26.join(targetDir, fileName);
    fs27.copyFileSync(item.localPath, filePath12);
    output.push(filePath12);
  }
  return output;
}
function enqueueJob(state, input) {
  const job = {
    id: `wjob_${randomUUID14()}`,
    type: input.type,
    status: "queued",
    progress: 0,
    estimatedTime: input.estimatedTime,
    fallbackStrategy: input.fallbackStrategy,
    createdAt: nowIso16(),
    updatedAt: nowIso16(),
    attempts: 0
  };
  return {
    ...state,
    jobs: [...state.jobs, job],
    trainingJobs: {
      ...state.trainingJobs,
      imageJobId: input.type === "training.image" ? job.id : state.trainingJobs.imageJobId,
      voiceJobId: input.type === "training.voice" ? job.id : state.trainingJobs.voiceJobId
    }
  };
}
function submitWizardPhotos(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_photos") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  if (input.mediaIDs.length < 1 || input.mediaIDs.length > 5) {
    throw new Error("wizard_photo_count_invalid:must_be_1_to_5");
  }
  const photosDir = path26.join(currentProfileDir(projectDir, sessionId), "photos");
  fs27.rmSync(photosDir, { recursive: true, force: true });
  const copied = copyMediaToProfile(projectDir, input.mediaIDs, photosDir);
  if (copied.length < 1 || copied.length > 5 || copied.length !== input.mediaIDs.length) {
    throw new Error("wizard_photo_copy_invalid:must_be_1_to_5");
  }
  const withJob = enqueueJob(
    {
      ...current,
      state: "training_image",
      assets: {
        ...current.assets,
        photos: copied
      }
    },
    {
      type: "training.image",
      estimatedTime: "\u7EA65-10\u5206\u949F",
      fallbackStrategy: "\u82E5\u663E\u5B58\u4E0D\u8DB3\u5C06\u81EA\u52A8\u964D\u7EA7\u5230embedding\u65B9\u6848"
    }
  );
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      photos: {
        count: copied.length,
        paths: copied.map((item) => path26.relative(currentProfileDir(projectDir, sessionId), item)),
        checksums: copied.map((item) => checksumFile(item))
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      image: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.imageJobId);
  if (!job) throw new Error("image_job_not_created");
  return { state: written, job };
}
function submitWizardVoice(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_voice") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const voiceDir = path26.join(currentProfileDir(projectDir, sessionId), "voice");
  fs27.mkdirSync(voiceDir, { recursive: true });
  const copied = copyMediaToProfile(projectDir, [input.mediaID], voiceDir);
  if (copied.length !== 1) throw new Error("voice_asset_not_found");
  const voicePath = path26.join(voiceDir, "original_sample.wav");
  fs27.copyFileSync(copied[0], voicePath);
  const withJob = enqueueJob(
    {
      ...current,
      state: "training_voice",
      assets: {
        ...current.assets,
        voiceSample: voicePath
      }
    },
    {
      type: "training.voice",
      estimatedTime: "\u7EA63-8\u5206\u949F",
      fallbackStrategy: "\u82E5\u663E\u5B58\u4E0D\u8DB3\u5C06\u81EA\u52A8\u964D\u7EA7\u5230embedding\u65B9\u6848"
    }
  );
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      voice: {
        hasSample: true,
        duration: 0,
        modelType: "gpt_sovits_v2"
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      voice: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.voiceJobId);
  if (!job) throw new Error("voice_job_not_created");
  return { state: written, job };
}
function submitWizardPersonality(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_personality") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const text = input.personalityText.trim();
  if (!text) throw new Error("invalid_personality_text");
  const personaPath = path26.join(currentProfileDir(projectDir, sessionId), "persona.json");
  const persona = {
    sourceText: text,
    generatedPrompt: `system: ${text}`,
    updatedAt: nowIso16()
  };
  safeWriteJson(personaPath, persona);
  const next = writeState2(projectDir, sessionId, {
    ...current,
    state: "completed",
    assets: {
      ...current.assets,
      personalityText: text
    }
  });
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      persona: {
        sourceText: text,
        generatedPrompt: persona.generatedPrompt
      }
    }
  });
  return next;
}
function pickQueuedTrainingJob(projectDir, sessionId) {
  const targetSessions = sessionId ? [normalizeSessionId(sessionId)] : listCompanionWizardSessions(projectDir);
  for (const sid of targetSessions) {
    const state = readCompanionWizardState(projectDir, sid);
    if (state.jobs.some((item) => item.status === "training")) continue;
    const queued = state.jobs.find((item) => item.status === "queued");
    if (queued) return { sessionId: sid, job: queued };
  }
  return null;
}
function markTrainingJobRunning(projectDir, jobID, sessionId = "main") {
  const sid = normalizeSessionId(sessionId);
  const resolvedSession = sessionId === "main" ? findSessionByJobId(projectDir, jobID) ?? sid : sid;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    jobs: current.jobs.map(
      (job2) => job2.id === jobID ? {
        ...job2,
        status: "training",
        progress: Math.max(5, job2.progress),
        attempts: job2.attempts + 1,
        updatedAt: nowIso16()
      } : job2
    )
  });
  const job = updated.jobs.find((item) => item.id === jobID);
  if (!job) return updated;
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, image: "training" }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, voice: "training" }
    });
  }
  return updated;
}
function requeueTrainingJob(projectDir, input) {
  const sid = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sid);
  return writeState2(projectDir, sid, {
    ...current,
    jobs: current.jobs.map(
      (job) => job.id === input.jobID ? {
        ...job,
        status: "queued",
        progress: Math.max(10, job.progress),
        checkpointPath: input.checkpointPath,
        message: input.message,
        updatedAt: nowIso16()
      } : job
    )
  });
}
function markTrainingJobFinished(projectDir, input) {
  const sid = normalizeSessionId(input.sessionId ?? "main");
  const resolvedSession = input.sessionId == null ? findSessionByJobId(projectDir, input.jobID) ?? sid : sid;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const job = current.jobs.find((item) => item.id === input.jobID);
  if (!job) return current;
  const nextState = job.type === "training.image" ? input.status === "failed" || input.status === "canceled" ? "training_image" : "awaiting_voice" : input.status === "failed" || input.status === "canceled" ? "training_voice" : "awaiting_personality";
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    state: nextState,
    jobs: current.jobs.map(
      (item) => item.id === input.jobID ? {
        ...item,
        status: input.status,
        message: input.message,
        progress: input.status === "failed" ? item.progress : 100,
        currentTier: input.tier,
        checkpointPath: input.checkpointPath ?? item.checkpointPath,
        updatedAt: nowIso16()
      } : item
    )
  });
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        image: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        voice: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  }
  return updated;
}
function cancelCompanionWizardTraining(projectDir, sessionId = "main") {
  const sid = resolveSessionForWrite(projectDir, sessionId);
  const current = readCompanionWizardState(projectDir, sid);
  let hasCanceled = false;
  const nextJobs = current.jobs.map((job) => {
    if (job.status !== "queued" && job.status !== "training") return job;
    hasCanceled = true;
    return {
      ...job,
      status: "canceled",
      message: "\u8BAD\u7EC3\u5DF2\u53D6\u6D88/\u53EF\u91CD\u8BD5",
      updatedAt: nowIso16()
    };
  });
  if (!hasCanceled) return current;
  const nextState = current.assets.voiceSample ? "awaiting_personality" : current.assets.photos.length > 0 ? "awaiting_voice" : "awaiting_photos";
  return writeState2(projectDir, sid, {
    ...current,
    state: nextState,
    jobs: nextJobs
  });
}
function getCompanionProfileCurrentDir(projectDir, sessionId = "main") {
  const sid = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, sid);
  return currentProfileDir(projectDir, sid);
}
function getWizardJobById(projectDir, jobID) {
  for (const sid of listCompanionWizardSessions(projectDir)) {
    const state = readCompanionWizardState(projectDir, sid);
    const match = state.jobs.find((job) => job.id === jobID);
    if (match) return { ...match, sessionId: sid };
  }
  return null;
}
function wizardChecklist(state) {
  return [
    state.assets.photos.length > 0 ? "visual:done" : "visual:pending",
    state.assets.voiceSample ? "voice:done" : "voice:pending",
    state.assets.personalityText ? "persona:done" : "persona:pending"
  ];
}
var init_wizard = __esm({
  "src/companion/wizard.ts"() {
    "use strict";
    init_store2();
    init_workflow();
  }
});

// src/multimodal/image.ts
import * as fs28 from "node:fs";
import * as path27 from "node:path";
function sanitizePrompt(prompt) {
  return prompt.trim().slice(0, 2e3);
}
function toBase64FromFile(filePath12) {
  try {
    if (!fs28.existsSync(filePath12)) return null;
    return fs28.readFileSync(filePath12).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:")) return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode(projectDir) {
  if (process.env.MIYA_MULTIMODAL_TEST_MODE === "1") return true;
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime;
  const multimodal = runtime?.multimodal;
  return multimodal?.test_mode === true;
}
async function generateImage(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const prompt = sanitizePrompt(input.prompt);
  if (!prompt) throw new Error("invalid_prompt");
  const model = input.model?.trim() || DEFAULT_IMAGE_MODEL;
  const size = input.size?.trim() || DEFAULT_IMAGE_SIZE;
  const referenceMediaIDs = (input.referenceMediaIDs ?? []).filter(Boolean);
  const references = referenceMediaIDs.map((id) => getMediaItem(projectDir, id)).filter((item) => Boolean(item)).map((item) => ({
    id: item.id,
    fileName: item.fileName,
    mimeType: item.mimeType,
    localPath: item.localPath
  }));
  const outputDir = getMiyaImageTempDir(projectDir);
  const outputPath = path27.join(outputDir, `flux-${Date.now()}.png`);
  const profileDir = path27.join(
    getMiyaRuntimeDir(projectDir),
    "profiles",
    "companion",
    "current"
  );
  let inference;
  if (useMultimodalTestMode(projectDir)) {
    inference = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      inference = await daemon.runFluxImageGenerate({
        prompt,
        outputPath,
        profileDir,
        references: references.map((item) => item.localPath).filter((item) => Boolean(item)),
        size
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number") pending = String(plan.pending);
        } catch {
        }
        throw new Error(
          `model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`
        );
      }
      if (!isRuntimeNotReadyError(error92)) throw error92;
      inference = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const payloadBase64 = toBase64FromFile(inference.outputPath) ?? BLANK_PNG_BASE64;
  const media = ingestMedia(projectDir, {
    source: "multimodal.image.generate",
    kind: "image",
    mimeType: "image/png",
    fileName: `generated-${Date.now()}.png`,
    contentBase64: payloadBase64,
    sizeBytes: Math.floor(payloadBase64.length * 3 / 4),
    metadata: {
      status: inference.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      prompt,
      model,
      size,
      tier: inference.tier,
      degraded: inference.degraded,
      engineMessage: inference.message,
      runtimeError: inference.message.startsWith("python_runtime_not_ready:") ? inference.message : void 0,
      references,
      createdBy: "miya_generate_image"
    }
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "image",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `generated:${model}`
    });
  }
  return {
    media,
    model,
    size,
    prompt
  };
}
var DEFAULT_IMAGE_MODEL, DEFAULT_IMAGE_SIZE, BLANK_PNG_BASE64;
var init_image = __esm({
  "src/multimodal/image.ts"() {
    "use strict";
    init_store4();
    init_daemon();
    init_store2();
    init_paths2();
    init_settings();
    init_workflow();
    DEFAULT_IMAGE_MODEL = "local:flux.1-schnell";
    DEFAULT_IMAGE_SIZE = "1024x1024";
    BLANK_PNG_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO6sYz0AAAAASUVORK5CYII=";
  }
});

// src/multimodal/vision-regression.ts
import * as path28 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
var FIXTURE_FILE;
var init_vision_regression = __esm({
  "src/multimodal/vision-regression.ts"() {
    "use strict";
    init_vision();
    FIXTURE_FILE = path28.join(
      path28.dirname(fileURLToPath2(import.meta.url)),
      "fixtures",
      "desktop-outbound-ocr-regression.json"
    );
  }
});

// src/multimodal/voice.ts
import * as fs29 from "node:fs";
import * as path29 from "node:path";
function normalizeFormat(format) {
  if (format === "mp3" || format === "ogg") return format;
  return "wav";
}
function buildSilentWavBase64(durationMs) {
  const sampleRate = 16e3;
  const channels = 1;
  const bitsPerSample = 16;
  const bytesPerSample = bitsPerSample / 8;
  const frameCount = Math.max(1, Math.floor(sampleRate * durationMs / 1e3));
  const dataSize = frameCount * channels * bytesPerSample;
  const buffer = Buffer.alloc(44 + dataSize);
  buffer.write("RIFF", 0);
  buffer.writeUInt32LE(36 + dataSize, 4);
  buffer.write("WAVE", 8);
  buffer.write("fmt ", 12);
  buffer.writeUInt32LE(16, 16);
  buffer.writeUInt16LE(1, 20);
  buffer.writeUInt16LE(channels, 22);
  buffer.writeUInt32LE(sampleRate, 24);
  buffer.writeUInt32LE(sampleRate * channels * bytesPerSample, 28);
  buffer.writeUInt16LE(channels * bytesPerSample, 32);
  buffer.writeUInt16LE(bitsPerSample, 34);
  buffer.write("data", 36);
  buffer.writeUInt32LE(dataSize, 40);
  return buffer.toString("base64");
}
function toBase64FromFile2(filePath12) {
  try {
    if (!fs29.existsSync(filePath12)) return null;
    return fs29.readFileSync(filePath12).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:")) return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode2(projectDir) {
  if (process.env.MIYA_MULTIMODAL_TEST_MODE === "1") return true;
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime;
  const multimodal = runtime?.multimodal;
  return multimodal?.test_mode === true;
}
async function synthesizeVoiceOutput(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const text = input.text.trim();
  if (!text) throw new Error("invalid_tts_text");
  const voice = input.voice?.trim() || DEFAULT_VOICE;
  const model = input.model?.trim() || DEFAULT_TTS_MODEL;
  const format = normalizeFormat(input.format);
  const mimeType = format === "mp3" ? "audio/mpeg" : format === "ogg" ? "audio/ogg" : "audio/wav";
  const estDurationMs = Math.max(600, Math.min(7e3, text.length * 55));
  const outputDir = getMiyaVoiceTempDir(projectDir);
  const outputPath = path29.join(outputDir, `tts-${Date.now()}.${format}`);
  const profileDir = path29.join(
    getMiyaRuntimeDir(projectDir),
    "profiles",
    "companion",
    "current"
  );
  let tts;
  if (useMultimodalTestMode2(projectDir)) {
    tts = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      tts = await daemon.runSovitsTts({
        text,
        outputPath,
        profileDir,
        voice,
        format
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget2(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number") pending = String(plan.pending);
        } catch {
        }
        throw new Error(
          `model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`
        );
      }
      if (!isRuntimeNotReadyError2(error92)) throw error92;
      tts = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const wavBase64 = toBase64FromFile2(tts.outputPath) ?? buildSilentWavBase64(estDurationMs);
  const media = ingestMedia(projectDir, {
    source: "multimodal.voice.output",
    kind: "audio",
    mimeType,
    fileName: `tts-${Date.now()}.${format}`,
    contentBase64: wavBase64,
    sizeBytes: Math.floor(wavBase64.length * 3 / 4),
    metadata: {
      status: tts.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      text,
      voice,
      model,
      format,
      tier: tts.tier,
      degraded: tts.degraded,
      engineMessage: tts.message,
      payloadCodec: "pcm_s16le",
      estimatedDurationMs: estDurationMs,
      runtimeError: tts.message.startsWith("python_runtime_not_ready:") ? tts.message : void 0,
      createdBy: "miya_voice_output"
    }
  });
  appendVoiceHistory(projectDir, {
    text,
    source: "talk",
    mediaID: media.id
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "audio",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `voice:${voice}`
    });
  }
  return {
    media,
    voice,
    model,
    format
  };
}
var DEFAULT_VOICE, DEFAULT_TTS_MODEL;
var init_voice = __esm({
  "src/multimodal/voice.ts"() {
    "use strict";
    init_store4();
    init_daemon();
    init_store2();
    init_paths2();
    init_settings();
    init_state2();
    init_workflow();
    DEFAULT_VOICE = "default";
    DEFAULT_TTS_MODEL = "local:gpt-sovits-v2pro";
  }
});

// src/multimodal/intent.ts
function extractFriend(text) {
  const bracket = text.match(/\s*\[([^\]]+)\]/);
  if (bracket?.[1]) return bracket[1].trim();
  const plain = text.match(/\s*([^\s!?]+)/);
  if (plain?.[1]) return plain[1].trim();
  return "";
}
function detectMultimodalIntent(text) {
  const normalized = text.trim();
  if (!normalized) return { type: "unknown" };
  if (/(|||)/.test(normalized)) {
    return {
      type: "selfie",
      prompt: "a natural selfie portrait, indoor soft light, realistic phone camera shot"
    };
  }
  if (/(||)/.test(normalized)) {
    const friend = extractFriend(normalized);
    return {
      type: "voice_to_friend",
      text: normalized,
      friend
    };
  }
  return { type: "unknown" };
}
var init_intent = __esm({
  "src/multimodal/intent.ts"() {
    "use strict";
  }
});

// src/multimodal/index.ts
var init_multimodal = __esm({
  "src/multimodal/index.ts"() {
    "use strict";
    init_image();
    init_vision();
    init_vision_regression();
    init_voice();
    init_intent();
  }
});

// src/resource-scheduler/store.ts
import * as fs30 from "node:fs";
import * as path30 from "node:path";
function schedulerDir(projectDir) {
  return path30.join(getMiyaRuntimeDir(projectDir), "resource-scheduler");
}
function snapshotPath(projectDir) {
  return path30.join(schedulerDir(projectDir), "state.json");
}
function eventsPath(projectDir) {
  return path30.join(schedulerDir(projectDir), "events.jsonl");
}
function ensureDir13(projectDir) {
  fs30.mkdirSync(schedulerDir(projectDir), { recursive: true });
}
function writeSchedulerSnapshot(projectDir, snapshot) {
  ensureDir13(projectDir);
  fs30.writeFileSync(
    snapshotPath(projectDir),
    `${JSON.stringify(snapshot, null, 2)}
`,
    "utf-8"
  );
}
function appendSchedulerEvent(projectDir, event) {
  ensureDir13(projectDir);
  fs30.appendFileSync(eventsPath(projectDir), `${JSON.stringify(event)}
`, "utf-8");
}
var init_store5 = __esm({
  "src/resource-scheduler/store.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/resource-scheduler/vram.ts
function clampNonNegative(value) {
  if (!Number.isFinite(value) || value <= 0) return 0;
  return Math.floor(value);
}
function calculateVramBudget(input) {
  const loadedVramMB = input.snapshot.loadedModels.reduce(
    (sum, model) => sum + clampNonNegative(model.vramMB),
    0
  );
  const availableMB = Math.max(
    0,
    clampNonNegative(input.snapshot.totalVramMB) - clampNonNegative(input.snapshot.safetyMarginMB) - clampNonNegative(input.snapshot.usedVramMB) - loadedVramMB
  );
  const loaded = new Map(
    input.snapshot.loadedModels.map((model) => [model.modelID, clampNonNegative(model.vramMB)])
  );
  const keepLoaded = /* @__PURE__ */ new Set();
  let modelsNeedLoadMB = 0;
  for (const model of input.models) {
    if (!model.required) continue;
    const need = clampNonNegative(model.vramMB);
    const loadedMB = loaded.get(model.modelID) ?? 0;
    if (loadedMB >= need) {
      keepLoaded.add(model.modelID);
      continue;
    }
    modelsNeedLoadMB += need;
  }
  const requiredMB = clampNonNegative(input.task.taskVramMB) + modelsNeedLoadMB;
  const overflowMB = Math.max(0, requiredMB - availableMB);
  const fit = overflowMB <= 0;
  const suggestedTaskVramMB = fit ? clampNonNegative(input.task.taskVramMB) : Math.max(256, clampNonNegative(input.task.taskVramMB) - overflowMB);
  const unloadFirst = input.snapshot.loadedModels.filter((model) => model.pins <= 0 && !keepLoaded.has(model.modelID)).sort((a, b) => Date.parse(a.lastUsedAt) - Date.parse(b.lastUsedAt)).map((model) => model.modelID);
  return {
    fit,
    availableMB,
    requiredMB,
    overflowMB,
    suggestedTaskVramMB,
    canUseReferenceOnly: suggestedTaskVramMB < 512,
    modelPlan: {
      keepLoaded: [...keepLoaded],
      unloadFirst
    }
  };
}
function decideModelSwapAction(input) {
  const current = (input.currentModelID ?? "").trim();
  const target = (input.targetModelID ?? "").trim();
  if (!target) return "reuse";
  if (current && current === target) return "reuse";
  if (input.budget.fit) return current ? "hot_load" : "reuse";
  if (input.budget.modelPlan.unloadFirst.length > 0) return "evict_then_load";
  return "degraded_reference";
}
var init_vram = __esm({
  "src/resource-scheduler/vram.ts"() {
    "use strict";
  }
});

// src/resource-scheduler/scheduler.ts
import { randomUUID as randomUUID15 } from "node:crypto";
function nowIso17() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function toNumber(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) return fallback;
  return Math.floor(parsed);
}
function toStringList(value) {
  if (!value) return [];
  return value.split(",").map((item) => item.trim()).filter(Boolean);
}
var ResourceScheduler;
var init_scheduler = __esm({
  "src/resource-scheduler/scheduler.ts"() {
    "use strict";
    init_store5();
    init_vram();
    ResourceScheduler = class {
      projectDir;
      totalVramMB;
      safetyMarginMB;
      maxConcurrentTasks;
      hotsetModelIDs = /* @__PURE__ */ new Set();
      warmPool = /* @__PURE__ */ new Map();
      warmPoolLimit;
      isolateTrainingLane;
      queue = [];
      active = /* @__PURE__ */ new Map();
      loadedModels = /* @__PURE__ */ new Map();
      currentModelByKind = /* @__PURE__ */ new Map();
      usedVramMB = 0;
      draining = false;
      constructor(projectDir, options = {}) {
        this.projectDir = projectDir;
        this.totalVramMB = Math.min(
          8192,
          options.totalVramMB ?? toNumber(process.env.MIYA_RESOURCE_TOTAL_VRAM_MB, 8192)
        );
        this.safetyMarginMB = options.safetyMarginMB ?? toNumber(process.env.MIYA_RESOURCE_SAFETY_MARGIN_MB, 768);
        this.maxConcurrentTasks = options.maxConcurrentTasks ?? toNumber(process.env.MIYA_RESOURCE_MAX_CONCURRENT, 2);
        this.warmPoolLimit = options.warmPoolLimit ?? toNumber(process.env.MIYA_RESOURCE_WARM_POOL_LIMIT, 8);
        this.isolateTrainingLane = options.isolateTrainingLane ?? process.env.MIYA_RESOURCE_ISOLATE_TRAINING_LANE !== "0";
        const hotset = /* @__PURE__ */ new Set([
          ...Array.isArray(options.hotsetModelIDs) ? options.hotsetModelIDs : [],
          ...toStringList(process.env.MIYA_RESOURCE_HOTSET_MODELS)
        ]);
        for (const modelID of hotset) {
          if (modelID) this.hotsetModelIDs.add(modelID);
        }
        this.recordSnapshot();
      }
      async acquire(request) {
        const pendingID = `lease_${randomUUID15()}`;
        return new Promise((resolve4, reject) => {
          const timeoutMs = typeof request.timeoutMs === "number" && request.timeoutMs > 0 ? request.timeoutMs : void 0;
          const timeoutAtMs = timeoutMs ? Date.now() + timeoutMs : void 0;
          const pending = {
            id: pendingID,
            request,
            createdAtMs: Date.now(),
            timeoutAtMs,
            resolve: resolve4,
            reject
          };
          this.queue.push(pending);
          this.queue.sort((a, b) => {
            const priorityA = a.request.priority ?? 0;
            const priorityB = b.request.priority ?? 0;
            if (priorityA !== priorityB) return priorityB - priorityA;
            return a.createdAtMs - b.createdAtMs;
          });
          appendSchedulerEvent(this.projectDir, {
            at: nowIso17(),
            type: "queued",
            leaseID: pendingID,
            kind: request.kind,
            priority: request.priority ?? 0,
            requestedVramMB: request.vramMB ?? 0,
            modelID: request.modelID
          });
          this.recordSnapshot();
          this.scheduleDrain();
        });
      }
      async withLease(request, run) {
        const lease = await this.acquire(request);
        try {
          return await run();
        } finally {
          lease.release();
        }
      }
      snapshot() {
        return {
          timestamp: nowIso17(),
          totalVramMB: this.totalVramMB,
          safetyMarginMB: this.safetyMarginMB,
          usedVramMB: this.usedVramMB,
          activeTasks: this.active.size,
          queueDepth: this.queue.length,
          loadedModels: [...this.loadedModels.values()].sort((a, b) => b.lastUsedAtMs - a.lastUsedAtMs).map((model) => ({
            modelID: model.modelID,
            vramMB: model.vramMB,
            pins: model.pins,
            lastUsedAt: new Date(model.lastUsedAtMs).toISOString()
          })),
          hotsetModelIDs: [...this.hotsetModelIDs.values()],
          warmPoolModels: [...this.warmPool.values()].sort((a, b) => b.cachedAtMs - a.cachedAtMs).map((model) => ({
            modelID: model.modelID,
            cachedAt: new Date(model.cachedAtMs).toISOString()
          }))
        };
      }
      planVramBudget(request) {
        return calculateVramBudget({
          snapshot: this.snapshot(),
          task: {
            taskID: request.kind,
            taskVramMB: Math.max(0, Math.floor(request.vramMB ?? 0)),
            priority: request.priority
          },
          models: request.modelID ? [
            {
              modelID: request.modelID,
              vramMB: Math.max(
                0,
                Math.floor(request.modelVramMB ?? request.vramMB ?? 0)
              ),
              required: true
            }
          ] : []
        });
      }
      scheduleDrain() {
        if (this.draining) return;
        this.draining = true;
        queueMicrotask(() => {
          this.draining = false;
          this.drainQueue();
        });
      }
      drainQueue() {
        let progressed = true;
        while (progressed) {
          progressed = false;
          this.removeExpiredPending();
          if (this.active.size >= this.maxConcurrentTasks) return;
          const pending = this.queue[0];
          if (!pending) return;
          if (!this.canGrant(pending.request)) return;
          this.queue.shift();
          const grantedAt = nowIso17();
          const requestVramMB = Math.max(0, Math.floor(pending.request.vramMB ?? 0));
          const lease = {
            id: pending.id,
            kind: pending.request.kind,
            grantedAt,
            requestVramMB,
            modelID: pending.request.modelID
          };
          this.active.set(lease.id, lease);
          if (requestVramMB > 0) this.usedVramMB += requestVramMB;
          if (pending.request.modelID) {
            const modelVramMB = Math.max(
              0,
              Math.floor(pending.request.modelVramMB ?? requestVramMB)
            );
            const swapAction = this.selectModelSwapAction(
              pending.request.kind,
              pending.request.modelID,
              pending.request
            );
            if (swapAction === "evict_then_load") {
              this.evictModelsIfNeeded(modelVramMB);
            }
            this.ensureModelLoaded(pending.request.modelID, modelVramMB);
            this.pinModel(pending.request.modelID);
            this.currentModelByKind.set(pending.request.kind, pending.request.modelID);
            appendSchedulerEvent(this.projectDir, {
              at: nowIso17(),
              type: "model_swap",
              kind: pending.request.kind,
              action: swapAction,
              modelID: pending.request.modelID,
              vramMB: modelVramMB
            });
          }
          appendSchedulerEvent(this.projectDir, {
            at: grantedAt,
            type: "granted",
            leaseID: lease.id,
            kind: lease.kind,
            requestedVramMB: requestVramMB,
            modelID: lease.modelID
          });
          this.recordSnapshot();
          pending.resolve({
            id: lease.id,
            kind: lease.kind,
            grantedAt,
            vramMB: requestVramMB,
            release: () => this.release(lease.id)
          });
          progressed = true;
        }
      }
      release(leaseID) {
        const lease = this.active.get(leaseID);
        if (!lease) return;
        this.active.delete(leaseID);
        if (lease.requestVramMB > 0) {
          this.usedVramMB = Math.max(0, this.usedVramMB - lease.requestVramMB);
        }
        if (lease.modelID) {
          this.unpinModel(lease.modelID);
          this.touchModel(lease.modelID);
        }
        appendSchedulerEvent(this.projectDir, {
          at: nowIso17(),
          type: "released",
          leaseID,
          kind: lease.kind,
          releasedVramMB: lease.requestVramMB,
          modelID: lease.modelID
        });
        this.recordSnapshot();
        this.scheduleDrain();
      }
      canGrant(request) {
        if (this.active.size >= this.maxConcurrentTasks) return false;
        if (this.isolateTrainingLane) {
          if (this.isTrainingKind(request.kind) && this.hasActiveInferenceTask()) return false;
          if (!this.isTrainingKind(request.kind) && this.hasActiveTrainingTask()) return false;
        }
        const neededVramMB = Math.max(0, Math.floor(request.vramMB ?? 0));
        if (neededVramMB === 0) return true;
        const modelVramMB = request.modelID ? Math.max(
          0,
          Math.floor(request.modelVramMB ?? request.vramMB ?? 0)
        ) : 0;
        this.evictModelsIfNeeded(neededVramMB + modelVramMB);
        return this.availableVramMB() >= neededVramMB + modelVramMB;
      }
      selectModelSwapAction(kind, targetModelID, request) {
        const budget = this.planVramBudget(request);
        return decideModelSwapAction({
          currentModelID: this.currentModelByKind.get(kind),
          targetModelID,
          budget
        });
      }
      availableVramMB() {
        return Math.max(
          0,
          this.totalVramMB - this.safetyMarginMB - this.usedVramMB - this.loadedModelsVramMB()
        );
      }
      loadedModelsVramMB() {
        let sum = 0;
        for (const model of this.loadedModels.values()) sum += model.vramMB;
        return sum;
      }
      removeExpiredPending() {
        const now = Date.now();
        const keep = [];
        for (const pending of this.queue) {
          if (pending.timeoutAtMs && pending.timeoutAtMs <= now) {
            appendSchedulerEvent(this.projectDir, {
              at: nowIso17(),
              type: "timeout",
              leaseID: pending.id,
              kind: pending.request.kind
            });
            pending.reject(new Error("resource_acquire_timeout"));
          } else {
            keep.push(pending);
          }
        }
        if (keep.length !== this.queue.length) {
          this.queue.length = 0;
          this.queue.push(...keep);
          this.recordSnapshot();
        }
      }
      ensureModelLoaded(modelID, vramMB) {
        if (!modelID || vramMB <= 0) return;
        const existing = this.loadedModels.get(modelID);
        if (existing) {
          existing.lastUsedAtMs = Date.now();
          return;
        }
        const warmEntry = this.warmPool.get(modelID);
        if (warmEntry) {
          this.warmPool.delete(modelID);
          appendSchedulerEvent(this.projectDir, {
            at: nowIso17(),
            type: "model_restored_from_warm_pool",
            modelID
          });
        }
        this.evictModelsIfNeeded(vramMB);
        this.loadedModels.set(modelID, {
          modelID,
          vramMB,
          pins: 0,
          lastUsedAtMs: Date.now()
        });
        appendSchedulerEvent(this.projectDir, {
          at: nowIso17(),
          type: "model_loaded",
          modelID,
          vramMB
        });
      }
      evictModelsIfNeeded(requiredVramMB) {
        if (requiredVramMB <= 0) return;
        if (this.availableVramMB() >= requiredVramMB) return;
        const candidates = [...this.loadedModels.values()].filter((item) => item.pins <= 0).sort((a, b) => {
          const hotA = this.hotsetModelIDs.has(a.modelID) ? 1 : 0;
          const hotB = this.hotsetModelIDs.has(b.modelID) ? 1 : 0;
          if (hotA !== hotB) return hotA - hotB;
          return a.lastUsedAtMs - b.lastUsedAtMs;
        });
        for (const candidate of candidates) {
          this.loadedModels.delete(candidate.modelID);
          this.addToWarmPool(candidate.modelID);
          appendSchedulerEvent(this.projectDir, {
            at: nowIso17(),
            type: "model_unloaded",
            modelID: candidate.modelID,
            vramMB: candidate.vramMB,
            reason: "lru_evict"
          });
          if (this.availableVramMB() >= requiredVramMB) break;
        }
      }
      pinModel(modelID) {
        const model = this.loadedModels.get(modelID);
        if (!model) return;
        model.pins += 1;
        model.lastUsedAtMs = Date.now();
      }
      unpinModel(modelID) {
        const model = this.loadedModels.get(modelID);
        if (!model) return;
        model.pins = Math.max(0, model.pins - 1);
        model.lastUsedAtMs = Date.now();
      }
      touchModel(modelID) {
        const model = this.loadedModels.get(modelID);
        if (!model) return;
        model.lastUsedAtMs = Date.now();
      }
      isTrainingKind(kind) {
        return kind === "training.image" || kind === "training.voice";
      }
      hasActiveTrainingTask() {
        for (const lease of this.active.values()) {
          if (this.isTrainingKind(lease.kind)) return true;
        }
        return false;
      }
      hasActiveInferenceTask() {
        for (const lease of this.active.values()) {
          if (!this.isTrainingKind(lease.kind)) return true;
        }
        return false;
      }
      addToWarmPool(modelID) {
        if (!modelID || this.hotsetModelIDs.has(modelID) || this.warmPoolLimit <= 0) return;
        this.warmPool.set(modelID, {
          modelID,
          cachedAtMs: Date.now()
        });
        this.pruneWarmPool();
      }
      pruneWarmPool() {
        if (this.warmPool.size <= this.warmPoolLimit) return;
        const entries = [...this.warmPool.values()].sort((a, b) => a.cachedAtMs - b.cachedAtMs);
        while (this.warmPool.size > this.warmPoolLimit) {
          const candidate = entries.shift();
          if (!candidate) break;
          this.warmPool.delete(candidate.modelID);
        }
      }
      recordSnapshot() {
        writeSchedulerSnapshot(this.projectDir, this.snapshot());
      }
    };
  }
});

// src/resource-scheduler/index.ts
function getResourceScheduler(projectDir, options) {
  const existing = schedulers.get(projectDir);
  if (existing) return existing;
  const created = new ResourceScheduler(projectDir, options);
  schedulers.set(projectDir, created);
  return created;
}
var schedulers;
var init_resource_scheduler = __esm({
  "src/resource-scheduler/index.ts"() {
    "use strict";
    init_scheduler();
    init_vram();
    schedulers = /* @__PURE__ */ new Map();
  }
});

// src/sessions/index.ts
import * as fs31 from "node:fs";
import * as path31 from "node:path";
function nowIso18() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath9(projectDir) {
  return path31.join(getMiyaRuntimeDir(projectDir), "sessions.json");
}
function ensureDir14(file3) {
  fs31.mkdirSync(path31.dirname(file3), { recursive: true });
}
function readStore5(projectDir) {
  const file3 = filePath9(projectDir);
  if (!fs31.existsSync(file3)) {
    return { sessions: {} };
  }
  try {
    const parsed = JSON.parse(fs31.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const normalized = { sessions: {} };
    for (const [id, session] of Object.entries(parsed.sessions ?? {})) {
      normalized.sessions[id] = {
        ...session,
        groupId: decryptSensitiveValue(
          projectDir,
          String(session.groupId ?? "")
        ),
        title: typeof session.title === "string" ? decryptSensitiveValue(projectDir, session.title) : session.title,
        routing: {
          ...session.routing ?? {
            opencodeSessionID: "main",
            agent: "1-task-manager"
          },
          opencodeSessionID: decryptSensitiveValue(
            projectDir,
            String(session.routing?.opencodeSessionID ?? "main")
          )
        },
        queue: Array.isArray(session.queue) ? session.queue.map((item) => ({
          ...item,
          text: decryptSensitiveValue(projectDir, String(item.text ?? "")),
          source: decryptSensitiveValue(
            projectDir,
            String(item.source ?? "")
          )
        })) : []
      };
    }
    return normalized;
  } catch {
    return { sessions: {} };
  }
}
function writeStore5(projectDir, store) {
  const file3 = filePath9(projectDir);
  ensureDir14(file3);
  const encrypted = { sessions: {} };
  for (const [id, session] of Object.entries(store.sessions)) {
    encrypted.sessions[id] = {
      ...session,
      groupId: encryptSensitiveValue(projectDir, session.groupId),
      title: session.title ? encryptSensitiveValue(projectDir, session.title) : session.title,
      routing: {
        ...session.routing,
        opencodeSessionID: encryptSensitiveValue(
          projectDir,
          session.routing.opencodeSessionID
        )
      },
      queue: session.queue.map((item) => ({
        ...item,
        text: encryptSensitiveValue(projectDir, item.text),
        source: encryptSensitiveValue(projectDir, item.source)
      }))
    };
  }
  fs31.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function sanitizeSession(value) {
  return {
    ...value,
    policy: {
      activation: value.policy?.activation ?? DEFAULT_POLICY.activation,
      reply: value.policy?.reply ?? DEFAULT_POLICY.reply,
      queueStrategy: value.policy?.queueStrategy ?? DEFAULT_POLICY.queueStrategy
    },
    routing: {
      opencodeSessionID: value.routing?.opencodeSessionID ?? "main",
      agent: value.routing?.agent ?? "1-task-manager"
    },
    recovery: value.recovery ? {
      recoverable: value.recovery.recoverable !== false,
      reasonCode: typeof value.recovery.reasonCode === "string" ? value.recovery.reasonCode : void 0,
      from: value.recovery.from === "autoflow" || value.recovery.from === "daemon" || value.recovery.from === "session" ? value.recovery.from : "session",
      updatedAt: value.recovery.updatedAt || nowIso18()
    } : void 0,
    queue: Array.isArray(value.queue) ? value.queue : []
  };
}
function listSessions(projectDir) {
  const store = readStore5(projectDir);
  return Object.values(store.sessions).map(sanitizeSession).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function getSession(projectDir, sessionID) {
  const store = readStore5(projectDir);
  const session = store.sessions[sessionID];
  return session ? sanitizeSession(session) : null;
}
function upsertSession(projectDir, input) {
  const store = readStore5(projectDir);
  const existing = store.sessions[input.id];
  const createdAt = existing?.createdAt ?? nowIso18();
  const session = sanitizeSession({
    id: input.id,
    kind: input.kind ?? existing?.kind ?? "channel",
    groupId: input.groupId ?? existing?.groupId ?? input.id,
    title: input.title ?? existing?.title,
    policy: existing?.policy ?? DEFAULT_POLICY,
    routing: {
      opencodeSessionID: input.routingSessionID ?? existing?.routing?.opencodeSessionID ?? "main",
      agent: input.agent ?? existing?.routing?.agent ?? "1-task-manager"
    },
    queue: existing?.queue ?? [],
    createdAt,
    updatedAt: nowIso18()
  });
  store.sessions[input.id] = session;
  writeStore5(projectDir, store);
  return session;
}
function setSessionPolicy(projectDir, sessionID, patch) {
  const store = readStore5(projectDir);
  const existing = store.sessions[sessionID];
  if (!existing) return null;
  const next = sanitizeSession({
    ...existing,
    policy: {
      ...existing.policy,
      ...patch
    },
    updatedAt: nowIso18()
  });
  store.sessions[sessionID] = next;
  writeStore5(projectDir, store);
  return next;
}
function enqueueSessionMessage(projectDir, sessionID, input) {
  const store = readStore5(projectDir);
  const existing = sanitizeSession(
    store.sessions[sessionID] ?? upsertSession(projectDir, {
      id: sessionID
    })
  );
  const message = {
    id: `queue_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    text: input.text,
    source: input.source,
    createdAt: nowIso18()
  };
  const nextQueue = [...existing.queue, message];
  const next = {
    ...existing,
    queue: nextQueue,
    updatedAt: nowIso18()
  };
  store.sessions[sessionID] = next;
  writeStore5(projectDir, store);
  return message;
}
function dequeueSessionMessage(projectDir, sessionID) {
  const store = readStore5(projectDir);
  const existing = store.sessions[sessionID];
  if (!existing || existing.queue.length === 0) {
    return null;
  }
  const [first, ...rest] = existing.queue;
  store.sessions[sessionID] = {
    ...existing,
    queue: rest,
    updatedAt: nowIso18()
  };
  writeStore5(projectDir, store);
  return first;
}
var DEFAULT_POLICY;
var init_sessions = __esm({
  "src/sessions/index.ts"() {
    "use strict";
    init_system_keyring();
    init_workflow();
    DEFAULT_POLICY = {
      activation: "active",
      reply: "auto",
      queueStrategy: "fifo"
    };
  }
});

// src/router/classifier.ts
function classifyIntent(text) {
  const lower = text.toLowerCase();
  if (/(||bug||test fail|failing|compile)/i.test(lower)) {
    return "code_fix";
  }
  if (/(||where|find|grep|search)/i.test(lower)) {
    return "code_search";
  }
  if (/(|api|docs|reference|)/i.test(lower)) {
    return "docs_research";
  }
  if (/(||tradeoff|risk|)/i.test(lower)) {
    return "architecture";
  }
  if (/(ui|||||)/i.test(lower)) {
    return "ui_design";
  }
  return "general";
}
function recommendedAgent(intent) {
  if (intent === "code_fix") return "5-code-fixer";
  if (intent === "code_search") return "2-code-search";
  if (intent === "docs_research") return "3-docs-helper";
  if (intent === "architecture") return "4-architecture-advisor";
  if (intent === "ui_design") return "6-ui-designer";
  return "1-task-manager";
}
var init_classifier = __esm({
  "src/router/classifier.ts"() {
    "use strict";
  }
});

// src/router/fallback.ts
function resolveFallbackAgent(intent, availableAgents) {
  const primary = recommendedAgent(intent);
  if (availableAgents.includes(primary)) return primary;
  if (availableAgents.includes("1-task-manager")) return "1-task-manager";
  return availableAgents[0] ?? primary;
}
function resolveAgentWithFeedback(intent, availableAgents, ranked) {
  const base = resolveFallbackAgent(intent, availableAgents);
  if (ranked.length === 0) return base;
  const preferred = ranked.find(
    (item) => availableAgents.includes(item.agent) && item.score >= 0.55
  );
  return preferred?.agent ?? base;
}
var init_fallback = __esm({
  "src/router/fallback.ts"() {
    "use strict";
    init_classifier();
  }
});

// src/router/learner.ts
import * as fs32 from "node:fs";
import * as path32 from "node:path";
function filePath10(projectDir) {
  return path32.join(getMiyaRuntimeDir(projectDir), "router-history.json");
}
function readStore6(projectDir) {
  const file3 = filePath10(projectDir);
  if (!fs32.existsSync(file3)) return { records: [] };
  try {
    const parsed = JSON.parse(fs32.readFileSync(file3, "utf-8"));
    return { records: Array.isArray(parsed.records) ? parsed.records : [] };
  } catch {
    return { records: [] };
  }
}
function rankAgentsByFeedback(projectDir, intent, availableAgents) {
  const records = readStore6(projectDir).records.filter((item) => item.intent === intent).slice(0, 300);
  const scored = availableAgents.map((agent) => {
    const matched = records.filter((item) => item.suggestedAgent === agent);
    const accepted = matched.filter((item) => item.accepted).length;
    const samples = matched.length;
    const acceptRate = samples > 0 ? accepted / samples : 0;
    const score = Number((acceptRate * 0.8 + Math.min(0.2, samples / 50)).toFixed(4));
    return {
      agent,
      score,
      samples,
      acceptRate: Number(acceptRate.toFixed(4))
    };
  });
  return scored.sort((a, b) => b.score - a.score);
}
var init_learner = __esm({
  "src/router/learner.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/router/runtime.ts
import * as fs33 from "node:fs";
import * as path33 from "node:path";
function getComplexityProfile(complexity) {
  if (complexity === "low") {
    return { maxAgents: 1, contextStrategy: "minimal", enableEarlyExit: true };
  }
  if (complexity === "medium") {
    return { maxAgents: 3, contextStrategy: "summary", enableEarlyExit: true };
  }
  return { maxAgents: 7, contextStrategy: "full", enableEarlyExit: false };
}
function primaryAgentForIntent(intent) {
  if (intent === "code_fix") return "5-code-fixer";
  if (intent === "code_search") return "2-code-search";
  if (intent === "docs_research") return "3-docs-helper";
  if (intent === "architecture") return "4-architecture-advisor";
  if (intent === "ui_design") return "6-ui-designer";
  return "1-task-manager";
}
function buildAgentPlan(input) {
  const profile = getComplexityProfile(input.complexity);
  const include = (target, list) => {
    if (!target || !input.availableAgents.includes(target) || list.includes(target)) return list;
    return [...list, target];
  };
  if (input.pinnedAgent) {
    return {
      plannedAgents: [input.selectedAgent],
      maxAgents: 1,
      contextStrategy: "minimal",
      requiresMultipleSteps: false,
      enableEarlyExit: true
    };
  }
  if (input.complexity === "low") {
    return {
      plannedAgents: [input.selectedAgent],
      maxAgents: profile.maxAgents,
      contextStrategy: profile.contextStrategy,
      requiresMultipleSteps: false,
      enableEarlyExit: profile.enableEarlyExit
    };
  }
  if (input.complexity === "medium") {
    let plan = [];
    plan = include("1-task-manager", plan);
    plan = include(input.selectedAgent, plan);
    plan = include(primaryAgentForIntent(input.intent), plan);
    plan = include("5-code-fixer", plan);
    return {
      plannedAgents: plan.slice(0, profile.maxAgents),
      maxAgents: profile.maxAgents,
      contextStrategy: profile.contextStrategy,
      requiresMultipleSteps: true,
      enableEarlyExit: profile.enableEarlyExit
    };
  }
  const highPlan = [
    "1-task-manager",
    input.selectedAgent,
    primaryAgentForIntent(input.intent),
    ...ORCHESTRATION_ORDER
  ].filter((agent, index, arr) => arr.indexOf(agent) === index).filter((agent) => input.availableAgents.includes(agent)).slice(0, profile.maxAgents);
  return {
    plannedAgents: highPlan,
    maxAgents: profile.maxAgents,
    contextStrategy: profile.contextStrategy,
    requiresMultipleSteps: true,
    enableEarlyExit: profile.enableEarlyExit
  };
}
function modeFile(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "router-mode.json");
}
function costFile(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "router-cost.jsonl");
}
function sessionStateFile(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "router-session-state.json");
}
function ensureDir15(projectDir) {
  fs33.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp3(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function nowIso19() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function parseMode(raw) {
  const input = raw && typeof raw === "object" ? raw : {};
  const forcedStage = input.forcedStage === "low" || input.forcedStage === "medium" || input.forcedStage === "high" ? input.forcedStage : void 0;
  const stageTokenMultiplierInput = input.stageTokenMultiplier && typeof input.stageTokenMultiplier === "object" ? input.stageTokenMultiplier : {};
  const stageCostInput = input.stageCostUsdPer1k && typeof input.stageCostUsdPer1k === "object" ? input.stageCostUsdPer1k : {};
  return {
    ecoMode: input.ecoMode !== false,
    forcedStage,
    stageTokenMultiplier: {
      low: clamp3(Number(stageTokenMultiplierInput.low ?? DEFAULT_MODE.stageTokenMultiplier.low), 0.2, 2.5),
      medium: clamp3(
        Number(stageTokenMultiplierInput.medium ?? DEFAULT_MODE.stageTokenMultiplier.medium),
        0.3,
        3
      ),
      high: clamp3(Number(stageTokenMultiplierInput.high ?? DEFAULT_MODE.stageTokenMultiplier.high), 0.4, 4)
    },
    stageCostUsdPer1k: {
      low: clamp3(Number(stageCostInput.low ?? DEFAULT_MODE.stageCostUsdPer1k.low), 1e-4, 0.1),
      medium: clamp3(Number(stageCostInput.medium ?? DEFAULT_MODE.stageCostUsdPer1k.medium), 1e-4, 0.2),
      high: clamp3(Number(stageCostInput.high ?? DEFAULT_MODE.stageCostUsdPer1k.high), 1e-4, 0.3)
    }
  };
}
function readRouterModeConfig(projectDir) {
  const file3 = modeFile(projectDir);
  if (!fs33.existsSync(file3)) return DEFAULT_MODE;
  try {
    const parsed = JSON.parse(fs33.readFileSync(file3, "utf-8"));
    return parseMode(parsed);
  } catch {
    return DEFAULT_MODE;
  }
}
function readSessionStore(projectDir) {
  const file3 = sessionStateFile(projectDir);
  if (!fs33.existsSync(file3)) return { sessions: {} };
  try {
    const parsed = JSON.parse(fs33.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) return { sessions: {} };
    return {
      sessions: Object.fromEntries(
        Object.entries(parsed.sessions).map(([sessionID, state]) => [
          sessionID,
          {
            sessionID,
            consecutiveFailures: clamp3(Number(state?.consecutiveFailures ?? 0), 0, 10),
            lastStage: state?.lastStage === "low" || state?.lastStage === "medium" || state?.lastStage === "high" ? state.lastStage : "medium",
            updatedAt: String(state?.updatedAt ?? nowIso19())
          }
        ])
      )
    };
  } catch {
    return { sessions: {} };
  }
}
function writeSessionStore(projectDir, store) {
  ensureDir15(projectDir);
  fs33.writeFileSync(sessionStateFile(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function getSessionState2(projectDir, sessionID) {
  const store = readSessionStore(projectDir);
  return store.sessions[sessionID] ?? {
    sessionID,
    consecutiveFailures: 0,
    lastStage: "medium",
    updatedAt: nowIso19()
  };
}
function stageLevel(stage) {
  if (stage === "low") return 0;
  if (stage === "medium") return 1;
  return 2;
}
function levelToStage(level) {
  if (level <= 0) return "low";
  if (level === 1) return "medium";
  return "high";
}
function readCostRows(projectDir, limit = 500) {
  const file3 = costFile(projectDir);
  if (!fs33.existsSync(file3)) return [];
  const rows = fs33.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => Boolean(item));
  return rows.slice(-Math.max(1, limit));
}
function appendCostRow(projectDir, row) {
  ensureDir15(projectDir);
  fs33.appendFileSync(costFile(projectDir), `${JSON.stringify(row)}
`, "utf-8");
}
function analyzeRouteComplexity(text) {
  const normalized = String(text ?? "").trim();
  const reasons = [];
  let score = 0;
  if (normalized.length > 1600) {
    score += 2;
    reasons.push("long_request");
  } else if (normalized.length > 700) {
    score += 1;
    reasons.push("medium_length");
  }
  if (/```[\s\S]*```/.test(normalized)) {
    score += 2;
    reasons.push("contains_code_block");
  }
  if (/(|tradeoff||risk|migration||performance||security|)/i.test(normalized)) {
    score += 1;
    reasons.push("architecture_or_risk");
  }
  if (/(||pipeline|workflow||verify||fix|loop)/i.test(normalized)) {
    score += 1;
    reasons.push("multi_step_execution");
  }
  if (/(|||critical|p0|severe)/i.test(normalized)) {
    score += 1;
    reasons.push("urgency_signal");
  }
  const complexity = score >= 4 ? "high" : score >= 2 ? "medium" : "low";
  return { complexity, score, reasons };
}
function stageFromComplexity(complexity) {
  if (complexity === "high") return "high";
  if (complexity === "medium") return "medium";
  return "low";
}
function compressTextByStage(text, stage) {
  const normalized = String(text ?? "").trim();
  if (!normalized) return { text: "", compressed: false };
  if (stage === "high") return { text: normalized, compressed: false };
  if (stage === "medium" && normalized.length <= 4200) return { text: normalized, compressed: false };
  if (stage === "low" && normalized.length <= 1600) return { text: normalized, compressed: false };
  if (stage === "medium") {
    const head2 = normalized.slice(0, 2600);
    const tail2 = normalized.slice(-1200);
    return {
      text: `${head2}

[MIYA_ROUTER_COMPRESSION stage=medium]
...
${tail2}`,
      compressed: true
    };
  }
  const head = normalized.slice(0, 900);
  const bulletLines = normalized.split(/\r?\n/).map((line) => line.trim()).filter((line) => /^[-*0-9.]/.test(line)).slice(0, 8).join("\n");
  const tail = normalized.slice(-480);
  const merged = [head, bulletLines, tail].filter(Boolean).join("\n");
  return {
    text: `${merged}

[MIYA_ROUTER_COMPRESSION stage=low reason=eco_mode]`,
    compressed: true
  };
}
function estimateInputTokens(text) {
  const length = String(text ?? "").length;
  return Math.max(20, Math.ceil(length / 3.6));
}
function estimateOutputTokens(inputTokens, stage) {
  if (stage === "low") return Math.max(60, Math.ceil(inputTokens * 0.35));
  if (stage === "medium") return Math.max(100, Math.ceil(inputTokens * 0.55));
  return Math.max(140, Math.ceil(inputTokens * 0.9));
}
function buildRouteExecutionPlan(input) {
  const intent = classifyIntent(input.text);
  const complexity = analyzeRouteComplexity(input.text);
  const mode = readRouterModeConfig(input.projectDir);
  const session = getSessionState2(input.projectDir, input.sessionID);
  const ranked = rankAgentsByFeedback(input.projectDir, intent, input.availableAgents);
  const preferredAgent = resolveFallbackAgent(intent, input.availableAgents);
  const fallbackAgent = resolveFallbackAgent(intent, input.availableAgents);
  const selectedByFeedback = resolveAgentWithFeedback(intent, input.availableAgents, ranked);
  const pinnedAgent = input.pinnedAgent?.trim();
  const selectedAgent = pinnedAgent && input.availableAgents.includes(pinnedAgent) ? pinnedAgent : selectedByFeedback;
  const feedbackScore = ranked.find((item) => item.agent === selectedAgent)?.score ?? 0;
  const feedbackSamples = ranked.find((item) => item.agent === selectedAgent)?.samples ?? 0;
  let stage = stageFromComplexity(complexity.complexity);
  const reasons = [...complexity.reasons];
  if (mode.forcedStage) {
    stage = mode.forcedStage;
    reasons.push("forced_stage");
  } else {
    if (mode.ecoMode) {
      stage = levelToStage(stageLevel(stage) - 1);
      reasons.push("eco_mode_downshift");
    }
    if (session.consecutiveFailures >= 1) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_1");
    }
    if (session.consecutiveFailures >= 2) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_2");
    }
  }
  const agentPlan = buildAgentPlan({
    complexity: complexity.complexity,
    intent,
    selectedAgent,
    availableAgents: input.availableAgents,
    pinnedAgent: pinnedAgent && input.availableAgents.includes(pinnedAgent) ? pinnedAgent : void 0
  });
  if (agentPlan.plannedAgents.length > 1) {
    reasons.push("multi_agent_plan");
  }
  if (pinnedAgent && input.availableAgents.includes(pinnedAgent)) {
    reasons.push("pinned_agent_lock");
  }
  return {
    intent,
    complexity: complexity.complexity,
    complexityScore: complexity.score,
    stage,
    agent: selectedAgent,
    plannedAgents: agentPlan.plannedAgents,
    maxAgents: agentPlan.maxAgents,
    contextStrategy: agentPlan.contextStrategy,
    requiresMultipleSteps: agentPlan.requiresMultipleSteps,
    enableEarlyExit: agentPlan.enableEarlyExit,
    preferredAgent,
    fallbackAgent,
    feedbackScore,
    feedbackSamples,
    ecoMode: mode.ecoMode,
    reasons
  };
}
function prepareRoutePayload(projectDir, input) {
  const mode = readRouterModeConfig(projectDir);
  const compressed = compressTextByStage(input.text, input.stage);
  const inputTokens = estimateInputTokens(compressed.text);
  const outputTokensEstimate = estimateOutputTokens(inputTokens, input.stage);
  const totalTokensEstimate = Math.ceil(
    (inputTokens + outputTokensEstimate) * mode.stageTokenMultiplier[input.stage]
  );
  const baselineHighTokensEstimate = Math.ceil(
    (inputTokens + estimateOutputTokens(inputTokens, "high")) * mode.stageTokenMultiplier.high
  );
  const costUsdEstimate = Number(
    (totalTokensEstimate / 1e3 * mode.stageCostUsdPer1k[input.stage]).toFixed(6)
  );
  return {
    text: compressed.text,
    compressed: compressed.compressed,
    inputTokens,
    outputTokensEstimate,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    costUsdEstimate
  };
}
function recordRouteExecutionOutcome(input) {
  const row = {
    at: nowIso19(),
    sessionID: input.sessionID,
    intent: input.intent,
    complexity: input.complexity,
    stage: input.stage,
    agent: input.agent,
    success: input.success,
    inputTokens: input.inputTokens,
    outputTokensEstimate: input.outputTokensEstimate,
    totalTokensEstimate: input.totalTokensEstimate,
    baselineHighTokensEstimate: input.baselineHighTokensEstimate,
    costUsdEstimate: input.costUsdEstimate
  };
  appendCostRow(input.projectDir, row);
  const store = readSessionStore(input.projectDir);
  const current = store.sessions[input.sessionID] ?? {
    sessionID: input.sessionID,
    consecutiveFailures: 0,
    lastStage: input.stage,
    updatedAt: nowIso19()
  };
  const next = {
    sessionID: input.sessionID,
    consecutiveFailures: input.success ? 0 : clamp3(current.consecutiveFailures + 1, 0, 10),
    lastStage: input.stage,
    updatedAt: nowIso19()
  };
  store.sessions[input.sessionID] = next;
  writeSessionStore(input.projectDir, store);
  return row;
}
function getRouteCostSummary(projectDir, limit = 300) {
  const rows = readCostRows(projectDir, limit);
  const byStage = {
    low: { records: 0, tokens: 0, costUsd: 0 },
    medium: { records: 0, tokens: 0, costUsd: 0 },
    high: { records: 0, tokens: 0, costUsd: 0 }
  };
  let totalTokensEstimate = 0;
  let baselineHighTokensEstimate = 0;
  let totalCostUsdEstimate = 0;
  for (const row of rows) {
    byStage[row.stage].records += 1;
    byStage[row.stage].tokens += row.totalTokensEstimate;
    byStage[row.stage].costUsd += row.costUsdEstimate;
    totalTokensEstimate += row.totalTokensEstimate;
    baselineHighTokensEstimate += row.baselineHighTokensEstimate;
    totalCostUsdEstimate += row.costUsdEstimate;
  }
  const savingsTokensEstimate = Math.max(0, baselineHighTokensEstimate - totalTokensEstimate);
  const savingsPercentEstimate = baselineHighTokensEstimate > 0 ? Number((savingsTokensEstimate / baselineHighTokensEstimate * 100).toFixed(2)) : 0;
  return {
    totalRecords: rows.length,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    savingsTokensEstimate,
    savingsPercentEstimate,
    totalCostUsdEstimate: Number(totalCostUsdEstimate.toFixed(6)),
    byStage: {
      low: {
        ...byStage.low,
        costUsd: Number(byStage.low.costUsd.toFixed(6))
      },
      medium: {
        ...byStage.medium,
        costUsd: Number(byStage.medium.costUsd.toFixed(6))
      },
      high: {
        ...byStage.high,
        costUsd: Number(byStage.high.costUsd.toFixed(6))
      }
    }
  };
}
function listRouteCostRecords(projectDir, limit = 40) {
  return readCostRows(projectDir, limit);
}
var DEFAULT_MODE, ORCHESTRATION_ORDER;
var init_runtime = __esm({
  "src/router/runtime.ts"() {
    "use strict";
    init_workflow();
    init_classifier();
    init_fallback();
    init_learner();
    DEFAULT_MODE = {
      ecoMode: true,
      stageTokenMultiplier: {
        low: 0.62,
        medium: 1,
        high: 1.45
      },
      stageCostUsdPer1k: {
        low: 9e-4,
        medium: 18e-4,
        high: 32e-4
      }
    };
    ORCHESTRATION_ORDER = [
      "1-task-manager",
      "2-code-search",
      "3-docs-helper",
      "4-architecture-advisor",
      "5-code-fixer",
      "6-ui-designer",
      "7-code-simplicity-reviewer"
    ];
  }
});

// src/router/index.ts
var init_router2 = __esm({
  "src/router/index.ts"() {
    "use strict";
    init_classifier();
    init_fallback();
    init_learner();
    init_runtime();
  }
});

// src/skills/frontmatter.ts
function normalizeScalar(value) {
  const trimmed = value.trim();
  if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
    return trimmed.slice(1, -1).trim();
  }
  return trimmed;
}
function normalizeList(value) {
  const trimmed = value.trim();
  if (!trimmed) return [];
  const body = trimmed.startsWith("[") && trimmed.endsWith("]") ? trimmed.slice(1, -1) : trimmed;
  return body.split(",").map((item) => normalizeScalar(item)).filter(Boolean);
}
function parseSkillFrontmatter(markdown) {
  const trimmed = markdown.trimStart();
  if (!trimmed.startsWith("---")) {
    return {};
  }
  const lines = trimmed.split(/\r?\n/);
  if (lines.length < 3 || lines[0].trim() !== "---") {
    return {};
  }
  const endIndex = lines.findIndex((line, index) => index > 0 && line.trim() === "---");
  if (endIndex === -1) {
    return {};
  }
  const result = {};
  let activeListKey;
  for (const rawLine of lines.slice(1, endIndex)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#")) continue;
    if (activeListKey && line.startsWith("- ")) {
      const value2 = normalizeScalar(line.slice(2));
      if (value2) {
        const existing = result[activeListKey] ?? [];
        result[activeListKey] = [...existing, value2];
      }
      continue;
    }
    activeListKey = void 0;
    const colon = line.indexOf(":");
    if (colon <= 0) continue;
    const key = line.slice(0, colon).trim();
    const value = line.slice(colon + 1).trim();
    if (key === "name") result.name = value;
    else if (key === "version") result.version = value;
    else if (key === "description") result.description = value;
    else if (LIST_KEYS.has(key)) {
      const listKey = key;
      const parsed = normalizeList(value);
      if (parsed.length > 0) {
        result[listKey] = parsed;
      } else {
        result[listKey] = [];
        activeListKey = listKey;
      }
    }
  }
  return result;
}
var LIST_KEYS;
var init_frontmatter = __esm({
  "src/skills/frontmatter.ts"() {
    "use strict";
    LIST_KEYS = /* @__PURE__ */ new Set(["bins", "env", "platforms", "permissions"]);
  }
});

// src/skills/gating.ts
import { spawnSync as spawnSync4 } from "node:child_process";
function hasBinary(bin) {
  const checker = process.platform === "win32" ? "where" : "which";
  const result = spawnSync4(checker, [bin], { stdio: "ignore" });
  return result.status === 0;
}
function evaluateSkillGate(frontmatter) {
  const reasons = [];
  if (Array.isArray(frontmatter.platforms) && frontmatter.platforms.length > 0) {
    if (!frontmatter.platforms.includes(process.platform)) {
      reasons.push(`platform_not_supported:${process.platform}`);
    }
  }
  for (const envName of frontmatter.env ?? []) {
    if (!process.env[envName]) {
      reasons.push(`missing_env:${envName}`);
    }
  }
  for (const bin of frontmatter.bins ?? []) {
    if (!hasBinary(bin)) {
      reasons.push(`missing_bin:${bin}`);
    }
  }
  return {
    loadable: reasons.length === 0,
    reasons
  };
}
var init_gating = __esm({
  "src/skills/gating.ts"() {
    "use strict";
  }
});

// src/skills/loader.ts
import * as fs34 from "node:fs";
import * as os3 from "node:os";
import * as path34 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";
function isSkillDir(dir) {
  const skillFile = path34.join(dir, "SKILL.md");
  return fs34.existsSync(skillFile);
}
function listSkillDirs(rootDir) {
  if (!fs34.existsSync(rootDir)) return [];
  const entries = fs34.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path34.join(rootDir, entry2.name));
  return entries.filter(isSkillDir);
}
function builtinSkillRoots(projectDir) {
  const roots = /* @__PURE__ */ new Set();
  const localBuiltinRoot = path34.dirname(fileURLToPath3(import.meta.url));
  roots.add(path34.join(projectDir, "miya-src", "src", "skills"));
  roots.add(localBuiltinRoot);
  return [...roots];
}
function enforcePermissionMetadataGate(source, frontmatter, gate) {
  if (source === "builtin") return gate;
  if ((frontmatter.permissions?.length ?? 0) > 0) return gate;
  const reasons = [...gate.reasons, "missing_permission_metadata"];
  return {
    loadable: false,
    reasons: [...new Set(reasons)]
  };
}
function discoverSkills(projectDir, extraDirs = []) {
  const workspaceRoot = path34.join(projectDir, "skills");
  const globalRoot = path34.join(os3.homedir(), ".config", "opencode", "miya", "skills");
  const scopedDirs = [
    { source: "workspace", dirs: listSkillDirs(workspaceRoot) },
    { source: "global", dirs: listSkillDirs(globalRoot) },
    {
      source: "builtin",
      dirs: builtinSkillRoots(projectDir).flatMap((root) => listSkillDirs(root))
    },
    {
      source: "extra",
      dirs: extraDirs.flatMap((root) => listSkillDirs(path34.resolve(projectDir, root)))
    }
  ];
  const precedence = {
    workspace: 4,
    global: 3,
    extra: 2,
    builtin: 1
  };
  const byName = /* @__PURE__ */ new Map();
  for (const scope of scopedDirs) {
    for (const dir of scope.dirs) {
      const skillFile = path34.join(dir, "SKILL.md");
      let content = "";
      try {
        content = fs34.readFileSync(skillFile, "utf-8");
      } catch {
        continue;
      }
      const frontmatter = parseSkillFrontmatter(content);
      const name = frontmatter.name ?? path34.basename(dir);
      const gate = enforcePermissionMetadataGate(
        scope.source,
        frontmatter,
        evaluateSkillGate(frontmatter)
      );
      const descriptor = {
        id: name,
        name,
        source: scope.source,
        dir,
        skillFile,
        frontmatter,
        gate
      };
      const existing = byName.get(name);
      if (!existing || precedence[scope.source] >= precedence[existing.source]) {
        byName.set(name, descriptor);
      }
    }
  }
  return [...byName.values()].sort((a, b) => a.name.localeCompare(b.name));
}
var init_loader2 = __esm({
  "src/skills/loader.ts"() {
    "use strict";
    init_frontmatter();
    init_gating();
  }
});

// src/skills/state.ts
import * as fs35 from "node:fs";
import * as path35 from "node:path";
function nowIso20() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath11(projectDir) {
  return path35.join(getMiyaRuntimeDir(projectDir), "skills.json");
}
function ensureDir16(file3) {
  fs35.mkdirSync(path35.dirname(file3), { recursive: true });
}
function readState(projectDir) {
  const file3 = filePath11(projectDir);
  if (!fs35.existsSync(file3)) {
    return { enabled: [], updatedAt: nowIso20() };
  }
  try {
    const parsed = JSON.parse(fs35.readFileSync(file3, "utf-8"));
    return {
      enabled: Array.isArray(parsed.enabled) ? parsed.enabled.map(String) : [],
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso20()
    };
  } catch {
    return { enabled: [], updatedAt: nowIso20() };
  }
}
function writeState3(projectDir, state) {
  const file3 = filePath11(projectDir);
  ensureDir16(file3);
  fs35.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
}
function listEnabledSkills(projectDir) {
  return readState(projectDir).enabled;
}
function setSkillEnabled(projectDir, skillID, enabled) {
  const state = readState(projectDir);
  const normalized = new Set(state.enabled);
  if (enabled) normalized.add(skillID);
  else normalized.delete(skillID);
  const next = {
    enabled: [...normalized].sort(),
    updatedAt: nowIso20()
  };
  writeState3(projectDir, next);
  return next.enabled;
}
var init_state4 = __esm({
  "src/skills/state.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/skills/sync.ts
import { createHash as createHash12 } from "node:crypto";
import * as fs36 from "node:fs";
import * as os4 from "node:os";
import * as path36 from "node:path";
function nowIso21(options) {
  return options?.now?.() ?? (/* @__PURE__ */ new Date()).toISOString();
}
function stateFile2(projectDir) {
  return path36.join(getMiyaRuntimeDir(projectDir), "ecosystem-bridge.json");
}
function readState2(projectDir) {
  const file3 = stateFile2(projectDir);
  if (!fs36.existsSync(file3)) return { ...DEFAULT_STATE2 };
  try {
    const parsed = JSON.parse(fs36.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : (/* @__PURE__ */ new Date(0)).toISOString(),
      sourcePacks: parsed.sourcePacks && typeof parsed.sourcePacks === "object" ? parsed.sourcePacks : {},
      importPlans: parsed.importPlans && typeof parsed.importPlans === "object" ? parsed.importPlans : {},
      pinnedReleases: parsed.pinnedReleases && typeof parsed.pinnedReleases === "object" ? parsed.pinnedReleases : {}
    };
  } catch {
    return { ...DEFAULT_STATE2 };
  }
}
function writeState4(projectDir, state, options) {
  const file3 = stateFile2(projectDir);
  fs36.mkdirSync(path36.dirname(file3), { recursive: true });
  const next = {
    ...state,
    version: 1,
    updatedAt: nowIso21(options)
  };
  fs36.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
}
function runGit(args, cwd) {
  const proc = runProcessSync("git", args, {
    cwd
  });
  return {
    exitCode: proc.exitCode,
    stdout: proc.stdout.trim(),
    stderr: proc.stderr.trim()
  };
}
function git(options, args, cwd) {
  return (options?.gitRunner ?? runGit)(args, cwd);
}
function normalizeText5(value) {
  const trimmed = value?.trim();
  if (!trimmed) return void 0;
  return trimmed;
}
function defaultSourceRoots(projectDir) {
  return [
    path36.join(projectDir, "skills"),
    path36.join(os4.homedir(), ".config", "opencode", "miya", "skills")
  ];
}
function listSkillReposFromRoot(rootDir) {
  if (!fs36.existsSync(rootDir)) return [];
  return fs36.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path36.join(rootDir, entry2.name)).filter((dir) => {
    return fs36.existsSync(path36.join(dir, "SKILL.md")) && fs36.existsSync(path36.join(dir, ".git"));
  });
}
function sanitizeIdSegment(input) {
  return input.replace(/[^a-zA-Z0-9_-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
}
function buildSourcePackID(repo, localDir) {
  const base = sanitizeIdSegment(path36.basename(localDir) || "source-pack") || "source-pack";
  const fingerprint = createHash12("sha256").update(`${repo ?? ""}|${path36.resolve(localDir)}`).digest("hex").slice(0, 12);
  return `${base}-${fingerprint}`;
}
function trustLevelForRepo(repo) {
  if (!repo) return "unknown";
  return TRUSTED_SOURCE_ALLOWLIST.some((rule) => rule.test(repo)) ? "allowlisted" : "untrusted";
}
function resolveSkillName(localDir) {
  const manifest = path36.join(localDir, "SKILL.md");
  if (!fs36.existsSync(manifest)) return path36.basename(localDir);
  try {
    const raw = fs36.readFileSync(manifest, "utf-8");
    const heading = /^#\s+(.+)$/m.exec(raw)?.[1]?.trim();
    if (heading) return heading;
  } catch {
  }
  return path36.basename(localDir);
}
function readGitValue(options, cwd, args) {
  const result = git(options, args, cwd);
  if (result.exitCode !== 0) return void 0;
  return normalizeText5(result.stdout);
}
function resolveUpstreamRef(localDir, branch, options) {
  const upstream = readGitValue(options, localDir, [
    "rev-parse",
    "--abbrev-ref",
    "--symbolic-full-name",
    "@{upstream}"
  ]);
  if (upstream) return upstream;
  if (branch && branch !== "HEAD") return `origin/${branch}`;
  return "origin/HEAD";
}
function resolveRevision(localDir, ref, options) {
  const resolved = readGitValue(options, localDir, ["rev-parse", `${ref}^{commit}`]);
  if (!resolved) {
    throw new Error(`source_pack_revision_unresolved:${ref}`);
  }
  return resolved;
}
function requireCleanWorkingTree(localDir, options) {
  const status = git(options, ["status", "--porcelain"], localDir);
  if (status.exitCode !== 0) {
    throw new Error(status.stderr || "source_pack_status_failed");
  }
  if (status.stdout.trim()) {
    throw new Error("source_pack_dirty_worktree");
  }
}
function discoverSourcePacks(projectDir, state, options) {
  const roots = options?.sourceRoots?.length ? options.sourceRoots : defaultSourceRoots(projectDir);
  const dirs = /* @__PURE__ */ new Set();
  for (const root of roots) {
    for (const repoDir of listSkillReposFromRoot(root)) {
      dirs.add(path36.resolve(repoDir));
    }
  }
  const packs = [];
  for (const localDir of [...dirs]) {
    const headRevision = readGitValue(options, localDir, ["rev-parse", "HEAD"]);
    if (!headRevision) continue;
    const repo = readGitValue(options, localDir, ["config", "--get", "remote.origin.url"]);
    const branch = readGitValue(options, localDir, ["rev-parse", "--abbrev-ref", "HEAD"]) ?? "HEAD";
    const sourcePackID = buildSourcePackID(repo, localDir);
    const sourceState = state.sourcePacks[sourcePackID];
    const importPlan = state.importPlans[sourcePackID];
    const pinnedRelease = state.pinnedReleases[sourcePackID];
    packs.push({
      sourcePackID,
      name: path36.basename(localDir),
      skillName: resolveSkillName(localDir),
      repo,
      localDir,
      branch,
      headRevision,
      latestRevision: sourceState?.latestRevision,
      lastPulledAt: sourceState?.lastPulledAt,
      trustLevel: trustLevelForRepo(repo),
      importPlan,
      pinnedRelease
    });
  }
  return packs.sort((a, b) => {
    const byName = a.name.localeCompare(b.name);
    if (byName !== 0) return byName;
    return a.sourcePackID.localeCompare(b.sourcePackID);
  });
}
function requireSourcePack(projectDir, sourcePackID, options) {
  const state = readState2(projectDir);
  const packs = discoverSourcePacks(projectDir, state, options);
  const sourcePack = packs.find((item) => item.sourcePackID === sourcePackID);
  if (!sourcePack) throw new Error(`unknown_source_pack:${sourcePackID}`);
  return { state, sourcePack };
}
function ensureImportPlan(state, sourcePack, options) {
  const existing = state.importPlans[sourcePack.sourcePackID];
  if (existing) {
    const refreshed = {
      ...existing,
      sourcePackID: sourcePack.sourcePackID,
      localDir: sourcePack.localDir,
      updatedAt: nowIso21(options)
    };
    state.importPlans[sourcePack.sourcePackID] = refreshed;
    return refreshed;
  }
  const created = {
    sourcePackID: sourcePack.sourcePackID,
    localDir: sourcePack.localDir,
    importMode: "skills_only",
    permissionMode: "sandbox_read_only",
    createdAt: nowIso21(options),
    updatedAt: nowIso21(options)
  };
  state.importPlans[sourcePack.sourcePackID] = created;
  return created;
}
function updateSourcePackState(state, sourcePack, patch) {
  const current = state.sourcePacks[sourcePack.sourcePackID];
  state.sourcePacks[sourcePack.sourcePackID] = {
    sourcePackID: sourcePack.sourcePackID,
    repo: sourcePack.repo,
    localDir: sourcePack.localDir,
    latestRevision: current?.latestRevision,
    lastPulledAt: current?.lastPulledAt,
    lastError: current?.lastError,
    ...patch
  };
}
function listEcosystemBridge(projectDir, options) {
  const state = readState2(projectDir);
  const sourcePacks = discoverSourcePacks(projectDir, state, options);
  const bySkillName = /* @__PURE__ */ new Map();
  for (const pack of sourcePacks) {
    const key = pack.skillName.toLowerCase();
    const list = bySkillName.get(key) ?? [];
    list.push(pack);
    bySkillName.set(key, list);
  }
  const conflicts = [];
  for (const [, list] of bySkillName.entries()) {
    if (list.length <= 1) continue;
    conflicts.push({
      type: "skill_name_collision",
      skillName: list[0].skillName,
      sourcePackIDs: list.map((item) => item.sourcePackID).sort()
    });
  }
  const importPlans = Object.values(state.importPlans).sort(
    (a, b) => a.sourcePackID.localeCompare(b.sourcePackID)
  );
  const pinnedReleases = Object.values(state.pinnedReleases).sort(
    (a, b) => a.sourcePackID.localeCompare(b.sourcePackID)
  );
  return {
    sourcePacks,
    importPlans,
    pinnedReleases,
    conflicts: conflicts.sort((a, b) => a.skillName.localeCompare(b.skillName))
  };
}
function pullSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pull = git(options, ["fetch", "--prune", "origin"], resolved.sourcePack.localDir);
  if (pull.exitCode !== 0) {
    updateSourcePackState(resolved.state, resolved.sourcePack, {
      lastError: pull.stderr || "source_pack_fetch_failed"
    });
    writeState4(projectDir, resolved.state, options);
    throw new Error(pull.stderr || "source_pack_fetch_failed");
  }
  const compareRef = resolveUpstreamRef(
    resolved.sourcePack.localDir,
    resolved.sourcePack.branch,
    options
  );
  const latestRevision = resolveRevision(resolved.sourcePack.localDir, compareRef, options);
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision,
    lastPulledAt: nowIso21(options),
    lastError: void 0
  });
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    latestRevision,
    compareRef,
    pulledAt: nowIso21(options)
  };
}
function diffSourcePack(projectDir, sourcePackID, options) {
  const { state, sourcePack } = requireSourcePack(projectDir, sourcePackID, options);
  const compareRef = state.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(sourcePack.localDir, sourcePack.branch, options);
  const compareRevision = resolveRevision(sourcePack.localDir, compareRef, options);
  const count = git(
    options,
    ["rev-list", "--left-right", "--count", `HEAD...${compareRevision}`],
    sourcePack.localDir
  );
  if (count.exitCode !== 0) {
    throw new Error(count.stderr || "source_pack_diff_failed");
  }
  const [aheadRaw, behindRaw] = count.stdout.split(/\s+/);
  const ahead = Number.parseInt(aheadRaw ?? "0", 10) || 0;
  const behind = Number.parseInt(behindRaw ?? "0", 10) || 0;
  const logResult = git(
    options,
    ["log", "--oneline", "--max-count", "20", `HEAD..${compareRevision}`],
    sourcePack.localDir
  );
  const pendingCommits = logResult.exitCode === 0 && logResult.stdout ? logResult.stdout.split("\n").map((line) => line.trim()).filter(Boolean) : [];
  return {
    sourcePackID,
    localDir: sourcePack.localDir,
    headRevision: sourcePack.headRevision,
    compareRevision,
    compareRef,
    ahead,
    behind,
    pendingCommits,
    pinnedRelease: state.pinnedReleases[sourcePackID]
  };
}
function applySourcePack(projectDir, sourcePackID, input = {}, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const targetRef = normalizeText5(input.revision) ?? resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(resolved.sourcePack.localDir, resolved.sourcePack.branch, options);
  const targetRevision = resolveRevision(resolved.sourcePack.localDir, targetRef, options);
  const previousRevision = resolved.sourcePack.headRevision;
  if (previousRevision !== targetRevision) {
    const checkout = git(
      options,
      ["checkout", "--detach", targetRevision],
      resolved.sourcePack.localDir
    );
    if (checkout.exitCode !== 0) {
      throw new Error(checkout.stderr || "source_pack_apply_failed");
    }
  }
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision: resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? targetRevision,
    lastError: void 0
  });
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : resolved.state.pinnedReleases[sourcePackID]?.previousRevision,
    appliedAt: nowIso21(options)
  };
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    appliedRevision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : void 0,
    detachedHead: true
  };
}
function rollbackSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pinned = resolved.state.pinnedReleases[sourcePackID];
  if (!pinned?.previousRevision) {
    throw new Error(`source_pack_rollback_unavailable:${sourcePackID}`);
  }
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const previousRevision = resolved.sourcePack.headRevision;
  const rollbackRevision = resolveRevision(
    resolved.sourcePack.localDir,
    pinned.previousRevision,
    options
  );
  const checkout = git(
    options,
    ["checkout", "--detach", rollbackRevision],
    resolved.sourcePack.localDir
  );
  if (checkout.exitCode !== 0) {
    throw new Error(checkout.stderr || "source_pack_rollback_failed");
  }
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: rollbackRevision,
    previousRevision,
    appliedAt: nowIso21(options)
  };
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    rolledBackTo: rollbackRevision,
    previousRevision,
    detachedHead: true
  };
}
var DEFAULT_STATE2, TRUSTED_SOURCE_ALLOWLIST;
var init_sync = __esm({
  "src/skills/sync.ts"() {
    "use strict";
    init_utils2();
    init_workflow();
    DEFAULT_STATE2 = {
      version: 1,
      updatedAt: (/* @__PURE__ */ new Date(0)).toISOString(),
      sourcePacks: {},
      importPlans: {},
      pinnedReleases: {}
    };
    TRUSTED_SOURCE_ALLOWLIST = [
      /^https?:\/\/github\.com\/(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i,
      /^git@github\.com:(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i
    ];
  }
});

// src/mcp/context7.ts
var context7;
var init_context7 = __esm({
  "src/mcp/context7.ts"() {
    "use strict";
    context7 = {
      type: "remote",
      url: "https://mcp.context7.com/mcp",
      headers: process.env.CONTEXT7_API_KEY ? { CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY } : void 0,
      oauth: false,
      capabilities: {
        sampling: false,
        mcpUi: false
      }
    };
  }
});

// src/mcp/grep-app.ts
var grep_app;
var init_grep_app = __esm({
  "src/mcp/grep-app.ts"() {
    "use strict";
    grep_app = {
      type: "remote",
      url: "https://mcp.grep.app",
      oauth: false,
      capabilities: {
        sampling: false,
        mcpUi: false
      }
    };
  }
});

// src/mcp/websearch.ts
var websearch;
var init_websearch = __esm({
  "src/mcp/websearch.ts"() {
    "use strict";
    websearch = {
      type: "remote",
      url: "https://mcp.exa.ai/mcp?tools=web_search_exa",
      headers: process.env.EXA_API_KEY ? { "x-api-key": process.env.EXA_API_KEY } : void 0,
      oauth: false,
      capabilities: {
        sampling: false,
        mcpUi: false
      }
    };
  }
});

// src/mcp/index.ts
function createBuiltinMcps(disabledMcps = []) {
  return Object.fromEntries(
    Object.entries(allBuiltinMcps).filter(
      ([name]) => !disabledMcps.includes(name)
    )
  );
}
function buildMcpServiceManifest(disabledMcps = []) {
  const builtins = createBuiltinMcps(disabledMcps);
  const mcps = Object.entries(builtins).map(([name, config3]) => {
    const caps = "capabilities" in config3 ? config3.capabilities : void 0;
    return {
      name,
      type: config3.type,
      sampling: Boolean(caps?.sampling),
      mcpUi: Boolean(caps?.mcpUi),
      serviceExpose: Boolean(caps?.serviceExpose)
    };
  });
  return {
    service: "miya-control-plane",
    version: 2,
    generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    mcps,
    controlPlaneEndpoints: [
      "gateway.status.get",
      "gateway.backpressure.stats",
      "daemon.backpressure.stats",
      "provider.override.audit.list",
      "mcp.capabilities.list",
      "mcp.service.expose"
    ]
  };
}
var allBuiltinMcps;
var init_mcp = __esm({
  "src/mcp/index.ts"() {
    "use strict";
    init_context7();
    init_grep_app();
    init_websearch();
    allBuiltinMcps = {
      websearch,
      context7,
      grep_app
    };
  }
});

// src/autoflow/state.ts
import * as fs37 from "node:fs";
import * as path37 from "node:path";
function nowIso22() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function stateFilePath(projectDir) {
  return path37.join(getMiyaRuntimeDir(projectDir), "autoflow-state.json");
}
function normalizeFixRounds(value) {
  if (!Number.isFinite(value)) return DEFAULT_MAX_FIX_ROUNDS;
  return Math.max(1, Math.min(10, Math.floor(Number(value))));
}
function normalizeState(sessionID, raw) {
  const createdAt = raw?.createdAt ?? nowIso22();
  const history = Array.isArray(raw?.history) ? raw?.history.slice(-MAX_HISTORY).map((item) => ({
    at: String(item.at ?? createdAt),
    phase: item.phase ?? "planning",
    event: String(item.event ?? "unknown"),
    summary: String(item.summary ?? "")
  })) : [];
  const fixCommands = Array.isArray(raw?.fixCommands) ? raw.fixCommands.map(String).map((item) => item.trim()).filter(Boolean) : [];
  const recentVerificationHashes = Array.isArray(raw?.recentVerificationHashes) ? raw.recentVerificationHashes.map(String).slice(-3) : [];
  const planTasks = Array.isArray(raw?.planTasks) ? raw.planTasks : [];
  return {
    sessionID,
    goal: String(raw?.goal ?? "").trim(),
    phase: raw?.phase ?? "planning",
    createdAt,
    updatedAt: raw?.updatedAt ?? createdAt,
    maxFixRounds: normalizeFixRounds(raw?.maxFixRounds),
    fixRound: Number.isFinite(raw?.fixRound) ? Math.max(0, Math.floor(Number(raw?.fixRound))) : 0,
    verificationCommand: raw?.verificationCommand ? String(raw.verificationCommand) : void 0,
    fixCommands,
    planTasks,
    recentVerificationHashes,
    lastError: raw?.lastError ? String(raw.lastError) : void 0,
    lastDag: raw?.lastDag && Number.isFinite(raw.lastDag.total) ? {
      total: Math.max(0, Math.floor(Number(raw.lastDag.total))),
      completed: Math.max(0, Math.floor(Number(raw.lastDag.completed))),
      failed: Math.max(0, Math.floor(Number(raw.lastDag.failed))),
      blocked: Math.max(0, Math.floor(Number(raw.lastDag.blocked)))
    } : void 0,
    history
  };
}
function readStore7(projectDir) {
  const file3 = stateFilePath(projectDir);
  if (!fs37.existsSync(file3)) return { sessions: {} };
  try {
    const parsed = JSON.parse(fs37.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const sessions = {};
    for (const [sessionID, state] of Object.entries(parsed.sessions)) {
      sessions[sessionID] = normalizeState(sessionID, state);
    }
    return { sessions };
  } catch {
    return { sessions: {} };
  }
}
function listAutoflowSessions(projectDir, limit = 50) {
  const store = readStore7(projectDir);
  return Object.values(store.sessions).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, Math.min(200, limit)));
}
var DEFAULT_MAX_FIX_ROUNDS, MAX_HISTORY;
var init_state5 = __esm({
  "src/autoflow/state.ts"() {
    "use strict";
    init_workflow();
    DEFAULT_MAX_FIX_ROUNDS = 3;
    MAX_HISTORY = 120;
  }
});

// src/ultrawork/scheduler.ts
var init_scheduler2 = __esm({
  "src/ultrawork/scheduler.ts"() {
    "use strict";
  }
});

// src/autoflow/engine.ts
var init_engine = __esm({
  "src/autoflow/engine.ts"() {
    "use strict";
    init_utils2();
    init_scheduler2();
    init_state5();
  }
});

// src/autoflow/persistent.ts
import * as fs38 from "node:fs";
import * as path38 from "node:path";
function storeFile2(projectDir) {
  return path38.join(getMiyaRuntimeDir(projectDir), "autoflow-persistent.json");
}
function clamp4(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeConfig(raw) {
  return {
    enabled: raw?.enabled !== false,
    resumeCooldownMs: clamp4(
      Number(raw?.resumeCooldownMs ?? DEFAULT_CONFIG.resumeCooldownMs),
      500,
      12e4
    ),
    maxAutoResumes: clamp4(
      Number(raw?.maxAutoResumes ?? DEFAULT_CONFIG.maxAutoResumes),
      1,
      50
    ),
    maxConsecutiveResumeFailures: clamp4(
      Number(
        raw?.maxConsecutiveResumeFailures ?? DEFAULT_CONFIG.maxConsecutiveResumeFailures
      ),
      1,
      20
    ),
    resumeTimeoutMs: clamp4(
      Number(raw?.resumeTimeoutMs ?? DEFAULT_CONFIG.resumeTimeoutMs),
      3e3,
      10 * 6e4
    )
  };
}
function normalizeRuntime(sessionID, raw) {
  return {
    sessionID,
    resumeAttempts: clamp4(Number(raw?.resumeAttempts ?? 0), 0, 1e3),
    resumeFailures: clamp4(Number(raw?.resumeFailures ?? 0), 0, 1e3),
    userStopped: Boolean(raw?.userStopped),
    lastStopAt: raw?.lastStopAt ? String(raw.lastStopAt) : void 0,
    lastStopType: raw?.lastStopType ? String(raw.lastStopType) : void 0,
    lastStopReason: raw?.lastStopReason ? String(raw.lastStopReason) : void 0,
    lastResumeAt: raw?.lastResumeAt ? String(raw.lastResumeAt) : void 0,
    lastOutcomePhase: raw?.lastOutcomePhase ? String(raw.lastOutcomePhase) : void 0,
    lastOutcomeSummary: raw?.lastOutcomeSummary ? String(raw.lastOutcomeSummary) : void 0
  };
}
function readStore8(projectDir) {
  const file3 = storeFile2(projectDir);
  if (!fs38.existsSync(file3)) return { config: DEFAULT_CONFIG, sessions: {} };
  try {
    const parsed = JSON.parse(
      fs38.readFileSync(file3, "utf-8")
    );
    const sessionsRaw = parsed.sessions && typeof parsed.sessions === "object" ? parsed.sessions : {};
    const sessions = Object.fromEntries(
      Object.entries(sessionsRaw).map(([sessionID, runtime]) => [
        sessionID,
        normalizeRuntime(sessionID, runtime)
      ])
    );
    return {
      config: normalizeConfig(parsed.config),
      sessions
    };
  } catch {
    return { config: DEFAULT_CONFIG, sessions: {} };
  }
}
function readAutoflowPersistentConfig(projectDir) {
  return readStore8(projectDir).config;
}
function getAutoflowPersistentRuntimeSnapshot(projectDir, limit = 50) {
  const store = readStore8(projectDir);
  return Object.values(store.sessions).sort(
    (a, b) => Date.parse(b.lastStopAt ?? b.lastResumeAt ?? "") - Date.parse(a.lastStopAt ?? a.lastResumeAt ?? "")
  ).slice(0, Math.max(1, Math.min(200, limit)));
}
var DEFAULT_CONFIG;
var init_persistent = __esm({
  "src/autoflow/persistent.ts"() {
    "use strict";
    init_sessions();
    init_workflow();
    init_engine();
    init_state5();
    DEFAULT_CONFIG = {
      enabled: true,
      resumeCooldownMs: 2500,
      maxAutoResumes: 8,
      maxConsecutiveResumeFailures: 3,
      resumeTimeoutMs: 9e4
    };
  }
});

// src/autoflow/index.ts
var init_autoflow = __esm({
  "src/autoflow/index.ts"() {
    "use strict";
    init_state5();
    init_engine();
    init_persistent();
  }
});

// src/gateway/control-ui-shared.ts
function normalizeControlUiBasePath(basePath) {
  if (!basePath) return "";
  let normalized = basePath.trim();
  if (!normalized) return "";
  if (!normalized.startsWith("/")) normalized = `/${normalized}`;
  if (normalized === "/") return "";
  if (normalized.endsWith("/")) normalized = normalized.slice(0, -1);
  return normalized;
}
var init_control_ui_shared = __esm({
  "src/gateway/control-ui-shared.ts"() {
    "use strict";
  }
});

// src/gateway/control-ui.ts
import fs39 from "node:fs";
import path39 from "node:path";
function contentTypeForExt(ext) {
  switch (ext) {
    case ".html":
      return "text/html; charset=utf-8";
    case ".js":
      return "application/javascript; charset=utf-8";
    case ".css":
      return "text/css; charset=utf-8";
    case ".json":
    case ".map":
      return "application/json; charset=utf-8";
    case ".svg":
      return "image/svg+xml";
    case ".png":
      return "image/png";
    case ".jpg":
    case ".jpeg":
      return "image/jpeg";
    case ".gif":
      return "image/gif";
    case ".webp":
      return "image/webp";
    case ".ico":
      return "image/x-icon";
    case ".txt":
      return "text/plain; charset=utf-8";
    default:
      return "application/octet-stream";
  }
}
function securityHeaders(contentType) {
  const headers = {
    "cache-control": "no-cache",
    "x-frame-options": "DENY",
    "content-security-policy": "frame-ancestors 'none'",
    "x-content-type-options": "nosniff"
  };
  if (contentType) headers["content-type"] = contentType;
  return headers;
}
function textResponse(status, body) {
  return new Response(body, {
    status,
    headers: securityHeaders("text/plain; charset=utf-8")
  });
}
function isSafeRelativePath(relPath) {
  if (!relPath) return false;
  const normalized = path39.posix.normalize(relPath);
  if (normalized.startsWith("../") || normalized === "..") return false;
  if (normalized.includes("\0")) return false;
  return true;
}
function resolveRequestedFile(pathname, basePath) {
  if (basePath) {
    if (pathname === basePath) return "index.html";
    if (!pathname.startsWith(`${basePath}/`)) return null;
    pathname = pathname.slice(basePath.length);
  }
  if (!pathname.startsWith("/")) return null;
  if (pathname === "/" || pathname === "") return "index.html";
  const assetsIndex = pathname.indexOf("/assets/");
  const rel = assetsIndex >= 0 ? pathname.slice(assetsIndex + 1) : pathname.slice(1);
  const requested = rel && !rel.endsWith("/") ? rel : `${rel}index.html`;
  return requested || "index.html";
}
function resolveRootState(projectDir) {
  const envRoot = process.env.MIYA_GATEWAY_UI_ROOT?.trim();
  const candidates = envRoot ? [envRoot] : [
    path39.join(projectDir, "miya-src", "gateway-ui", "dist"),
    path39.join(projectDir, "gateway-ui", "dist"),
    path39.join(projectDir, ".opencode", "miya", "gateway-ui", "dist"),
    path39.join(projectDir, ".opencode", "miya", "gateway-ui")
  ];
  for (const candidate of candidates) {
    const indexPath = path39.join(candidate, "index.html");
    if (fs39.existsSync(indexPath) && fs39.statSync(indexPath).isFile()) {
      return { kind: "resolved", path: candidate };
    }
  }
  if (envRoot) return { kind: "invalid", path: envRoot };
  return { kind: "missing" };
}
function createControlUiRequestOptions(projectDir) {
  const envBasePath = process.env.MIYA_GATEWAY_UI_BASE_PATH;
  const defaultBasePath = envBasePath && envBasePath.trim().length > 0 ? envBasePath : "/control";
  return {
    basePath: normalizeControlUiBasePath(defaultBasePath),
    root: resolveRootState(projectDir)
  };
}
function handleControlUiHttpRequest(request, opts) {
  if (request.method !== "GET" && request.method !== "HEAD") return null;
  const url3 = new URL(request.url);
  const pathname = url3.pathname;
  const basePath = normalizeControlUiBasePath(opts?.basePath);
  const requestedFile = resolveRequestedFile(pathname, basePath);
  if (!requestedFile) return null;
  if (!isSafeRelativePath(requestedFile)) {
    return textResponse(404, "Not Found");
  }
  const root = opts?.root;
  if (root?.kind === "invalid") {
    return textResponse(
      503,
      `Control UI assets not found at ${root.path}. Set MIYA_GATEWAY_UI_ROOT to a built UI directory.`
    );
  }
  if (root?.kind === "missing") {
    return textResponse(
      503,
      "Control UI assets not found. Set MIYA_GATEWAY_UI_ROOT to a built UI directory."
    );
  }
  if (!root || root.kind !== "resolved") return null;
  const filePath12 = path39.join(root.path, requestedFile);
  if (!filePath12.startsWith(root.path)) {
    return textResponse(404, "Not Found");
  }
  const indexPath = path39.join(root.path, "index.html");
  const resolvedPath = fs39.existsSync(filePath12) && fs39.statSync(filePath12).isFile() ? filePath12 : indexPath;
  if (!fs39.existsSync(resolvedPath) || !fs39.statSync(resolvedPath).isFile()) {
    return textResponse(404, "Not Found");
  }
  const headers = securityHeaders(
    contentTypeForExt(path39.extname(resolvedPath).toLowerCase())
  );
  if (request.method === "HEAD") {
    return new Response(null, { status: 200, headers });
  }
  const body = fs39.readFileSync(resolvedPath);
  return new Response(body, {
    status: 200,
    headers
  });
}
var init_control_ui = __esm({
  "src/gateway/control-ui.ts"() {
    "use strict";
    init_control_ui_shared();
  }
});

// src/gateway/bootstrap.ts
function formatGatewayStateWithRuntime(state, ownerPID, isOwner, activeAgentId, storageRevision) {
  return [
    `url=${state.url}`,
    `port=${state.port}`,
    `pid=${state.pid}`,
    `owner_pid=${ownerPID ?? 0}`,
    `is_owner=${Boolean(isOwner)}`,
    `started_at=${state.startedAt}`,
    `status=${state.status}`,
    `active_agent=${activeAgentId ?? ""}`,
    `storage_revision=${storageRevision ?? 0}`
  ].join("\n");
}
var init_bootstrap = __esm({
  "src/gateway/bootstrap.ts"() {
    "use strict";
  }
});

// src/gateway/http-router.ts
import { spawnSync as spawnSync5 } from "node:child_process";
function normalizeNodeHeaders(headers) {
  const normalized = {};
  for (const [key, value] of Object.entries(headers)) {
    if (typeof value === "string") {
      normalized[key] = value;
      continue;
    }
    if (Array.isArray(value) && value.length > 0) {
      normalized[key] = value.join(", ");
    }
  }
  return normalized;
}
function toNodeRequest(req, hostname6, port) {
  const hostHeader = typeof req.headers.host === "string" && req.headers.host.trim() ? req.headers.host.trim() : `${hostname6}:${port}`;
  const requestUrl = new URL(req.url || "/", `http://${hostHeader}`);
  return new Request(requestUrl, {
    method: req.method ?? "GET",
    headers: normalizeNodeHeaders(req.headers)
  });
}
async function sendNodeResponse(req, res, response) {
  res.statusCode = response.status;
  for (const [key, value] of response.headers.entries()) {
    res.setHeader(key, value);
  }
  if ((req.method ?? "GET").toUpperCase() === "HEAD") {
    res.end();
    return;
  }
  if (!response.body) {
    res.end();
    return;
  }
  const body = Buffer.from(await response.arrayBuffer());
  res.end(body);
}
function reserveGatewayPort(hostname6, configuredPort) {
  if (configuredPort > 0) {
    return configuredPort;
  }
  const script = [
    "const net=require('node:net');",
    'const host=process.argv[1]||"127.0.0.1";',
    "const s=net.createServer();",
    "s.listen(0,host,()=>{",
    "const address=s.address();",
    "if(address&&typeof address==='object'){process.stdout.write(String(address.port));}",
    "s.close(()=>process.exit(0));",
    "});",
    "s.on('error',()=>process.exit(1));"
  ].join("");
  const probe = spawnSync5("node", ["-e", script, hostname6], {
    encoding: "utf-8",
    stdio: ["ignore", "pipe", "pipe"],
    windowsHide: true
  });
  if (probe.status !== 0) {
    throw new Error(`gateway_port_reservation_failed:${String(probe.stderr || "").trim()}`);
  }
  const reserved = Number(String(probe.stdout || "").trim());
  if (!Number.isFinite(reserved) || reserved <= 0) {
    throw new Error("gateway_port_reservation_invalid");
  }
  return Math.floor(reserved);
}
var init_http_router = __esm({
  "src/gateway/http-router.ts"() {
    "use strict";
  }
});

// src/gateway/negotiation-budget.ts
function nowIso23() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function sanitizeBudget(input) {
  const autoRetry = Number.isFinite(input.autoRetry) ? Math.max(0, Math.floor(input.autoRetry)) : 0;
  const humanEdit = Number.isFinite(input.humanEdit) ? Math.max(0, Math.floor(input.humanEdit)) : 0;
  return { autoRetry, humanEdit };
}
function applyNegotiationBudget(store, input) {
  const budget = sanitizeBudget(input.budget);
  const fixability = input.fixability;
  const existing = store.get(input.key);
  const state = existing ? {
    ...existing,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    updatedAt: nowIso23()
  } : {
    key: input.key,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    autoUsed: 0,
    humanUsed: 0,
    updatedAt: nowIso23()
  };
  if (!input.attemptType) {
    store.set(input.key, state);
    return { allowed: true, state };
  }
  if (state.fixability === "impossible") {
    store.set(input.key, state);
    return { allowed: false, reason: "fixability_impossible", state };
  }
  if (input.attemptType === "auto") {
    if (state.autoUsed >= state.budget.autoRetry) {
      store.set(input.key, state);
      return { allowed: false, reason: "auto_retry_exhausted", state };
    }
    state.autoUsed += 1;
  } else {
    if (state.humanUsed >= state.budget.humanEdit) {
      store.set(input.key, state);
      return { allowed: false, reason: "human_edit_exhausted", state };
    }
    state.humanUsed += 1;
  }
  state.updatedAt = nowIso23();
  store.set(input.key, state);
  return { allowed: true, state };
}
var init_negotiation_budget = __esm({
  "src/gateway/negotiation-budget.ts"() {
    "use strict";
  }
});

// src/gateway/methods/channels.ts
function registerChannelMethods(deps) {
  const { methods, projectDir, parseText: parseText2, parseChannel: parseChannel2 } = deps;
  methods.register(
    "channels.list",
    async () => deps.runtime.channelRuntime.listChannels()
  );
  methods.register("channels.status", async () => ({
    channels: deps.runtime.channelRuntime.listChannels(),
    pendingPairs: deps.runtime.channelRuntime.listPairs("pending")
  }));
  methods.register("channels.pair.list", async (params) => {
    if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
      return deps.runtime.channelRuntime.listPairs(params.status);
    }
    return deps.runtime.channelRuntime.listPairs();
  });
  methods.register("channels.pair.approve", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return deps.runtime.channelRuntime.approvePair(pairID);
  });
  methods.register("channels.pair.reject", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return deps.runtime.channelRuntime.rejectPair(pairID);
  });
  methods.register("channels.contact.tier.set", async (params) => {
    const channel = parseChannel2(params.channel);
    const senderID = parseText2(params.senderID);
    const tier = parseText2(params.tier);
    if (!channel || !senderID)
      throw new Error("invalid_channels_contact_tier_args");
    if (tier !== "owner" && tier !== "friend") {
      throw new Error("invalid_channels_contact_tier");
    }
    return setContactTier(projectDir, channel, senderID, tier);
  });
  methods.register("channels.contact.tier.get", async (params) => {
    const channel = parseChannel2(params.channel);
    const senderID = parseText2(params.senderID);
    if (!channel || !senderID)
      throw new Error("invalid_channels_contact_tier_args");
    return {
      channel,
      senderID,
      tier: getContactTier(projectDir, channel, senderID)
    };
  });
  methods.register("channels.contact.tier.list", async (params) => {
    const channel = parseChannel2(params.channel);
    return {
      contacts: listContactTiers(projectDir, channel ?? void 0)
    };
  });
  methods.register("channels.message.send", async (params) => {
    const channel = parseChannel2(params.channel);
    const destination = parseText2(params.destination);
    const text = parseText2(params.text);
    const mediaID = parseText2(params.mediaID);
    const mediaPathInput = parseText2(params.mediaPath);
    const idempotencyKey = parseText2(params.idempotencyKey);
    const sessionID = parseText2(params.sessionID) || "main";
    const policyHash = parseText2(params.policyHash) || void 0;
    const mediaFromStore = mediaID ? getMediaItem(projectDir, mediaID) : null;
    const mediaPath = mediaPathInput || mediaFromStore?.localPath || "";
    if (!channel || !destination || !text && !mediaPath) {
      throw new Error("invalid_channels_send_args");
    }
    const outboundCheckRaw = params.outboundCheck && typeof params.outboundCheck === "object" ? params.outboundCheck : null;
    const outboundCheck = {
      archAdvisorApproved: outboundCheckRaw && typeof outboundCheckRaw.archAdvisorApproved === "boolean" ? Boolean(outboundCheckRaw.archAdvisorApproved) : void 0,
      intent: outboundCheckRaw && typeof outboundCheckRaw.intent === "string" ? String(outboundCheckRaw.intent) : void 0,
      factorRecipientIsMe: outboundCheckRaw && typeof outboundCheckRaw.factorRecipientIsMe === "boolean" ? Boolean(outboundCheckRaw.factorRecipientIsMe) : void 0,
      userInitiated: outboundCheckRaw && typeof outboundCheckRaw.userInitiated === "boolean" ? Boolean(outboundCheckRaw.userInitiated) : void 0,
      negotiationID: outboundCheckRaw && typeof outboundCheckRaw.negotiationID === "string" ? String(outboundCheckRaw.negotiationID) : void 0,
      retryAttemptType: outboundCheckRaw && (outboundCheckRaw.retryAttemptType === "auto" || outboundCheckRaw.retryAttemptType === "human") ? outboundCheckRaw.retryAttemptType : void 0,
      evidenceConfidence: outboundCheckRaw && typeof outboundCheckRaw.evidenceConfidence === "number" && Number.isFinite(outboundCheckRaw.evidenceConfidence) ? Number(outboundCheckRaw.evidenceConfidence) : void 0,
      captureLimitations: outboundCheckRaw && Array.isArray(outboundCheckRaw.captureLimitations) ? outboundCheckRaw.captureLimitations.filter((item) => typeof item === "string").map((item) => item.trim()).filter((item) => item.length > 0).slice(0, 32) : void 0,
      psycheSignals: outboundCheckRaw?.psycheSignals && typeof outboundCheckRaw.psycheSignals === "object" && !Array.isArray(outboundCheckRaw.psycheSignals) ? outboundCheckRaw.psycheSignals : void 0
    };
    const confirmationRaw = params.confirmation && typeof params.confirmation === "object" ? params.confirmation : null;
    return deps.sendChannelMessageGuarded({
      channel,
      destination,
      text,
      mediaPath,
      idempotencyKey,
      sessionID,
      policyHash,
      outboundCheck,
      confirmation: {
        physicalConfirmed: confirmationRaw && typeof confirmationRaw.physicalConfirmed === "boolean" ? Boolean(confirmationRaw.physicalConfirmed) : void 0,
        password: confirmationRaw && typeof confirmationRaw.password === "string" ? String(confirmationRaw.password) : void 0,
        passphrase: confirmationRaw && typeof confirmationRaw.passphrase === "string" ? String(confirmationRaw.passphrase) : void 0,
        ownerSyncToken: confirmationRaw && typeof confirmationRaw.ownerSyncToken === "string" ? String(confirmationRaw.ownerSyncToken) : void 0
      }
    });
  });
}
var init_channels = __esm({
  "src/gateway/methods/channels.ts"() {
    "use strict";
    init_channel();
    init_store2();
  }
});

// src/gateway/methods/memory.ts
import {
  randomUUID as randomUUID16
} from "node:crypto";
function registerMemoryMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  const isMemoryRuntimeUnavailable = (error92) => String(error92 instanceof Error ? error92.message : error92).includes(
    "sqlite_runtime_unavailable"
  );
  const createDegradedCandidate = (fact) => {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    return {
      id: `volatile_${randomUUID16()}`,
      text: fact,
      source: "conversation",
      embedding: [],
      score: 0,
      confidence: 0.3,
      tier: "L2",
      status: "candidate",
      accessCount: 0,
      isArchived: false,
      createdAt: now,
      updatedAt: now,
      lastAccessedAt: now
    };
  };
  methods.register("companion.memory.add", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    const fact = parseText2(params.fact);
    if (!fact) throw new Error("invalid_memory_fact");
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    let created;
    let degraded = false;
    try {
      created = upsertCompanionMemoryVector(projectDir, {
        text: fact,
        source: "conversation",
        activate: false,
        sourceType: parseText2(params.sourceType) === "direct_correction" ? "direct_correction" : "conversation"
      });
    } catch (error92) {
      if (!isMemoryRuntimeUnavailable(error92)) throw error92;
      created = createDegradedCandidate(fact);
      degraded = true;
    }
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    const learningGate = deps.getLearningGate();
    return {
      memory: created,
      stage: created.status,
      learningGate: {
        stage: "candidate",
        approvalMode: learningGate.candidateMode,
        interruptsUser: false
      },
      needsCorrectionWizard: Boolean(created.conflictWizardID),
      message: created.conflictWizardID ? "memory_pending_conflict_requires_correction_wizard" : degraded ? "memory_pending_confirmation_required:degraded_sqlite_runtime" : "memory_pending_confirmation_required",
      profile
    };
  });
  methods.register("companion.memory.list", async () => {
    deps.requireOwnerMode(projectDir);
    return readCompanionProfile(projectDir).memoryFacts;
  });
  methods.register("companion.memory.pending.list", async () => {
    deps.requireOwnerMode(projectDir);
    return listPendingCompanionMemoryVectors(projectDir);
  });
  methods.register("companion.memory.corrections.list", async () => {
    deps.requireOwnerMode(projectDir);
    return listCompanionMemoryCorrections(projectDir);
  });
  methods.register("companion.memory.confirm", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText2(params.memoryID);
    const sessionID = parseText2(params.sessionID) || "main";
    if (!memoryID) throw new Error("invalid_memory_id");
    const learningGate = deps.getLearningGate();
    if (learningGate.persistentRequiresApproval) {
      const ticket = deps.resolveApprovalTicket({
        projectDir,
        sessionID,
        permission: "memory_write",
        patterns: [
          "memory_stage=persistent",
          `memory_id=${memoryID}`,
          "action=confirm"
        ]
      });
      if (!ticket.ok) throw new Error(`approval_required:${ticket.reason}`);
    }
    const confirm = typeof params.confirm === "boolean" ? Boolean(params.confirm) : true;
    const updated = confirmCompanionMemoryVector(projectDir, {
      memoryID,
      confirm,
      supersedeConflicts: typeof params.supersedeConflicts === "boolean" ? Boolean(params.supersedeConflicts) : true
    });
    if (!updated) throw new Error("memory_not_found");
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return {
      memory: updated,
      stage: updated.status,
      learningGate: {
        stage: "persistent",
        approvalMode: learningGate.persistentRequiresApproval ? "modal_approval" : "toast_gate",
        interruptsUser: learningGate.persistentRequiresApproval
      },
      profile
    };
  });
  methods.register("companion.memory.update", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText2(params.memoryID);
    if (!memoryID) throw new Error("invalid_memory_id");
    const updated = updateCompanionMemoryVector(projectDir, {
      memoryID,
      text: parseText2(params.text) || void 0,
      memoryKind: parseText2(params.memoryKind) === "Fact" || parseText2(params.memoryKind) === "Insight" || parseText2(params.memoryKind) === "UserPreference" ? parseText2(params.memoryKind) : void 0,
      confidence: typeof params.confidence === "number" && Number.isFinite(params.confidence) ? Number(params.confidence) : void 0,
      tier: parseText2(params.tier) === "L0" || parseText2(params.tier) === "L1" || parseText2(params.tier) === "L2" || parseText2(params.tier) === "L3" ? parseText2(params.tier) : void 0,
      status: parseText2(params.status) === "candidate" || parseText2(params.status) === "pending" || parseText2(params.status) === "active" || parseText2(params.status) === "superseded" || parseText2(params.status) === "archived" ? parseText2(params.status) : void 0
    });
    if (!updated) throw new Error("memory_not_found");
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return { memory: updated, profile };
  });
  methods.register("companion.memory.archive", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText2(params.memoryID);
    if (!memoryID) throw new Error("invalid_memory_id");
    const archived = typeof params.archived === "boolean" ? Boolean(params.archived) : true;
    const updated = archiveCompanionMemoryVector(projectDir, {
      memoryID,
      archived
    });
    if (!updated) throw new Error("memory_not_found");
    return { memory: updated };
  });
  methods.register("companion.memory.search", async (params) => {
    deps.requireOwnerMode(projectDir);
    const query = parseText2(params.query);
    if (!query) throw new Error("invalid_memory_query");
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(20, Number(params.limit)) : 5;
    const threshold = typeof params.threshold === "number" && params.threshold >= 0 ? Number(params.threshold) : void 0;
    const recencyHalfLifeDays = typeof params.recencyHalfLifeDays === "number" && params.recencyHalfLifeDays > 0 ? Number(params.recencyHalfLifeDays) : void 0;
    return searchCompanionMemoryVectors(projectDir, query, limit, {
      threshold,
      recencyHalfLifeDays,
      mode: parseText2(params.mode) === "vector" || parseText2(params.mode) === "keyword" ? parseText2(params.mode) : "hybrid"
    });
  });
  methods.register("companion.memory.decay", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const halfLifeDays = typeof params.halfLifeDays === "number" && params.halfLifeDays > 0 ? Number(params.halfLifeDays) : 30;
    return decayCompanionMemoryVectors(projectDir, halfLifeDays);
  });
  methods.register("companion.memory.vector.list", async () => {
    deps.requireOwnerMode(projectDir);
    return listCompanionMemoryVectors(projectDir);
  });
}
var init_memory = __esm({
  "src/gateway/methods/memory.ts"() {
    "use strict";
    init_memory_vector();
    init_store4();
  }
});

// src/gateway/protocol.ts
function parseIncomingFrame(message) {
  let payload = message;
  if (typeof message === "string") {
    const raw = message.trim();
    if (!raw) return { error: "empty_message" };
    if (raw === "status") {
      payload = { type: "request", id: "legacy-status", method: "gateway.status.get", params: {} };
    } else {
      try {
        payload = JSON.parse(raw);
      } catch {
        return { error: "invalid_json" };
      }
    }
  }
  try {
    const frame = GatewayIncomingFrameSchema.parse(payload);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}
function toResponseFrame(input) {
  const result = toJsonCompatible(input.result);
  const errorDetails = toJsonCompatible(input.errorDetails);
  if (input.ok) {
    return ResponseFrameSchema.parse({
      type: "response",
      id: input.id,
      ok: true,
      result
    });
  }
  return ResponseFrameSchema.parse({
    type: "response",
    id: input.id,
    ok: false,
    error: {
      code: input.errorCode ?? "internal_error",
      message: input.errorMessage ?? "Internal error",
      details: errorDetails
    }
  });
}
function toEventFrame(input) {
  const payload = toJsonCompatible(input.payload);
  return EventFrameSchema.parse({
    type: "event",
    event: input.event,
    payload,
    stateVersion: input.stateVersion
  });
}
function toPongFrame(ts) {
  return PongFrameSchema.parse({
    type: "pong",
    ts
  });
}
function toJsonCompatible(input) {
  if (input === void 0) return null;
  if (input === null) return null;
  if (typeof input === "string" || typeof input === "number" || typeof input === "boolean") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map((item) => toJsonCompatible(item));
  }
  if (typeof input === "object") {
    const source = input;
    const next = {};
    for (const [key, value] of Object.entries(source)) {
      if (value === void 0) continue;
      next[key] = toJsonCompatible(value);
    }
    return next;
  }
  return String(input);
}
var JsonValue, JsonObject, HelloFrameSchema, RequestFrameSchema, PingFrameSchema, PongFrameSchema, ResponseFrameSchema, EventFrameSchema, GatewayIncomingFrameSchema, GatewayOutgoingFrameSchema, GatewayMethodRegistry;
var init_protocol = __esm({
  "src/gateway/protocol.ts"() {
    "use strict";
    init_zod();
    JsonValue = external_exports.lazy(
      () => external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean(), external_exports.null(), external_exports.array(JsonValue), external_exports.record(external_exports.string(), JsonValue)])
    );
    JsonObject = external_exports.record(external_exports.string(), JsonValue);
    HelloFrameSchema = external_exports.object({
      type: external_exports.literal("hello"),
      role: external_exports.enum(["ui", "admin", "node", "channel", "unknown"]).default("unknown"),
      clientID: external_exports.string().optional(),
      protocolVersion: external_exports.string().optional(),
      auth: external_exports.object({
        token: external_exports.string().optional()
      }).optional(),
      capabilities: external_exports.array(external_exports.string()).optional()
    });
    RequestFrameSchema = external_exports.object({
      type: external_exports.literal("request"),
      id: external_exports.string().min(1),
      method: external_exports.string().min(1),
      params: JsonObject.default({})
    });
    PingFrameSchema = external_exports.object({
      type: external_exports.literal("ping"),
      ts: external_exports.number().int().nonnegative()
    });
    PongFrameSchema = external_exports.object({
      type: external_exports.literal("pong"),
      ts: external_exports.number().int().nonnegative()
    });
    ResponseFrameSchema = external_exports.object({
      type: external_exports.literal("response"),
      id: external_exports.string(),
      ok: external_exports.boolean(),
      result: JsonValue.optional(),
      error: external_exports.object({
        code: external_exports.string(),
        message: external_exports.string(),
        details: JsonValue.optional()
      }).optional()
    });
    EventFrameSchema = external_exports.object({
      type: external_exports.literal("event"),
      event: external_exports.string().min(1),
      payload: JsonValue,
      stateVersion: external_exports.record(external_exports.string(), external_exports.number()).optional()
    });
    GatewayIncomingFrameSchema = external_exports.union([HelloFrameSchema, RequestFrameSchema, PingFrameSchema]);
    GatewayOutgoingFrameSchema = external_exports.union([ResponseFrameSchema, EventFrameSchema, PongFrameSchema]);
    GatewayMethodRegistry = class {
      handlers = /* @__PURE__ */ new Map();
      inFlight = 0;
      queue = [];
      rejectedOverloaded = 0;
      rejectedTimeout = 0;
      queueWaitSamplesMs = [];
      maxInFlight;
      maxQueued;
      queueTimeoutMs;
      constructor(options = {}) {
        this.maxInFlight = Math.max(
          1,
          Math.floor(
            options.maxInFlight ?? Number(process.env.MIYA_GATEWAY_MAX_IN_FLIGHT ?? 8)
          )
        );
        this.maxQueued = Math.max(
          1,
          Math.floor(
            options.maxQueued ?? Number(process.env.MIYA_GATEWAY_MAX_QUEUED ?? 64)
          )
        );
        this.queueTimeoutMs = Math.max(
          100,
          Math.floor(
            options.queueTimeoutMs ?? Number(process.env.MIYA_GATEWAY_QUEUE_TIMEOUT_MS ?? 15e3)
          )
        );
      }
      register(method, handler) {
        this.handlers.set(method, handler);
      }
      async invoke(method, params, context) {
        if (this.inFlight < this.maxInFlight) {
          return this.executeNow(method, params, context);
        }
        if (this.queue.length >= this.maxQueued) {
          this.rejectedOverloaded += 1;
          throw new Error(
            `gateway_backpressure_overloaded:in_flight=${this.inFlight}:queued=${this.queue.length}`
          );
        }
        return await new Promise((resolve4, reject) => {
          const queued = {
            method,
            params,
            context,
            enqueuedAtMs: Date.now(),
            resolve: resolve4,
            reject,
            timeout: setTimeout(() => {
              const index = this.queue.indexOf(queued);
              if (index >= 0) this.queue.splice(index, 1);
              this.rejectedTimeout += 1;
              reject(new Error("gateway_backpressure_timeout"));
            }, this.queueTimeoutMs)
          };
          this.queue.push(queued);
        });
      }
      list() {
        return [...this.handlers.keys()].sort();
      }
      stats() {
        const rejectedOverloaded = this.rejectedOverloaded;
        const rejectedTimeout = this.rejectedTimeout;
        const queueWaitMsP95 = this.queueWaitMsP95();
        return {
          inFlight: this.inFlight,
          queued: this.queue.length,
          maxInFlight: this.maxInFlight,
          maxQueued: this.maxQueued,
          rejected_overloaded: rejectedOverloaded,
          rejected_timeout: rejectedTimeout,
          queue_wait_ms_p95: queueWaitMsP95,
          rejectedOverloaded,
          rejectedTimeout,
          queueWaitMsP95
        };
      }
      async executeNow(method, params, context) {
        const handler = this.handlers.get(method);
        if (!handler) throw new Error(`unknown_method:${method}`);
        this.inFlight += 1;
        try {
          return await handler(params, context);
        } finally {
          this.inFlight = Math.max(0, this.inFlight - 1);
          this.drainQueue();
        }
      }
      drainQueue() {
        if (this.inFlight >= this.maxInFlight) return;
        const next = this.queue.shift();
        if (!next) return;
        clearTimeout(next.timeout);
        this.recordQueueWait(Date.now() - next.enqueuedAtMs);
        void this.executeNow(next.method, next.params, next.context).then((value) => next.resolve(value)).catch((error92) => next.reject(error92)).finally(() => {
          if (this.inFlight < this.maxInFlight && this.queue.length > 0) {
            this.drainQueue();
          }
        });
      }
      recordQueueWait(waitMs) {
        if (!Number.isFinite(waitMs) || waitMs < 0) return;
        this.queueWaitSamplesMs.push(waitMs);
        if (this.queueWaitSamplesMs.length > 256) {
          this.queueWaitSamplesMs.splice(0, this.queueWaitSamplesMs.length - 256);
        }
      }
      queueWaitMsP95() {
        if (this.queueWaitSamplesMs.length === 0) return 0;
        const sorted = [...this.queueWaitSamplesMs].sort((a, b) => a - b);
        const index = Math.max(
          0,
          Math.min(sorted.length - 1, Math.floor(sorted.length * 0.95))
        );
        return Math.floor(sorted[index] ?? 0);
      }
    };
  }
});

// src/gateway/methods/nodes.ts
function registerNodeMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("nodes.register", async (params, context) => {
    const nodeID = parseText2(params.nodeID);
    const deviceID = parseText2(params.deviceID);
    if (!nodeID || !deviceID) throw new Error("invalid_nodes_register_args");
    const node = registerNode(projectDir, {
      nodeID,
      deviceID,
      type: params.type === "cli" || params.type === "desktop" || params.type === "mobile" || params.type === "browser" ? params.type : void 0,
      platform: parseText2(params.platform) || process.platform,
      capabilities: Array.isArray(params.capabilities) ? params.capabilities.map(String) : [],
      token: parseText2(params.token) || void 0,
      permissions: params.permissions && typeof params.permissions === "object" ? {
        screenRecording: typeof params.permissions.screenRecording === "boolean" ? Boolean(
          params.permissions.screenRecording
        ) : void 0,
        accessibility: typeof params.permissions.accessibility === "boolean" ? Boolean(
          params.permissions.accessibility
        ) : void 0,
        filesystem: params.permissions.filesystem === "none" || params.permissions.filesystem === "read" || params.permissions.filesystem === "full" ? params.permissions.filesystem : void 0,
        network: typeof params.permissions.network === "boolean" ? Boolean(
          params.permissions.network
        ) : void 0
      } : void 0
    });
    const pair = createNodePairRequest(projectDir, { nodeID, deviceID });
    const ws = context.ws;
    if (ws) deps.runtime.nodeSockets.set(nodeID, ws);
    return { node, pair };
  });
  methods.register("nodes.list", async () => listNodes(projectDir));
  methods.register("nodes.heartbeat", async (params) => {
    const nodeID = parseText2(params.nodeID);
    if (!nodeID) throw new Error("invalid_node_id");
    const node = touchNodeHeartbeat(projectDir, nodeID);
    if (!node) throw new Error("node_not_found");
    return node;
  });
  methods.register("nodes.token.issue", async (params) => {
    const nodeID = parseText2(params.nodeID);
    if (!nodeID) throw new Error("invalid_node_id");
    const issued = issueNodeToken(projectDir, nodeID);
    if (!issued) throw new Error("node_not_found");
    return issued;
  });
  methods.register("nodes.status", async () => ({
    nodes: listNodes(projectDir),
    pendingPairs: listNodePairs(projectDir, "pending")
  }));
  methods.register("nodes.describe", async (params) => {
    const nodeID = parseText2(params.nodeID);
    if (!nodeID) throw new Error("invalid_node_id");
    return describeNode(projectDir, nodeID);
  });
  methods.register("nodes.pair.list", async (params) => {
    if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
      return listNodePairs(projectDir, params.status);
    }
    return listNodePairs(projectDir);
  });
  methods.register("nodes.pair.approve", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return resolveNodePair(projectDir, pairID, "approved");
  });
  methods.register("nodes.pair.reject", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return resolveNodePair(projectDir, pairID, "rejected");
  });
  methods.register("nodes.invoke", async (params) => {
    const nodeID = parseText2(params.nodeID);
    const capability = parseText2(params.capability);
    const sessionID = parseText2(params.sessionID) || "main";
    const policyHash = parseText2(params.policyHash) || void 0;
    const args = params.args && typeof params.args === "object" ? params.args : {};
    if (!nodeID || !capability) throw new Error("invalid_nodes_invoke_args");
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "desktop_control");
    const token = deps.enforceToken({
      projectDir,
      sessionID,
      permission: "node_invoke",
      patterns: [
        `nodeId=${nodeID}`,
        `cap=${capability}`,
        `args_sha256=${deps.hashText(JSON.stringify(args))}`
      ]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    const invoke = createInvokeRequest(projectDir, {
      nodeID,
      capability,
      args
    });
    markInvokeSent(projectDir, invoke.id);
    const nodeSocket = deps.runtime.nodeSockets.get(nodeID);
    if (nodeSocket) {
      nodeSocket.send(
        JSON.stringify(
          toEventFrame({
            event: "node.invoke.request",
            payload: invoke,
            stateVersion: { gateway: deps.runtime.stateVersion }
          })
        )
      );
    }
    return invoke;
  });
  methods.register("nodes.invoke.result", async (params) => {
    const invokeID = parseText2(params.invokeID);
    if (!invokeID) throw new Error("invalid_invoke_id");
    return resolveInvokeResult(projectDir, invokeID, {
      ok: Boolean(params.ok),
      result: params.result && typeof params.result === "object" ? params.result : void 0,
      error: parseText2(params.error) || void 0
    });
  });
  methods.register("devices.list", async () => listDevices(projectDir));
  methods.register("nodes.invokes.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(200, Math.floor(params.limit)) : 40;
    return listInvokeRequests(projectDir, limit);
  });
}
var init_nodes2 = __esm({
  "src/gateway/methods/nodes.ts"() {
    "use strict";
    init_nodes();
    init_protocol();
  }
});

// src/gateway/methods/sessions.ts
function registerSessionMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("sessions.list", async () => listSessions(projectDir));
  methods.register("sessions.get", async (params) => {
    const sessionID = parseText2(params.sessionID);
    if (!sessionID) throw new Error("invalid_session_id");
    return getSession(projectDir, sessionID);
  });
  methods.register("sessions.policy.set", async (params) => {
    const sessionID = parseText2(params.sessionID);
    const policyHash = parseText2(params.policyHash) || void 0;
    if (!sessionID) throw new Error("invalid_session_id");
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const patch = {};
    if (params.activation === "active" || params.activation === "queued" || params.activation === "muted") {
      patch.activation = params.activation;
    }
    if (params.reply === "auto" || params.reply === "manual" || params.reply === "summary_only") {
      patch.reply = params.reply;
    }
    if (params.queueStrategy === "fifo" || params.queueStrategy === "priority" || params.queueStrategy === "cooldown") {
      patch.queueStrategy = params.queueStrategy;
    }
    const updated = setSessionPolicy(projectDir, sessionID, patch);
    if (!updated) throw new Error("session_not_found");
    return updated;
  });
  methods.register("sessions.send", async (params) => {
    const sessionID = parseText2(params.sessionID);
    const text = parseText2(params.text);
    if (!sessionID || !text) throw new Error("invalid_sessions_send_args");
    if (text.trim() === "/start") {
      const wizard = isCompanionWizardEmpty(projectDir, sessionID) ? startCompanionWizard(projectDir, { sessionId: sessionID }) : readCompanionWizardState(projectDir, sessionID);
      return {
        sessionID: wizard.sessionId,
        wizard,
        checklist: wizardChecklist(wizard),
        message: wizard.state === "awaiting_photos" ? deps.wizardPromptPhotos : `\u68C0\u6D4B\u5230\u5DF2\u6709\u5411\u5BFC\u8FDB\u5EA6\uFF0C\u5DF2\u6062\u590D\u7EE7\u7EED\u3002${deps.wizardPromptByState(wizard.state)}`,
        instruction: "\u5C06\u7167\u7247\u62D6\u62FD\u5230\u804A\u5929\u4E2D"
      };
    }
    if (text.trim() === "/reset_personality") {
      const wizard = resetCompanionWizard(projectDir, sessionID);
      return {
        sessionID: wizard.sessionId,
        wizard,
        message: "\u5DF2\u91CD\u7F6E\u4EBA\u683C\u8D44\u4EA7\uFF0C\u8BF7\u91CD\u65B0\u5F00\u59CB /start"
      };
    }
    upsertSession(projectDir, {
      id: sessionID,
      kind: sessionID.startsWith("opencode:") ? "opencode" : "channel",
      groupId: sessionID,
      routingSessionID: parseText2(params.routingSessionID) || "main",
      agent: parseText2(params.agent) || "1-task-manager"
    });
    return deps.routeSessionMessage(projectDir, {
      sessionID,
      text,
      source: parseText2(params.source) || "gateway"
    });
  });
}
var init_sessions2 = __esm({
  "src/gateway/methods/sessions.ts"() {
    "use strict";
    init_wizard();
    init_sessions();
  }
});

// src/gateway/methods/registry.ts
function registerCoreSessionMethods(deps) {
  registerSessionMethods(deps);
}
var init_registry2 = __esm({
  "src/gateway/methods/registry.ts"() {
    "use strict";
    init_sessions2();
  }
});

// src/gateway/methods/security.ts
function registerSecurityMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("security.identity.status", async () => {
    const state = readOwnerIdentityState(projectDir);
    return {
      ...state,
      passwordHash: state.passwordHash ? "***" : void 0,
      passphraseHash: state.passphraseHash ? "***" : void 0
    };
  });
  methods.register("security.identity.init", async (params) => {
    const password = parseText2(params.password);
    const passphrase = parseText2(params.passphrase);
    if (!password || !passphrase) throw new Error("invalid_owner_secret_input");
    const next = initOwnerIdentity(projectDir, {
      password,
      passphrase,
      voiceprintEmbeddingID: parseText2(params.voiceprintEmbeddingID) || void 0,
      voiceprintModelPath: parseText2(params.voiceprintModelPath) || void 0,
      voiceprintSampleDir: parseText2(params.voiceprintSampleDir) || void 0,
      voiceprintThresholds: {
        ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : void 0,
        guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : void 0,
        ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : void 0,
        guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : void 0,
        ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : void 0,
        minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : void 0,
        farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : void 0,
        frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : void 0
      }
    });
    return {
      ...next,
      passwordHash: "***",
      passphraseHash: "***"
    };
  });
  methods.register("security.identity.rotate", async (params) => {
    const newPassword = parseText2(params.newPassword);
    const newPassphrase = parseText2(params.newPassphrase);
    if (!newPassword || !newPassphrase)
      throw new Error("invalid_new_owner_secret");
    const next = rotateOwnerSecrets(projectDir, {
      currentPassword: parseText2(params.currentPassword) || void 0,
      currentPassphrase: parseText2(params.currentPassphrase) || void 0,
      newPassword,
      newPassphrase
    });
    return {
      ...next,
      passwordHash: "***",
      passphraseHash: "***"
    };
  });
  methods.register("security.voiceprint.threshold.get", async () => {
    const state = readOwnerIdentityState(projectDir);
    return {
      ...state.voiceprintThresholds
    };
  });
  methods.register("security.voiceprint.threshold.set", async (params) => {
    const next = updateVoiceprintThresholds(projectDir, {
      ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : void 0,
      guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : void 0,
      ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : void 0,
      guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : void 0,
      ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : void 0,
      minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : void 0,
      farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : void 0,
      frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : void 0
    });
    return {
      ...next.voiceprintThresholds
    };
  });
  methods.register("security.owner_sync.issue", async (params) => {
    const action = parseText2(params.action) || "outbound.high_risk.send";
    const payloadHash = parseText2(params.payloadHash);
    if (!payloadHash) throw new Error("invalid_payload_hash");
    return issueOwnerSyncToken(projectDir, {
      action,
      payloadHash,
      ttlMs: typeof params.ttlMs === "number" ? Number(params.ttlMs) : void 0
    });
  });
}
var init_security = __esm({
  "src/gateway/methods/security.ts"() {
    "use strict";
    init_owner_identity();
    init_owner_sync();
  }
});

// src/gateway/methods/voice.ts
function registerVoiceMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("voice.status", async () => readVoiceState(projectDir));
  methods.register("voice.wake.enable", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      enabled: true,
      wakeWordEnabled: true
    });
  });
  methods.register("voice.wake.disable", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      wakeWordEnabled: false
    });
  });
  methods.register("voice.talk.start", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      enabled: true,
      talkMode: true,
      routeSessionID: parseText2(params.sessionID) || readVoiceState(projectDir).routeSessionID
    });
  });
  methods.register("voice.talk.stop", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      talkMode: false
    });
  });
  methods.register("voice.input.ingest", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const mediaID = parseText2(params.mediaID) || void 0;
    const source = parseText2(params.source) === "wake" || parseText2(params.source) === "talk" || parseText2(params.source) === "media" ? parseText2(params.source) : "manual";
    const language = parseText2(params.language) || void 0;
    const speakerHint = parseText2(params.speakerHint) || void 0;
    const speakerScore = typeof params.speakerScore === "number" ? Number(params.speakerScore) : void 0;
    const mediaPath = mediaID ? getMediaItem(projectDir, mediaID)?.localPath : void 0;
    const voiceprint = await deps.verifyVoiceprintWithLocalModel(projectDir, {
      mediaPath,
      speakerHint,
      speakerScore
    });
    const mode = voiceprint.mode;
    setInteractionMode(projectDir, mode);
    if (mode !== "owner") {
      transitionSafetyState(projectDir, {
        source: "speaker_gate",
        reason: `speaker_mode_${mode}`,
        domains: {
          outbound_send: "paused",
          desktop_control: "paused",
          memory_read: "paused"
        }
      });
    }
    let text = parseText2(params.text);
    if (!text && mediaID) {
      const media = getMediaItem(projectDir, mediaID);
      const transcript = media?.metadata?.transcript;
      text = typeof transcript === "string" && transcript.trim() ? transcript.trim() : `[media:${mediaID}]`;
    }
    if (!text) throw new Error("invalid_voice_input");
    if (mode === "guest") {
      appendGuestConversation(projectDir, {
        text,
        source,
        sessionID: parseText2(params.sessionID) || "main"
      });
      return {
        item: appendVoiceHistory(projectDir, {
          text,
          source,
          language,
          mediaID
        }),
        routed: {
          delivered: false,
          queued: false,
          reason: "guest_mode_restricted"
        },
        mode,
        voiceprint,
        reply: "\u4E0D\u597D\u610F\u601D\uFF0C\u6211\u73B0\u5728\u53EA\u80FD\u542C\u4E3B\u4EBA\u7684\u6307\u4EE4\u54E6\uFF0C\u4F46\u6211\u53EF\u4EE5\u966A\u4F60\u804A\u5929\u3002",
        voice: readVoiceState(projectDir)
      };
    }
    const item = appendVoiceHistory(projectDir, {
      text,
      source,
      language,
      mediaID
    });
    const voice = readVoiceState(projectDir);
    const targetSessionID = parseText2(params.sessionID) || voice.routeSessionID || "main";
    const routed = await deps.routeSessionMessage(projectDir, {
      sessionID: targetSessionID,
      text,
      source: `voice:${source}`
    });
    return {
      item,
      routed,
      mode,
      voiceprint,
      voice: readVoiceState(projectDir)
    };
  });
  methods.register("voice.history.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return readVoiceState(projectDir).history.slice(0, limit);
  });
  methods.register("voice.history.clear", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_delete");
    return clearVoiceHistory(projectDir);
  });
}
var init_voice2 = __esm({
  "src/gateway/methods/voice.ts"() {
    "use strict";
    init_store2();
    init_state_machine();
    init_owner_identity();
    init_state2();
  }
});

// src/gateway/ownership-lock.ts
function isProcessAlive(pid) {
  if (!Number.isFinite(pid) || pid <= 0) return false;
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
var init_ownership_lock = __esm({
  "src/gateway/ownership-lock.ts"() {
    "use strict";
  }
});

// src/gateway/render/console.ts
function renderConsoleHtml(snapshot) {
  const payload = JSON.stringify(snapshot).replace(/</g, "\\u003c");
  return `<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya Gateway React</title>
  <style>
    body { margin: 0; font-family: "Segoe UI", "Microsoft YaHei", sans-serif; background: #0f172a; color: #e2e8f0; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .row { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); margin-bottom: 12px; }
    .card { background: #111827; border: 1px solid #1f2937; border-radius: 10px; padding: 12px; }
    .title { color: #93c5fd; font-size: 12px; text-transform: uppercase; }
    .value { font-size: 20px; font-weight: 700; margin-top: 6px; }
    .ok { color: #4ade80; }
    .bad { color: #f87171; }
    textarea { width: 100%; min-height: 220px; resize: vertical; background: #020617; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; padding: 8px; font-family: Consolas, monospace; }
    button { background: #2563eb; color: #fff; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .line { margin: 6px 0; color: #cbd5e1; font-size: 13px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Miya Gateway</h2>
    <div id="daemonStatus" class="line">loading...</div>
    <div class="row">
      <div class="card">
        <div class="title">Daemon CPU/VRAM/Uptime</div>
        <div id="daemonStats" class="value">--</div>
        <div id="daemonJob" class="line">Active Job: --</div>
      </div>
      <div class="card">
        <div class="title">Sessions</div>
        <div id="sessionsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Jobs</div>
        <div id="jobsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Autoflow</div>
        <div id="autoflowValue" class="value">0 active</div>
        <div id="autoflowPhase" class="line">phase: --</div>
      </div>
      <div class="card">
        <div class="title">Routing Cost</div>
        <div id="routingValue" class="value">--</div>
        <div id="routingStage" class="line">stage: --</div>
      </div>
      <div class="card">
        <div class="title">Learning HitRate</div>
        <div id="learningValue" class="value">--</div>
        <div id="learningDrafts" class="line">drafts: --</div>
      </div>
      <div class="card">
        <div class="title">Policy Hash</div>
        <div id="policyHash" class="line">--</div>
      </div>
    </div>
    <div class="card">
      <div class="title">Configuration Center (read/write .opencode/miya/config.json)</div>
      <div class="line">Patch JSON format: { set: {"ui.language":"zh-CN"}, unset: [] }</div>
      <textarea id="patchText">{"set":{},"unset":[]}</textarea>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <button id="saveButton">\u4FDD\u5B58\u914D\u7F6E</button>
        <span id="saveState" class="line">idle</span>
      </div>
      <pre id="configJson" class="line" style="white-space:pre-wrap;max-height:220px;overflow:auto"></pre>
    </div>
  </div>
  <script>window.__MIYA_SNAPSHOT__ = ${payload};</script>
  <script>
    (function () {
      let state = window.__MIYA_SNAPSHOT__ || {};
      const patchInput = document.getElementById('patchText');
      const saveButton = document.getElementById('saveButton');
      const saveState = document.getElementById('saveState');
      const daemonStatus = document.getElementById('daemonStatus');
      const daemonStats = document.getElementById('daemonStats');
      const daemonJob = document.getElementById('daemonJob');
      const sessionsValue = document.getElementById('sessionsValue');
      const jobsValue = document.getElementById('jobsValue');
      const autoflowValue = document.getElementById('autoflowValue');
      const autoflowPhase = document.getElementById('autoflowPhase');
      const routingValue = document.getElementById('routingValue');
      const routingStage = document.getElementById('routingStage');
      const learningValue = document.getElementById('learningValue');
      const learningDrafts = document.getElementById('learningDrafts');
      const policyHash = document.getElementById('policyHash');
      const configJson = document.getElementById('configJson');

      let ws = null;
      let reqID = 1;
      const pending = new Map();

      function updateSave(value) {
        saveState.textContent = value;
        saveButton.disabled = value === 'saving';
      }

      function render(next) {
        state = next || {};
        const daemonOk = Boolean(state.daemon && state.daemon.connected);
        const label = daemonOk
          ? 'Miya Daemon Connected'
          : ((state.daemon && state.daemon.statusText) || 'Miya Daemon Disconnected');
        daemonStatus.textContent = label;
        daemonStatus.className = 'line ' + (daemonOk ? 'ok' : 'bad');

        const cpu =
          state.daemon && typeof state.daemon.cpuPercent === 'number'
            ? state.daemon.cpuPercent.toFixed(1) + '%'
            : '--';
        const vramUsed =
          state.daemon && typeof state.daemon.vramUsedMB === 'number' ? state.daemon.vramUsedMB : '--';
        const vramTotal =
          state.daemon && typeof state.daemon.vramTotalMB === 'number' ? state.daemon.vramTotalMB : '--';
        const uptime =
          state.daemon && typeof state.daemon.uptimeSec === 'number' ? state.daemon.uptimeSec + 's' : '--';
        daemonStats.textContent = cpu + ' | ' + vramUsed + '/' + vramTotal + ' MB | ' + uptime;

        const jobID = state.daemon && state.daemon.activeJobID ? state.daemon.activeJobID : '--';
        const jobProgress =
          state.daemon && typeof state.daemon.activeJobProgress === 'number'
            ? state.daemon.activeJobProgress + '%'
            : '--';
        daemonJob.textContent = 'Active Job: ' + jobID + ' | ' + jobProgress;

        sessionsValue.textContent =
          String((state.sessions && state.sessions.active) || 0) +
          '/' +
          String((state.sessions && state.sessions.total) || 0);
        jobsValue.textContent =
          String((state.jobs && state.jobs.enabled) || 0) +
          '/' +
          String((state.jobs && state.jobs.total) || 0);
        const activeAutoflow = (state.autoflow && state.autoflow.active) || 0;
        autoflowValue.textContent = String(activeAutoflow) + ' active';
        const firstAutoflow = state.autoflow && state.autoflow.sessions && state.autoflow.sessions[0];
        autoflowPhase.textContent =
          'phase: ' + (firstAutoflow && firstAutoflow.phase ? firstAutoflow.phase : '--');
        const routingCost =
          state.routing && state.routing.cost ? state.routing.cost : null;
        if (routingCost) {
          routingValue.textContent =
            String(routingCost.totalTokensEstimate || 0) +
            ' tk | save ' +
            String(routingCost.savingsPercentEstimate || 0) +
            '%';
        } else {
          routingValue.textContent = '--';
        }
        routingStage.textContent =
          'stage: ' + ((state.routing && state.routing.forcedStage) || (state.routing && state.routing.ecoMode ? 'eco' : 'auto') || '--');
        const learningStats =
          state.learning && state.learning.stats ? state.learning.stats : null;
        if (learningStats) {
          learningValue.textContent =
            (Number(learningStats.hitRate || 0) * 100).toFixed(1) + '%';
          learningDrafts.textContent =
            'drafts: ' + String(learningStats.total || 0) + ' | uses: ' + String(learningStats.totalUses || 0);
        } else {
          learningValue.textContent = '--';
          learningDrafts.textContent = 'drafts: --';
        }
        policyHash.textContent = state.policyHash || '--';
        configJson.textContent = JSON.stringify(state.configCenter || {}, null, 2);
      }

      function sendReq(method, params) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          return Promise.reject(new Error('ws_not_open'));
        }
        const id = 'r-' + reqID++;
        ws.send(JSON.stringify({ type: 'request', id, method, params }));
        return new Promise((resolve, reject) => {
          const timer = setTimeout(() => {
            pending.delete(id);
            reject(new Error('request_timeout'));
          }, 8000);
          pending.set(id, { resolve, reject, timer });
        });
      }

      async function loadStatus() {
        try {
          const res = await fetch('/api/status', { cache: 'no-store' });
          const data = await res.json();
          render(data);
        } catch {}
      }

      function openWs() {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        const token =
          new URLSearchParams(location.search).get('token') ||
          localStorage.getItem('miya_gateway_token') ||
          '';
        if (token) localStorage.setItem('miya_gateway_token', token);

        ws = new WebSocket(proto + '://' + location.host + '/ws');
        ws.onopen = function () {
          ws.send(
            JSON.stringify({
              type: 'hello',
              role: 'ui',
              protocolVersion: '1.0',
              auth: token ? { token } : undefined,
            }),
          );
          ws.send(
            JSON.stringify({
              type: 'request',
              id: 'sub',
              method: 'gateway.subscribe',
              params: { events: ['*'] },
            }),
          );
        };
        ws.onmessage = function (evt) {
          try {
            const frame = JSON.parse(evt.data);
            if (frame.type === 'event' && frame.event === 'gateway.snapshot') {
              render(frame.payload);
              return;
            }
            if (frame.type === 'response') {
              const entry = pending.get(frame.id);
              if (!entry) return;
              pending.delete(frame.id);
              clearTimeout(entry.timer);
              if (frame.ok) entry.resolve(frame.result);
              else entry.reject(new Error((frame.error && frame.error.message) || 'request_failed'));
            }
          } catch {}
        };
        ws.onclose = function () {
          for (const entry of pending.values()) {
            clearTimeout(entry.timer);
            entry.reject(new Error('ws_closed'));
          }
          pending.clear();
        };
      }

      saveButton.addEventListener('click', async function () {
        updateSave('saving');
        try {
          const patch = JSON.parse(patchInput.value || '{}');
          await sendReq('config.center.patch', { patch, policyHash: state ? state.policyHash : undefined });
          updateSave('ok');
        } catch (err) {
          updateSave('error:' + String((err && err.message) || err));
        }
      });

      render(state);
      loadStatus();
      setInterval(loadStatus, 3000);
      openWs();
    })();
  </script>
</body>
</html>`;
}
var init_console = __esm({
  "src/gateway/render/console.ts"() {
    "use strict";
  }
});

// src/gateway/render/webchat.ts
function renderWebChatHtml() {
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya WebChat</title>
  <style>
    body{margin:0;font-family:Segoe UI,sans-serif;background:#0b1117;color:#e6edf7}
    main{max-width:900px;margin:0 auto;padding:14px;display:grid;gap:10px}
    #log{min-height:360px;border:1px solid #253047;border-radius:8px;background:#111827;padding:10px;white-space:pre-wrap}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px}
    input{border:1px solid #253047;border-radius:8px;background:#111827;color:#e6edf7;padding:8px}
    button{border:1px solid #253047;border-radius:8px;background:#1f6feb;color:#fff;padding:8px 12px;cursor:pointer}
  </style>
</head>
<body>
<main>
  <h2 style="margin:0">Miya WebChat</h2>
  <div id="log"></div>
  <div class="row"><input id="msg" placeholder="Type message"><button id="send">Send</button></div>
</main>
<script>
  const logEl=document.getElementById('log'); const msgEl=document.getElementById('msg'); const sendBtn=document.getElementById('send');
  const p=location.protocol==='https:'?'wss':'ws'; const ws=new WebSocket(p+'://'+location.host+'/ws');
  const log=(t)=>{logEl.textContent+=t+'\\n'; logEl.scrollTop=logEl.scrollHeight;};
  const send=()=>{const text=msgEl.value.trim(); if(!text)return; ws.send(JSON.stringify({type:'request',id:'send-'+Date.now(),method:'sessions.send',params:{sessionID:'webchat:main',text,source:'webchat'}})); log('[you] '+text); msgEl.value='';};
  sendBtn.onclick=send; msgEl.addEventListener('keydown',(e)=>{if(e.key==='Enter')send();});
  ws.onopen=()=>{const qs=new URLSearchParams(location.search);const token=qs.get('token')||localStorage.getItem('miya_gateway_token')||'';if(token)localStorage.setItem('miya_gateway_token',token);ws.send(JSON.stringify({type:'hello',role:'ui',auth:token?{token}:undefined})); ws.send(JSON.stringify({type:'request',id:'sub',method:'gateway.subscribe',params:{events:['*']}})); log('[system] connected');};
  ws.onmessage=(event)=>{try{const frame=JSON.parse(event.data); if(frame.type==='response'&&!frame.ok)log('[error] '+(frame.error?.message||'request_failed'));}catch{}};
</script>
</body>
</html>`;
}
var init_webchat = __esm({
  "src/gateway/render/webchat.ts"() {
    "use strict";
  }
});

// src/gateway/sanitizer.ts
function normalizeWhitespace(text) {
  return text.replace(/\r\n/g, "\n").trim();
}
function inferContextMode(text) {
  const trimmed = normalizeWhitespace(text);
  if (!trimmed) return "work";
  let workScore = 0;
  let chatScore = 0;
  for (const pattern of WORK_HINTS) {
    if (pattern.test(trimmed)) workScore += 1;
  }
  for (const pattern of CHAT_HINTS) {
    if (pattern.test(trimmed)) chatScore += 1;
  }
  return workScore >= chatScore ? "work" : "chat";
}
function sanitizeWorkContext(text) {
  const removed = [];
  let body = normalizeWhitespace(text);
  if (WORK_BLOCKED_WORDS.test(body)) {
    removed.push("persona_words");
    body = body.replace(WORK_BLOCKED_WORDS, "");
  }
  body = body.replace(/[ \t]{2,}/g, " ").replace(/\n{3,}/g, "\n\n").trim();
  return {
    text: ["[Context Mode: WORK]", WORK_INSTRUCTION, body].filter(Boolean).join("\n"),
    removed
  };
}
function sanitizeChatContext(text) {
  const removed = [];
  const lines = normalizeWhitespace(text).split("\n");
  const kept = [];
  for (const line of lines) {
    if (CODE_CONTEXT_LINE.test(line)) {
      removed.push("code_context_line");
      continue;
    }
    kept.push(line);
  }
  const body = kept.join("\n").replace(/\n{3,}/g, "\n\n").trim();
  return {
    text: ["[Context Mode: CHAT]", CHAT_INSTRUCTION, body].filter(Boolean).join("\n"),
    removed
  };
}
function sanitizeGatewayContext(input) {
  const mode = input.modeHint ?? inferContextMode(input.text);
  if (mode === "chat") {
    const sanitized2 = sanitizeChatContext(input.text);
    return {
      mode,
      payload: sanitized2.text,
      removedSignals: sanitized2.removed
    };
  }
  const sanitized = sanitizeWorkContext(input.text);
  return {
    mode,
    payload: sanitized.text,
    removedSignals: sanitized.removed
  };
}
var WORK_INSTRUCTION, CHAT_INSTRUCTION, WORK_HINTS, CHAT_HINTS, WORK_BLOCKED_WORDS, CODE_CONTEXT_LINE;
var init_sanitizer = __esm({
  "src/gateway/sanitizer.ts"() {
    "use strict";
    WORK_INSTRUCTION = "You are a technical coding assistant. No small talk.";
    CHAT_INSTRUCTION = "You are Miya, a girlfriend assistant. Be gentle and cute.";
    WORK_HINTS = [
      /```/,
      /\b(stack trace|traceback|exception|TypeError|ReferenceError)\b/i,
      /\b(function|class|import|npm|pnpm|bun|pip|pytest|docker|sql|api)\b/i,
      /\b(\.ts|\.tsx|\.js|\.py|\.md|package\.json|tsconfig)\b/i,
      /(|||||||||)/
    ];
    CHAT_HINTS = [
      /(||||||||||)/,
      /\b(love|dear|sweet|cute|hug)\b/i
    ];
    WORK_BLOCKED_WORDS = /(||||||||)/g;
    CODE_CONTEXT_LINE = new RegExp(
      [
        "^\\s*```",
        "^\\s*(src|apps?|packages?)[/\\\\]",
        "^\\s*[A-Za-z]:[/\\\\]",
        "^\\s*at\\s+\\S+\\s*\\(",
        '^\\s*File\\s+".*",\\s+line\\s+\\d+',
        "\\.(ts|tsx|js|jsx|py|java|go|rs|cpp|c|h|json|yaml|yml|toml|md)\\b",
        "\\b(package\\.json|tsconfig|requirements\\.txt|pnpm-lock|bun\\.lock)\\b"
      ].join("|"),
      "i"
    );
  }
});

// src/gateway/state-files.ts
import * as fs40 from "node:fs";
import * as path40 from "node:path";
function gatewayFile(projectDir) {
  return path40.join(getMiyaRuntimeDir(projectDir), "gateway.json");
}
function trustModeFile(projectDir) {
  return path40.join(getMiyaRuntimeDir(projectDir), "gateway-trust-mode.json");
}
function psycheModeFile(projectDir) {
  return path40.join(getMiyaRuntimeDir(projectDir), "gateway-psyche-mode.json");
}
function learningGateFile(projectDir) {
  return path40.join(getMiyaRuntimeDir(projectDir), "gateway-learning-gate.json");
}
function ensureDir17(file3) {
  fs40.mkdirSync(path40.dirname(file3), { recursive: true });
}
function writeJsonAtomic(file3, payload) {
  ensureDir17(file3);
  const tmp = `${file3}.tmp.${process.pid}.${Date.now()}`;
  fs40.writeFileSync(tmp, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
  fs40.renameSync(tmp, file3);
}
function safeReadJsonObject(file3) {
  if (!fs40.existsSync(file3)) return null;
  try {
    const parsed = JSON.parse(fs40.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return null;
    return parsed;
  } catch {
    return null;
  }
}
var init_state_files = __esm({
  "src/gateway/state-files.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/gateway/ws-runtime.ts
function normalizeWsInput(message) {
  if (typeof message === "string") return message;
  if (Buffer.isBuffer(message)) return message.toString("utf-8");
  if (Array.isArray(message)) return Buffer.concat(message).toString("utf-8");
  return Buffer.from(message).toString("utf-8");
}
var init_ws_runtime = __esm({
  "src/gateway/ws-runtime.ts"() {
    "use strict";
  }
});

// src/gateway/index.ts
var gateway_exports = {};
__export(gateway_exports, {
  createGatewayTools: () => createGatewayTools,
  ensureGatewayRunning: () => ensureGatewayRunning,
  isGatewayOwner: () => isGatewayOwner,
  probeGatewayAlive: () => probeGatewayAlive,
  registerGatewayDependencies: () => registerGatewayDependencies,
  startGatewayWithLog: () => startGatewayWithLog,
  stopGateway: () => stopGateway
});
import { spawnSync as spawnSync6 } from "node:child_process";
import { createHash as createHash13, randomUUID as randomUUID17 } from "node:crypto";
import * as fs41 from "node:fs";
import { createServer } from "node:http";
import * as os5 from "node:os";
import * as path41 from "node:path";
import WebSocket2, { WebSocketServer } from "ws";
function fallbackMemorySqliteStats(projectDir) {
  return {
    sqlitePath: path41.join(getMiyaRuntimeDir(projectDir), "memory", "memories.sqlite"),
    memoryCount: 0,
    candidateCount: 0,
    activeCount: 0,
    vectorCount: 0,
    graphCount: 0,
    rawLogCount: 0,
    pendingRawLogCount: 0,
    evidenceCount: 0,
    eventCount: 0
  };
}
function readMemoryObservability(projectDir) {
  const sqlite = (() => {
    try {
      return getCompanionMemorySqliteStats(projectDir);
    } catch (error92) {
      log("[gateway] memory sqlite stats degraded", {
        projectDir,
        error: error92 instanceof Error ? error92.message : String(error92)
      });
      return fallbackMemorySqliteStats(projectDir);
    }
  })();
  const pendingVectors = (() => {
    try {
      return listPendingCompanionMemoryVectors(projectDir).length;
    } catch (error92) {
      log("[gateway] memory pending vectors degraded", {
        projectDir,
        error: error92 instanceof Error ? error92.message : String(error92)
      });
      return 0;
    }
  })();
  return {
    sqlite,
    pendingVectors
  };
}
function nowIso24() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function resolveKillSwitchMode(projectDir, kill) {
  if (kill.active) return "all_stop";
  const outbound = isDomainExecutionAllowed(projectDir, "outbound_send");
  const desktop = isDomainExecutionAllowed(projectDir, "desktop_control");
  if (!outbound && !desktop) return "all_stop";
  if (!outbound) return "outbound_only";
  if (!desktop) return "desktop_only";
  return "off";
}
function resolvePsycheApprovalMode(input) {
  if (input.decision !== "allow") return "modal_approval";
  if (input.urgency === "high" || input.urgency === "critical") return "modal_approval";
  if (input.trust.minScore >= input.mode.silentMin) return "silent_audit";
  if (input.trust.minScore <= input.mode.modalMax) return "modal_approval";
  return "toast_gate";
}
function appendNexusInsight(runtime, input) {
  const trimmed = input.text.trim();
  if (!trimmed) return;
  runtime.nexus.insights.push({
    at: input.at ?? nowIso24(),
    text: trimmed,
    auditID: input.auditID
  });
  if (runtime.nexus.insights.length > 30) {
    runtime.nexus.insights.splice(0, runtime.nexus.insights.length - 30);
  }
}
function shouldEmitThrottledLog(cache, key, windowMs) {
  const now = Date.now();
  const last = cache.get(key) ?? 0;
  if (now - last < windowMs) return false;
  cache.set(key, now);
  return true;
}
function depsOf(projectDir) {
  return dependencies.get(projectDir) ?? {};
}
function registerGatewayDependencies(projectDir, deps) {
  const current = dependencies.get(projectDir) ?? {};
  dependencies.set(projectDir, { ...current, ...deps });
}
function normalizeTrustMode2(input) {
  const silentMinRaw = Number(input?.silentMin ?? DEFAULT_TRUST_MODE.silentMin);
  const modalMaxRaw = Number(input?.modalMax ?? DEFAULT_TRUST_MODE.modalMax);
  const silentMin = Math.max(0, Math.min(100, Number.isFinite(silentMinRaw) ? silentMinRaw : DEFAULT_TRUST_MODE.silentMin));
  const modalMax = Math.max(0, Math.min(100, Number.isFinite(modalMaxRaw) ? modalMaxRaw : DEFAULT_TRUST_MODE.modalMax));
  const correctedSilentMin = Math.max(Math.ceil(modalMax), Math.round(silentMin));
  return {
    silentMin: correctedSilentMin,
    modalMax: Math.round(modalMax)
  };
}
function readTrustModeConfig(projectDir) {
  const raw = safeReadJsonObject(trustModeFile(projectDir));
  if (!raw) return DEFAULT_TRUST_MODE;
  return normalizeTrustMode2({
    silentMin: typeof raw.silentMin === "number" ? raw.silentMin : void 0,
    modalMax: typeof raw.modalMax === "number" ? raw.modalMax : void 0
  });
}
function writeTrustModeConfig(projectDir, config3) {
  const normalized = normalizeTrustMode2(config3);
  writeJsonAtomic(trustModeFile(projectDir), normalized);
  return normalized;
}
function normalizePsycheMode(input) {
  return {
    resonanceEnabled: typeof input?.resonanceEnabled === "boolean" ? input.resonanceEnabled : DEFAULT_PSYCHE_MODE.resonanceEnabled,
    captureProbeEnabled: typeof input?.captureProbeEnabled === "boolean" ? input.captureProbeEnabled : DEFAULT_PSYCHE_MODE.captureProbeEnabled
  };
}
function readPsycheModeConfig(projectDir) {
  const raw = safeReadJsonObject(psycheModeFile(projectDir));
  if (!raw) return DEFAULT_PSYCHE_MODE;
  return normalizePsycheMode({
    resonanceEnabled: typeof raw.resonanceEnabled === "boolean" ? raw.resonanceEnabled : void 0,
    captureProbeEnabled: typeof raw.captureProbeEnabled === "boolean" ? raw.captureProbeEnabled : void 0
  });
}
function writePsycheModeConfig(projectDir, config3) {
  const current = readPsycheModeConfig(projectDir);
  const normalized = normalizePsycheMode({
    ...current,
    ...config3
  });
  writeJsonAtomic(psycheModeFile(projectDir), normalized);
  return normalized;
}
function normalizeLearningGate(input) {
  return {
    candidateMode: input?.candidateMode === "silent_audit" ? "silent_audit" : "toast_gate",
    persistentRequiresApproval: typeof input?.persistentRequiresApproval === "boolean" ? input.persistentRequiresApproval : DEFAULT_LEARNING_GATE.persistentRequiresApproval
  };
}
function readLearningGateConfig(projectDir) {
  const raw = safeReadJsonObject(learningGateFile(projectDir));
  if (!raw) return DEFAULT_LEARNING_GATE;
  return normalizeLearningGate({
    candidateMode: raw.candidateMode === "silent_audit" || raw.candidateMode === "toast_gate" ? raw.candidateMode : void 0,
    persistentRequiresApproval: typeof raw.persistentRequiresApproval === "boolean" ? raw.persistentRequiresApproval : void 0
  });
}
function writeLearningGateConfig(projectDir, config3) {
  const current = readLearningGateConfig(projectDir);
  const normalized = normalizeLearningGate({
    ...current,
    ...config3
  });
  writeJsonAtomic(learningGateFile(projectDir), normalized);
  return normalized;
}
function resolvePsycheConsultEnabled(projectDir, mode) {
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "1") return true;
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "0") return false;
  const config3 = readConfig(projectDir);
  const configured = config3.automation?.psycheConsultEnabled;
  if (typeof configured === "boolean") return configured;
  return mode.resonanceEnabled;
}
function gatewayOwnerLockFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "gateway-owner.json");
}
function readGatewayOwnerLock(projectDir) {
  const raw = safeReadJsonObject(gatewayOwnerLockFile(projectDir));
  if (!raw) return null;
  const pid = Number(raw.pid);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  const startedAt = String(raw.startedAt ?? "");
  if (!Number.isFinite(pid) || !token || !updatedAt || !startedAt) return null;
  return { pid, token, updatedAt, startedAt };
}
function describeOwnerLock(lock) {
  if (!lock) return { exists: false };
  return {
    exists: true,
    pid: lock.pid,
    updatedAt: lock.updatedAt,
    startedAt: lock.startedAt,
    fresh: isOwnerLockFresh(lock),
    alive: isProcessAlive(lock.pid)
  };
}
function isOwnerLockFresh(lock) {
  const ts = Date.parse(lock.updatedAt);
  if (!Number.isFinite(ts)) return false;
  return Date.now() - ts <= 15e3;
}
function ownerSummary(projectDir) {
  const lock = readGatewayOwnerLock(projectDir);
  if (!lock) {
    return {
      isOwner: false,
      ownerFresh: false
    };
  }
  const token = ownerTokens.get(projectDir);
  return {
    isOwner: Boolean(token) && lock.pid === process.pid && lock.token === token,
    ownerPID: lock.pid,
    ownerFresh: isOwnerLockFresh(lock)
  };
}
function writeOwnerLock(projectDir, token) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const existing = readGatewayOwnerLock(projectDir);
  const lock = {
    pid: process.pid,
    token,
    updatedAt: nowIso24(),
    startedAt: existing?.pid === process.pid && existing.token === token ? existing.startedAt : nowIso24()
  };
  writeJsonAtomic(file3, lock);
  return lock;
}
function touchOwnerLock(projectDir) {
  const token = ownerTokens.get(projectDir);
  if (!token) return;
  writeOwnerLock(projectDir, token);
}
function removeOwnerLock(projectDir) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  const token = ownerTokens.get(projectDir);
  if (!lock || !token) return;
  if (lock.pid === process.pid && lock.token === token) {
    try {
      fs41.unlinkSync(file3);
    } catch {
    }
  }
}
function acquireGatewayOwner(projectDir) {
  const existingToken = ownerTokens.get(projectDir) ?? randomUUID17();
  ownerTokens.set(projectDir, existingToken);
  const lockFile = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  if (lock && lock.pid === process.pid && lock.token === existingToken && isOwnerLockFresh(lock)) {
    const refreshed = {
      ...lock,
      updatedAt: nowIso24()
    };
    writeJsonAtomic(lockFile, refreshed);
    return { owned: true, owner: refreshed };
  }
  if (lock && isProcessAlive(lock.pid) && isOwnerLockFresh(lock)) {
    return { owned: false, owner: lock };
  }
  const created = writeOwnerLock(projectDir, existingToken);
  return { owned: true, owner: created };
}
function readGatewayStateFile(projectDir) {
  const raw = safeReadJsonObject(gatewayFile(projectDir));
  if (!raw) return null;
  const url3 = String(raw.url ?? "").trim();
  const port = Number(raw.port);
  const pid = Number(raw.pid);
  const startedAt = String(raw.startedAt ?? "");
  const status = String(raw.status ?? "running");
  if (!url3 || !Number.isFinite(port) || !Number.isFinite(pid) || !startedAt) {
    return null;
  }
  return {
    url: url3,
    port,
    pid,
    startedAt,
    status: status === "killswitch" ? "killswitch" : "running"
  };
}
function describeGatewayState(state) {
  if (!state) return { exists: false };
  return {
    exists: true,
    url: state.url,
    port: state.port,
    pid: state.pid,
    startedAt: state.startedAt,
    status: state.status,
    pidAlive: isProcessAlive(state.pid)
  };
}
function clearGatewayStateFile(projectDir) {
  try {
    fs41.unlinkSync(gatewayFile(projectDir));
  } catch {
  }
}
function isGatewayOwner(projectDir) {
  const token = ownerTokens.get(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  if (!token || !lock) return false;
  return lock.pid === process.pid && lock.token === token && isOwnerLockFresh(lock);
}
async function probeGatewayAlive(url3, timeoutMs = 800) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const response = await fetch(`${url3.replace(/\/+$/, "")}/api/status`, {
      method: "GET",
      signal: controller.signal
    });
    return response.ok;
  } catch {
    return false;
  } finally {
    clearTimeout(timer);
  }
}
function killAwareStatus(projectDir) {
  return readKillSwitch(projectDir).active ? "killswitch" : "running";
}
function gatewayPort(runtime) {
  return Number(runtime.server.port ?? 0);
}
function resolveGatewayListenOptions(projectDir) {
  const config3 = readConfig(projectDir);
  const gateway = config3.gateway ?? {};
  const rawHost = String(gateway.bindHost ?? "").trim();
  const rawPort = Number(gateway.port);
  const hostname6 = rawHost || "127.0.0.1";
  const port = Number.isFinite(rawPort) && rawPort > 0 && rawPort <= 65535 ? Math.floor(rawPort) : 0;
  return { hostname: hostname6, port };
}
function logControlUiFallback(projectDir, pathname, controlUi, responseStatus) {
  const logKey = `${projectDir}:control-ui-fallback`;
  if (!shouldEmitThrottledLog(controlUiFallbackLoggedAtByDir, logKey, 1e4)) return;
  log("[gateway] control-ui fallback to built-in console", {
    projectDir,
    pathname,
    responseStatus,
    uiRootKind: controlUi.root?.kind ?? "unknown",
    uiRootPath: controlUi.root && "path" in controlUi.root ? String(controlUi.root.path) : void 0,
    uiBasePath: controlUi.basePath ?? "",
    envUiRoot: process.env.MIYA_GATEWAY_UI_ROOT ?? "",
    envUiBasePath: process.env.MIYA_GATEWAY_UI_BASE_PATH ?? ""
  });
}
function toGatewayState(projectDir, runtime) {
  const host = String(runtime.server.hostname || "127.0.0.1") || "127.0.0.1";
  return {
    url: `http://${host}:${gatewayPort(runtime)}`,
    port: gatewayPort(runtime),
    pid: process.pid,
    startedAt: runtime.startedAt,
    status: killAwareStatus(projectDir)
  };
}
function writeGatewayState(projectDir, state) {
  const file3 = gatewayFile(projectDir);
  writeJsonAtomic(file3, state);
}
function syncGatewayState(projectDir, runtime) {
  const state = toGatewayState(projectDir, runtime);
  writeGatewayState(projectDir, state);
  return state;
}
function stopGateway(projectDir) {
  const runtime = runtimes.get(projectDir);
  if (!runtime) return { stopped: false };
  try {
    maybeReflectOnSessionEnd(projectDir, {
      minPendingLogs: 50,
      maxLogs: 200
    });
  } catch (error92) {
    log("[gateway] skip memory reflect during stop due to runtime limitation", {
      projectDir,
      error: error92 instanceof Error ? error92.message : String(error92)
    });
  }
  const previous = toGatewayState(projectDir, runtime);
  if (runtime.wizardTickTimer) {
    clearInterval(runtime.wizardTickTimer);
    runtime.wizardTickTimer = void 0;
  }
  if (runtime.ownerBeatTimer) {
    clearInterval(runtime.ownerBeatTimer);
    runtime.ownerBeatTimer = void 0;
  }
  if (runtime.memoryReflectTimer) {
    clearInterval(runtime.memoryReflectTimer);
    runtime.memoryReflectTimer = void 0;
  }
  if (runtime.daemonLauncherUnsubscribe) {
    runtime.daemonLauncherUnsubscribe();
    runtime.daemonLauncherUnsubscribe = void 0;
  }
  try {
    runtime.channelRuntime.stop();
  } catch {
  }
  try {
    for (const ws of runtime.wsClients) {
      try {
        ws.close();
      } catch {
      }
    }
    runtime.server.wsServer.close();
    runtime.server.httpServer.close();
  } catch {
  }
  runtimes.delete(projectDir);
  clearGatewayStateFile(projectDir);
  removeOwnerLock(projectDir);
  return { stopped: true, previous };
}
function hashText2(input) {
  return createHash13("sha256").update(input).digest("hex");
}
function parseText(value) {
  return typeof value === "string" ? value : "";
}
function parseChannel(value) {
  return isChannelName(value) ? value : null;
}
function runStartupSelfCheck(projectDir) {
  const checks = [];
  const commands = [
    "opencode.debug.config",
    "opencode.debug.skill",
    "opencode.debug.paths"
  ];
  for (const name of commands) {
    const startedMs = Date.now();
    const subcommand = name.replace("opencode.debug.", "");
    const result = spawnSync6("opencode", ["debug", subcommand], {
      cwd: projectDir,
      encoding: "utf-8",
      timeout: 8e3
    });
    const output = `${result.stdout ?? ""}${result.stderr ?? ""}`.trim().slice(0, 2e3);
    checks.push({
      name,
      ok: result.status === 0 && !result.error,
      exitCode: typeof result.status === "number" ? result.status : -1,
      durationMs: Date.now() - startedMs,
      output: output || (result.error ? String(result.error.message) : "")
    });
  }
  return {
    ranAt: nowIso24(),
    overall: checks.every((item) => item.ok) ? "ok" : "degraded",
    checks
  };
}
function wizardPromptByState(state) {
  if (state === "awaiting_photos") return WIZARD_PROMPT_PHOTOS;
  if (state === "awaiting_voice") return WIZARD_PROMPT_VOICE;
  if (state === "awaiting_personality") return WIZARD_PROMPT_PERSONALITY;
  if (state === "completed") return WIZARD_PROMPT_DONE;
  return "";
}
function contextEnvelopeByMode(mode) {
  if (mode === "guest") {
    return [
      "[Guest Mode Active]",
      "Only use public persona.",
      "Do not access memory/vault/relationship private context.",
      "Refuse desktop control, outbound actions, and sensitive data requests."
    ].join("\n");
  }
  if (mode === "unknown") {
    return "[Unknown Speaker] Safety-first mode: avoid sensitive actions until owner verification.";
  }
  return "[Owner Mode Active] Full private context is available.";
}
function containsSensitiveText(text) {
  const sensitivePattern = /(|||||seed||token|secret|api[_-]?key|wallet||||otp|password)/i;
  return sensitivePattern.test(text);
}
function inferIntentSuspicious(text) {
  const suspiciousPattern = /(|||||||||||||)/i;
  return suspiciousPattern.test(text);
}
function isHighRiskInstruction(text) {
  return /(||||||||||)/i.test(
    text
  );
}
function isCriticalInjectionIntent(text) {
  return /(|.*(||)|.*(||)|.*(|).*(|token|)|.*(|))/i.test(
    text
  );
}
function shouldBypassIntentGuard(source) {
  return /^policy:|^system:/.test(source);
}
function buildSessionPayloadByMode(mode, text) {
  if (mode === "guest") {
    if (containsSensitiveText(text) || isHighRiskInstruction(text)) {
      const digest = hashText2(text).slice(0, 16);
      return {
        redacted: true,
        payload: [
          "[Guest Mode Active]",
          "Private context pointers: memory=null, vault=null, relationship=null.",
          "Sensitive request is blocked in guest mode.",
          `redacted_request_sha256=${digest}`,
          "Reply policy: refuse sensitive actions and keep light conversation only."
        ].join("\n")
      };
    }
    return {
      redacted: false,
      payload: [
        contextEnvelopeByMode(mode),
        "Private context pointers: memory=null, vault=null, relationship=null.",
        text
      ].join("\n")
    };
  }
  if (mode === "unknown") {
    return {
      redacted: false,
      payload: [contextEnvelopeByMode(mode), text].join("\n")
    };
  }
  return { redacted: false, payload: [contextEnvelopeByMode(mode), text].join("\n") };
}
async function enforceCriticalIntentGuard(projectDir, input) {
  if (shouldBypassIntentGuard(input.source)) return false;
  if (!isCriticalInjectionIntent(input.text)) return false;
  const traceID = randomUUID17();
  const reason = "critical_intent_killswitch_triggered";
  activateKillSwitch(projectDir, reason, traceID);
  appendPolicyIncident(projectDir, {
    type: "decision_fusion_hard",
    reason,
    pausedDomains: ["outbound_send", "desktop_control"],
    statusByDomain: {
      outbound_send: "paused",
      desktop_control: "paused"
    },
    semanticSummary: {
      trigger: "critical_intent_guard",
      keyAssertion: "Message matched critical injection / exfiltration intent pattern.",
      recovery: "Use OpenCode local password to unlock and manually resume domains."
    },
    semanticTags: ["recipient_mismatch"],
    details: {
      source: input.source,
      sessionID: input.sessionID,
      textDigest: hashText2(input.text).slice(0, 24)
    }
  });
  await notifySafetyReport(projectDir, input.sessionID, [
    "Miya \u7EA2\u8272\u8B66\u62A5\uFF1A\u5DF2\u89E6\u53D1\u5F02\u5E38\u68C0\u6D4B\u7194\u65AD\uFF08Kill-Switch\uFF09",
    `\u539F\u56E0: ${reason}`,
    "\u68C0\u6D4B\u5230\u9AD8\u5371\u6CE8\u5165/\u8D8A\u6743\u610F\u56FE\uFF0C\u5DF2\u6682\u505C\u9AD8\u5371\u80FD\u529B\u57DF\u3002",
    "\u6062\u590D\uFF1A\u8BF7\u5728 OpenCode \u5B8C\u6210\u672C\u5730\u9A8C\u8BC1\u540E\u624B\u52A8\u6062\u590D\u3002"
  ]);
  return true;
}
function collectStringValues(input, maxItems = 40) {
  const out = [];
  const stack = [input];
  while (stack.length > 0 && out.length < maxItems) {
    const current = stack.pop();
    if (typeof current === "string") {
      const text = current.trim();
      if (text.length > 0) out.push(text);
      continue;
    }
    if (!current || typeof current !== "object") continue;
    if (Array.isArray(current)) {
      for (const item of current) stack.push(item);
      continue;
    }
    for (const value of Object.values(current)) {
      stack.push(value);
    }
  }
  return out;
}
function shouldGuardMethod(method) {
  if (method.startsWith("policy.") || method.startsWith("gateway.") || method.startsWith("doctor.")) {
    return false;
  }
  return true;
}
function assertConsoleMethodAllowed(method, context) {
  if (context.role !== "ui") return;
  if (UI_ALLOWED_METHODS.has(method)) return;
  throw new Error(`console_method_forbidden:${method}`);
}
function interventionAuditFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "audit", "intervention.jsonl");
}
function appendInterventionAudit(projectDir, input) {
  const id = `intervention_${randomUUID17()}`;
  const file3 = interventionAuditFile(projectDir);
  fs41.mkdirSync(path41.dirname(file3), { recursive: true });
  fs41.appendFileSync(
    file3,
    `${JSON.stringify({
      id,
      at: nowIso24(),
      ...input
    })}
`,
    "utf-8"
  );
  return id;
}
function normalizeApprovalTier(input) {
  if (input === "high" || input === "thorough") return "THOROUGH";
  if (input === "low" || input === "light") return "LIGHT";
  return "STANDARD";
}
async function invokeGatewayMethod(projectDir, runtime, method, params, context) {
  assertConsoleMethodAllowed(method, context);
  if (shouldGuardMethod(method)) {
    const texts = collectStringValues(params);
    for (const text of texts) {
      if (await enforceCriticalIntentGuard(projectDir, {
        sessionID: parseText(params.sessionID) || "main",
        text,
        source: `method:${method}`
      })) {
        throw new Error("kill_switch_triggered_by_critical_intent");
      }
    }
  }
  return runtime.methods.invoke(method, params, context);
}
function parseExecSpec(raw) {
  const input = raw.trim();
  if (!input) return null;
  const tokens = [];
  let current = "";
  let quote = null;
  for (let i = 0; i < input.length; i += 1) {
    const ch = input[i] ?? "";
    if ((ch === '"' || ch === "'") && (!quote || quote === ch)) {
      quote = quote ? null : ch;
      continue;
    }
    if (!quote && /\s/.test(ch)) {
      if (current) tokens.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current) tokens.push(current);
  if (tokens.length === 0) return null;
  return {
    command: tokens[0],
    args: tokens.slice(1)
  };
}
async function verifyVoiceprintWithLocalModel(projectDir, input) {
  const config3 = readConfig(projectDir);
  const strictFromConfig = config3.security?.voiceprint?.strict !== false;
  const strict = process.env.MIYA_VOICEPRINT_STRICT !== void 0 ? process.env.MIYA_VOICEPRINT_STRICT !== "0" : strictFromConfig;
  const hintMode = resolveInteractionMode(projectDir, {
    speakerHint: input.speakerHint,
    speakerScore: input.speakerScore
  });
  const audioPath = (input.mediaPath ?? "").trim();
  const cmdRaw = String(process.env.MIYA_VOICEPRINT_VERIFY_CMD ?? "").trim();
  if (!audioPath || !fs41.existsSync(audioPath)) {
    return { mode: strict ? "unknown" : hintMode, score: input.speakerScore, source: "no_audio" };
  }
  if (!cmdRaw) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : void 0,
      source: "strict_no_cmd"
    };
  }
  const spec = parseExecSpec(cmdRaw);
  if (!spec) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : void 0,
      source: "strict_invalid_cmd"
    };
  }
  const state = readOwnerIdentityState(projectDir);
  if (!state.voiceprintModelPath || !fs41.existsSync(state.voiceprintModelPath)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_model_missing"
    };
  }
  if (!state.voiceprintSampleDir || !fs41.existsSync(state.voiceprintSampleDir)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_samples_missing"
    };
  }
  const daemon = getMiyaClient(projectDir);
  const args = spec.args.map(
    (item) => item.replaceAll("{audio}", audioPath).replaceAll("{model}", state.voiceprintModelPath).replaceAll("{samples}", state.voiceprintSampleDir || "").replaceAll("{embedding}", state.voiceprintEmbeddingID ?? "")
  );
  try {
    const result = await daemon.runIsolatedProcess({
      kind: "voice.asr",
      command: spec.command,
      args,
      timeoutMs: 45e3,
      resource: { priority: 90, vramMB: 0, modelID: "local:eres2net", modelVramMB: 0 },
      metadata: { stage: "security.voiceprint.verify", audioPath, compute: "cpu" }
    });
    if (result.exitCode !== 0) {
      return {
        mode: strict ? "unknown" : hintMode,
        score: input.speakerScore,
        source: "strict_cmd_failed"
      };
    }
    const stdout = result.stdout.trim();
    const parsed = JSON.parse(stdout);
    const score = typeof parsed.speaker_score === "number" ? Number(parsed.speaker_score) : input.speakerScore;
    const liveness = typeof parsed.liveness_score === "number" ? Number(parsed.liveness_score) : void 0;
    const sampleDuration = typeof parsed.sample_duration_sec === "number" ? Number(parsed.sample_duration_sec) : void 0;
    const diarization = Array.isArray(parsed.diarization) ? parsed.diarization : [];
    const ownerSegments = diarization.filter(
      (seg) => String(seg.speaker ?? "").toLowerCase() === "owner"
    ).length;
    const thresholds = state.voiceprintThresholds;
    const diarizationLooksOwner = diarization.length === 0 ? true : ownerSegments / diarization.length >= thresholds.ownerMinDiarizationRatio;
    const sampleDurationOk = typeof sampleDuration !== "number" || sampleDuration >= thresholds.minSampleDurationSec;
    const mode = parsed.mode && ["owner", "guest", "unknown"].includes(parsed.mode) ? parsed.mode : !sampleDurationOk ? "unknown" : typeof score === "number" ? score >= thresholds.ownerMinScore && (liveness ?? 1) >= thresholds.ownerMinLiveness && diarizationLooksOwner ? "owner" : score < thresholds.guestMaxScore || typeof liveness === "number" && liveness < thresholds.guestMaxLiveness ? "guest" : "unknown" : "unknown";
    return { mode, score, source: "voiceprint_cmd" };
  } catch {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_cmd_error"
    };
  }
}
function normalizeRuntimeDependencyRecommendations(status) {
  const fromPlan = Array.isArray(status.repairPlan?.recommendations) ? status.repairPlan?.recommendations ?? [] : [];
  if (fromPlan.length > 0) return fromPlan;
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const fallback = [];
  if (issues.some((issue3) => issue3.startsWith("torch_not_installed"))) {
    fallback.push({
      package: "torch",
      recommendedVersion: ">=2.2.0",
      reason: "PyTorch runtime is required by FLUX/GPT-SoVITS tasks.",
      command: 'pip install "torch>=2.2.0" "torchvision>=0.17.0" "torchaudio>=2.2.0"'
    });
  }
  if (issues.some((issue3) => issue3.startsWith("ffmpeg_missing"))) {
    fallback.push({
      package: "ffmpeg",
      recommendedVersion: "system_latest",
      reason: "Audio conversion requires ffmpeg binary in PATH.",
      command: "winget install --id Gyan.FFmpeg -e"
    });
  }
  if (fallback.length === 0 && issues.length > 0) {
    fallback.push({
      package: "python-deps",
      recommendedVersion: "requirements.txt",
      reason: "Environment check reported dependency issues.",
      command: "python -m pip install --upgrade pip setuptools wheel && python -m pip install --disable-pip-version-check -r miya-src/python/requirements.txt"
    });
  }
  return fallback;
}
function buildDependencyAssistPrompt(status) {
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const recommendations = normalizeRuntimeDependencyRecommendations(status);
  const recommendationLines = recommendations.map(
    (item) => `- ${item.package} ${item.recommendedVersion}
  reason: ${item.reason}
  cmd: ${item.command}`
  ).join("\n");
  return [
    "Miya dependency fault detected in local Python runtime.",
    `python: ${status.pythonPath ?? "unknown"}`,
    `issues: ${issues.join(", ") || "none"}`,
    "Please produce a short repair guide with exact commands and conflict explanation.",
    "Use and refine these baseline recommendations:",
    recommendationLines || "- reinstall requirements and inspect pip stderr"
  ].join("\n");
}
async function maybeTriggerDependencyAssist(projectDir, runtime, status) {
  const issueType = status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok";
  if (issueType !== "dependency_fault") return { triggered: false };
  const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
  const digest = hashText2(prompt);
  if (runtime.dependencyAssistHashes.has(digest)) {
    return { triggered: false };
  }
  runtime.dependencyAssistHashes.add(digest);
  const routed = await routeSessionMessage(projectDir, {
    sessionID: "main",
    source: "daemon.python.env.dependency_fault",
    text: prompt
  });
  return { triggered: true, routed };
}
function deriveRiskLevel(input) {
  if (input.containsSensitive && (input.factorIntentSuspicious || !input.factorRecipientIsMe)) {
    return "HIGH";
  }
  if (input.containsSensitive || input.factorIntentSuspicious) {
    return "MEDIUM";
  }
  return "LOW";
}
function requirePolicyHash(projectDir, providedHash) {
  const policyGuard = assertPolicyHash(projectDir, providedHash);
  if (!policyGuard.ok) {
    throw new Error(`${policyGuard.reason}:expected=${policyGuard.hash}`);
  }
  return policyGuard.hash;
}
function requireDomainRunning(projectDir, domain3) {
  if (!isDomainRunning(projectDir, domain3) || !isDomainExecutionAllowed(projectDir, domain3)) {
    throw new Error(`domain_paused:${domain3}`);
  }
}
function requireOwnerMode(projectDir) {
  const state = readOwnerIdentityState(projectDir);
  if (state.mode !== "owner") {
    throw new Error(`owner_mode_required:current=${state.mode}`);
  }
}
function resolveNegotiationID(input) {
  const explicit = (input.explicitID ?? "").trim();
  if (explicit) return explicit;
  const consultAuditID = (input.consultAuditID ?? "").trim();
  if (consultAuditID) return consultAuditID;
  return `neg_${hashText2(
    `${input.sessionID}|${input.channel}|${input.destination}|${input.payloadHash}`
  ).slice(0, 24)}`;
}
function consumeNegotiationBudget(input) {
  const applied = applyNegotiationBudget(input.runtime.negotiationBudgets, {
    key: input.negotiationID,
    fixability: input.fixability,
    budget: input.budget,
    attemptType: input.attemptType
  });
  if (applied.allowed) return { ok: true, state: applied.state };
  return {
    ok: false,
    state: applied.state,
    reason: applied.reason
  };
}
async function sendChannelMessageGuarded(projectDir, runtime, input) {
  const resolvedPolicyHash = requirePolicyHash(projectDir, input.policyHash);
  requireDomainRunning(projectDir, "outbound_send");
  requireDomainRunning(projectDir, "desktop_control");
  const identity = readOwnerIdentityState(projectDir);
  const localPhysicalConfirmed = Boolean(input.confirmation?.physicalConfirmed);
  const localPasswordVerified = verifyOwnerPasswordOnly(projectDir, input.confirmation?.password);
  const localGuestOverride = (identity.mode === "guest" || identity.mode === "unknown") && localPhysicalConfirmed && localPasswordVerified;
  if ((identity.mode === "guest" || identity.mode === "unknown") && !localGuestOverride) {
    return {
      sent: false,
      message: "outbound_blocked:guest_mode",
      policyHash: currentPolicyHash(projectDir)
    };
  }
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = hashText2(`${input.text}||${mediaPath}`);
  const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
  const intent = input.outboundCheck?.intent ?? "initiate";
  const factorRecipientIsMeInput = input.outboundCheck?.factorRecipientIsMe;
  const factorRecipientIsMe = typeof factorRecipientIsMeInput === "boolean" ? factorRecipientIsMeInput : getContactTier(projectDir, input.channel, input.destination) === "owner";
  const containsSensitive = containsSensitiveText(input.text);
  const factorIntentSuspicious = inferIntentSuspicious(input.text);
  const confidenceIntentRaw = factorIntentSuspicious ? 0.35 : containsSensitive ? 0.75 : 0.95;
  const riskLevel = deriveRiskLevel({
    containsSensitive,
    factorIntentSuspicious,
    factorRecipientIsMe
  });
  const captureLimitations = Array.isArray(input.outboundCheck?.captureLimitations) ? input.outboundCheck.captureLimitations : [];
  let evidenceConfidence = typeof input.outboundCheck?.evidenceConfidence === "number" && Number.isFinite(input.outboundCheck.evidenceConfidence) ? Number(input.outboundCheck.evidenceConfidence) : confidenceIntentRaw;
  evidenceConfidence = Math.max(0, Math.min(1, evidenceConfidence));
  if (captureLimitations.some(
    (item) => item === "no_desktop_screenshot" || item === "pixel_evidence_unavailable" || item.startsWith("capture_tree_exhausted") || item === "capture_method_unspecified"
  )) {
    evidenceConfidence = Math.min(evidenceConfidence, 0.34);
  }
  const userInitiated = input.outboundCheck?.userInitiated !== false;
  if (isHighRiskInstruction(input.text)) {
    const physicalConfirmed = localPhysicalConfirmed;
    const secretVerified = verifyOwnerSecrets(projectDir, {
      password: input.confirmation?.password,
      passphrase: input.confirmation?.passphrase
    });
    if (!physicalConfirmed || !secretVerified) {
      return {
        sent: false,
        message: "outbound_blocked:high_risk_confirmation_required",
        requiresConfirmation: true,
        policyHash: currentPolicyHash(projectDir)
      };
    }
    const ownerSyncRequired = process.env.MIYA_OWNER_SYNC_REQUIRED !== "0";
    if (ownerSyncRequired && !localGuestOverride) {
      const providedOwnerSyncToken = String(input.confirmation?.ownerSyncToken ?? "").trim();
      if (!providedOwnerSyncToken) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: "outbound_blocked:owner_sync_confirmation_required",
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: `\u8BF7\u7528\u672C\u4EBA\u6863\u5728 QQ/\u5FAE\u4FE1 \u56DE\u590D: \u540C\u610F ${pending.token}\uFF0810\u5206\u949F\u5185\u6709\u6548\uFF09`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      const ownerSync = verifyOwnerSyncToken(projectDir, {
        token: providedOwnerSyncToken,
        action: "outbound.high_risk.send",
        payloadHash
      });
      if (!ownerSync.ok) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: `outbound_blocked:owner_sync_confirmation_required:${ownerSync.reason ?? "invalid_token"}`,
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: `\u8BF7\u7528\u672C\u4EBA\u6863\u5728 QQ/\u5FAE\u4FE1 \u56DE\u590D: \u540C\u610F ${pending.token}\uFF0810\u5206\u949F\u5185\u6709\u6548\uFF09`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      consumeOwnerSyncToken(projectDir, providedOwnerSyncToken);
    }
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    const cached3 = runtime.outboundSendDedupe.get(key);
    if (cached3) {
      return {
        ...cached3.result,
        cached: true
      };
    }
  }
  const fusion = evaluateOutboundDecisionFusion({
    factorTextSensitive: containsSensitive,
    factorRecipientIsMe,
    factorIntentSuspicious,
    confidenceIntent: confidenceIntentRaw,
    trustMinScore: runtime.nexus.trust?.minScore,
    trustMode: runtime.nexus.trustMode,
    evidenceConfidence
  });
  if (fusion.action === "hard_fuse") {
    const safetyState = transitionSafetyState(projectDir, {
      source: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: "decision_fusion_hard",
        keyAssertion: "A=contains_sensitive and decision fusion matched in danger zone (confidence < 0.5).",
        recovery: "Review outbound intent in OpenCode and manually resume paused domains after confirmation."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya\u5B89\u5168\u62A5\u544A\uFF1A\u5DF2\u89E6\u53D1\u786C\u7194\u65AD\u5E76\u6682\u505C\u80FD\u529B\u57DF",
      `\u89E6\u53D1\u539F\u56E0: ${incident.reason}`,
      `\u80FD\u529B\u57DF\u72B6\u6001: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `\u5173\u952E\u65AD\u8A00: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      "\u6062\u590D\u6761\u4EF6: \u8BF7\u5728\u786E\u8BA4\u5916\u53D1\u610F\u56FE\u540E\u624B\u52A8\u6062\u590D\u57DF\u5F00\u5173"
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_hard",
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (fusion.action === "soft_fuse") {
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_soft",
      reason: "outbound_blocked:decision_fusion_soft_confirmation_required",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      semanticSummary: {
        trigger: "decision_fusion_soft",
        keyAssertion: "Decision fusion matched in gray zone (0.5 <= confidence <= 0.85), manual confirmation required.",
        recovery: "Confirm outbound intent in OpenCode, then retry with explicit approval."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya\u5B89\u5168\u63D0\u793A\uFF1A\u5F53\u524D\u5916\u53D1\u8FDB\u5165\u7070\u533A\u67D4\u6027\u7194\u65AD",
      `\u89E6\u53D1\u539F\u56E0: ${incident.reason}`,
      `\u5173\u952E\u65AD\u8A00: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      "\u5EFA\u8BAE\u786E\u8BA4: \u4EB2\u7231\u7684\uFF0C\u8FD9\u53E5\u8BDD\u542C\u8D77\u6765\u6709\u70B9\u654F\u611F\uFF0C\u4F60\u662F\u8BA4\u771F\u7684\u5417\uFF1F"
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_soft_confirmation_required",
      requiresConfirmation: true,
      policyHash: resolvedPolicyHash,
      incident
    };
  }
  const psycheMode = runtime.nexus.psycheMode;
  const psycheConsultEnabled = resolvePsycheConsultEnabled(projectDir, psycheMode);
  if (!psycheMode.resonanceEnabled && !userInitiated) {
    runtime.nexus.guardianSafeHoldReason = "resonance_disabled";
    appendNexusInsight(runtime, {
      text: "\u5171\u9E23\u5C42\u5DF2\u5173\u95ED\uFF1A\u81EA\u52A8\u89E6\u8FBE\u8FDB\u5165\u9759\u9ED8\u7B49\u5F85\u3002"
    });
    const negotiationID2 = resolveNegotiationID({
      explicitID: input.outboundCheck?.negotiationID,
      sessionID: input.sessionID,
      channel: input.channel,
      destination: input.destination,
      payloadHash
    });
    const budgetState = consumeNegotiationBudget({
      runtime,
      negotiationID: negotiationID2,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      attemptType: input.outboundCheck?.retryAttemptType
    });
    if (!budgetState.ok) {
      return {
        sent: false,
        message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
        policyHash: resolvedPolicyHash,
        retryAfterSec: 120,
        fixability: "retry_later",
        budget: { autoRetry: 1, humanEdit: 1 },
        approvalMode: "modal_approval",
        negotiationID: negotiationID2
      };
    }
    return {
      sent: false,
      message: "outbound_blocked:resonance_disabled_safe_hold",
      policyHash: resolvedPolicyHash,
      retryAfterSec: 120,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      approvalMode: "toast_gate",
      negotiationID: negotiationID2,
      psyche: {
        decision: "defer",
        reason: "resonance_disabled_safe_hold",
        state: "UNKNOWN"
      }
    };
  }
  runtime.nexus.guardianSafeHoldReason = void 0;
  let psycheConsult = null;
  if (psycheConsultEnabled) {
    try {
      const daemon = getMiyaClient(projectDir);
      const consult = await daemon.psycheConsult({
        intent: `outbound.send.${input.channel}`,
        urgency: riskLevel === "HIGH" ? "high" : riskLevel === "MEDIUM" ? "medium" : "low",
        channel: input.channel,
        userInitiated,
        allowScreenProbe: psycheMode.captureProbeEnabled,
        signals: input.outboundCheck?.psycheSignals,
        captureLimitations: input.outboundCheck?.captureLimitations,
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence
        }
      });
      psycheConsult = {
        auditID: consult.auditID,
        intent: consult.intent,
        urgency: consult.urgency,
        channel: consult.channel,
        userInitiated: consult.userInitiated,
        state: consult.state
      };
      const approvalMode = resolvePsycheApprovalMode({
        decision: consult.decision,
        urgency: consult.urgency,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      runtime.nexus.trust = consult.trust;
      runtime.nexus.sessionId = input.sessionID;
      runtime.nexus.permission = "external_message";
      appendNexusInsight(runtime, {
        text: consult.insightText,
        auditID: consult.auditID,
        at: consult.at
      });
      publishGatewayEvent(runtime, "insight.append", {
        at: consult.at,
        text: consult.insightText,
        auditID: consult.auditID
      });
      publishGatewayEvent(runtime, "trust.update", {
        at: consult.at,
        auditID: consult.auditID,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      if (consult.decision !== "allow") {
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          consultAuditID: consult.auditID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: consult.fixability,
          budget: consult.budget,
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            psyche: consult,
            retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
            fixability: consult.fixability,
            budget: consult.budget,
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        try {
          await daemon.psycheOutcome({
            consultAuditID: consult.auditID,
            intent: consult.intent,
            urgency: consult.urgency,
            channel: consult.channel,
            userInitiated: consult.userInitiated,
            state: consult.state,
            delivered: false,
            blockedReason: consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred",
            trust: {
              target: `${input.channel}:${input.destination}`,
              source: `session:${input.sessionID}`,
              action: `outbound.send.${input.channel}`,
              evidenceConfidence,
              highRiskRollback: riskLevel === "HIGH" && consult.decision === "deny"
            }
          });
        } catch {
        }
        return {
          sent: false,
          message: consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred",
          policyHash: resolvedPolicyHash,
          psyche: consult,
          retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
          fixability: consult.fixability,
          budget: consult.budget,
          approvalMode,
          negotiationID: negotiationID2
        };
      }
    } catch (error92) {
      if (!userInitiated) {
        runtime.nexus.guardianSafeHoldReason = "psyche_consult_unavailable";
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            retryAfterSec: 30,
            fixability: "retry_later",
            budget: { autoRetry: 1, humanEdit: 1 },
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        return {
          sent: false,
          message: "outbound_blocked:psyche_deferred",
          policyHash: resolvedPolicyHash,
          retryAfterSec: 30,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          approvalMode: "modal_approval",
          negotiationID: negotiationID2,
          psyche: {
            decision: "defer",
            reason: "psyche_consult_unavailable",
            state: "UNKNOWN",
            error: error92 instanceof Error ? error92.message : String(error92)
          }
        };
      }
    }
  }
  const outboundTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "external_message",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!outboundTicket.ok) throw new Error(`approval_required:${outboundTicket.reason}`);
  const desktopTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "desktop_control",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!desktopTicket.ok) throw new Error(`approval_required:${desktopTicket.reason}`);
  const sendFingerprint = hashText2(
    `${input.channel}|${input.destination}|${payloadHash}|${Math.floor(Date.now() / 6e4)}`
  ).slice(0, 40);
  const outboundRuntime = runtime.channelRuntime;
  const result = await outboundRuntime.sendMessage({
    channel: input.channel,
    destination: input.destination,
    text: input.text,
    mediaPath: mediaPath || void 0,
    sessionID: input.sessionID,
    sendFingerprint,
    payloadHash,
    approvalTickets: {
      outboundSend: outboundTicket.ticket,
      desktopControl: desktopTicket.ticket
    },
    outboundCheck: {
      archAdvisorApproved,
      riskLevel,
      intent: intent === "reply" ? "reply" : "initiate",
      containsSensitive,
      policyHash: resolvedPolicyHash
    }
  });
  runtime.nexus.guardianSafeHoldReason = void 0;
  const negotiationID = (input.outboundCheck?.negotiationID ?? "").trim();
  if (Boolean(result.sent) && negotiationID) {
    runtime.negotiationBudgets.delete(negotiationID);
  }
  if (psycheConsultEnabled && psycheConsult) {
    try {
      const daemon = getMiyaClient(projectDir);
      await daemon.psycheOutcome({
        consultAuditID: psycheConsult.auditID,
        intent: psycheConsult.intent,
        urgency: psycheConsult.urgency,
        channel: psycheConsult.channel,
        userInitiated: psycheConsult.userInitiated,
        state: psycheConsult.state,
        delivered: Boolean(result.sent),
        blockedReason: result.sent ? void 0 : String(result.message ?? ""),
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence,
          highRiskRollback: riskLevel === "HIGH" && !result.sent
        }
      });
    } catch {
    }
  }
  const violationType = result.message === "outbound_blocked:friend_tier_sensitive_content_denied" ? "friend_tier_sensitive_violation" : result.message === "outbound_blocked:friend_tier_can_only_reply" ? "friend_tier_initiate_violation" : null;
  if (violationType) {
    const safetyState = transitionSafetyState(projectDir, {
      source: "friend_tier_violation",
      reason: result.message,
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: violationType,
      reason: result.message,
      channel: input.channel,
      destination: input.destination,
      auditID: result.auditID,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: violationType,
        keyAssertion: `Outbound to friend tier violated policy (${result.message}).`,
        recovery: "Review recipient tier and outbound payload, then manually resume paused domains."
      },
      semanticTags: ["recipient_mismatch"]
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya\u5B89\u5168\u62A5\u544A\uFF1A\u670B\u53CB\u6863\u5916\u53D1\u8FDD\u89C4\uFF0C\u5DF2\u6682\u505C\u80FD\u529B\u57DF",
      `\u89E6\u53D1\u539F\u56E0: ${result.message}`,
      `\u80FD\u529B\u57DF\u72B6\u6001: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `\u6536\u4EF6\u901A\u9053: ${input.channel}, \u6536\u4EF6\u76EE\u6807: ${input.destination}`,
      "\u6062\u590D\u6761\u4EF6: \u8C03\u6574\u8054\u7CFB\u4EBA\u6863\u4F4D/\u5185\u5BB9\u540E\u624B\u52A8\u6062\u590D\u57DF\u5F00\u5173"
    ]);
    return {
      ...result,
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    runtime.outboundSendDedupe.set(key, { ts: Date.now(), result });
    const cutoff = Date.now() - 10 * 60 * 1e3;
    for (const [dedupeKey, value] of runtime.outboundSendDedupe.entries()) {
      if (value.ts < cutoff) runtime.outboundSendDedupe.delete(dedupeKey);
    }
  }
  return {
    ...result,
    policyHash: resolvedPolicyHash,
    sendFingerprint
  };
}
async function notifySafetyReport(projectDir, sessionID, lines) {
  try {
    await routeSessionMessage(projectDir, {
      sessionID: sessionID || "main",
      text: lines.join("\n"),
      source: "policy:incident"
    });
  } catch {
  }
}
function enforceInteractionModeIsolation(projectDir, mode) {
  if (mode === "owner") return;
  transitionSafetyState(projectDir, {
    source: "interaction_mode_isolation",
    reason: `interaction_mode_${mode}`,
    domains: {
      outbound_send: "paused",
      desktop_control: "paused",
      memory_read: "paused",
      memory_write: "paused",
      memory_delete: "paused"
    }
  });
}
function listBackground(projectDir) {
  const manager = depsOf(projectDir).backgroundManager;
  if (!manager) {
    return { total: 0, running: 0, tasks: [] };
  }
  const tasks = manager.listTasks(100);
  return {
    total: tasks.length,
    running: tasks.filter((item) => item.status === "running").length,
    tasks: tasks.map((item) => ({
      id: item.id,
      description: item.description,
      agent: item.agent,
      status: item.status,
      startedAt: item.startedAt.toISOString(),
      completedAt: item.completedAt?.toISOString()
    }))
  };
}
function collectDoctorIssues(projectDir, runtime, base) {
  const issues = [];
  const host = String(runtime.server.hostname || "127.0.0.1");
  if (host !== "127.0.0.1" && host !== "localhost") {
    issues.push({
      code: "gateway_bind_non_loopback",
      severity: "warn",
      message: `Gateway bind host is ${host}.`,
      fix: "Use loopback bind by default, or add strict external auth."
    });
  }
  if (base.killSwitch.active) {
    issues.push({
      code: "kill_switch_active",
      severity: "error",
      message: `Kill switch active: ${base.killSwitch.reason ?? "unknown"}.`,
      fix: "Resolve cause and run miya_kill_release."
    });
  }
  const channelStore = readChannelStore(projectDir);
  for (const channel of Object.values(channelStore.channels)) {
    if (channel.enabled && channel.name !== "webchat" && channel.allowlist.length === 0) {
      issues.push({
        code: `channel_allowlist_empty_${channel.name}`,
        severity: "warn",
        message: `${channel.name} enabled without allowlist.`,
        fix: "Approve at least one pair request before auto handling."
      });
    }
  }
  for (const node of base.nodes.list) {
    if (node.connected && !node.paired) {
      issues.push({
        code: `node_unpaired_${node.nodeID}`,
        severity: "warn",
        message: `Node ${node.nodeID} connected but not paired.`,
        fix: "Approve node pairing."
      });
    }
  }
  if (base.skills.discovered.some((item) => !item.gate.loadable)) {
    issues.push({
      code: "skills_gate_failures",
      severity: "info",
      message: "Some skills are gated by missing requirements.",
      fix: "Inspect skills.status and satisfy gate requirements."
    });
  }
  if (base.voice.enabled && base.voice.wakeWordEnabled && !base.voice.talkMode) {
    issues.push({
      code: "voice_wake_without_talk_mode",
      severity: "info",
      message: "Voice wake word is enabled while talk mode is disabled.",
      fix: "Enable talk mode if you expect always-on voice behavior."
    });
  }
  if (base.companion.enabled && !base.companion.onboardingCompleted) {
    issues.push({
      code: "companion_onboarding_incomplete",
      severity: "warn",
      message: "Companion mode enabled before onboarding completion.",
      fix: "Run companion.wizard.start and finish profile setup."
    });
  }
  return issues;
}
function buildSnapshot(projectDir, runtime) {
  const deps = depsOf(projectDir);
  const kill = readKillSwitch(projectDir);
  const jobs = deps.automationService?.listJobs() ?? [];
  const approvals = deps.automationService?.listApprovals() ?? [];
  const recentRuns = deps.automationService?.listHistory(20) ?? [];
  const sessions = listSessions(projectDir);
  const channels = runtime.channelRuntime.listChannels();
  const pendingPairs = runtime.channelRuntime.listPairs("pending");
  const recentOutbound = listOutboundAudit(projectDir, 30);
  const nodes = listNodes(projectDir);
  const devices = listDevices(projectDir);
  const invokes = listInvokeRequests(projectDir, 40);
  const enabledSkills = listEnabledSkills(projectDir);
  const discoveredSkills = discoverSkills(projectDir, deps.extraSkillDirs ?? []);
  const mediaRecent = listMediaItems(projectDir, 20);
  const voice = readVoiceState(projectDir);
  const canvas = readCanvasState(projectDir);
  const companion = readCompanionProfile(projectDir);
  const ownerIdentity = readOwnerIdentityState(projectDir);
  const persistedRuntime = readPersistedAgentRuntime(projectDir);
  const owner = ownerSummary(projectDir);
  if (owner.isOwner) {
    ensureMiyaLauncher(projectDir);
  }
  const autoflowSessions = listAutoflowSessions(projectDir, 30);
  const autoflowPersistentConfig = readAutoflowPersistentConfig(projectDir);
  const autoflowPersistentSessions = getAutoflowPersistentRuntimeSnapshot(projectDir, 30);
  const routingMode = readRouterModeConfig(projectDir);
  const routingCost = getRouteCostSummary(projectDir, 500);
  const routingRecent = listRouteCostRecords(projectDir, 20);
  const memoryObservability = readMemoryObservability(projectDir);
  const learningStats = getLearningStats(projectDir);
  const learningTopDrafts = listSkillDrafts(projectDir, { limit: 8 }).map((item) => ({
    id: item.id,
    status: item.status,
    source: item.source,
    confidence: item.confidence,
    uses: item.uses,
    hitRate: item.uses > 0 ? Number((item.hits / item.uses).toFixed(3)) : 0,
    title: item.title
  }));
  runtime.nexus.pendingTickets = approvals.filter((item) => item.status === "pending").length;
  runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, kill);
  const base = {
    updatedAt: nowIso24(),
    lifecycle: {
      gateway: "standalone_background",
      ui: "opencode_bound"
    },
    gateway: syncGatewayState(projectDir, runtime),
    runtime: {
      isOwner: owner.isOwner,
      ownerPID: owner.ownerPID,
      ownerFresh: owner.ownerFresh,
      activeAgentId: persistedRuntime.activeAgentId,
      storageRevision: persistedRuntime.revision
    },
    daemon: getLauncherDaemonSnapshot(projectDir),
    policyHash: currentPolicyHash(projectDir),
    configCenter: readConfig(projectDir),
    killSwitch: kill,
    nexus: {
      sessionId: runtime.nexus.sessionId,
      activeTool: runtime.nexus.activeTool,
      jobId: runtime.nexus.jobId,
      permission: runtime.nexus.permission,
      pendingTickets: runtime.nexus.pendingTickets,
      killSwitchMode: resolveKillSwitchMode(projectDir, kill),
      insights: runtime.nexus.insights.slice(-10),
      trust: runtime.nexus.trust,
      trustMode: runtime.nexus.trustMode,
      psycheMode: runtime.nexus.psycheMode,
      learningGate: runtime.nexus.learningGate,
      guardianSafeHoldReason: runtime.nexus.guardianSafeHoldReason
    },
    safety: {
      recentSelfApproval: listRecentSelfApprovalRecords(projectDir, 15)
    },
    jobs: {
      total: jobs.length,
      enabled: jobs.filter((item) => item.enabled).length,
      pendingApprovals: approvals.filter((item) => item.status === "pending").length,
      recentRuns
    },
    loop: getSessionState(projectDir, "main"),
    autoflow: {
      active: autoflowSessions.filter(
        (item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing"
      ).length,
      sessions: autoflowSessions.map((item) => {
        const phaseProgress = item.phase === "planning" ? 10 : item.phase === "execution" ? 45 : item.phase === "verification" ? 70 : item.phase === "fixing" ? 80 : item.phase === "completed" ? 100 : item.phase === "failed" ? 100 : 0;
        const fixProgress = item.maxFixRounds > 0 ? Math.min(20, Math.floor(item.fixRound / item.maxFixRounds * 20)) : 0;
        const retryReason = [...item.history].reverse().find((row) => row.event === "verification_failed" || row.event === "execution_failed")?.summary;
        return {
          sessionID: item.sessionID,
          phase: item.phase,
          goal: item.goal,
          fixRound: item.fixRound,
          maxFixRounds: item.maxFixRounds,
          updatedAt: item.updatedAt,
          progressPct: Math.min(100, phaseProgress + fixProgress),
          retryReason,
          lastError: item.lastError,
          lastDag: item.lastDag
        };
      }),
      persistent: {
        enabled: autoflowPersistentConfig.enabled,
        resumeCooldownMs: autoflowPersistentConfig.resumeCooldownMs,
        maxAutoResumes: autoflowPersistentConfig.maxAutoResumes,
        maxConsecutiveResumeFailures: autoflowPersistentConfig.maxConsecutiveResumeFailures,
        resumeTimeoutMs: autoflowPersistentConfig.resumeTimeoutMs,
        sessions: autoflowPersistentSessions.map((item) => ({
          sessionID: item.sessionID,
          resumeAttempts: item.resumeAttempts,
          resumeFailures: item.resumeFailures,
          userStopped: item.userStopped,
          lastOutcomePhase: item.lastOutcomePhase,
          lastOutcomeSummary: item.lastOutcomeSummary
        }))
      }
    },
    routing: {
      ecoMode: routingMode.ecoMode,
      forcedStage: routingMode.forcedStage,
      cost: routingCost,
      recent: routingRecent
    },
    learning: {
      stats: learningStats,
      topDrafts: learningTopDrafts
    },
    background: listBackground(projectDir),
    sessions: {
      total: sessions.length,
      active: sessions.filter((item) => item.policy.activation === "active").length,
      queued: sessions.filter((item) => item.policy.activation === "queued").length,
      muted: sessions.filter((item) => item.policy.activation === "muted").length,
      items: sessions.slice(0, 100)
    },
    channels: {
      states: channels,
      pendingPairs,
      recentOutbound
    },
    nodes: {
      total: nodes.length,
      connected: nodes.filter((item) => item.connected).length,
      pendingPairs: listNodePairs(projectDir, "pending").length,
      list: nodes,
      devices,
      invokes
    },
    skills: {
      enabled: enabledSkills,
      discovered: discoveredSkills
    },
    media: {
      total: mediaRecent.length,
      recent: mediaRecent
    },
    voice,
    canvas: {
      activeDocID: canvas.activeDocID,
      docs: listCanvasDocs(projectDir),
      events: canvas.events.slice(0, 100)
    },
    companion,
    security: {
      ownerIdentity: {
        ...ownerIdentity,
        passwordHash: ownerIdentity.passwordHash ? "***" : void 0,
        passphraseHash: ownerIdentity.passphraseHash ? "***" : void 0
      }
    },
    observability: {
      trace: {
        sessionID: runtime.nexus.sessionId,
        method: runtime.nexus.activeTool,
        jobID: runtime.nexus.jobId
      },
      gateway: runtime.methods.stats(),
      daemon: getLauncherBackpressureStats(projectDir),
      memory: {
        sqlite: memoryObservability.sqlite,
        pendingVectors: memoryObservability.pendingVectors
      },
      router: routingCost
    },
    health: {
      overall: "ok",
      startupSelfCheck: runtime.startupSelfCheck,
      doctorIssueCount: 0
    }
  };
  const doctorIssues = collectDoctorIssues(projectDir, runtime, base);
  const hasErrors = doctorIssues.some((item) => item.severity === "error");
  base.health = {
    overall: hasErrors || runtime.startupSelfCheck && runtime.startupSelfCheck.overall === "degraded" ? "degraded" : "ok",
    startupSelfCheck: runtime.startupSelfCheck,
    doctorIssueCount: doctorIssues.length
  };
  return {
    ...base,
    doctor: {
      issues: doctorIssues
    }
  };
}
function daemonProgressAuditFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "audit", "daemon-job-progress.jsonl");
}
function appendDaemonProgressAudit(projectDir, input) {
  const file3 = daemonProgressAuditFile(projectDir);
  fs41.mkdirSync(path41.dirname(file3), { recursive: true });
  fs41.appendFileSync(
    file3,
    `${JSON.stringify({ id: `dprogress_${randomUUID17()}`, ...input })}
`,
    "utf-8"
  );
}
function gatewayMethodAuditFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "audit", "gateway-methods.jsonl");
}
function appendGatewayMethodAudit(projectDir, input) {
  const file3 = gatewayMethodAuditFile(projectDir);
  fs41.mkdirSync(path41.dirname(file3), { recursive: true });
  fs41.appendFileSync(
    file3,
    `${JSON.stringify({
      id: `gmethod_${randomUUID17()}`,
      at: nowIso24(),
      ...input
    })}
`,
    "utf-8"
  );
}
async function routeSessionMessage(projectDir, input) {
  const availableAgents = [
    "1-task-manager",
    "2-code-search",
    "3-docs-helper",
    "4-architecture-advisor",
    "5-code-fixer",
    "6-ui-designer"
  ];
  const deps = depsOf(projectDir);
  if (await enforceCriticalIntentGuard(projectDir, input)) {
    return {
      delivered: false,
      queued: false,
      reason: "kill_switch_triggered_by_critical_intent"
    };
  }
  const interactionMode = readOwnerIdentityState(projectDir).mode;
  enforceInteractionModeIsolation(projectDir, interactionMode);
  const payload = buildSessionPayloadByMode(interactionMode, input.text);
  const sanitized = sanitizeGatewayContext({
    text: payload.payload
  });
  const safeText = sanitized.payload;
  appendShortTermMemoryLog(projectDir, {
    sessionID: input.sessionID,
    sender: "user",
    text: safeText
  });
  if (interactionMode === "guest") {
    appendGuestConversation(projectDir, {
      text: payload.redacted ? "[redacted_sensitive_guest_request]" : input.text,
      source: input.source,
      sessionID: input.sessionID
    });
  }
  const session = getSession(projectDir, input.sessionID) ?? upsertSession(projectDir, {
    id: input.sessionID,
    kind: input.sessionID.startsWith("opencode:") ? "opencode" : "channel",
    groupId: input.sessionID,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  if (session.policy.activation !== "active" || session.policy.reply !== "auto") {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: `policy_${session.policy.activation}_${session.policy.reply}`
    };
  }
  const client = deps.client;
  if (!client) {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: "client_unavailable"
    };
  }
  const pinnedAgent = session.routing.agent && session.routing.agent !== "1-task-manager" ? session.routing.agent : void 0;
  const plan = buildRouteExecutionPlan({
    projectDir,
    sessionID: input.sessionID,
    text: safeText,
    availableAgents,
    pinnedAgent
  });
  const learning = buildLearningInjection(projectDir, safeText, {
    threshold: 0.66,
    limit: 2
  });
  const enrichedText = learning.snippet ? `${learning.snippet}

---

${safeText}` : safeText;
  const payloadPlan = prepareRoutePayload(projectDir, {
    text: enrichedText,
    stage: plan.stage
  });
  const routedAgents = buildRoutedAgentSequence(plan, availableAgents, safeText);
  let lastAttemptedAgent = routedAgents[0] ?? plan.agent;
  try {
    for (let index = 0; index < routedAgents.length; index++) {
      const agent = routedAgents[index];
      if (!agent) continue;
      lastAttemptedAgent = agent;
      const routedText = buildRoutedAgentPayload({
        originalText: safeText,
        payloadText: payloadPlan.text,
        agent,
        index,
        total: routedAgents.length,
        contextStrategy: plan.contextStrategy
      });
      await client.session.prompt({
        path: { id: session.routing.opencodeSessionID },
        body: {
          agent,
          parts: [{ type: "text", text: routedText }]
        },
        query: { directory: projectDir }
      });
    }
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: plan.stage,
      agent: lastAttemptedAgent,
      success: true,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, void 0, { hit: true });
      }
    }
    dequeueSessionMessage(projectDir, input.sessionID);
    return { delivered: true, queued: false };
  } catch (error92) {
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: plan.stage,
      agent: lastAttemptedAgent,
      success: false,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, void 0, { hit: false });
      }
    }
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: error92 instanceof Error ? error92.message : String(error92)
    };
  }
}
function buildRoutedAgentSequence(plan, availableAgents, originalText) {
  const source = plan.plannedAgents.length > 0 ? plan.plannedAgents : [plan.agent];
  const filtered = source.filter((agent) => availableAgents.includes(agent));
  const unique = filtered.filter((agent, index, arr) => arr.indexOf(agent) === index);
  const base = unique.length > 0 ? unique : [plan.agent];
  if (plan.complexity === "low") {
    return base.slice(0, 1);
  }
  if (plan.complexity === "medium") {
    if (plan.enableEarlyExit && shouldEarlyExitForMediumTask(originalText)) {
      return base.slice(0, 1);
    }
    const mediumLimit = Math.max(2, Math.min(3, plan.maxAgents ?? 3));
    return base.slice(0, mediumLimit);
  }
  const highLimit = Math.max(1, plan.maxAgents ?? base.length);
  return base.slice(0, highLimit);
}
function shouldEarlyExitForMediumTask(text) {
  const normalized = text.trim().toLowerCase();
  if (!normalized) return false;
  const quickFixSignals = [
    "type error",
    "ts",
    "typescript",
    "lint",
    "\u4FEE\u590D",
    "\u62A5\u9519",
    "\u9519\u8BEF",
    "hotfix",
    "bugfix"
  ];
  const multiStepSignals = [
    "\u91CD\u6784",
    "\u67B6\u6784",
    "\u5E76\u884C",
    "\u5B8C\u6574\u6D41\u7A0B",
    "\u7AEF\u5230\u7AEF",
    "multi-step",
    "workflow",
    "\u65B0\u589E\u9875\u9762",
    "\u767B\u5F55\u9875\u9762"
  ];
  const hasQuickFixSignal = quickFixSignals.some((token) => normalized.includes(token));
  const hasMultiStepSignal = multiStepSignals.some((token) => normalized.includes(token));
  return hasQuickFixSignal && !hasMultiStepSignal;
}
function buildRoutedAgentPayload(input) {
  if (input.total <= 1) return input.payloadText;
  const header = `[MIYA_ROUTER_PIPELINE step=${input.index + 1}/${input.total} agent=${input.agent} context=${input.contextStrategy}]`;
  if (input.contextStrategy === "full") {
    return `${header}
${input.payloadText}`;
  }
  if (input.contextStrategy === "summary") {
    const summary = input.originalText.trim().slice(0, 1500);
    return `${header}
Task summary:
${summary}

Execution hint: focus on this step and avoid repeating prior output.`;
  }
  const minimal = input.originalText.trim().slice(0, 700);
  return `${header}
${minimal}`;
}
function resolveApprovalTicket(input) {
  const kill = readKillSwitch(input.projectDir);
  if (kill.active) {
    return { ok: false, reason: "kill_switch_active" };
  }
  const request = {
    sessionID: input.sessionID,
    permission: input.permission,
    patterns: input.patterns
  };
  const tier = requiredTierForRequest(request);
  const requestHash = buildRequestHash(
    {
      permission: input.permission,
      patterns: input.patterns,
      toolCallID: "",
      messageID: ""
    },
    false
  );
  const token = findApprovalToken(input.projectDir, input.sessionID, [requestHash], tier);
  if (token) {
    return {
      ok: true,
      ticket: {
        permission: input.permission,
        requestHash,
        traceID: token.trace_id,
        createdAt: token.created_at,
        expiresAt: token.expires_at,
        tier: token.tier
      }
    };
  }
  activateKillSwitch(input.projectDir, "missing_evidence", randomUUID17());
  return { ok: false, reason: "missing_evidence" };
}
function enforceToken(input) {
  const resolved = resolveApprovalTicket(input);
  return resolved.ok ? { ok: true } : resolved;
}
function maybeBroadcast(projectDir, runtime) {
  if (!hasEventSubscribers(runtime, "gateway.snapshot")) {
    return;
  }
  runtime.stateVersion += 1;
  const frame = toEventFrame({
    event: "gateway.snapshot",
    payload: buildSnapshot(projectDir, runtime),
    stateVersion: { gateway: runtime.stateVersion }
  });
  publishFrame(runtime, frame.event, frame);
}
function publishGatewayEvent(runtime, event, payload) {
  runtime.stateVersion += 1;
  publishFrame(
    runtime,
    event,
    toEventFrame({
      event,
      payload,
      stateVersion: { gateway: runtime.stateVersion }
    })
  );
}
function isEventSubscribed(wsData, event) {
  return wsData.subscriptions.has("*") || wsData.subscriptions.has(event);
}
function hasEventSubscribers(runtime, event) {
  for (const ws of runtime.wsClients) {
    if (ws.readyState !== WebSocket2.OPEN) continue;
    const wsData = ensureWsData(runtime, ws);
    if (!wsData.authenticated || !isEventSubscribed(wsData, event)) continue;
    return true;
  }
  return false;
}
function publishFrame(runtime, event, frame) {
  let encoded = null;
  for (const ws of runtime.wsClients) {
    if (ws.readyState !== WebSocket2.OPEN) continue;
    const wsData = ensureWsData(runtime, ws);
    if (!wsData.authenticated || !isEventSubscribed(wsData, event)) continue;
    try {
      if (encoded === null) {
        encoded = JSON.stringify(frame);
      }
      ws.send(encoded);
    } catch {
    }
  }
}
function emitWizardProgress(runtime, payload) {
  publishGatewayEvent(runtime, "companion.wizard.progress", payload);
}
function emitWizardRequeueProgress(runtime, input) {
  emitWizardProgress(runtime, {
    sessionId: input.sessionId,
    jobID: input.jobID,
    type: input.type,
    status: "pending",
    progress: Math.max(10, input.progress),
    message: WIZARD_REQUEUE_MESSAGE,
    step: input.step
  });
}
function emitWizardDoneProgress(runtime, input) {
  const finalStatus = input.status === "failed" ? "failed" : input.status;
  emitWizardProgress(runtime, {
    sessionId: input.sessionId,
    jobID: input.jobID,
    type: input.type,
    status: finalStatus,
    progress: finalStatus === "failed" || finalStatus === "canceled" ? 50 : 100,
    currentTier: input.tier,
    message: input.message,
    step: input.step,
    nextPrompt: wizardPromptByState(input.step)
  });
}
async function runWizardTrainingWorker(projectDir, runtime) {
  if (runtime.wizardRunnerBusy) return;
  const queued = pickQueuedTrainingJob(projectDir);
  if (!queued) return;
  runtime.wizardRunnerBusy = true;
  try {
    const runningState = markTrainingJobRunning(projectDir, queued.job.id, queued.sessionId);
    emitWizardProgress(runtime, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: "training",
      progress: 5,
      step: runningState.state
    });
    const daemon = getMiyaClient(projectDir);
    const profileDir = getCompanionProfileCurrentDir(projectDir, queued.sessionId);
    if (queued.job.type === "training.image") {
      const photosDir = path41.join(profileDir, "photos");
      const result2 = await daemon.runFluxTraining({
        profileDir,
        photosDir,
        jobID: queued.job.id,
        checkpointPath: queued.job.checkpointPath
      });
      if (result2.status === "failed" && result2.checkpointPath && queued.job.attempts < 3) {
        const requeued = requeueTrainingJob(projectDir, {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          checkpointPath: result2.checkpointPath,
          message: WIZARD_REQUEUE_MESSAGE
        });
        emitWizardRequeueProgress(runtime, {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          type: queued.job.type,
          progress: queued.job.progress,
          step: requeued.state
        });
        return;
      }
      const done2 = markTrainingJobFinished(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        status: result2.status === "failed" ? "failed" : result2.status,
        message: result2.message,
        tier: result2.tier,
        checkpointPath: result2.checkpointPath
      });
      emitWizardDoneProgress(runtime, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        status: result2.status,
        tier: result2.tier,
        message: result2.message,
        step: done2.state
      });
      return;
    }
    const voiceSamplePath = path41.join(profileDir, "voice", "original_sample.wav");
    const result = await daemon.runSovitsTraining({
      profileDir,
      voiceSamplePath,
      jobID: queued.job.id,
      checkpointPath: queued.job.checkpointPath
    });
    if (result.status === "failed" && result.checkpointPath && queued.job.attempts < 3) {
      const requeued = requeueTrainingJob(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        checkpointPath: result.checkpointPath,
        message: WIZARD_REQUEUE_MESSAGE
      });
      emitWizardRequeueProgress(runtime, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        progress: queued.job.progress,
        step: requeued.state
      });
      return;
    }
    const done = markTrainingJobFinished(projectDir, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      status: result.status === "failed" ? "failed" : result.status,
      message: result.message,
      tier: result.tier,
      checkpointPath: result.checkpointPath
    });
    emitWizardDoneProgress(runtime, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: result.status,
      tier: result.tier,
      message: result.message,
      step: done.state
    });
  } finally {
    runtime.wizardRunnerBusy = false;
  }
}
function ensureWsData(runtime, ws) {
  const existing = runtime.wsMeta.get(ws);
  if (existing) {
    return existing;
  }
  const fallback = {
    clientID: `ws_${randomUUID17()}`,
    role: "unknown",
    subscriptions: /* @__PURE__ */ new Set(["*"]),
    authenticated: !process.env.MIYA_GATEWAY_TOKEN
  };
  runtime.wsMeta.set(ws, fallback);
  return fallback;
}
async function onInboundMessage(projectDir, runtime, message) {
  if (message.channel === "qq" || message.channel === "wechat") {
    const tier = getContactTier(projectDir, message.channel, message.senderID);
    if (tier === "owner") {
      const token = detectOwnerSyncTokenFromText(message.text);
      if (token) {
        const approval = approveOwnerSyncToken(projectDir, {
          token,
          channel: message.channel,
          senderID: message.senderID
        });
        await notifySafetyReport(projectDir, "main", [
          approval.ok ? `Miya \u5B89\u5168\u786E\u8BA4\uFF1A\u5DF2\u6536\u5230\u672C\u4EBA\u6863\u540C\u6B65\u786E\u8BA4 token=${token}` : `Miya \u5B89\u5168\u786E\u8BA4\u5931\u8D25\uFF1Atoken=${token} reason=${approval.reason ?? "unknown"}`
        ]);
        maybeBroadcast(projectDir, runtime);
        return;
      }
    }
  }
  const sessionID = `${message.channel}:${message.conversationID}`;
  upsertSession(projectDir, {
    id: sessionID,
    kind: "channel",
    groupId: sessionID,
    title: message.displayName,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  await routeSessionMessage(projectDir, {
    sessionID,
    text: message.text,
    source: message.channel
  });
  maybeBroadcast(projectDir, runtime);
}
function createMethods(projectDir, runtime) {
  const config3 = readConfig(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const maxInFlight = typeof backpressure?.max_in_flight === "number" ? Number(backpressure.max_in_flight) : void 0;
  const maxQueued = typeof backpressure?.max_queued === "number" ? Number(backpressure.max_queued) : void 0;
  const queueTimeoutMs = typeof backpressure?.queue_timeout_ms === "number" ? Number(backpressure.queue_timeout_ms) : void 0;
  const methods = new GatewayMethodRegistry({
    maxInFlight,
    maxQueued,
    queueTimeoutMs
  });
  const agentRuntimeApi = new AgentModelRuntimeApi(projectDir);
  methods.register("gateway.status.get", async () => buildSnapshot(projectDir, runtime));
  methods.register("autoflow.status.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const sessions = listAutoflowSessions(projectDir, Math.max(1, Math.min(200, limit)));
    const persistentConfig = readAutoflowPersistentConfig(projectDir);
    const persistentSessions = getAutoflowPersistentRuntimeSnapshot(projectDir, Math.max(1, Math.min(200, limit)));
    return {
      active: sessions.filter(
        (item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing"
      ).length,
      sessions,
      persistent: {
        ...persistentConfig,
        sessions: persistentSessions
      }
    };
  });
  methods.register("routing.stats.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 200;
    const mode = readRouterModeConfig(projectDir);
    return {
      mode,
      cost: getRouteCostSummary(projectDir, Math.max(1, Math.min(1e3, limit))),
      recent: listRouteCostRecords(projectDir, Math.max(1, Math.min(100, limit)))
    };
  });
  methods.register("learning.drafts.stats", async () => ({
    stats: getLearningStats(projectDir)
  }));
  methods.register("learning.drafts.list", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const statusRaw = parseText(params.status);
    const status = statusRaw === "draft" || statusRaw === "recommended" || statusRaw === "accepted" || statusRaw === "rejected" ? statusRaw : void 0;
    return {
      drafts: listSkillDrafts(projectDir, {
        limit: Math.max(1, Math.min(200, limit)),
        status
      })
    };
  });
  methods.register("learning.drafts.recommend", async (params) => {
    const query = parseText(params.query);
    if (!query) throw new Error("query_required");
    const threshold = typeof params.threshold === "number" ? Number(params.threshold) : void 0;
    const limit = typeof params.limit === "number" ? Number(params.limit) : void 0;
    return buildLearningInjection(projectDir, query, {
      threshold,
      limit
    });
  });
  methods.register("gateway.shutdown", async () => {
    const state = syncGatewayState(projectDir, runtime);
    setTimeout(() => {
      stopGateway(projectDir);
    }, 20);
    return { ok: true, state };
  });
  methods.register("doctor.run", async () => buildSnapshot(projectDir, runtime).doctor);
  methods.register("gateway.backpressure.stats", async () => ({
    ...runtime.methods.stats(),
    updatedAt: nowIso24()
  }));
  methods.register("daemon.backpressure.stats", async () => ({
    ...getLauncherBackpressureStats(projectDir),
    updatedAt: nowIso24()
  }));
  methods.register("gateway.audit.tail", async (params) => {
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 100;
    const limit = Math.max(1, Math.min(1e3, Math.floor(limitRaw)));
    const file3 = gatewayMethodAuditFile(projectDir);
    if (!fs41.existsSync(file3)) return [];
    const lines = fs41.readFileSync(file3, "utf-8").trim().split(/\r?\n/).filter(Boolean);
    return lines.slice(Math.max(0, lines.length - limit)).map((line) => {
      try {
        return JSON.parse(line);
      } catch {
        return null;
      }
    }).filter((item) => Boolean(item));
  });
  methods.register("gateway.pressure.run", async (params) => {
    const concurrencyRaw = typeof params.concurrency === "number" ? Number(params.concurrency) : 10;
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 1;
    const timeoutMs = typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : 2e4;
    const concurrency = Math.max(1, Math.min(100, Math.floor(concurrencyRaw)));
    const rounds = Math.max(1, Math.min(20, Math.floor(roundsRaw)));
    const startedAtMs = Date.now();
    let success3 = 0;
    let failed = 0;
    const errors = [];
    for (let round = 0; round < rounds; round += 1) {
      const tasks = Array.from({ length: concurrency }, async (_, index) => {
        try {
          const probe = spawnSync6(
            process.platform === "win32" ? "cmd" : "sh",
            process.platform === "win32" ? ["/c", "echo", `miya-pressure-${round}-${index}`] : ["-lc", `echo miya-pressure-${round}-${index}`],
            {
              cwd: projectDir,
              encoding: "utf-8",
              timeout: Math.max(1e3, timeoutMs),
              windowsHide: true
            }
          );
          if (probe.status !== 0) {
            throw new Error(
              `pressure_probe_failed:${probe.status ?? -1}:${String(probe.stderr ?? "").trim() || "no_stderr"}`
            );
          }
          await Promise.resolve();
          success3 += 1;
        } catch (error92) {
          failed += 1;
          errors.push(error92 instanceof Error ? error92.message : String(error92));
        }
      });
      await Promise.all(tasks);
    }
    return {
      success: success3,
      failed,
      elapsedMs: Date.now() - startedAtMs,
      gateway: runtime.methods.stats(),
      daemon: getLauncherBackpressureStats(projectDir),
      errors: errors.slice(0, 20)
    };
  });
  methods.register("gateway.startup.probe.run", async (params) => {
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 20;
    const rounds = Math.max(1, Math.min(100, Math.floor(roundsRaw)));
    const waitMsRaw = typeof params.waitMs === "number" ? Number(params.waitMs) : 250;
    const waitMs = Math.max(50, Math.min(5e3, Math.floor(waitMsRaw)));
    if (params.refreshDebug === true) {
      runtime.startupSelfCheck = runStartupSelfCheck(projectDir);
    }
    const state = ensureGatewayRunning(projectDir);
    let healthy = 0;
    let daemonReady = 0;
    const samples = [];
    for (let index = 0; index < rounds; index += 1) {
      const gatewayAlive = await probeGatewayAlive(state.url, 1200);
      const daemonSnapshot = getLauncherDaemonSnapshot(projectDir);
      const daemonConnected = Boolean(daemonSnapshot.connected);
      if (gatewayAlive) healthy += 1;
      if (daemonConnected) daemonReady += 1;
      samples.push({
        index: index + 1,
        gatewayAlive,
        daemonConnected,
        daemonStatus: daemonSnapshot.statusText
      });
      if (index < rounds - 1) {
        await new Promise((resolve4) => setTimeout(resolve4, waitMs));
      }
    }
    return {
      rounds,
      gatewayHealthy: healthy,
      daemonConnected: daemonReady,
      gatewaySuccessRate: Number((healthy / rounds * 100).toFixed(2)),
      daemonSuccessRate: Number((daemonReady / rounds * 100).toFixed(2)),
      startupSelfCheck: runtime.startupSelfCheck,
      samples
    };
  });
  methods.register("config.center.get", async () => readConfig(projectDir));
  methods.register("provider.override.audit.list", async (params) => {
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 50;
    const limit = Math.max(1, Math.min(500, Math.floor(limitRaw)));
    return listProviderOverrideAudits(projectDir, limit);
  });
  methods.register("agent.runtime.list", async () => agentRuntimeApi.list());
  methods.register("agent.runtime.set", async (params) => {
    const agentName = parseText(params.agentName || params.agent);
    const model = params.model;
    const activate = typeof params.activate === "boolean" ? params.activate : true;
    if (!agentName) throw new Error("invalid_agent_name");
    if (typeof model !== "string" || model.trim().length === 0) {
      throw new Error("invalid_model_ref");
    }
    const result = agentRuntimeApi.set({
      agentName,
      model,
      variant: params.variant,
      providerID: params.providerID,
      options: params.options,
      apiKey: params.apiKey,
      baseURL: params.baseURL,
      activate
    });
    return {
      ...result,
      state: agentRuntimeApi.list()
    };
  });
  methods.register("agent.runtime.reset", async (params) => {
    const agentName = parseText(params.agentName || params.agent);
    if (!agentName) throw new Error("invalid_agent_name");
    const clearActive = typeof params.clearActive === "boolean" ? params.clearActive : true;
    const activeAgentId = parseText(params.activeAgentId) || void 0;
    const result = agentRuntimeApi.reset({
      agentName,
      clearActive,
      activeAgentId
    });
    return {
      ...result,
      state: agentRuntimeApi.list()
    };
  });
  methods.register("config.center.patch", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    const validation = validateConfigPatch(projectDir, params.patch);
    if (!validation.ok) {
      throw new Error(`config_validation_failed:${validation.errors.join("|")}`);
    }
    const applied = applyConfigPatch(projectDir, validation);
    return {
      updatedConfig: applied.updatedConfig,
      changedKeys: applied.applied.map((item) => item.key)
    };
  });
  registerCoreSessionMethods({
    projectDir,
    methods,
    parseText,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    routeSessionMessage,
    wizardPromptPhotos: WIZARD_PROMPT_PHOTOS,
    wizardPromptByState
  });
  methods.register("cron.list", async () => depsOf(projectDir).automationService?.listJobs() ?? []);
  methods.register("cron.runs.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(200, Number(params.limit)) : 50;
    return depsOf(projectDir).automationService?.listHistory(limit) ?? [];
  });
  methods.register("cron.add", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const name = parseText(params.name);
    const time5 = parseText(params.time);
    const command = parseText(params.command);
    if (!name || !time5 || !command) throw new Error("invalid_cron_add_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.scheduleDailyCommand({
      name,
      time: time5,
      command,
      cwd: parseText(params.cwd) || void 0,
      timeoutMs: typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : void 0,
      requireApproval: typeof params.requireApproval === "boolean" ? params.requireApproval : false
    });
  });
  methods.register("cron.remove", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const jobID = parseText(params.jobID);
    if (!jobID) throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return { removed: service.deleteJob(jobID) };
  });
  methods.register("cron.update", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const jobID = parseText(params.jobID);
    if (!jobID || typeof params.enabled !== "boolean") throw new Error("invalid_cron_update_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.setJobEnabled(jobID, params.enabled);
  });
  methods.register("cron.run.now", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const jobID = parseText(params.jobID);
    if (!jobID) throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.runJobNow(jobID);
  });
  methods.register("cron.approvals.list", async () => depsOf(projectDir).automationService?.listApprovals() ?? []);
  methods.register("cron.approvals.approve", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const approvalID = parseText(params.approvalID);
    if (!approvalID) throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.approveAndRun(approvalID);
  });
  methods.register("cron.approvals.reject", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const approvalID = parseText(params.approvalID);
    if (!approvalID) throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.rejectApproval(approvalID);
  });
  registerChannelMethods({
    projectDir,
    methods,
    runtime,
    parseText,
    parseChannel,
    sendChannelMessageGuarded: (input) => sendChannelMessageGuarded(projectDir, runtime, input)
  });
  registerSecurityMethods({
    projectDir,
    methods,
    parseText
  });
  methods.register("policy.get", async () => {
    const policy = readPolicy(projectDir);
    return {
      policy,
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("daemon.python.env.status", async () => {
    const daemon = getMiyaClient(projectDir);
    const status = await daemon.getPythonRuntimeStatus();
    if (!status) return null;
    const recommendations = normalizeRuntimeDependencyRecommendations(status);
    const assist = await maybeTriggerDependencyAssist(projectDir, runtime, status);
    return {
      ...status,
      repairPlan: {
        ...status.repairPlan ?? {},
        recommendations
      },
      opencodeAssist: assist
    };
  });
  methods.register("daemon.python.env.repair.plan", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const status = await daemon.getPythonRuntimeStatus();
    if (!status) throw new Error("python_runtime_status_unavailable");
    const recommendations = normalizeRuntimeDependencyRecommendations(status);
    const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
    const route = await routeSessionMessage(projectDir, {
      sessionID: parseText(params.sessionID) || "main",
      source: "daemon.python.env.repair.plan",
      text: prompt
    });
    return {
      issueType: status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok",
      warnings: status.repairPlan?.warnings ?? [],
      conflicts: status.repairPlan?.conflicts ?? [],
      oneShotCommand: status.repairPlan?.oneShotCommand,
      recommendations,
      routed: route
    };
  });
  methods.register("daemon.model.lock.status", async () => {
    const daemon = getMiyaClient(projectDir);
    return daemon.getModelLockStatus();
  });
  methods.register("daemon.model.update.plan", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    return daemon.getModelUpdatePlan(target || void 0);
  });
  methods.register("daemon.model.update.apply", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    return daemon.applyModelUpdate(target || void 0);
  });
  methods.register("daemon.model.update.wizard", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    const plan = await daemon.getModelUpdatePlan(target || void 0);
    const pending = Array.isArray(plan.items) ? plan.items.filter((item) => item && item.ok === false) : [];
    const models = pending.map((item) => String(item.model ?? "").trim()).filter(Boolean);
    return {
      pending: typeof plan.pending === "number" ? plan.pending : pending.length,
      models,
      blockers: pending.map((item) => ({
        model: String(item.model ?? ""),
        reason: String(item.reason ?? "metadata_mismatch")
      })),
      suggestedCommands: {
        plan: models.length > 0 ? models.map((model) => `daemon.model.update.plan target=${model}`) : ["daemon.model.update.plan"],
        apply: models.length > 0 ? models.map((model) => `daemon.model.update.apply target=${model}`) : ["daemon.model.update.apply"]
      },
      nextAction: pending.length > 0 ? "apply model update before inference/training" : "model metadata is synchronized"
    };
  });
  methods.register("policy.domains.list", async () => {
    const policy = readPolicy(projectDir);
    return {
      domains: POLICY_DOMAINS.map((domain3) => ({
        domain: domain3,
        status: policy.domains[domain3]
      })),
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("policy.incidents.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return {
      incidents: listPolicyIncidents(projectDir, limit)
    };
  });
  methods.register("policy.domain.pause", async (params) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) {
      throw new Error("invalid_policy_domain");
    }
    const state = transitionSafetyState(projectDir, {
      source: "policy.domain.pause",
      reason: `manual_pause:${domain3}`,
      policyHash: currentPolicyHash(projectDir),
      domains: {
        [domain3]: "paused"
      }
    });
    appendPolicyIncident(projectDir, {
      type: "manual_pause",
      reason: `manual_pause:${domain3}`,
      pausedDomains: [domain3],
      statusByDomain: {
        [domain3]: state.domains[domain3] === "running" ? "running" : "paused"
      },
      policyHash: currentPolicyHash(projectDir)
    });
    return {
      domain: domain3,
      status: state.domains[domain3] === "running" ? "running" : "paused",
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("policy.domain.resume", async (params) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) {
      throw new Error("invalid_policy_domain");
    }
    const kill = readKillSwitch(projectDir);
    const safety = readSafetyState(projectDir);
    if (kill.active || safety.globalState === "killed") {
      throw new Error("kill_switch_active");
    }
    const state = transitionSafetyState(projectDir, {
      source: "policy.domain.resume",
      reason: `manual_resume:${domain3}`,
      policyHash: currentPolicyHash(projectDir),
      domains: {
        [domain3]: "running"
      }
    });
    appendPolicyIncident(projectDir, {
      type: "manual_resume",
      reason: `manual_resume:${domain3}`,
      pausedDomains: [domain3],
      statusByDomain: {
        [domain3]: state.domains[domain3] === "running" ? "running" : "paused"
      },
      policyHash: currentPolicyHash(projectDir)
    });
    return {
      domain: domain3,
      status: state.domains[domain3] === "running" ? "running" : "paused",
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("killswitch.set_mode", async (params) => {
    const modeRaw = parseText(params.mode)?.toLowerCase();
    const mode = modeRaw === "all_stop" || modeRaw === "outbound_only" || modeRaw === "desktop_only" || modeRaw === "off" ? modeRaw : null;
    if (!mode) throw new Error("invalid_killswitch_mode");
    const reason = parseText(params.reason) || `manual_mode:${mode}`;
    if (mode === "all_stop") {
      const traceID = randomUUID17();
      activateKillSwitch(projectDir, reason, traceID);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        traceID,
        policyHash: currentPolicyHash(projectDir),
        globalState: "killed",
        domains: {
          outbound_send: "killed",
          desktop_control: "killed"
        }
      });
    } else if (mode === "off") {
      releaseKillSwitch(projectDir);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        policyHash: currentPolicyHash(projectDir),
        globalState: "running",
        domains: {
          outbound_send: "running",
          desktop_control: "running"
        }
      });
    } else {
      releaseKillSwitch(projectDir);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        policyHash: currentPolicyHash(projectDir),
        globalState: "running",
        domains: {
          outbound_send: mode === "desktop_only" ? "running" : "paused",
          desktop_control: mode === "outbound_only" ? "running" : "paused"
        }
      });
    }
    runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, readKillSwitch(projectDir));
    appendNexusInsight(runtime, {
      text: `KillSwitch mode -> ${runtime.nexus.killSwitchMode}`
    });
    publishGatewayEvent(runtime, "gateway.killswitch.mode", {
      mode: runtime.nexus.killSwitchMode,
      at: nowIso24()
    });
    return {
      mode: runtime.nexus.killSwitchMode,
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("intervention.approve", async (params, context) => {
    const sessionID = parseText(params.sessionID) || "main";
    const permission = parseText(params.permission) || "external_message";
    const action = parseText(params.action) || `intervention_approve:${permission}`;
    const tierText = normalizeApprovalTier(parseText(params.tier).toLowerCase());
    const patternsRaw = Array.isArray(params.patterns) ? params.patterns : ["*"];
    const patterns = patternsRaw.map((item) => String(item).trim()).filter(Boolean);
    const normalizedPatterns = patterns.length > 0 ? patterns : ["*"];
    const requestHash = buildRequestHash(
      {
        permission,
        patterns: normalizedPatterns,
        toolCallID: "",
        messageID: ""
      },
      false
    );
    const token = saveApprovalToken(projectDir, sessionID, {
      trace_id: randomUUID17(),
      request_hash: requestHash,
      tier: tierText,
      action
    });
    const auditID = appendInterventionAudit(projectDir, {
      command: "approve",
      actor: context.clientID,
      sourceRole: context.role,
      payload: {
        sessionID,
        permission,
        patterns: normalizedPatterns,
        tier: tierText,
        requestHash,
        tokenExpiresAt: token.expires_at
      }
    });
    appendNexusInsight(runtime, {
      text: `Intervention approve -> ${permission} (${sessionID})`,
      auditID
    });
    publishGatewayEvent(runtime, "intervention.approve", {
      at: nowIso24(),
      auditID,
      sessionID,
      permission,
      tier: tierText,
      tokenExpiresAt: token.expires_at
    });
    return {
      status: "recorded",
      auditID,
      grant: {
        sessionID,
        permission,
        requestHash,
        expiresAt: token.expires_at
      }
    };
  });
  methods.register("intervention.pause", async (params, context) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) throw new Error("invalid_policy_domain");
    const result = await methods.invoke(
      "policy.domain.pause",
      { domain: domain3 },
      { clientID: context.clientID, role: "admin" }
    );
    const auditID = appendInterventionAudit(projectDir, {
      command: "pause",
      actor: context.clientID,
      sourceRole: context.role,
      payload: { domain: domain3, result }
    });
    publishGatewayEvent(runtime, "intervention.pause", {
      at: nowIso24(),
      auditID,
      domain: domain3,
      result
    });
    return {
      status: "recorded",
      auditID,
      domain: domain3,
      result
    };
  });
  methods.register("intervention.kill", async (params, context) => {
    const reason = parseText(params.reason) || "intervention_kill";
    const result = await methods.invoke(
      "killswitch.set_mode",
      { mode: "all_stop", reason },
      { clientID: context.clientID, role: "admin" }
    );
    const auditID = appendInterventionAudit(projectDir, {
      command: "kill",
      actor: context.clientID,
      sourceRole: context.role,
      payload: { reason, result }
    });
    publishGatewayEvent(runtime, "intervention.kill", {
      at: nowIso24(),
      auditID,
      reason,
      result
    });
    return {
      status: "recorded",
      auditID,
      result
    };
  });
  methods.register("intervention.annotate", async (params, context) => {
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_annotation_text");
    const at = parseText(params.at) || nowIso24();
    const targetAuditID = parseText(params.auditID) || void 0;
    const annotation = await methods.invoke(
      "insight.append",
      {
        text,
        at,
        auditID: targetAuditID
      },
      { clientID: context.clientID, role: "admin" }
    );
    const auditID = appendInterventionAudit(projectDir, {
      command: "annotate",
      actor: context.clientID,
      sourceRole: context.role,
      payload: {
        text,
        at,
        targetAuditID
      }
    });
    publishGatewayEvent(runtime, "intervention.annotate", {
      at,
      auditID,
      targetAuditID,
      text
    });
    return {
      status: "recorded",
      auditID,
      annotation
    };
  });
  methods.register("trust.set_mode", async (params) => {
    const silentMinRaw = Number(params.silentMin);
    const modalMaxRaw = Number(params.modalMax);
    if (!Number.isFinite(silentMinRaw) || !Number.isFinite(modalMaxRaw)) {
      throw new Error("invalid_trust_mode_thresholds");
    }
    const next = writeTrustModeConfig(projectDir, {
      silentMin: silentMinRaw,
      modalMax: modalMaxRaw
    });
    runtime.nexus.trustMode = next;
    appendNexusInsight(runtime, {
      text: `Trust mode updated: silent>=${next.silentMin}, modal<=${next.modalMax}`
    });
    publishGatewayEvent(runtime, "trust.mode.update", {
      at: nowIso24(),
      mode: next
    });
    return {
      mode: next
    };
  });
  methods.register("psyche.mode.get", async () => {
    const mode = readPsycheModeConfig(projectDir);
    runtime.nexus.psycheMode = mode;
    return {
      mode,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, mode)
    };
  });
  methods.register("psyche.mode.set", async (params) => {
    const next = writePsycheModeConfig(projectDir, {
      resonanceEnabled: typeof params.resonanceEnabled === "boolean" ? Boolean(params.resonanceEnabled) : void 0,
      captureProbeEnabled: typeof params.captureProbeEnabled === "boolean" ? Boolean(params.captureProbeEnabled) : void 0
    });
    runtime.nexus.psycheMode = next;
    appendNexusInsight(runtime, {
      text: `\u5B88\u95E8\u5458\u6A21\u5F0F\u5DF2\u66F4\u65B0\uFF1A\u5171\u9E23\u5C42=${next.resonanceEnabled ? "\u5F00\u542F" : "\u5173\u95ED"}\uFF0C\u622A\u56FE\u6838\u9A8C=${next.captureProbeEnabled ? "\u5F00\u542F" : "\u5173\u95ED"}`
    });
    publishGatewayEvent(runtime, "psyche.mode.update", {
      at: nowIso24(),
      mode: next,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, next)
    });
    return {
      mode: next,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, next)
    };
  });
  methods.register("learning.gate.get", async () => {
    const gate = readLearningGateConfig(projectDir);
    runtime.nexus.learningGate = gate;
    return { gate };
  });
  methods.register("learning.gate.set", async (params) => {
    const next = writeLearningGateConfig(projectDir, {
      candidateMode: params.candidateMode === "silent_audit" || params.candidateMode === "toast_gate" ? params.candidateMode : void 0,
      persistentRequiresApproval: typeof params.persistentRequiresApproval === "boolean" ? Boolean(params.persistentRequiresApproval) : void 0
    });
    runtime.nexus.learningGate = next;
    appendNexusInsight(runtime, {
      text: `\u5B66\u4E60\u95F8\u95E8\u5DF2\u66F4\u65B0\uFF1Acandidate=${next.candidateMode}, persistent_requires_approval=${next.persistentRequiresApproval ? "1" : "0"}`
    });
    publishGatewayEvent(runtime, "learning.gate.update", {
      at: nowIso24(),
      gate: next
    });
    return { gate: next };
  });
  methods.register("insight.append", async (params) => {
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_insight_text");
    const at = parseText(params.at) || nowIso24();
    const auditID = parseText(params.auditID);
    appendNexusInsight(runtime, { text, at, auditID: auditID || void 0 });
    publishGatewayEvent(runtime, "insight.append", {
      at,
      text,
      auditID: auditID || void 0
    });
    return {
      ok: true,
      at,
      text,
      auditID: auditID || void 0
    };
  });
  registerNodeMethods({
    projectDir,
    methods,
    runtime,
    parseText,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    enforceToken,
    hashText: hashText2
  });
  methods.register("skills.status", async () => ({
    enabled: listEnabledSkills(projectDir),
    discovered: discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? [])
  }));
  methods.register("miya.sync.list", async () => listEcosystemBridge(projectDir));
  methods.register("miya.sync.diff", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    return diffSourcePack(projectDir, sourcePackID);
  });
  methods.register("miya.sync.pull", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, "action=pull"]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    return pullSourcePack(projectDir, sourcePackID);
  });
  methods.register("miya.sync.apply", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const revision = parseText(params.revision) || void 0;
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, `revision=${revision ?? "latest"}`]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    return applySourcePack(projectDir, sourcePackID, { revision });
  });
  methods.register("miya.sync.rollback", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, "action=rollback"]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    return rollbackSourcePack(projectDir, sourcePackID);
  });
  methods.register("mcp.capabilities.list", async (params) => {
    const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
    const mcps = createBuiltinMcps(disabled);
    return {
      mcps: Object.entries(mcps).map(([name, config4]) => {
        const caps = "capabilities" in config4 ? config4.capabilities : void 0;
        return {
          name,
          type: config4.type,
          sampling: Boolean(caps?.sampling),
          mcpUi: Boolean(caps?.mcpUi),
          serviceExpose: Boolean(
            caps?.serviceExpose
          )
        };
      })
    };
  });
  methods.register("mcp.service.expose", async (params) => {
    const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
    return buildMcpServiceManifest(disabled);
  });
  methods.register("skills.enable", async (params) => {
    const skillID = parseText(params.skillID);
    if (!skillID) throw new Error("invalid_skill_id");
    const discovered = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []);
    const descriptor = discovered.find((item) => item.id === skillID || item.name === skillID);
    if (!descriptor) throw new Error(`skill_not_found:${skillID}`);
    if (!descriptor.gate.loadable) {
      throw new Error(`skill_not_loadable:${descriptor.gate.reasons.join("|")}`);
    }
    return { enabled: setSkillEnabled(projectDir, descriptor.id, true) };
  });
  methods.register("skills.disable", async (params) => {
    const skillID = parseText(params.skillID);
    if (!skillID) throw new Error("invalid_skill_id");
    return { enabled: setSkillEnabled(projectDir, skillID, false) };
  });
  methods.register("skills.install", async (params) => {
    const repo = parseText(params.repo);
    const targetName = parseText(params.targetName) || void 0;
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!repo) throw new Error("invalid_repo");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`repo=${repo}`]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    const root = path41.join(os5.homedir(), ".config", "opencode", "miya", "skills");
    fs41.mkdirSync(root, { recursive: true });
    const name = targetName || repo.split("/").filter(Boolean).pop()?.replace(/\.git$/i, "") || `skill-${Date.now().toString(36)}`;
    const target = path41.join(root, name);
    if (fs41.existsSync(target)) return { ok: false, message: `target_exists:${target}` };
    const proc = spawnSync6("git", ["clone", "--depth", "1", repo, target], {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "pipe"]
    });
    if (proc.status !== 0) {
      return {
        ok: false,
        message: String(proc.stderr || "").trim() || "git_clone_failed"
      };
    }
    const installed = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []).find(
      (item) => path41.resolve(item.dir) === path41.resolve(target)
    );
    if (!installed) {
      fs41.rmSync(target, { recursive: true, force: true });
      return {
        ok: false,
        message: "installed_skill_invalid:manifest_not_found"
      };
    }
    if (installed.gate.reasons.includes("missing_permission_metadata")) {
      fs41.rmSync(target, { recursive: true, force: true });
      return {
        ok: false,
        message: "installed_skill_invalid:missing_permission_metadata"
      };
    }
    return {
      ok: true,
      message: "installed",
      dir: target,
      gate: installed.gate
    };
  });
  methods.register("skills.update", async (params) => {
    const dir = parseText(params.dir);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!dir) throw new Error("invalid_dir");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`dir=${dir}`]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    const proc = spawnSync6("git", ["-C", dir, "pull", "--ff-only"], {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "pipe"]
    });
    if (proc.status !== 0) {
      return {
        ok: false,
        message: String(proc.stderr || "").trim() || "git_pull_failed"
      };
    }
    return {
      ok: true,
      message: String(proc.stdout || "").trim() || "updated"
    };
  });
  methods.register("media.ingest", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const source = parseText(params.source);
    const mimeType = parseText(params.mimeType);
    const fileName = parseText(params.fileName);
    if (!source || !mimeType || !fileName) throw new Error("invalid_media_ingest_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (params.kind !== "image" && params.kind !== "audio" && params.kind !== "video" && params.kind !== "file") {
      throw new Error("invalid_media_kind");
    }
    return ingestMedia(projectDir, {
      source,
      kind: params.kind,
      mimeType,
      fileName,
      contentBase64: parseText(params.contentBase64) || void 0,
      sizeBytes: typeof params.sizeBytes === "number" ? Number(params.sizeBytes) : void 0,
      ttlHours: typeof params.ttlHours === "number" ? Number(params.ttlHours) : void 0,
      metadata: params.metadata && typeof params.metadata === "object" ? params.metadata : void 0
    });
  });
  methods.register("media.get", async (params) => {
    const mediaID = parseText(params.mediaID);
    if (!mediaID) throw new Error("invalid_media_id");
    return getMediaItem(projectDir, mediaID);
  });
  methods.register("media.gc.run", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return runMediaGc(projectDir);
  });
  methods.register("media.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return listMediaItems(projectDir, limit);
  });
  registerVoiceMethods({
    projectDir,
    methods,
    parseText,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    verifyVoiceprintWithLocalModel,
    routeSessionMessage
  });
  methods.register("canvas.status", async () => {
    const state = readCanvasState(projectDir);
    return {
      activeDocID: state.activeDocID,
      docs: listCanvasDocs(projectDir),
      events: state.events.slice(0, 100)
    };
  });
  methods.register("canvas.list", async () => listCanvasDocs(projectDir));
  methods.register("canvas.get", async (params) => {
    const docID = parseText(params.docID);
    if (!docID) throw new Error("invalid_doc_id");
    return getCanvasDoc(projectDir, docID);
  });
  methods.register("canvas.open", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const title = parseText(params.title);
    const type = parseText(params.type);
    const content = parseText(params.content);
    if (!title) throw new Error("invalid_canvas_title");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (type && type !== "text" && type !== "markdown" && type !== "json" && type !== "html") {
      throw new Error("invalid_canvas_type");
    }
    const docType = type === "text" || type === "markdown" || type === "json" || type === "html" ? type : void 0;
    return openCanvasDoc(projectDir, {
      title,
      type: docType,
      content,
      actor: parseText(params.actor) || "gateway"
    });
  });
  methods.register("canvas.render", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const docID = parseText(params.docID);
    const content = parseText(params.content);
    if (!docID || !content) throw new Error("invalid_canvas_render_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return renderCanvasDoc(projectDir, {
      docID,
      content,
      merge: Boolean(params.merge),
      actor: parseText(params.actor) || "gateway"
    });
  });
  methods.register("canvas.close", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const docID = parseText(params.docID);
    if (!docID) throw new Error("invalid_doc_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return closeCanvasDoc(projectDir, docID, parseText(params.actor) || "gateway");
  });
  methods.register("companion.status", async () => readCompanionProfile(projectDir));
  methods.register("companion.wizard.start", async (params) => {
    const sessionId = parseText(params.sessionID) || "wizard:companion";
    const session = upsertSession(projectDir, {
      id: "wizard:companion",
      kind: "wizard",
      groupId: "wizard:companion",
      title: "Companion Onboarding",
      routingSessionID: "main",
      agent: "1-task-manager"
    });
    const profile = readCompanionProfile(projectDir);
    const forceReset = Boolean(params.forceReset);
    const wizard = !forceReset && !isCompanionWizardEmpty(projectDir, sessionId) ? readCompanionWizardState(projectDir, sessionId) : startCompanionWizard(projectDir, {
      sessionId,
      forceReset
    });
    return {
      session,
      profile,
      wizard,
      checklist: wizardChecklist(wizard),
      state: wizard.state,
      message: wizardPromptByState(wizard.state),
      instruction: "\u5C06\u7167\u7247\u62D6\u62FD\u5230\u804A\u5929\u4E2D"
    };
  });
  methods.register("companion.wizard.status", async (params) => {
    const wizard = readCompanionWizardState(projectDir, parseText(params.sessionID) || "main");
    return {
      wizard,
      checklist: wizardChecklist(wizard),
      prompt: wizardPromptByState(wizard.state)
    };
  });
  methods.register("companion.wizard.photos.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const mediaIDs = Array.isArray(params.photoMediaIDs) ? params.photoMediaIDs.map(String) : Array.isArray(params.imageMediaIDs) ? params.imageMediaIDs.map(String) : [];
    const sessionId = parseText(params.sessionID) || "main";
    const { state, job } = submitWizardPhotos(projectDir, { mediaIDs, sessionId });
    return {
      state: state.state,
      message: "\u6536\u5230\u7167\u7247\uFF0C\u5F00\u59CB\u8BAD\u7EC3\u56FE\u50CF\u6A21\u578B...",
      jobId: job.id,
      estimatedTime: job.estimatedTime,
      fallbackStrategy: job.fallbackStrategy,
      checklist: wizardChecklist(state)
    };
  });
  methods.register("companion.wizard.voice.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const mediaID = parseText(params.mediaID) || parseText(params.audioMediaID);
    if (!mediaID) throw new Error("invalid_voice_media_id");
    const sessionId = parseText(params.sessionID) || "main";
    const { state, job } = submitWizardVoice(projectDir, { mediaID, sessionId });
    return {
      state: state.state,
      message: "\u6536\u5230\u8BED\u97F3\u6837\u672C\uFF0C\u5F00\u59CB\u8BAD\u7EC3\u58F0\u97F3\u6A21\u578B...",
      jobId: job.id,
      estimatedTime: job.estimatedTime,
      checklist: wizardChecklist(state)
    };
  });
  methods.register("companion.wizard.personality.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const personalityText = parseText(params.personalityText);
    const sessionId = parseText(params.sessionID) || "main";
    const wizard = submitWizardPersonality(projectDir, {
      personalityText,
      sessionId
    });
    patchCompanionProfile(projectDir, {
      onboardingCompleted: true
    });
    return {
      state: wizard.state,
      message: WIZARD_PROMPT_DONE,
      personaPreview: wizard.assets.personalityText.slice(0, 120),
      checklist: wizardChecklist(wizard)
    };
  });
  methods.register("companion.wizard.cancel", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const sessionId = parseText(params.sessionID) || "main";
    const daemon = getMiyaClient(projectDir);
    const state = readCompanionWizardState(projectDir, sessionId);
    const cancelRequests = [];
    for (const job of state.jobs) {
      if (job.status === "queued" || job.status === "training") {
        cancelRequests.push(daemon.requestTrainingCancel(job.id));
      }
    }
    if (cancelRequests.length > 0) {
      await Promise.allSettled(cancelRequests);
    }
    const canceled = cancelCompanionWizardTraining(projectDir, sessionId);
    return {
      state: canceled.state,
      checklist: wizardChecklist(canceled),
      message: WIZARD_CANCELLED_MESSAGE
    };
  });
  methods.register("companion.wizard.submit", async (params) => {
    if (Array.isArray(params.photoMediaIDs) || Array.isArray(params.imageMediaIDs)) {
      return invokeGatewayMethod(
        projectDir,
        runtime,
        "companion.wizard.photos.submit",
        params,
        { clientID: "gateway", role: "admin" }
      );
    }
    if (typeof params.mediaID === "string" || typeof params.audioMediaID === "string") {
      return invokeGatewayMethod(
        projectDir,
        runtime,
        "companion.wizard.voice.submit",
        params,
        { clientID: "gateway", role: "admin" }
      );
    }
    if (typeof params.personalityText === "string") {
      return invokeGatewayMethod(
        projectDir,
        runtime,
        "companion.wizard.personality.submit",
        params,
        { clientID: "gateway", role: "admin" }
      );
    }
    throw new Error("invalid_wizard_submit_payload");
  });
  methods.register("companion.wizard.tick", async () => {
    await runWizardTrainingWorker(projectDir, runtime);
    return {
      wizard: readCompanionWizardState(projectDir, "main")
    };
  });
  methods.register("companion.wizard.progress.get", async (params) => {
    const jobID = parseText(params.jobId) || parseText(params.jobID);
    if (!jobID) throw new Error("invalid_job_id");
    const job = getWizardJobById(projectDir, jobID);
    if (!job) throw new Error("job_not_found");
    const status = job.status === "queued" ? "pending" : job.status;
    const nextStep = status === "completed" || status === "degraded" ? readCompanionWizardState(projectDir, job.sessionId).state : void 0;
    return {
      status,
      progress: job.progress,
      currentTier: job.currentTier,
      message: job.message ?? "",
      nextStep,
      checkpointPath: job.checkpointPath,
      sessionId: job.sessionId
    };
  });
  methods.register("companion.profile.update", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    return patchCompanionProfile(projectDir, {
      enabled: typeof params.enabled === "boolean" ? Boolean(params.enabled) : void 0,
      onboardingCompleted: typeof params.onboardingCompleted === "boolean" ? Boolean(params.onboardingCompleted) : void 0,
      name: parseText(params.name) || void 0,
      persona: parseText(params.persona) || void 0,
      relationship: parseText(params.relationship) || void 0,
      style: parseText(params.style) || void 0
    });
  });
  registerMemoryMethods({
    projectDir,
    methods,
    parseText,
    requireOwnerMode,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    resolveApprovalTicket,
    getLearningGate: () => runtime.nexus.learningGate
  });
  methods.register("miya.memory.sqlite.stats", async () => {
    requireOwnerMode(projectDir);
    return getCompanionMemorySqliteStats(projectDir);
  });
  methods.register("miya.memory.pack.compile", async (params) => {
    requireOwnerMode(projectDir);
    const query = parseText(params.query) || "";
    const domain3 = parseText(params.domain) === "relationship" || parseText(params.domain) === "personal" || parseText(params.domain) === "system" ? parseText(params.domain) : "work";
    const l0Limit = typeof params.l0Limit === "number" && params.l0Limit > 0 ? Math.min(20, Number(params.l0Limit)) : void 0;
    const l1Limit = typeof params.l1Limit === "number" && params.l1Limit > 0 ? Math.min(30, Number(params.l1Limit)) : void 0;
    const modeRaw = parseText(params.mode);
    const mode = modeRaw === "response" || modeRaw === "audit" ? modeRaw : "execution";
    return buildMemoryPack(projectDir, {
      query,
      domain: domain3,
      mode,
      l0Limit,
      l1Limit
    });
  });
  methods.register("miya.memory.perception.pack", async (params) => {
    requireOwnerMode(projectDir);
    const query = parseText(params.query) || "";
    const domain3 = parseText(params.domain) === "relationship" || parseText(params.domain) === "personal" || parseText(params.domain) === "system" ? parseText(params.domain) : "work";
    const modeRaw = parseText(params.mode);
    const mode = modeRaw === "response" || modeRaw === "audit" ? modeRaw : "execution";
    const pack = buildMemoryPack(projectDir, {
      query,
      domain: domain3,
      mode,
      l0Limit: typeof params.l0Limit === "number" && params.l0Limit > 0 ? Math.min(20, Number(params.l0Limit)) : void 0,
      l1Limit: typeof params.l1Limit === "number" && params.l1Limit > 0 ? Math.min(30, Number(params.l1Limit)) : void 0
    });
    return {
      mode,
      domain: domain3,
      pack
    };
  });
  methods.register("miya.memory.events.list", async (params) => {
    requireOwnerMode(projectDir);
    const since = parseText(params.since) || void 0;
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(2e3, Number(params.limit)) : void 0;
    return listMemoryEvents(projectDir, { since, limit });
  });
  methods.register("miya.memory.evidence.get", async (params) => {
    requireOwnerMode(projectDir);
    const auditID = parseText(params.auditID);
    if (!auditID) throw new Error("invalid_audit_id");
    const found = getEvidencePack(projectDir, auditID);
    if (!found) throw new Error("evidence_not_found");
    return found;
  });
  methods.register("miya.contextfs.get", async (params) => {
    requireOwnerMode(projectDir);
    const uri = parseText(params.uri);
    if (!uri) throw new Error("invalid_contextfs_uri");
    const resolved = resolveContextFsUri(projectDir, uri);
    if (!resolved) throw new Error("contextfs_not_found");
    return resolved;
  });
  methods.register("miya.memory.log.append", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || void 0;
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_memory_log_text");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const senderRaw = parseText(params.sender);
    const sender = senderRaw === "assistant" || senderRaw === "system" ? senderRaw : "user";
    const entry2 = appendShortTermMemoryLog(projectDir, {
      sessionID: parseText(params.sessionID) || "main",
      sender,
      text,
      at: parseText(params.at) || void 0,
      messageID: parseText(params.messageID) || void 0
    });
    return {
      entry: entry2,
      learningGate: {
        stage: "ephemeral",
        approvalMode: "silent_audit",
        interruptsUser: false
      }
    };
  });
  methods.register("miya.memory.reflect", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const force = typeof params.force === "boolean" ? Boolean(params.force) : false;
    const minLogs = typeof params.minLogs === "number" && params.minLogs > 0 ? Number(params.minLogs) : 1;
    const maxLogs = typeof params.maxLogs === "number" && params.maxLogs > 0 ? Math.min(500, Number(params.maxLogs)) : 50;
    const cooldownMinutes = typeof params.cooldownMinutes === "number" && params.cooldownMinutes >= 0 ? Number(params.cooldownMinutes) : 0;
    const idempotencyKey = parseText(params.idempotencyKey) || void 0;
    const result = reflectCompanionMemory(projectDir, {
      force,
      minLogs,
      maxLogs,
      cooldownMinutes,
      idempotencyKey,
      policyHash: currentPolicyHash(projectDir)
    });
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return {
      ...result,
      learningGate: {
        stage: "candidate",
        approvalMode: runtime.nexus.learningGate.candidateMode,
        interruptsUser: false
      },
      profile
    };
  });
  methods.register("companion.asset.add", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const type = parseText(params.type);
    const pathOrUrl = parseText(params.pathOrUrl);
    if (!pathOrUrl) throw new Error("invalid_asset_path");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (type !== "image" && type !== "audio") throw new Error("invalid_asset_type");
    return addCompanionAsset(projectDir, {
      type,
      pathOrUrl,
      label: parseText(params.label) || void 0
    });
  });
  methods.register("companion.asset.list", async () => readCompanionProfile(projectDir).assets);
  methods.register("companion.reset", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_delete");
    const profile = resetCompanionProfile(projectDir);
    const wizard = resetCompanionWizard(projectDir);
    return { profile, wizard };
  });
  methods.register("companion.intent.handle", async (params) => {
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_intent_text");
    const channel = parseChannel(params.channel) ?? "wechat";
    const destination = parseText(params.destination);
    const sessionID = parseText(params.sessionID) || "main";
    const intent = detectMultimodalIntent(text);
    if (intent.type === "selfie") {
      const generated = await generateImage(projectDir, {
        prompt: intent.prompt,
        model: "local:flux.1-schnell",
        registerAsCompanionAsset: true
      });
      if (!destination) {
        return {
          intent: "selfie",
          sent: false,
          mediaID: generated.media.id,
          path: generated.media.localPath,
          message: "selfie_generated_destination_missing"
        };
      }
      const send = await sendChannelMessageGuarded(projectDir, runtime, {
        channel,
        destination,
        text: "\u7ED9\u4F60\u4E00\u5F20\u6211\u7684\u81EA\u62CD",
        mediaPath: generated.media.localPath,
        sessionID,
        policyHash: currentPolicyHash(projectDir),
        outboundCheck: {
          archAdvisorApproved: true,
          intent: "reply"
        }
      });
      return {
        intent: "selfie",
        sent: send.sent,
        send,
        mediaID: generated.media.id,
        path: generated.media.localPath
      };
    }
    if (intent.type === "voice_to_friend") {
      const resolvedDestination = destination || intent.friend;
      if (!resolvedDestination) throw new Error("voice_destination_missing");
      const voice = await synthesizeVoiceOutput(projectDir, {
        text,
        voice: "companion",
        model: "local:gpt-sovits-v2pro",
        format: "wav",
        registerAsCompanionAsset: true
      });
      const send = await sendChannelMessageGuarded(projectDir, runtime, {
        channel: "wechat",
        destination: resolvedDestination,
        text: "\u8BED\u97F3\u6D88\u606F\u5DF2\u751F\u6210",
        mediaPath: voice.media.localPath,
        sessionID,
        policyHash: currentPolicyHash(projectDir),
        outboundCheck: {
          archAdvisorApproved: true,
          intent: "reply"
        }
      });
      return {
        intent: "voice_to_friend",
        friend: resolvedDestination,
        sent: send.sent,
        send,
        mediaID: voice.media.id,
        path: voice.media.localPath
      };
    }
    return { intent: "unknown", message: "no_multimodal_intent_matched" };
  });
  methods.register("daemon.vram.budget", async (params) => {
    const scheduler = getResourceScheduler(projectDir);
    const modelID = parseText(params.modelID) || "local:flux.1-schnell";
    const kindRaw = parseText(params.kind);
    const kind = kindRaw === "image.generate" || kindRaw === "vision.analyze" || kindRaw === "voice.tts" || kindRaw === "voice.asr" || kindRaw === "training.image" || kindRaw === "training.voice" || kindRaw === "shell.exec" ? kindRaw : "generic";
    const requestVram = typeof params.vramMB === "number" ? Number(params.vramMB) : 1024;
    const modelVram = typeof params.modelVramMB === "number" ? Number(params.modelVramMB) : 2048;
    const snapshot = scheduler.snapshot();
    const budget = calculateVramBudget({
      snapshot,
      task: {
        taskID: kind,
        taskVramMB: requestVram
      },
      models: [{ modelID, vramMB: modelVram, required: true }]
    });
    return {
      snapshot,
      budget,
      swapAction: decideModelSwapAction({
        currentModelID: snapshot.loadedModels[0]?.modelID,
        targetModelID: modelID,
        budget
      })
    };
  });
  return methods;
}
async function routeGatewayHttpRequest(projectDir, runtime, request, controlUi) {
  const url3 = new URL(request.url);
  if (url3.pathname === "/api/status") {
    return Response.json(buildSnapshot(projectDir, runtime), {
      headers: { "cache-control": "no-store" }
    });
  }
  const controlUiResponse = handleControlUiHttpRequest(request, controlUi);
  if (controlUiResponse) {
    const missingUiFallback = controlUiResponse.status === 503 && controlUi.root?.kind !== "resolved";
    if (missingUiFallback) {
      logControlUiFallback(projectDir, url3.pathname, controlUi, controlUiResponse.status);
    }
    if (!missingUiFallback) return controlUiResponse;
  }
  if (url3.pathname === "/webchat") {
    return new Response(renderWebChatHtml(), {
      headers: {
        "content-type": "text/html; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  if (url3.pathname.startsWith("/api/webhooks/")) {
    return new Response("HTTP control API disabled; use WebSocket RPC (/ws).", {
      status: 410,
      headers: {
        "content-type": "text/plain; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  if (url3.pathname === "/" || url3.pathname === "/index.html") {
    const gatewayState = syncGatewayState(projectDir, runtime);
    const uiBasePath = normalizeControlUiBasePath(controlUi.basePath || "/control") || "/control";
    const wsUrl = `${gatewayState.url.replace(/^http/i, "ws")}/ws`;
    return new Response(
      [
        "Miya Gateway is running.",
        `status=${gatewayState.status}`,
        `api_status=${gatewayState.url}/api/status`,
        `ws=${wsUrl}`,
        `control_ui=${gatewayState.url}${uiBasePath}`
      ].join("\n"),
      {
        headers: {
          "content-type": "text/plain; charset=utf-8",
          "cache-control": "no-store"
        }
      }
    );
  }
  if (url3.pathname === "/console") {
    return new Response(renderConsoleHtml(buildSnapshot(projectDir, runtime)), {
      headers: {
        "content-type": "text/html; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  return new Response("Not Found", { status: 404 });
}
function ensureGatewayRunning(projectDir) {
  const existing = runtimes.get(projectDir);
  if (existing) {
    const owner2 = acquireGatewayOwner(projectDir);
    if (owner2.owned) {
      touchOwnerLock(projectDir);
    }
    log("[gateway] runtime already active; reused existing runtime", {
      projectDir,
      owner: describeOwnerLock(owner2.owner ?? null)
    });
    return syncGatewayState(projectDir, existing);
  }
  const owner = acquireGatewayOwner(projectDir);
  if (!owner.owned) {
    const state = readGatewayStateFile(projectDir);
    const ownerAlive = owner.owner ? isProcessAlive(owner.owner.pid) : false;
    const ownerFresh = owner.owner ? isOwnerLockFresh(owner.owner) : false;
    log("[gateway] owner lock held by another process", {
      projectDir,
      owner: describeOwnerLock(owner.owner ?? null),
      state: describeGatewayState(state)
    });
    if (state && owner.owner && state.pid !== owner.owner.pid) {
      clearGatewayStateFile(projectDir);
      log("[gateway] cleared stale gateway state file due to pid mismatch", {
        projectDir,
        statePid: state.pid,
        ownerPid: owner.owner.pid
      });
    }
    if (state && isProcessAlive(state.pid)) {
      log("[gateway] follower mode attached to existing owner state", {
        projectDir,
        state: describeGatewayState(state)
      });
      return state;
    }
    if (state && !isProcessAlive(state.pid)) {
      clearGatewayStateFile(projectDir);
      log("[gateway] removed dead gateway state pid", {
        projectDir,
        statePid: state.pid
      });
    }
    if (owner.owner && !ownerAlive) {
      const retry = acquireGatewayOwner(projectDir);
      if (!retry.owned) {
        log("[gateway] ownership reacquire failed after dead owner detected", {
          projectDir,
          previousOwner: describeOwnerLock(owner.owner),
          retryOwner: describeOwnerLock(retry.owner ?? null)
        });
        throw new Error("gateway_owned_by_other_process");
      }
      log("[gateway] ownership reacquired after dead owner detected", {
        projectDir,
        retryOwner: describeOwnerLock(retry.owner ?? null)
      });
    } else {
      log("[gateway] follower refused ownership takeover", {
        projectDir,
        ownerAlive,
        ownerFresh
      });
      throw new Error("gateway_owned_by_other_process");
    }
  }
  let runtime;
  const methods = new GatewayMethodRegistry();
  const controlUi = createControlUiRequestOptions(projectDir);
  const channelRuntime = new ChannelRuntime(projectDir, {
    onInbound: async (message) => {
      await onInboundMessage(projectDir, runtime, message);
    },
    onPairRequested: async () => {
      maybeBroadcast(projectDir, runtime);
    }
  });
  const listen = resolveGatewayListenOptions(projectDir);
  log("[gateway] creating runtime server", {
    projectDir,
    listen,
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
    controlUiRoot: controlUi.root?.kind ?? "unknown"
  });
  try {
    const port = reserveGatewayPort(listen.hostname, listen.port);
    const wsServer = new WebSocketServer({ noServer: true });
    const httpServer = createServer((req, res) => {
      void (async () => {
        const request = toNodeRequest(req, listen.hostname, port);
        const response = await routeGatewayHttpRequest(projectDir, runtime, request, controlUi);
        await sendNodeResponse(req, res, response);
      })().catch((error92) => {
        log("[gateway] http request failed", {
          projectDir,
          error: error92 instanceof Error ? error92.message : String(error92)
        });
        if (!res.headersSent) {
          res.statusCode = 500;
          res.setHeader("content-type", "text/plain; charset=utf-8");
        }
        if (!res.writableEnded) {
          res.end("Internal Server Error");
        }
      });
    });
    httpServer.on("upgrade", (req, socket, head) => {
      const requestUrl = new URL(req.url || "/", `http://${req.headers.host || "127.0.0.1"}`);
      if (requestUrl.pathname !== "/ws") {
        socket.write("HTTP/1.1 404 Not Found\r\n\r\n");
        socket.destroy();
        return;
      }
      wsServer.handleUpgrade(req, socket, head, (ws) => {
        wsServer.emit("connection", ws, req);
      });
    });
    runtime = {
      startedAt: nowIso24(),
      server: {
        hostname: listen.hostname,
        port,
        httpServer,
        wsServer
      },
      methods,
      stateVersion: 1,
      controlUi,
      channelRuntime,
      outboundSendDedupe: /* @__PURE__ */ new Map(),
      wsClients: /* @__PURE__ */ new Set(),
      nodeSockets: /* @__PURE__ */ new Map(),
      wsMeta: /* @__PURE__ */ new WeakMap(),
      wizardTickTimer: void 0,
      ownerBeatTimer: void 0,
      memoryReflectTimer: void 0,
      wizardRunnerBusy: false,
      dependencyAssistHashes: /* @__PURE__ */ new Set(),
      daemonLauncherUnsubscribe: void 0,
      startupSelfCheck: void 0,
      negotiationBudgets: /* @__PURE__ */ new Map(),
      nexus: {
        sessionId: "main",
        activeTool: void 0,
        jobId: void 0,
        permission: void 0,
        pendingTickets: 0,
        killSwitchMode: "off",
        insights: [],
        trust: void 0,
        trustMode: readTrustModeConfig(projectDir),
        psycheMode: readPsycheModeConfig(projectDir),
        learningGate: readLearningGateConfig(projectDir),
        guardianSafeHoldReason: void 0
      }
    };
    runtime.startupSelfCheck = void 0;
    runtime.methods = createMethods(projectDir, runtime);
    wsServer.on("connection", (ws) => {
      runtime.wsClients.add(ws);
      ensureWsData(runtime, ws);
      ws.on("close", () => {
        const wsData = ensureWsData(runtime, ws);
        if (wsData.nodeID) {
          runtime.nodeSockets.delete(wsData.nodeID);
          markNodeDisconnected(projectDir, wsData.nodeID);
        }
        runtime.wsClients.delete(ws);
        runtime.wsMeta.delete(ws);
      });
      ws.on("message", async (input) => {
        const wsData = ensureWsData(runtime, ws);
        const parsed = parseIncomingFrame(normalizeWsInput(input));
        if (!parsed.frame) {
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: "invalid",
                ok: false,
                errorCode: "bad_request",
                errorMessage: parsed.error ?? "invalid_frame"
              })
            )
          );
          return;
        }
        const frame = parsed.frame;
        if (frame.type === "ping") {
          ws.send(JSON.stringify(toPongFrame(frame.ts)));
          return;
        }
        if (frame.type === "hello") {
          const requiredToken = process.env.MIYA_GATEWAY_TOKEN;
          const incomingToken = frame.auth?.token;
          if (requiredToken && incomingToken !== requiredToken) {
            ws.send(
              JSON.stringify(
                toResponseFrame({
                  id: "hello",
                  ok: false,
                  errorCode: "unauthorized",
                  errorMessage: "invalid_gateway_token"
                })
              )
            );
            ws.close();
            return;
          }
          wsData.authenticated = true;
          if (frame.clientID) wsData.clientID = frame.clientID;
          if (frame.role) wsData.role = frame.role;
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: "hello",
                ok: true,
                result: {
                  clientID: wsData.clientID,
                  role: wsData.role,
                  methods: runtime.methods.list()
                }
              })
            )
          );
          return;
        }
        if (!wsData.authenticated) {
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: frame.id,
                ok: false,
                errorCode: "unauthorized",
                errorMessage: "send_hello_with_auth_first"
              })
            )
          );
          return;
        }
        if (frame.method === "gateway.subscribe") {
          wsData.subscriptions = new Set(
            Array.isArray(frame.params?.events) ? frame.params.events.map(String) : ["*"]
          );
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: frame.id,
                ok: true,
                result: {
                  subscribed: [...wsData.subscriptions]
                }
              })
            )
          );
          setTimeout(() => {
            try {
              ws.send(
                JSON.stringify(
                  toEventFrame({
                    event: "gateway.snapshot",
                    payload: buildSnapshot(projectDir, runtime),
                    stateVersion: { gateway: runtime.stateVersion }
                  })
                )
              );
            } catch {
            }
          }, 0);
          return;
        }
        if (frame.method === "nodes.register") {
          const nodeID = parseText(frame.params?.nodeID);
          if (nodeID) {
            wsData.nodeID = nodeID;
            runtime.nodeSockets.set(nodeID, ws);
          }
        }
        runtime.nexus.activeTool = frame.method;
        const frameSessionID = parseText(frame.params?.sessionID);
        if (frameSessionID) {
          runtime.nexus.sessionId = frameSessionID;
        }
        const frameJobID = parseText(frame.params?.jobID) || parseText(frame.params?.jobId);
        if (frameJobID) {
          runtime.nexus.jobId = frameJobID;
        }
        const invokeStartedAt = Date.now();
        try {
          const result = await invokeGatewayMethod(
            projectDir,
            runtime,
            frame.method,
            frame.params ?? {},
            {
              clientID: wsData.clientID,
              role: wsData.role,
              ws
            }
          );
          appendGatewayMethodAudit(projectDir, {
            method: frame.method,
            requestID: frame.id,
            clientID: wsData.clientID,
            role: wsData.role,
            sessionID: frameSessionID || void 0,
            jobID: frameJobID || void 0,
            ok: true,
            durationMs: Date.now() - invokeStartedAt
          });
          ws.send(JSON.stringify(toResponseFrame({ id: frame.id, ok: true, result })));
          if (frame.method !== "gateway.status.get") {
            maybeBroadcast(projectDir, runtime);
          }
        } catch (error92) {
          const messageText = error92 instanceof Error ? error92.message : String(error92);
          appendGatewayMethodAudit(projectDir, {
            method: frame.method,
            requestID: frame.id,
            clientID: wsData.clientID,
            role: wsData.role,
            sessionID: frameSessionID || void 0,
            jobID: frameJobID || void 0,
            ok: false,
            durationMs: Date.now() - invokeStartedAt,
            error: messageText
          });
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: frame.id,
                ok: false,
                errorCode: messageText.startsWith("unknown_method:") ? "unknown_method" : "method_failed",
                errorMessage: messageText
              })
            )
          );
        }
      });
    });
    httpServer.listen(port, listen.hostname);
  } catch (error92) {
    clearGatewayStateFile(projectDir);
    removeOwnerLock(projectDir);
    log("[gateway] failed to bind server", {
      projectDir,
      listen,
      error: error92 instanceof Error ? error92.message : String(error92)
    });
    throw error92;
  }
  runtimes.set(projectDir, runtime);
  runtime.wizardTickTimer = setInterval(() => {
    void runWizardTrainingWorker(projectDir, runtime);
  }, 1200);
  runtime.ownerBeatTimer = setInterval(() => {
    touchOwnerLock(projectDir);
  }, 5e3);
  runtime.memoryReflectTimer = setInterval(() => {
    const reflected = maybeAutoReflectCompanionMemory(projectDir, {
      idleMinutes: 60,
      minPendingLogs: 200,
      cooldownMinutes: 12 * 60,
      maxLogs: 500
    });
    if (reflected) {
      syncCompanionProfileMemoryFacts(projectDir);
    }
  }, 5 * 60 * 1e3);
  runtime.daemonLauncherUnsubscribe = subscribeLauncherEvents(projectDir, (event) => {
    appendDaemonProgressAudit(projectDir, event);
    if (event.type === "job.progress") {
      publishGatewayEvent(runtime, "daemon.job_progress", event);
      const phase = String(event.payload?.phase ?? "");
      if (phase === "audio.filler") {
        publishGatewayEvent(runtime, "daemon.audio_filler", event);
      }
      const config3 = readConfig(projectDir);
      const notifyOnTerminal = config3.runtime?.notifications?.job_toast !== false;
      const status = String(event.payload?.status ?? "").trim().toLowerCase();
      if (notifyOnTerminal && (status === "completed" || status === "failed" || status === "degraded" || status === "canceled")) {
        publishGatewayEvent(runtime, "daemon.job_terminal", event);
      }
      return;
    }
    publishGatewayEvent(runtime, event.type, event);
  });
  void runtime.channelRuntime.start();
  log("[gateway] runtime started", {
    projectDir,
    state: toGatewayState(projectDir, runtime),
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir))
  });
  return syncGatewayState(projectDir, runtime);
}
function createGatewayTools(ctx) {
  const miya_gateway_start = tool({
    description: "Start Miya Gateway and persist .opencode/miya/gateway.json.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      const state = ensureGatewayRunning(ctx.directory);
      const persisted = readPersistedAgentRuntime(ctx.directory);
      const owner = ownerSummary(ctx.directory);
      const healthy = await probeGatewayAlive(state.url, 1e3);
      return [
        formatGatewayStateWithRuntime(
          state,
          owner.ownerPID,
          owner.isOwner,
          persisted.activeAgentId,
          persisted.revision
        ),
        `gateway_healthy=${healthy}`
      ].join("\n");
    }
  });
  const miya_gateway_status = tool({
    description: "Read current Miya Gateway state.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      const state = ensureGatewayRunning(ctx.directory);
      const persisted = readPersistedAgentRuntime(ctx.directory);
      const owner = ownerSummary(ctx.directory);
      const healthy = await probeGatewayAlive(state.url, 1e3);
      return [
        formatGatewayStateWithRuntime(
          state,
          owner.ownerPID,
          owner.isOwner,
          persisted.activeAgentId,
          persisted.revision
        ),
        `gateway_healthy=${healthy}`
      ].join("\n");
    }
  });
  const miya_gateway_doctor = tool({
    description: "Run control-plane doctor checks.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      ensureGatewayRunning(ctx.directory);
      const runtime = runtimes.get(ctx.directory);
      if (!runtime) return "doctor_failed=gateway_unavailable";
      const issues = buildSnapshot(ctx.directory, runtime).doctor.issues;
      if (issues.length === 0) return "doctor=ok\nissues=0";
      return [
        "doctor=issues",
        `issues=${issues.length}`,
        ...issues.map((issue3) => `- [${issue3.severity}] ${issue3.code} | ${issue3.message}`)
      ].join("\n");
    }
  });
  const miya_gateway_shutdown = tool({
    description: "Stop Miya Gateway runtime.",
    args: {},
    async execute() {
      const result = stopGateway(ctx.directory);
      if (!result.stopped) return "stopped=false\nreason=not_running";
      return [
        "stopped=true",
        `url=${result.previous?.url ?? ""}`,
        `port=${result.previous?.port ?? 0}`
      ].join("\n");
    }
  });
  const miya_memory_reflect = tool({
    description: "Trigger Miya memory reflection (Memory Consolidation Loop) and sync long-term graph.",
    args: {
      force: z2.boolean().optional().describe("Force reflection even with low pending logs"),
      minLogs: z2.number().optional().describe("Minimum pending logs required"),
      maxLogs: z2.number().optional().describe("Maximum logs processed in this run"),
      cooldownMinutes: z2.number().optional().describe("Cooldown window in minutes"),
      idempotencyKey: z2.string().optional().describe("Optional idempotency key")
    },
    async execute(args) {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      ensureGatewayRunning(ctx.directory);
      const runtime = runtimes.get(ctx.directory);
      if (!runtime) throw new Error("gateway_runtime_unavailable");
      const result = await invokeGatewayMethod(
        ctx.directory,
        runtime,
        "miya.memory.reflect",
        {
          policyHash: currentPolicyHash(ctx.directory),
          force: Boolean(args.force),
          minLogs: typeof args.minLogs === "number" ? Math.floor(args.minLogs) : void 0,
          maxLogs: typeof args.maxLogs === "number" ? Math.floor(args.maxLogs) : void 0,
          cooldownMinutes: typeof args.cooldownMinutes === "number" ? Number(args.cooldownMinutes) : void 0,
          idempotencyKey: typeof args.idempotencyKey === "string" && args.idempotencyKey.trim().length > 0 ? args.idempotencyKey.trim() : void 0
        },
        { clientID: "gateway-tool", role: "admin" }
      );
      return JSON.stringify(result, null, 2);
    }
  });
  return {
    miya_gateway_start,
    miya_gateway_status,
    miya_gateway_doctor,
    miya_gateway_shutdown,
    miya_memory_reflect
  };
}
function startGatewayWithLog(projectDir) {
  const stateFile3 = gatewayFile(projectDir);
  const ownerFile = gatewayOwnerLockFile(projectDir);
  log("[gateway] startup requested", {
    projectDir,
    pid: process.pid,
    stateFile: stateFile3,
    ownerFile,
    existingState: describeGatewayState(readGatewayStateFile(projectDir)),
    existingOwner: describeOwnerLock(readGatewayOwnerLock(projectDir))
  });
  try {
    const state = ensureGatewayRunning(projectDir);
    const owner = ownerSummary(projectDir);
    log("[gateway] started", {
      ...state,
      owner
    });
    void probeGatewayAlive(state.url, 1500).then((healthy) => {
      log("[gateway] startup health probe result", {
        projectDir,
        url: state.url,
        healthy
      });
    }).catch((error92) => {
      log("[gateway] startup health probe failed", {
        projectDir,
        url: state.url,
        error: error92 instanceof Error ? error92.message : String(error92)
      });
    });
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    if (message === "gateway_owned_by_other_process") {
      const owner = readGatewayOwnerLock(projectDir);
      const state = readGatewayStateFile(projectDir);
      log("[gateway] follower mode: owner is another process", {
        projectDir,
        owner: describeOwnerLock(owner),
        state: describeGatewayState(state)
      });
      const timerKey = projectDir;
      if (!followerRecoveryTimers.has(timerKey)) {
        const timer = setTimeout(() => {
          followerRecoveryTimers.delete(timerKey);
          try {
            const recovered = ensureGatewayRunning(projectDir);
            log("[gateway] follower delayed recovery succeeded", {
              projectDir,
              state: recovered
            });
          } catch (recoveryError) {
            log("[gateway] follower delayed recovery still blocked", {
              projectDir,
              error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError),
              owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
              state: describeGatewayState(readGatewayStateFile(projectDir))
            });
          }
        }, 6e3);
        followerRecoveryTimers.set(timerKey, timer);
      }
      return;
    }
    log("[gateway] failed to start", {
      projectDir,
      error: message,
      owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
      state: describeGatewayState(readGatewayStateFile(projectDir))
    });
  }
}
var z2, runtimes, dependencies, ownerTokens, controlUiFallbackLoggedAtByDir, followerRecoveryTimers, DEFAULT_TRUST_MODE, DEFAULT_PSYCHE_MODE, DEFAULT_LEARNING_GATE, WIZARD_PROMPT_PHOTOS, WIZARD_PROMPT_VOICE, WIZARD_PROMPT_PERSONALITY, WIZARD_PROMPT_DONE, WIZARD_CANCELLED_MESSAGE, WIZARD_REQUEUE_MESSAGE, UI_ALLOWED_METHODS;
var init_gateway = __esm({
  "src/gateway/index.ts"() {
    "use strict";
    init_dist();
    init_channel();
    init_channel();
    init_channel();
    init_store3();
    init_state_machine();
    init_risk();
    init_policy2();
    init_decision_fusion();
    init_incident();
    init_nodes();
    init_store2();
    init_daemon();
    init_owner_identity();
    init_owner_sync();
    init_settings();
    init_state2();
    init_agent_model_persistence();
    init_provider_override_audit();
    init_agent_model_api();
    init_state3();
    init_store4();
    init_memory_vector();
    init_memory_sqlite();
    init_memory_reflect();
    init_wizard();
    init_multimodal();
    init_resource_scheduler();
    init_sessions();
    init_router2();
    init_loader2();
    init_state4();
    init_sync();
    init_mcp();
    init_logger();
    init_workflow();
    init_learning();
    init_autoflow();
    init_control_ui();
    init_control_ui_shared();
    init_bootstrap();
    init_http_router();
    init_negotiation_budget();
    init_channels();
    init_memory();
    init_nodes2();
    init_registry2();
    init_security();
    init_voice2();
    init_ownership_lock();
    init_console();
    init_webchat();
    init_sanitizer();
    init_state_files();
    init_protocol();
    init_ws_runtime();
    z2 = tool.schema;
    runtimes = /* @__PURE__ */ new Map();
    dependencies = /* @__PURE__ */ new Map();
    ownerTokens = /* @__PURE__ */ new Map();
    controlUiFallbackLoggedAtByDir = /* @__PURE__ */ new Map();
    followerRecoveryTimers = /* @__PURE__ */ new Map();
    DEFAULT_TRUST_MODE = {
      silentMin: 90,
      modalMax: 50
    };
    DEFAULT_PSYCHE_MODE = {
      resonanceEnabled: true,
      captureProbeEnabled: true
    };
    DEFAULT_LEARNING_GATE = {
      candidateMode: "toast_gate",
      persistentRequiresApproval: true
    };
    WIZARD_PROMPT_PHOTOS = "\u7ED9\u6211\u5C55\u793A\u6211\u5E94\u8BE5\u662F\u4EC0\u4E48\u6837\u5B50\u3002\u53D1\u90011\u52305\u5F20\u7167\u7247\u3002";
    WIZARD_PROMPT_VOICE = "\u6211\u5E94\u8BE5\u7528\u4EC0\u4E48\u58F0\u97F3\uFF1F\u5F55\u97F3\u6216\u53D1\u9001\u6587\u4EF6\u3002";
    WIZARD_PROMPT_PERSONALITY = "\u6211\u662F\u8C01\uFF1F\u544A\u8BC9\u6211\u6211\u7684\u6027\u683C\u3001\u4E60\u60EF\u548C\u6211\u4EEC\u7684\u5173\u7CFB\u3002";
    WIZARD_PROMPT_DONE = "\u8BBE\u7F6E\u5B8C\u6210\u3002\u4F60\u597D\uFF0C\u4EB2\u7231\u7684\uFF01";
    WIZARD_CANCELLED_MESSAGE = "\u8BAD\u7EC3\u5DF2\u53D6\u6D88/\u53EF\u91CD\u8BD5";
    WIZARD_REQUEUE_MESSAGE = "\u8BAD\u7EC3\u4E2D\u65AD\uFF0C\u5DF2\u4ECEcheckpoint\u81EA\u52A8\u91CD\u6392\u961F\u6062\u590D";
    UI_ALLOWED_METHODS = /* @__PURE__ */ new Set([
      "gateway.status.get",
      "gateway.backpressure.stats",
      "daemon.backpressure.stats",
      "doctor.run",
      "config.center.get",
      "provider.override.audit.list",
      "sessions.list",
      "sessions.get",
      "cron.list",
      "cron.runs.list",
      "cron.approvals.list",
      "channels.list",
      "channels.status",
      "channels.pair.list",
      "channels.contact.tier.get",
      "channels.contact.tier.list",
      "security.identity.status",
      "security.voiceprint.threshold.get",
      "policy.get",
      "policy.domains.list",
      "policy.incidents.list",
      "psyche.mode.get",
      "learning.gate.get",
      "nodes.list",
      "nodes.status",
      "nodes.describe",
      "nodes.pair.list",
      "devices.list",
      "skills.status",
      "miya.sync.list",
      "miya.sync.diff",
      "mcp.capabilities.list",
      "media.get",
      "media.list",
      "voice.status",
      "voice.history.list",
      "canvas.status",
      "canvas.list",
      "canvas.get",
      "companion.status",
      "companion.wizard.status",
      "companion.memory.list",
      "companion.memory.pending.list",
      "companion.memory.corrections.list",
      "companion.memory.add",
      "companion.memory.confirm",
      "companion.memory.update",
      "companion.memory.archive",
      "companion.memory.search",
      "companion.memory.vector.list",
      "miya.memory.sqlite.stats",
      "miya.memory.pack.compile",
      "miya.memory.perception.pack",
      "miya.memory.events.list",
      "miya.memory.evidence.get",
      "miya.contextfs.get",
      "daemon.vram.budget",
      "autoflow.status.get",
      "routing.stats.get",
      "learning.drafts.stats",
      "learning.drafts.list",
      "learning.drafts.recommend",
      // Stateless console may only observe or submit human interventions.
      "intervention.approve",
      "intervention.pause",
      "intervention.kill",
      "intervention.annotate"
    ]);
  }
});

// src/safety/evidence.ts
var LARGE_FILE_LIMIT;
var init_evidence = __esm({
  "src/safety/evidence.ts"() {
    "use strict";
    init_utils2();
    LARGE_FILE_LIMIT = 2 * 1024 * 1024;
  }
});

// src/safety/verifier.ts
var init_verifier = __esm({
  "src/safety/verifier.ts"() {
    "use strict";
  }
});

// src/settings/tools.ts
var z3;
var init_tools = __esm({
  "src/settings/tools.ts"() {
    "use strict";
    init_dist();
    init_gateway();
    init_evidence();
    init_store3();
    init_verifier();
    init_registry();
    init_store();
    z3 = tool.schema;
  }
});

// src/settings/index.ts
var init_settings = __esm({
  "src/settings/index.ts"() {
    "use strict";
    init_registry();
    init_store();
    init_tools();
  }
});

// src/daemon/ws-protocol.ts
function parseDaemonOutgoingFrame(input) {
  try {
    const value = typeof input === "string" ? JSON.parse(input) : input;
    const frame = DaemonOutgoingFrameSchema.parse(value);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}
var JsonValue2, JsonObject2, DaemonHelloFrameSchema, DaemonRequestFrameSchema, DaemonResponseFrameSchema, DaemonEventFrameSchema, DaemonPingFrameSchema, DaemonPongFrameSchema, DaemonIncomingFrameSchema, DaemonOutgoingFrameSchema;
var init_ws_protocol = __esm({
  "src/daemon/ws-protocol.ts"() {
    "use strict";
    init_zod();
    JsonValue2 = external_exports.lazy(
      () => external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean(), external_exports.null(), external_exports.array(JsonValue2), external_exports.record(external_exports.string(), JsonValue2)])
    );
    JsonObject2 = external_exports.record(external_exports.string(), JsonValue2);
    DaemonHelloFrameSchema = external_exports.object({
      type: external_exports.literal("hello"),
      clientID: external_exports.string().min(1).max(120).optional(),
      role: external_exports.enum(["plugin", "ui", "unknown"]).default("plugin"),
      protocolVersion: external_exports.string().default("1.0"),
      auth: external_exports.object({
        token: external_exports.string().min(1)
      }).optional()
    });
    DaemonRequestFrameSchema = external_exports.object({
      type: external_exports.literal("request"),
      id: external_exports.string().min(1),
      method: external_exports.string().min(1),
      params: JsonObject2.default({})
    });
    DaemonResponseFrameSchema = external_exports.object({
      type: external_exports.literal("response"),
      id: external_exports.string(),
      ok: external_exports.boolean(),
      result: JsonValue2.optional(),
      error: external_exports.object({
        code: external_exports.string(),
        message: external_exports.string(),
        details: JsonValue2.optional()
      }).optional()
    });
    DaemonEventFrameSchema = external_exports.object({
      type: external_exports.literal("event"),
      event: external_exports.string().min(1),
      payload: JsonValue2
    });
    DaemonPingFrameSchema = external_exports.object({
      type: external_exports.literal("ping"),
      ts: external_exports.number().int().nonnegative()
    });
    DaemonPongFrameSchema = external_exports.object({
      type: external_exports.literal("pong"),
      ts: external_exports.number().int().nonnegative()
    });
    DaemonIncomingFrameSchema = external_exports.union([
      DaemonHelloFrameSchema,
      DaemonRequestFrameSchema,
      DaemonPingFrameSchema
    ]);
    DaemonOutgoingFrameSchema = external_exports.union([
      DaemonResponseFrameSchema,
      DaemonEventFrameSchema,
      DaemonPongFrameSchema
    ]);
  }
});

// src/daemon/launcher.ts
import { randomUUID as randomUUID18 } from "node:crypto";
import * as fs42 from "node:fs";
import * as path42 from "node:path";
import { spawn as spawn3, spawnSync as spawnSync7 } from "node:child_process";
import { fileURLToPath as fileURLToPath4 } from "node:url";
function emitLauncherEvent(runtime, type, payload) {
  if (runtime.listeners.size === 0) return;
  const event = {
    type,
    at: nowIso25(),
    payload,
    snapshot: { ...runtime.snapshot }
  };
  for (const listener of runtime.listeners) {
    try {
      listener(event);
    } catch {
    }
  }
}
function syncBackpressureSnapshot(runtime) {
  runtime.snapshot.pendingRequests = runtime.pending.size;
  runtime.snapshot.rejectedRequests = runtime.rejectedRequests;
  runtime.snapshot.lastRejectReason = runtime.lastRejectReason;
}
function nowIso25() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function daemonDir(projectDir) {
  return path42.join(getMiyaRuntimeDir(projectDir), "daemon");
}
function daemonPidFile(projectDir) {
  return path42.join(daemonDir(projectDir), "daemon.pid");
}
function ensureDaemonDir(projectDir) {
  fs42.mkdirSync(daemonDir(projectDir), { recursive: true });
}
function safeWriteJson2(filePath12, payload) {
  fs42.mkdirSync(path42.dirname(filePath12), { recursive: true });
  fs42.writeFileSync(filePath12, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
}
function safeReadJson2(filePath12) {
  if (!fs42.existsSync(filePath12)) return null;
  try {
    const parsed = JSON.parse(fs42.readFileSync(filePath12, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return null;
    return parsed;
  } catch {
    return null;
  }
}
function toDaemonLock(raw) {
  if (!raw) return null;
  const pid = Number(raw.pid);
  const wsPort = Number(raw.wsPort);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  if (!Number.isFinite(pid) || !Number.isFinite(wsPort) || !token || !updatedAt) return null;
  return { pid, wsPort, token, updatedAt };
}
function resolveHostScriptPath(projectDir) {
  const here = path42.dirname(fileURLToPath4(import.meta.url));
  const candidates = [
    path42.join(here, "host.ts"),
    path42.join(here, "host.js"),
    path42.join(projectDir, "src", "daemon", "host.ts"),
    path42.join(projectDir, "dist", "daemon", "host.js"),
    path42.join(projectDir, "miya-src", "src", "daemon", "host.ts"),
    path42.join(projectDir, "miya-src", "dist", "daemon", "host.js")
  ];
  for (const candidate of candidates) {
    if (fs42.existsSync(candidate)) return candidate;
  }
  return path42.join(here, "host.js");
}
function noteLaunchFailure(runtime, reason) {
  runtime.consecutiveLaunchFailures += 1;
  runtime.lastRejectReason = reason;
  if (runtime.consecutiveLaunchFailures >= runtime.maxConsecutiveLaunchFailures) {
    runtime.retryHalted = true;
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = `Miya Daemon Retry Halted (${reason})`;
  }
  syncBackpressureSnapshot(runtime);
}
function resetLaunchFailureState(runtime) {
  runtime.consecutiveLaunchFailures = 0;
  runtime.retryHalted = false;
  runtime.lastRejectReason = void 0;
  syncBackpressureSnapshot(runtime);
}
function resolveNodeBinary() {
  if (resolvedNodeBinaryCache !== void 0) return resolvedNodeBinaryCache;
  const configured = process.env.MIYA_NODE_BIN?.trim();
  const windowsNodeCandidates = process.platform === "win32" ? [
    path42.join(process.env.ProgramFiles ?? "C:\\Program Files", "nodejs", "node.exe"),
    path42.join(
      process.env["ProgramFiles(x86)"] ?? "C:\\Program Files (x86)",
      "nodejs",
      "node.exe"
    ),
    path42.join(process.env.LOCALAPPDATA ?? "", "Programs", "nodejs", "node.exe")
  ] : [];
  const candidates = [
    configured || null,
    (() => {
      const execBase = path42.basename(process.execPath).toLowerCase();
      return execBase === "node" || execBase === "node.exe" ? process.execPath : null;
    })(),
    ...windowsNodeCandidates,
    process.platform === "win32" ? "node.exe" : "node"
  ].filter((item) => Boolean(item));
  for (const candidate of candidates) {
    try {
      const probe = spawnSync7(candidate, ["--version"], {
        stdio: ["ignore", "ignore", "ignore"],
        timeout: 2e3,
        windowsHide: true
      });
      if (probe.status === 0) {
        resolvedNodeBinaryCache = candidate;
        return candidate;
      }
    } catch {
    }
  }
  return null;
}
function resolveLifecycleMode(projectDir) {
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "service") return "service_experimental";
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "coupled") return "coupled";
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime ?? {};
  return runtime.service_mode_experimental === true ? "service_experimental" : "coupled";
}
function spawnDaemon(runtime) {
  if (runtime.retryHalted) {
    return false;
  }
  if (runtime.lifecycleMode === "service_experimental") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Service Mode (attach only)";
    return false;
  }
  const now = Date.now();
  if (now - runtime.lastSpawnAttemptAtMs < 3e3) {
    return false;
  }
  runtime.lastSpawnAttemptAtMs = now;
  cleanupExistingDaemon(runtime.projectDir);
  const nodeBinary = resolveNodeBinary();
  if (!nodeBinary) {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (node_not_found)";
    noteLaunchFailure(runtime, "node_not_found");
    return false;
  }
  const binaryBase = path42.basename(nodeBinary).toLowerCase();
  if (binaryBase.includes("powershell") || binaryBase === "pwsh.exe") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (invalid_runtime_binary)";
    noteLaunchFailure(runtime, "invalid_runtime_binary");
    return false;
  }
  const hostScript = resolveHostScriptPath(runtime.projectDir);
  const nodeArgs = [
    ...hostScript.endsWith(".ts") ? ["--import", "tsx"] : [],
    hostScript,
    "--project-dir",
    runtime.projectDir,
    "--parent-lock-file",
    runtime.parentLockFile,
    "--token",
    runtime.daemonToken
  ];
  spawn3(
    nodeBinary,
    nodeArgs,
    {
      cwd: path42.dirname(hostScript),
      detached: true,
      stdio: "ignore",
      windowsHide: true
    }
  ).unref();
  return true;
}
function readPidFile(projectDir) {
  const file3 = daemonPidFile(projectDir);
  if (!fs42.existsSync(file3)) return null;
  const raw = fs42.readFileSync(file3, "utf-8").trim();
  const pid = Number(raw);
  if (!Number.isFinite(pid) || pid <= 0) return null;
  return pid;
}
function isPidAlive(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function cleanupExistingDaemon(projectDir) {
  const stalePid = readPidFile(projectDir);
  if (!stalePid || !isPidAlive(stalePid)) return;
  try {
    process.kill(stalePid);
  } catch {
  }
}
function writeParentLock(runtime) {
  safeWriteJson2(runtime.parentLockFile, {
    pid: process.pid,
    plugin: "miya",
    updatedAt: nowIso25()
  });
}
function connectWebSocket(runtime, lock) {
  const url3 = `ws://127.0.0.1:${lock.wsPort}/ws?token=${encodeURIComponent(runtime.daemonToken)}`;
  const ws = new WebSocket(url3);
  runtime.ws = ws;
  ws.onopen = () => {
    resetLaunchFailureState(runtime);
    runtime.connected = true;
    runtime.reconnectBackoffMs = 1e3;
    runtime.snapshot.statusText = "Miya Daemon Connected";
    runtime.snapshot.connected = true;
    runtime.snapshot.port = lock.wsPort;
    runtime.snapshot.pid = lock.pid;
    const hello = DaemonHelloFrameSchema.parse({
      type: "hello",
      clientID: `plugin-${process.pid}`,
      role: "plugin",
      protocolVersion: "1.0",
      auth: { token: runtime.daemonToken }
    });
    ws.send(JSON.stringify(hello));
    startHeartbeat(runtime);
    startStatusPoll(runtime);
  };
  ws.onmessage = (event) => {
    const parsed = parseDaemonOutgoingFrame(event.data);
    if (!parsed.frame) return;
    const frame = parsed.frame;
    if (frame.type === "pong") {
      runtime.lastPongAt = Date.now();
      if (runtime.pingWatchdog) clearTimeout(runtime.pingWatchdog);
      return;
    }
    if (frame.type === "response") {
      if (frame.id === "hello" && frame.ok) return;
      const pending = runtime.pending.get(frame.id);
      if (pending) {
        runtime.pending.delete(frame.id);
        clearTimeout(pending.timeout);
        syncBackpressureSnapshot(runtime);
        if (frame.ok) {
          pending.resolve(frame.result);
        } else {
          pending.reject(new Error(frame.error?.message ?? "daemon_request_failed"));
        }
      }
      return;
    }
    if (frame.type === "event" && frame.event === "daemon.ready") {
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.connected = true;
      emitLauncherEvent(runtime, "daemon.ready");
      return;
    }
    if (frame.type === "event" && frame.event === "job.progress") {
      const payload = frame.payload && typeof frame.payload === "object" && !Array.isArray(frame.payload) ? frame.payload : {};
      runtime.snapshot.activeJobID = typeof payload.jobID === "string" ? payload.jobID : runtime.snapshot.activeJobID;
      runtime.snapshot.activeJobProgress = typeof payload.progress === "number" ? Math.floor(payload.progress) : runtime.snapshot.activeJobProgress;
      runtime.snapshot.statusText = typeof payload.status === "string" && payload.status ? payload.status : runtime.snapshot.statusText;
      emitLauncherEvent(runtime, "job.progress", payload);
    }
  };
  ws.onerror = () => {
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Reconnecting";
  };
  ws.onclose = () => {
    noteLaunchFailure(runtime, "ws_closed");
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disconnected";
    emitLauncherEvent(runtime, "daemon.disconnected");
    stopHeartbeat(runtime);
    stopStatusPoll(runtime);
    scheduleReconnect(runtime);
  };
}
function daemonRequest(runtime, method, params, timeoutMs = 8e3) {
  if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN) {
    runtime.lastRejectReason = "ws_not_open";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(new Error("daemon_ws_not_open"));
  }
  if (runtime.pending.size >= runtime.maxPendingRequests) {
    runtime.lastRejectReason = "overloaded";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(
      new Error(
        `daemon_backpressure_overloaded:pending=${runtime.pending.size}:max=${runtime.maxPendingRequests}`
      )
    );
  }
  runtime.reqSeq += 1;
  const id = `req-${runtime.reqSeq}`;
  const frame = DaemonRequestFrameSchema.parse({
    type: "request",
    id,
    method,
    params
  });
  return new Promise((resolve4, reject) => {
    const timeout = setTimeout(() => {
      runtime.pending.delete(id);
      runtime.lastRejectReason = "timeout";
      runtime.rejectedRequests += 1;
      syncBackpressureSnapshot(runtime);
      reject(new Error("daemon_request_timeout"));
    }, Math.max(1e3, timeoutMs));
    runtime.pending.set(id, { resolve: resolve4, reject, timeout });
    syncBackpressureSnapshot(runtime);
    runtime.ws?.send(JSON.stringify(frame));
  });
}
function startHeartbeat(runtime) {
  stopHeartbeat(runtime);
  runtime.pingTimer = setInterval(() => {
    if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN) return;
    const ping = DaemonPingFrameSchema.parse({
      type: "ping",
      ts: Date.now()
    });
    runtime.ws.send(JSON.stringify(ping));
    if (runtime.pingWatchdog) clearTimeout(runtime.pingWatchdog);
    runtime.pingWatchdog = setTimeout(() => {
      if (runtime.ws && runtime.ws.readyState === WebSocket.OPEN) {
        runtime.ws.close();
      }
    }, 3e4);
  }, 1e4);
}
function stopHeartbeat(runtime) {
  if (runtime.pingTimer) clearInterval(runtime.pingTimer);
  runtime.pingTimer = void 0;
  if (runtime.pingWatchdog) clearTimeout(runtime.pingWatchdog);
  runtime.pingWatchdog = void 0;
}
function startStatusPoll(runtime) {
  stopStatusPoll(runtime);
  runtime.statusTimer = setInterval(async () => {
    try {
      const data = await daemonRequest(runtime, "daemon.status.get", {});
      if (!data || typeof data !== "object") return;
      runtime.snapshot.connected = true;
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.uptimeSec = typeof data.uptimeSec === "number" ? data.uptimeSec : runtime.snapshot.uptimeSec;
      runtime.snapshot.cpuPercent = typeof data.cpuPercent === "number" ? data.cpuPercent : runtime.snapshot.cpuPercent;
      runtime.snapshot.vramUsedMB = typeof data.vramUsedMB === "number" ? data.vramUsedMB : runtime.snapshot.vramUsedMB;
      runtime.snapshot.vramTotalMB = typeof data.vramTotalMB === "number" ? data.vramTotalMB : runtime.snapshot.vramTotalMB;
      runtime.snapshot.lastSeenAt = typeof data.lastSeenAt === "string" ? data.lastSeenAt : runtime.snapshot.lastSeenAt;
    } catch {
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Reconnecting";
    }
  }, 3e3);
}
function stopStatusPoll(runtime) {
  if (runtime.statusTimer) clearInterval(runtime.statusTimer);
  runtime.statusTimer = void 0;
}
function scheduleReconnect(runtime) {
  if (runtime.retryHalted) return;
  if (runtime.reconnectTimer) return;
  const wait = runtime.reconnectBackoffMs;
  runtime.reconnectBackoffMs = Math.min(runtime.reconnectBackoffMs * 2, 3e4);
  runtime.reconnectTimer = setTimeout(() => {
    runtime.reconnectTimer = void 0;
    ensureDaemonLaunched(runtime);
  }, wait);
}
function ensureDaemonLaunched(runtime) {
  if (runtime.retryHalted) {
    return;
  }
  writeParentLock(runtime);
  if (Date.now() < runtime.launchCooldownUntilMs) {
    return;
  }
  const lock = toDaemonLock(safeReadJson2(runtime.daemonLockFile));
  const lockFresh = lock && Number.isFinite(Date.parse(lock.updatedAt)) && Date.now() - Date.parse(lock.updatedAt) < 3e4;
  const lockOwnedByLauncher = runtime.lifecycleMode === "service_experimental" ? Boolean(lock) && (runtime.daemonToken ? lock?.token === runtime.daemonToken : true) : Boolean(lock) && lock?.token === runtime.daemonToken;
  if (!lockFresh || !lockOwnedByLauncher) {
    if (runtime.lifecycleMode === "service_experimental") {
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Service Mode (waiting for daemon lock)";
      scheduleReconnect(runtime);
      return;
    }
    if (runtime.reconnectTimer) {
      return;
    }
    const spawned = spawnDaemon(runtime);
    if (!spawned) {
      runtime.reconnectBackoffMs = Math.max(runtime.reconnectBackoffMs, 15e3);
      runtime.launchCooldownUntilMs = Date.now() + 15e3;
      if (!runtime.retryHalted) {
        noteLaunchFailure(runtime, "spawn_skipped_or_failed");
      }
    }
    scheduleReconnect(runtime);
    return;
  }
  if (!runtime.ws || runtime.ws.readyState >= WebSocket.CLOSING) {
    connectWebSocket(runtime, lock);
  }
}
function cleanupRuntime(runtime) {
  if (runtime.parentBeatTimer) clearInterval(runtime.parentBeatTimer);
  runtime.parentBeatTimer = void 0;
  if (runtime.reconnectTimer) clearTimeout(runtime.reconnectTimer);
  runtime.reconnectTimer = void 0;
  stopHeartbeat(runtime);
  stopStatusPoll(runtime);
  for (const pending of runtime.pending.values()) {
    clearTimeout(pending.timeout);
    pending.reject(new Error("launcher_shutdown"));
  }
  runtime.pending.clear();
  syncBackpressureSnapshot(runtime);
  runtime.listeners.clear();
  try {
    runtime.ws?.close();
  } catch {
  }
  runtime.ws = void 0;
}
function ensureMiyaLauncher(projectDir) {
  const existing = runtimes2.get(projectDir);
  if (existing) return { ...existing.snapshot };
  ensureDaemonDir(projectDir);
  const lifecycleMode = resolveLifecycleMode(projectDir);
  const config3 = readConfig(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const configuredMaxPending = typeof backpressure?.daemon_max_pending_requests === "number" ? Number(backpressure.daemon_max_pending_requests) : Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64);
  const configuredMaxFailures = typeof backpressure?.daemon_max_consecutive_failures === "number" ? Number(backpressure.daemon_max_consecutive_failures) : Number(process.env.MIYA_DAEMON_MAX_CONSECUTIVE_FAILURES ?? 5);
  const daemonToken = lifecycleMode === "service_experimental" ? String(process.env.MIYA_DAEMON_SERVICE_TOKEN ?? process.env.MIYA_DAEMON_TOKEN ?? "") : randomUUID18();
  const runtime = {
    projectDir,
    lifecycleMode,
    daemonToken,
    parentLockFile: path42.join(daemonDir(projectDir), "parent.lock.json"),
    daemonLockFile: path42.join(daemonDir(projectDir), "daemon.lock.json"),
    reconnectBackoffMs: 1e3,
    connected: false,
    reqSeq: 0,
    pending: /* @__PURE__ */ new Map(),
    maxPendingRequests: Math.max(
      4,
      Math.floor(configuredMaxPending)
    ),
    rejectedRequests: 0,
    lastRejectReason: void 0,
    listeners: /* @__PURE__ */ new Set(),
    lastSpawnAttemptAtMs: 0,
    launchCooldownUntilMs: 0,
    consecutiveLaunchFailures: 0,
    retryHalted: false,
    maxConsecutiveLaunchFailures: Math.max(1, Math.floor(configuredMaxFailures)),
    snapshot: {
      connected: false,
      statusText: lifecycleMode === "service_experimental" ? daemonToken ? "Miya Daemon Service Mode (attach only)" : "Miya Daemon Service Mode (token missing)" : "Miya Daemon Booting",
      lifecycleMode,
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso25()
    }
  };
  syncBackpressureSnapshot(runtime);
  runtimes2.set(projectDir, runtime);
  writeParentLock(runtime);
  runtime.parentBeatTimer = setInterval(() => {
    writeParentLock(runtime);
  }, 1e4);
  ensureDaemonLaunched(runtime);
  return { ...runtime.snapshot };
}
function getLauncherDaemonSnapshot(projectDir) {
  const runtime = runtimes2.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      statusText: "Miya Daemon Not Started",
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso25()
    };
  }
  syncBackpressureSnapshot(runtime);
  return { ...runtime.snapshot };
}
function getLauncherBackpressureStats(projectDir) {
  const runtime = runtimes2.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      maxPendingRequests: Math.max(
        4,
        Math.floor(Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64))
      ),
      pendingRequests: 0,
      rejectedRequests: 0
    };
  }
  syncBackpressureSnapshot(runtime);
  return {
    connected: runtime.connected,
    maxPendingRequests: runtime.maxPendingRequests,
    pendingRequests: runtime.snapshot.pendingRequests,
    rejectedRequests: runtime.snapshot.rejectedRequests,
    lastRejectReason: runtime.snapshot.lastRejectReason
  };
}
function subscribeLauncherEvents(projectDir, listener) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes2.get(projectDir);
  if (!runtime) return () => {
  };
  runtime.listeners.add(listener);
  return () => {
    const current = runtimes2.get(projectDir);
    current?.listeners.delete(listener);
  };
}
async function waitForDaemonConnection(runtime, timeoutMs) {
  if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected) return;
  const startedAt = Date.now();
  while (Date.now() - startedAt < timeoutMs) {
    ensureDaemonLaunched(runtime);
    if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected) return;
    await new Promise((resolve4) => setTimeout(resolve4, 150));
  }
  throw new Error("daemon_connect_timeout");
}
async function daemonInvoke(projectDir, method, params, timeoutMs = 6e4) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes2.get(projectDir);
  if (!runtime) throw new Error("daemon_runtime_missing");
  await waitForDaemonConnection(runtime, Math.min(timeoutMs, 15e3));
  return daemonRequest(runtime, method, params, timeoutMs);
}
var runtimes2, resolvedNodeBinaryCache;
var init_launcher = __esm({
  "src/daemon/launcher.ts"() {
    "use strict";
    init_workflow();
    init_settings();
    init_ws_protocol();
    runtimes2 = /* @__PURE__ */ new Map();
    process.on("exit", () => {
      for (const runtime of runtimes2.values()) {
        cleanupRuntime(runtime);
        try {
          fs42.rmSync(runtime.parentLockFile, { force: true });
        } catch {
        }
      }
    });
  }
});

// src/daemon/client.ts
function getMiyaClient(projectDir) {
  const existing = clients.get(projectDir);
  if (existing) return existing;
  const created = new MiyaClient(projectDir);
  clients.set(projectDir, created);
  return created;
}
var MiyaClient, clients;
var init_client = __esm({
  "src/daemon/client.ts"() {
    "use strict";
    init_launcher();
    MiyaClient = class {
      constructor(projectDir) {
        this.projectDir = projectDir;
        ensureMiyaLauncher(projectDir);
      }
      async runFluxImageGenerate(input) {
        return daemonInvoke(
          this.projectDir,
          "daemon.flux.generate",
          input,
          24e4
        );
      }
      async runSovitsTts(input) {
        return daemonInvoke(
          this.projectDir,
          "daemon.sovits.tts",
          input,
          18e4
        );
      }
      async runFluxTraining(input) {
        return daemonInvoke(
          this.projectDir,
          "daemon.training.flux",
          input,
          35 * 6e4
        );
      }
      async runSovitsTraining(input) {
        return daemonInvoke(
          this.projectDir,
          "daemon.training.sovits",
          input,
          35 * 6e4
        );
      }
      async requestTrainingCancel(jobID) {
        await daemonInvoke(this.projectDir, "daemon.training.cancel", { jobID }, 15e3);
      }
      async getPythonRuntimeStatus() {
        return daemonInvoke(this.projectDir, "daemon.python.env.get", {}, 15e3);
      }
      async getModelLockStatus() {
        return daemonInvoke(this.projectDir, "daemon.model.locks.get", {}, 15e3);
      }
      async getModelUpdatePlan(target) {
        return daemonInvoke(
          this.projectDir,
          "daemon.model.update.plan",
          target ? { target } : {},
          2e4
        );
      }
      async applyModelUpdate(target) {
        return daemonInvoke(
          this.projectDir,
          "daemon.model.update.apply",
          target ? { target } : {},
          3e4
        );
      }
      async runIsolatedProcess(input) {
        return daemonInvoke(
          this.projectDir,
          "daemon.process.run_isolated",
          input,
          Math.max(3e4, input.timeoutMs ?? 12e4) + 1e4
        );
      }
      async psycheConsult(input) {
        const timeoutMs = Math.max(
          1e3,
          Math.floor(Number(process.env.MIYA_PSYCHE_CONSULT_TIMEOUT_MS ?? 3e3))
        );
        return daemonInvoke(
          this.projectDir,
          "daemon.psyche.consult",
          input,
          timeoutMs
        );
      }
      async psycheOutcome(input) {
        return daemonInvoke(
          this.projectDir,
          "daemon.psyche.outcome",
          input,
          15e3
        );
      }
    };
    clients = /* @__PURE__ */ new Map();
  }
});

// src/daemon/python-runtime.ts
var init_python_runtime = __esm({
  "src/daemon/python-runtime.ts"() {
    "use strict";
    init_workflow();
  }
});

// src/daemon/index.ts
var init_daemon = __esm({
  "src/daemon/index.ts"() {
    "use strict";
    init_client();
    init_launcher();
    init_python_runtime();
  }
});

// src/cli/index.ts
import { spawn as spawn4, spawnSync as spawnSync8 } from "node:child_process";
import * as fs44 from "node:fs";
import * as os7 from "node:os";
import * as path44 from "node:path";
import { fileURLToPath as fileURLToPath5 } from "node:url";

// src/cli/install.ts
import * as readline from "node:readline/promises";
import * as fs4 from "node:fs";
import * as path4 from "node:path";

// src/cli/model-selection.ts
function defaultTieBreaker(left, right) {
  return left.model.localeCompare(right.model);
}
function rankModels(models, scoreFn, options = {}) {
  const excluded = new Set(options.excludeModels ?? []);
  const tieBreaker = options.tieBreaker ?? defaultTieBreaker;
  return models.filter((model) => !excluded.has(model.model)).map((candidate) => ({
    candidate,
    score: scoreFn(candidate)
  })).sort((left, right) => {
    if (left.score !== right.score) return right.score - left.score;
    return tieBreaker(left.candidate, right.candidate);
  });
}
function pickBestModel(models, scoreFn, options = {}) {
  return rankModels(models, scoreFn, options)[0]?.candidate ?? null;
}
function pickPrimaryAndSupport(models, scoring, preferredPrimaryModel) {
  if (models.length === 0) return { primary: null, support: null };
  const preferredPrimary = preferredPrimaryModel ? models.find((candidate) => candidate.model === preferredPrimaryModel) : void 0;
  const primary = preferredPrimary ?? pickBestModel(models, scoring.primary);
  if (!primary) return { primary: null, support: null };
  const support = pickBestModel(models, scoring.support, {
    excludeModels: [primary.model]
  }) ?? pickBestModel(models, scoring.support);
  return { primary, support };
}

// src/cli/chutes-selection.ts
function speedBonus(modelName) {
  const lower = modelName.toLowerCase();
  let score = 0;
  if (lower.includes("nano")) score += 60;
  if (lower.includes("flash")) score += 45;
  if (lower.includes("mini")) score += 30;
  if (lower.includes("lite")) score += 20;
  if (lower.includes("small")) score += 15;
  return score;
}
var scoreChutesPrimaryForCoding = (model) => {
  return (model.reasoning ? 120 : 0) + (model.toolcall ? 80 : 0) + (model.attachment ? 20 : 0) + Math.min(model.contextLimit, 1e6) / 9e3 + Math.min(model.outputLimit, 3e5) / 1e4 + (model.status === "active" ? 10 : 0);
};
var scoreChutesSupportForCoding = (model) => {
  return (model.toolcall ? 90 : 0) + (model.reasoning ? 35 : 0) + speedBonus(model.model) + Math.min(model.contextLimit, 4e5) / 2e4 + (model.status === "active" ? 8 : 0);
};
function pickBestCodingChutesModel(models) {
  return pickBestModel(models, scoreChutesPrimaryForCoding);
}
function pickSupportChutesModel(models, primaryModel) {
  const { support } = pickPrimaryAndSupport(
    models,
    {
      primary: scoreChutesPrimaryForCoding,
      support: scoreChutesSupportForCoding
    },
    primaryModel
  );
  return support;
}

// src/cli/config-manager.ts
init_config_io();

// src/cli/dynamic-model-selection.ts
init_constants();
var AGENTS = [
  "orchestrator",
  "oracle",
  "designer",
  "explorer",
  "librarian",
  "fixer"
];
function normalizeAgentName3(agentName) {
  return AGENT_ALIASES[agentName] ?? agentName;
}
var ROLE_VARIANT = {
  orchestrator: void 0,
  oracle: "high",
  designer: "medium",
  explorer: "low",
  librarian: "low",
  fixer: "low"
};
function getEnabledProviders(config3) {
  const providers = [];
  if (config3.hasOpenAI) providers.push("openai");
  if (config3.hasAnthropic) providers.push("anthropic");
  if (config3.hasCopilot) providers.push("github-copilot");
  if (config3.hasZaiPlan) providers.push("zai-coding-plan");
  if (config3.hasKimi) providers.push("kimi-for-coding");
  if (config3.hasAntigravity) providers.push("google");
  if (config3.hasChutes) providers.push("chutes");
  if (config3.useOpenCodeFreeModels) providers.push("opencode");
  return providers;
}
function tokenScore(name, re, points) {
  return re.test(name) ? points : 0;
}
function statusScore(status) {
  if (status === "active") return 20;
  if (status === "beta") return 8;
  if (status === "alpha") return -5;
  return -40;
}
function baseScore(model) {
  const lowered = `${model.model} ${model.name}`.toLowerCase();
  const context = Math.min(model.contextLimit, 1e6) / 5e4;
  const output = Math.min(model.outputLimit, 3e5) / 3e4;
  const deep = tokenScore(
    lowered,
    /(opus|pro|thinking|reason|r1|gpt-5|k2\.5)/i,
    12
  );
  const fast = tokenScore(
    lowered,
    /(nano|flash|mini|lite|fast|turbo|haiku|small)/i,
    12
  );
  const code = tokenScore(lowered, /(codex|coder|code|dev|program)/i, 12);
  const versionBoost = tokenScore(lowered, /gpt-5\.3/i, 12) + tokenScore(lowered, /gpt-5\.2/i, 8) + tokenScore(lowered, /k2\.5/i, 6);
  return statusScore(model.status) + context + output + deep + fast + code + versionBoost + (model.toolcall ? 25 : 0);
}
function roleScore(agent, model) {
  const lowered = `${model.model} ${model.name}`.toLowerCase();
  const reasoning = model.reasoning ? 1 : 0;
  const toolcall = model.toolcall ? 1 : 0;
  const attachment = model.attachment ? 1 : 0;
  const context = Math.min(model.contextLimit, 1e6) / 6e4;
  const output = Math.min(model.outputLimit, 3e5) / 4e4;
  const deep = tokenScore(
    lowered,
    /(opus|pro|thinking|reason|r1|gpt-5|k2\.5)/i,
    1
  );
  const fast = tokenScore(
    lowered,
    /(nano|flash|mini|lite|fast|turbo|haiku|small)/i,
    1
  );
  const code = tokenScore(lowered, /(codex|coder|code|dev|program)/i, 1);
  if ((agent === "orchestrator" || agent === "explorer" || agent === "librarian" || agent === "fixer") && !model.toolcall) {
    return -1e4;
  }
  if (model.status === "deprecated") {
    return -5e3;
  }
  const score = baseScore(model);
  if (agent === "orchestrator") {
    return score + reasoning * 40 + toolcall * 25 + deep * 10 + code * 8 + context;
  }
  if (agent === "oracle") {
    return score + reasoning * 55 + deep * 18 + context * 1.2 + toolcall * 10;
  }
  if (agent === "designer") {
    return score + attachment * 25 + reasoning * 18 + toolcall * 15 + context * 0.8 + output;
  }
  if (agent === "explorer") {
    return score + fast * 35 + toolcall * 28 + reasoning * 8 + context * 0.7;
  }
  if (agent === "librarian") {
    return score + context * 30 + toolcall * 22 + reasoning * 15 + output * 10;
  }
  return score + code * 28 + toolcall * 24 + fast * 18 + reasoning * 14 + output * 8;
}
function rankModels2(models, agent) {
  return [...models].sort((a, b) => roleScore(agent, b) - roleScore(agent, a));
}
function dedupe(models) {
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (const model of models) {
    if (!model || seen.has(model)) continue;
    seen.add(model);
    result.push(model);
  }
  return result;
}
function buildDynamicModelPlan(catalog, config3) {
  const enabledProviders = new Set(getEnabledProviders(config3));
  const providerCandidates = catalog.filter(
    (m) => enabledProviders.has(m.providerID)
  );
  if (providerCandidates.length === 0) {
    return null;
  }
  const agents = {};
  const chains = {};
  for (const agent of AGENTS) {
    const ranked = rankModels2(providerCandidates, agent);
    const primary = ranked[0];
    if (!primary) continue;
    const providerOrder = dedupe(ranked.map((m) => m.providerID));
    const perProviderBest = providerOrder.map(
      (providerID) => ranked.find((m) => m.providerID === providerID)?.model
    ).filter((m) => Boolean(m));
    const selectedOpencode = agent === "explorer" || agent === "librarian" || agent === "fixer" ? config3.selectedOpenCodeSecondaryModel ?? config3.selectedOpenCodePrimaryModel : config3.selectedOpenCodePrimaryModel;
    const selectedChutes = agent === "explorer" || agent === "librarian" || agent === "fixer" ? config3.selectedChutesSecondaryModel ?? config3.selectedChutesPrimaryModel : config3.selectedChutesPrimaryModel;
    const chain = dedupe([
      primary.model,
      ...perProviderBest,
      selectedChutes,
      selectedOpencode,
      "opencode/big-pickle"
    ]).slice(0, 7);
    agents[normalizeAgentName3(agent)] = {
      model: chain[0] ?? primary.model,
      variant: ROLE_VARIANT[agent]
    };
    chains[normalizeAgentName3(agent)] = chain;
  }
  if (Object.keys(agents).length === 0) {
    return null;
  }
  return { agents, chains };
}

// src/cli/process.ts
import { spawn } from "node:child_process";
async function runCommand(command, args, timeoutMs = 3e4) {
  return await new Promise((resolve4, reject) => {
    let stdout = "";
    let stderr = "";
    let settled = false;
    const proc = spawn(command, args, {
      stdio: ["ignore", "pipe", "pipe"],
      windowsHide: true
    });
    proc.stdout?.setEncoding("utf8");
    proc.stdout?.on("data", (chunk) => {
      stdout += String(chunk);
    });
    proc.stderr?.setEncoding("utf8");
    proc.stderr?.on("data", (chunk) => {
      stderr += String(chunk);
    });
    const timer = setTimeout(() => {
      if (settled) return;
      settled = true;
      try {
        proc.kill();
      } catch {
      }
      reject(new Error("command_timeout"));
    }, Math.max(1e3, timeoutMs));
    proc.on("error", (error92) => {
      if (settled) return;
      settled = true;
      clearTimeout(timer);
      reject(error92);
    });
    proc.on("close", (code) => {
      if (settled) return;
      settled = true;
      clearTimeout(timer);
      resolve4({
        exitCode: code,
        stdout,
        stderr
      });
    });
  });
}

// src/cli/opencode-models.ts
function isFreeModel(record3) {
  const inputCost = record3.cost?.input ?? 0;
  const outputCost = record3.cost?.output ?? 0;
  const cacheReadCost = record3.cost?.cache?.read ?? 0;
  const cacheWriteCost = record3.cost?.cache?.write ?? 0;
  return inputCost === 0 && outputCost === 0 && cacheReadCost === 0 && cacheWriteCost === 0;
}
function parseDailyRequestLimit(record3) {
  const explicitLimit = record3.quota?.requestsPerDay ?? record3.meta?.requestsPerDay ?? record3.meta?.dailyLimit;
  if (typeof explicitLimit === "number" && Number.isFinite(explicitLimit)) {
    return explicitLimit;
  }
  const source = `${record3.id} ${record3.name ?? ""}`.toLowerCase();
  const match = source.match(
    /\b(300|2000|5000)\b(?:\s*(?:req|requests|rpd|\/day))?/
  );
  if (!match) return void 0;
  const parsed = Number.parseInt(match[1], 10);
  return Number.isFinite(parsed) ? parsed : void 0;
}
function normalizeDiscoveredModel(record3, providerFilter) {
  if (providerFilter && record3.providerID !== providerFilter) return null;
  const fullModel = `${record3.providerID}/${record3.id}`;
  return {
    providerID: record3.providerID,
    model: fullModel,
    name: record3.name ?? record3.id,
    status: record3.status ?? "active",
    contextLimit: record3.limit?.context ?? 0,
    outputLimit: record3.limit?.output ?? 0,
    reasoning: record3.capabilities?.reasoning === true,
    toolcall: record3.capabilities?.toolcall === true,
    attachment: record3.capabilities?.attachment === true,
    dailyRequestLimit: parseDailyRequestLimit(record3),
    costInput: record3.cost?.input,
    costOutput: record3.cost?.output
  };
}
function parseOpenCodeModelsVerboseOutput(output, providerFilter, freeOnly = true) {
  const lines = output.split(/\r?\n/);
  const models = [];
  for (let index = 0; index < lines.length; index++) {
    const line = lines[index]?.trim();
    if (!line || !line.includes("/")) continue;
    const isModelHeader = /^[a-z0-9-]+\/[a-z0-9._-]+$/i.test(line);
    if (!isModelHeader) continue;
    let jsonStart = -1;
    for (let search = index + 1; search < lines.length; search++) {
      if (lines[search]?.trim().startsWith("{")) {
        jsonStart = search;
        break;
      }
      if (/^[a-z0-9-]+\/[a-z0-9._-]+$/i.test(lines[search]?.trim() ?? "")) {
        break;
      }
    }
    if (jsonStart === -1) continue;
    let braceDepth = 0;
    const jsonLines = [];
    let jsonEnd = -1;
    for (let cursor = jsonStart; cursor < lines.length; cursor++) {
      const current = lines[cursor] ?? "";
      jsonLines.push(current);
      for (const char of current) {
        if (char === "{") braceDepth++;
        if (char === "}") braceDepth--;
      }
      if (braceDepth === 0 && jsonLines.length > 0) {
        jsonEnd = cursor;
        break;
      }
    }
    if (jsonEnd === -1) continue;
    try {
      const parsed = JSON.parse(
        jsonLines.join("\n")
      );
      const normalized = normalizeDiscoveredModel(parsed, providerFilter);
      if (!normalized) continue;
      if (freeOnly && !isFreeModel(parsed)) continue;
      if (normalized) models.push(normalized);
    } catch {
    }
    index = jsonEnd;
  }
  return models;
}
async function discoverFreeModelsByProvider(providerID) {
  try {
    const result = await runCommand(
      "opencode",
      ["models", "--refresh", "--verbose"],
      45e3
    );
    if (result.exitCode !== 0) {
      return {
        models: [],
        error: result.stderr.trim() || "Failed to fetch OpenCode models."
      };
    }
    return {
      models: parseOpenCodeModelsVerboseOutput(
        result.stdout,
        providerID,
        true
      )
    };
  } catch {
    return {
      models: [],
      error: "Unable to run `opencode models --refresh --verbose`."
    };
  }
}
async function discoverModelCatalog() {
  try {
    const result = await runCommand(
      "opencode",
      ["models", "--refresh", "--verbose"],
      45e3
    );
    if (result.exitCode !== 0) {
      return {
        models: [],
        error: result.stderr.trim() || "Failed to fetch OpenCode models."
      };
    }
    return {
      models: parseOpenCodeModelsVerboseOutput(result.stdout, void 0, false)
    };
  } catch {
    return {
      models: [],
      error: "Unable to run `opencode models --refresh --verbose`."
    };
  }
}
async function discoverOpenCodeFreeModels() {
  return discoverFreeModelsByProvider("opencode");
}
async function discoverProviderFreeModels(providerID) {
  return discoverFreeModelsByProvider(providerID);
}

// src/cli/opencode-selection.ts
var scoreOpenCodePrimaryForCoding = (model) => {
  return (model.reasoning ? 100 : 0) + (model.toolcall ? 80 : 0) + (model.attachment ? 20 : 0) + Math.min(model.contextLimit, 1e6) / 1e4 + Math.min(model.outputLimit, 3e5) / 1e4 + (model.status === "active" ? 10 : 0);
};
function speedBonus2(modelName) {
  const lower = modelName.toLowerCase();
  let score = 0;
  if (lower.includes("nano")) score += 60;
  if (lower.includes("flash")) score += 45;
  if (lower.includes("mini")) score += 25;
  if (lower.includes("preview")) score += 10;
  return score;
}
var scoreOpenCodeSupportForCoding = (model) => {
  return (model.toolcall ? 90 : 0) + (model.reasoning ? 50 : 0) + speedBonus2(model.model) + Math.min(model.contextLimit, 4e5) / 2e4 + (model.status === "active" ? 5 : 0);
};
function pickBestCodingOpenCodeModel(models) {
  return pickBestModel(models, scoreOpenCodePrimaryForCoding);
}
function pickSupportOpenCodeModel(models, primaryModel) {
  const { support } = pickPrimaryAndSupport(
    models,
    {
      primary: scoreOpenCodePrimaryForCoding,
      support: scoreOpenCodeSupportForCoding
    },
    primaryModel
  );
  return support;
}

// src/cli/config-manager.ts
init_paths();
init_providers();

// src/cli/system.ts
async function isOpenCodeInstalled() {
  try {
    const result = await runCommand("opencode", ["--version"], 8e3);
    return result.exitCode === 0;
  } catch {
    return false;
  }
}
async function isTmuxInstalled() {
  try {
    const result = await runCommand("tmux", ["-V"], 8e3);
    return result.exitCode === 0;
  } catch {
    return false;
  }
}
async function getOpenCodeVersion() {
  try {
    const result = await runCommand("opencode", ["--version"], 8e3);
    return result.exitCode === 0 ? result.stdout.trim() : null;
  } catch {
    return null;
  }
}

// src/cli/install.ts
init_custom_skills();
init_skills();
var GREEN = "\x1B[32m";
var BLUE = "\x1B[34m";
var YELLOW = "\x1B[33m";
var RED = "\x1B[31m";
var BOLD = "\x1B[1m";
var DIM = "\x1B[2m";
var RESET = "\x1B[0m";
var SYMBOLS = {
  check: `${GREEN}\u2713${RESET}`,
  cross: `${RED}\u2717${RESET}`,
  arrow: `${BLUE}\u2192${RESET}`,
  bullet: `${DIM}\u2022${RESET}`,
  info: `${BLUE}\u2139${RESET}`,
  warn: `${YELLOW}\u26A0${RESET}`,
  star: `${YELLOW}\u2605${RESET}`
};
function printHeader(isUpdate) {
  console.log();
  console.log(
    `${BOLD}miya ${isUpdate ? "Update" : "Install"}${RESET}`
  );
  console.log("=".repeat(30));
  console.log();
}
function printStep(step, total, message) {
  console.log(`${DIM}[${step}/${total}]${RESET} ${message}`);
}
function printSuccess(message) {
  console.log(`${SYMBOLS.check} ${message}`);
}
function printError(message) {
  console.log(`${SYMBOLS.cross} ${RED}${message}${RESET}`);
}
function printInfo(message) {
  console.log(`${SYMBOLS.info} ${message}`);
}
function printWarning(message) {
  console.log(`${SYMBOLS.warn} ${YELLOW}${message}${RESET}`);
}
async function checkOpenCodeInstalled() {
  const installed = await isOpenCodeInstalled();
  if (!installed) {
    printError("OpenCode is not installed on this system.");
    printInfo("Install it with:");
    console.log(
      `     ${BLUE}curl -fsSL https://opencode.ai/install | bash${RESET}`
    );
    return { ok: false };
  }
  const version3 = await getOpenCodeVersion();
  printSuccess(`OpenCode ${version3 ?? ""} detected`);
  return { ok: true, version: version3 ?? void 0 };
}
function handleStepResult(result, successMsg) {
  if (!result.success) {
    printError(`Failed: ${result.error}`);
    return false;
  }
  printSuccess(
    `${successMsg} ${SYMBOLS.arrow} ${DIM}${result.configPath}${RESET}`
  );
  return true;
}
function formatConfigSummary(config3) {
  const liteConfig = generateLiteConfig(config3);
  const preset = liteConfig.preset || "unknown";
  const lines = [];
  lines.push(`${BOLD}Configuration Summary${RESET}`);
  lines.push("");
  lines.push(`  ${BOLD}Preset:${RESET} ${BLUE}${preset}${RESET}`);
  lines.push(`  ${config3.hasKimi ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} Kimi`);
  lines.push(
    `  ${config3.hasOpenAI ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} OpenAI`
  );
  lines.push(
    `  ${config3.hasAnthropic ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} Anthropic`
  );
  lines.push(
    `  ${config3.hasCopilot ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} GitHub Copilot`
  );
  lines.push(
    `  ${config3.hasZaiPlan ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} ZAI Coding Plan`
  );
  lines.push(
    `  ${config3.hasAntigravity ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} Antigravity (Google)`
  );
  lines.push(
    `  ${config3.hasChutes ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} Chutes`
  );
  lines.push(`  ${SYMBOLS.check} Opencode Zen`);
  if (config3.useOpenCodeFreeModels && config3.selectedOpenCodePrimaryModel) {
    lines.push(
      `  ${SYMBOLS.check} OpenCode Free Primary: ${BLUE}${config3.selectedOpenCodePrimaryModel}${RESET}`
    );
  }
  if (config3.useOpenCodeFreeModels && config3.selectedOpenCodeSecondaryModel) {
    lines.push(
      `  ${SYMBOLS.check} OpenCode Free Support: ${BLUE}${config3.selectedOpenCodeSecondaryModel}${RESET}`
    );
  }
  if (config3.hasChutes && config3.selectedChutesPrimaryModel) {
    lines.push(
      `  ${SYMBOLS.check} Chutes Primary: ${BLUE}${config3.selectedChutesPrimaryModel}${RESET}`
    );
  }
  if (config3.hasChutes && config3.selectedChutesSecondaryModel) {
    lines.push(
      `  ${SYMBOLS.check} Chutes Support: ${BLUE}${config3.selectedChutesSecondaryModel}${RESET}`
    );
  }
  lines.push(
    `  ${config3.hasTmux ? SYMBOLS.check : `${DIM}\u25CB${RESET}`} Tmux Integration`
  );
  return lines.join("\n");
}
function printAgentModels(config3) {
  const liteConfig = generateLiteConfig(config3);
  const presetName = liteConfig.preset || "unknown";
  const presets = liteConfig.presets;
  const agents = presets?.[presetName];
  if (!agents || Object.keys(agents).length === 0) return;
  console.log(
    `${BOLD}Agent Configuration (Preset: ${BLUE}${presetName}${RESET}):${RESET}`
  );
  console.log();
  const maxAgentLen = Math.max(...Object.keys(agents).map((a) => a.length));
  for (const [agent, info] of Object.entries(agents)) {
    const padding = " ".repeat(maxAgentLen - agent.length);
    const skillsStr = info.skills.length > 0 ? ` ${DIM}[${info.skills.join(", ")}]${RESET}` : "";
    console.log(
      `  ${DIM}${agent}${RESET}${padding} ${SYMBOLS.arrow} ${BLUE}${info.model}${RESET}${skillsStr}`
    );
  }
  console.log();
}
function argsToConfig(args) {
  return {
    hasKimi: args.kimi === "yes",
    hasOpenAI: args.openai === "yes",
    hasAnthropic: args.anthropic === "yes",
    hasCopilot: args.copilot === "yes",
    hasZaiPlan: args.zaiPlan === "yes",
    hasAntigravity: args.antigravity === "yes",
    hasChutes: args.chutes === "yes",
    hasOpencodeZen: true,
    // Always enabled - free models available to all users
    useOpenCodeFreeModels: args.opencodeFree === "yes",
    preferredOpenCodeModel: args.opencodeFreeModel && args.opencodeFreeModel !== "auto" ? args.opencodeFreeModel : void 0,
    hasTmux: args.tmux === "yes",
    installSkills: args.skills === "yes",
    installCustomSkills: args.skills === "yes",
    // Install custom skills when skills=yes
    isolated: args.isolated === "yes"
  };
}
function applyIsolatedConfigHomeIfNeeded(enable) {
  if (!enable) return null;
  const isolatedHome = path4.join(process.cwd(), ".opencode", "miya-isolated-xdg");
  fs4.mkdirSync(isolatedHome, { recursive: true });
  process.env.XDG_CONFIG_HOME = isolatedHome;
  return isolatedHome;
}
async function askModelSelection(rl, models, defaultModel, prompt) {
  const defaultIndex = Math.max(
    0,
    models.findIndex((model) => model.model === defaultModel)
  );
  for (const [index, model] of models.entries()) {
    const marker = model.model === defaultModel ? `${BOLD}(recommended)${RESET}` : "";
    console.log(
      `  ${DIM}${index + 1}.${RESET} ${BLUE}${model.model}${RESET} ${DIM}${model.name}${RESET} ${marker}`
    );
  }
  const answer = (await rl.question(
    `${BLUE}${prompt}${RESET} ${DIM}[default: ${defaultIndex + 1}]${RESET}: `
  )).trim().toLowerCase();
  if (!answer) return defaultModel;
  const asNumber = Number.parseInt(answer, 10);
  if (Number.isFinite(asNumber)) {
    const chosen = models[asNumber - 1];
    if (chosen) return chosen.model;
  }
  const byId = models.find((model) => model.model.toLowerCase() === answer);
  return byId?.model ?? defaultModel;
}
async function askYesNo(rl, prompt, defaultValue = "no") {
  const hint = defaultValue === "yes" ? "[Y/n]" : "[y/N]";
  const answer = (await rl.question(`${BLUE}${prompt}${RESET} ${hint}: `)).trim().toLowerCase();
  if (answer === "") return defaultValue;
  if (answer === "y" || answer === "yes") return "yes";
  if (answer === "n" || answer === "no") return "no";
  return defaultValue;
}
async function runInteractiveMode(detected) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  const tmuxInstalled = await isTmuxInstalled();
  const totalQuestions = tmuxInstalled ? 9 : 8;
  try {
    console.log(`${BOLD}Question 1/${totalQuestions}:${RESET}`);
    const useOpenCodeFree = await askYesNo(
      rl,
      "Use only OpenCode free models (opencode/*) with live refresh?",
      "yes"
    );
    console.log();
    let availableOpenCodeFreeModels;
    let selectedOpenCodePrimaryModel;
    let selectedOpenCodeSecondaryModel;
    let availableChutesFreeModels;
    let selectedChutesPrimaryModel;
    let selectedChutesSecondaryModel;
    if (useOpenCodeFree === "yes") {
      printInfo("Refreshing models with: opencode models --refresh --verbose");
      const discovery = await discoverOpenCodeFreeModels();
      if (discovery.models.length === 0) {
        printWarning(
          discovery.error ?? "No OpenCode free models found. Continuing without OpenCode free-model assignment."
        );
      } else {
        availableOpenCodeFreeModels = discovery.models;
        const recommendedPrimary = pickBestCodingOpenCodeModel(discovery.models)?.model ?? discovery.models[0]?.model;
        if (recommendedPrimary) {
          console.log(`${BOLD}OpenCode Free Models:${RESET}`);
          selectedOpenCodePrimaryModel = await askModelSelection(
            rl,
            discovery.models,
            recommendedPrimary,
            "Choose primary model for 1-task-manager/4-architecture-advisor"
          );
        }
        if (selectedOpenCodePrimaryModel) {
          const recommendedSecondary = pickSupportOpenCodeModel(
            discovery.models,
            selectedOpenCodePrimaryModel
          )?.model ?? selectedOpenCodePrimaryModel;
          selectedOpenCodeSecondaryModel = await askModelSelection(
            rl,
            discovery.models,
            recommendedSecondary,
            "Choose support model for 2-code-search/3-docs-helper/5-code-fixer"
          );
        }
        console.log();
      }
    }
    console.log(`${BOLD}Question 2/${totalQuestions}:${RESET}`);
    const kimi = await askYesNo(
      rl,
      "Do you want to use Kimi For Coding?",
      detected.hasKimi ? "yes" : "no"
    );
    console.log();
    console.log(`${BOLD}Question 3/${totalQuestions}:${RESET}`);
    const openai = await askYesNo(
      rl,
      "Do you have access to OpenAI API?",
      detected.hasOpenAI ? "yes" : "no"
    );
    console.log();
    console.log(`${BOLD}Question 4/${totalQuestions}:${RESET}`);
    const anthropic = await askYesNo(
      rl,
      "Do you have access to Anthropic models?",
      detected.hasAnthropic ? "yes" : "no"
    );
    console.log();
    console.log(`${BOLD}Question 5/${totalQuestions}:${RESET}`);
    const copilot = await askYesNo(
      rl,
      "Do you have access to GitHub Copilot models?",
      detected.hasCopilot ? "yes" : "no"
    );
    console.log();
    console.log(`${BOLD}Question 6/${totalQuestions}:${RESET}`);
    const zaiPlan = await askYesNo(
      rl,
      "Do you have access to ZAI Coding Plan models?",
      detected.hasZaiPlan ? "yes" : "no"
    );
    console.log();
    console.log(`${BOLD}Question 7/${totalQuestions}:${RESET}`);
    const antigravity = await askYesNo(
      rl,
      "Enable Antigravity authentication for Google models?",
      detected.hasAntigravity ? "yes" : "no"
    );
    console.log();
    console.log(`${BOLD}Question 8/${totalQuestions}:${RESET}`);
    const chutes = await askYesNo(
      rl,
      "Enable Chutes provider with free daily capped models?",
      detected.hasChutes ? "yes" : "no"
    );
    console.log();
    if (chutes === "yes") {
      printInfo(
        "Refreshing Chutes model list with: opencode models --refresh --verbose"
      );
      const discovery = await discoverProviderFreeModels("chutes");
      if (discovery.models.length === 0) {
        printWarning(
          discovery.error ?? "No free Chutes models found. Continuing without Chutes dynamic assignment."
        );
      } else {
        availableChutesFreeModels = discovery.models;
        const recommendedPrimary = pickBestCodingChutesModel(discovery.models)?.model ?? discovery.models[0]?.model;
        if (recommendedPrimary) {
          console.log(`${BOLD}Chutes Free Models:${RESET}`);
          selectedChutesPrimaryModel = await askModelSelection(
            rl,
            discovery.models,
            recommendedPrimary,
            "Choose Chutes primary model for 1-task-manager/4-architecture-advisor/6-ui-designer"
          );
        }
        if (selectedChutesPrimaryModel) {
          const recommendedSecondary = pickSupportChutesModel(discovery.models, selectedChutesPrimaryModel)?.model ?? selectedChutesPrimaryModel;
          selectedChutesSecondaryModel = await askModelSelection(
            rl,
            discovery.models,
            recommendedSecondary,
            "Choose Chutes support model for 2-code-search/3-docs-helper/5-code-fixer"
          );
        }
        console.log();
      }
    }
    let tmux = "no";
    if (tmuxInstalled) {
      console.log(`${BOLD}Question 9/${totalQuestions}:${RESET}`);
      printInfo(
        `${BOLD}Tmux detected!${RESET} We can enable tmux integration for sub-agent panes.`
      );
      tmux = await askYesNo(
        rl,
        "Enable tmux integration?",
        detected.hasTmux ? "yes" : "no"
      );
      console.log();
    }
    console.log(`${BOLD}Recommended Skills:${RESET}`);
    for (const skill of RECOMMENDED_SKILLS) {
      console.log(
        `  ${SYMBOLS.bullet} ${BOLD}${skill.name}${RESET}: ${skill.description}`
      );
    }
    console.log();
    const skills = await askYesNo(rl, "Install recommended skills?", "yes");
    console.log();
    console.log(`${BOLD}Custom Skills:${RESET}`);
    for (const skill of CUSTOM_SKILLS) {
      console.log(
        `  ${SYMBOLS.bullet} ${BOLD}${skill.name}${RESET}: ${skill.description}`
      );
    }
    console.log();
    const customSkills = await askYesNo(rl, "Install custom skills?", "yes");
    console.log();
    return {
      hasKimi: kimi === "yes",
      hasOpenAI: openai === "yes",
      hasAnthropic: anthropic === "yes",
      hasCopilot: copilot === "yes",
      hasZaiPlan: zaiPlan === "yes",
      hasAntigravity: antigravity === "yes",
      hasChutes: chutes === "yes",
      hasOpencodeZen: true,
      useOpenCodeFreeModels: useOpenCodeFree === "yes" && selectedOpenCodePrimaryModel !== void 0,
      selectedOpenCodePrimaryModel,
      selectedOpenCodeSecondaryModel,
      availableOpenCodeFreeModels,
      selectedChutesPrimaryModel,
      selectedChutesSecondaryModel,
      availableChutesFreeModels,
      hasTmux: tmux === "yes",
      installSkills: skills === "yes",
      installCustomSkills: customSkills === "yes"
    };
  } finally {
    rl.close();
  }
}
async function runInstall(config3) {
  const resolvedConfig = {
    ...config3
  };
  const detected = detectCurrentConfig();
  const isUpdate = detected.isInstalled;
  printHeader(isUpdate);
  const hasAnyEnabledProvider = resolvedConfig.hasKimi || resolvedConfig.hasOpenAI || resolvedConfig.hasAnthropic || resolvedConfig.hasCopilot || resolvedConfig.hasZaiPlan || resolvedConfig.hasAntigravity || resolvedConfig.hasChutes || resolvedConfig.useOpenCodeFreeModels;
  let totalSteps = 4;
  if (resolvedConfig.useOpenCodeFreeModels) totalSteps += 1;
  if (resolvedConfig.hasAntigravity) totalSteps += 2;
  if (resolvedConfig.hasChutes) totalSteps += 1;
  if (hasAnyEnabledProvider) totalSteps += 1;
  if (resolvedConfig.installSkills) totalSteps += 1;
  if (resolvedConfig.installCustomSkills) totalSteps += 1;
  let step = 1;
  printStep(step++, totalSteps, "Checking OpenCode installation...");
  const { ok } = await checkOpenCodeInstalled();
  if (!ok) return 1;
  if (resolvedConfig.useOpenCodeFreeModels && (resolvedConfig.availableOpenCodeFreeModels?.length ?? 0) === 0) {
    printStep(
      step++,
      totalSteps,
      "Refreshing OpenCode free models (opencode/*)..."
    );
    const discovery = await discoverOpenCodeFreeModels();
    if (discovery.models.length === 0) {
      printWarning(
        discovery.error ?? "No OpenCode free models found. Continuing without dynamic OpenCode assignment."
      );
      resolvedConfig.useOpenCodeFreeModels = false;
    } else {
      resolvedConfig.availableOpenCodeFreeModels = discovery.models;
      const selectedPrimary = resolvedConfig.preferredOpenCodeModel && discovery.models.some(
        (model) => model.model === resolvedConfig.preferredOpenCodeModel
      ) ? resolvedConfig.preferredOpenCodeModel : resolvedConfig.selectedOpenCodePrimaryModel ?? pickBestCodingOpenCodeModel(discovery.models)?.model;
      resolvedConfig.selectedOpenCodePrimaryModel = selectedPrimary ?? discovery.models[0]?.model;
      resolvedConfig.selectedOpenCodeSecondaryModel = resolvedConfig.selectedOpenCodeSecondaryModel ?? pickSupportOpenCodeModel(
        discovery.models,
        resolvedConfig.selectedOpenCodePrimaryModel
      )?.model ?? resolvedConfig.selectedOpenCodePrimaryModel;
      printSuccess(
        `OpenCode free models ready (${discovery.models.length} models found)`
      );
    }
  } else if (resolvedConfig.useOpenCodeFreeModels && (resolvedConfig.availableOpenCodeFreeModels?.length ?? 0) > 0) {
    const availableModels = resolvedConfig.availableOpenCodeFreeModels ?? [];
    resolvedConfig.selectedOpenCodePrimaryModel = resolvedConfig.selectedOpenCodePrimaryModel ?? pickBestCodingOpenCodeModel(availableModels)?.model;
    resolvedConfig.selectedOpenCodeSecondaryModel = resolvedConfig.selectedOpenCodeSecondaryModel ?? pickSupportOpenCodeModel(
      availableModels,
      resolvedConfig.selectedOpenCodePrimaryModel
    )?.model ?? resolvedConfig.selectedOpenCodePrimaryModel;
    printStep(
      step++,
      totalSteps,
      "Using previously refreshed OpenCode free model list..."
    );
    printSuccess(
      `OpenCode free models ready (${availableModels.length} models found)`
    );
  }
  if (resolvedConfig.hasChutes && (resolvedConfig.availableChutesFreeModels?.length ?? 0) === 0) {
    printStep(
      step++,
      totalSteps,
      "Refreshing Chutes free models (chutes/*)..."
    );
    const discovery = await discoverProviderFreeModels("chutes");
    if (discovery.models.length === 0) {
      printWarning(
        discovery.error ?? "No free Chutes models found. Continuing with fallback Chutes mapping."
      );
    } else {
      resolvedConfig.availableChutesFreeModels = discovery.models;
      resolvedConfig.selectedChutesPrimaryModel = resolvedConfig.selectedChutesPrimaryModel ?? pickBestCodingChutesModel(discovery.models)?.model ?? discovery.models[0]?.model;
      resolvedConfig.selectedChutesSecondaryModel = resolvedConfig.selectedChutesSecondaryModel ?? pickSupportChutesModel(
        discovery.models,
        resolvedConfig.selectedChutesPrimaryModel
      )?.model ?? resolvedConfig.selectedChutesPrimaryModel;
      printSuccess(
        `Chutes models ready (${discovery.models.length} models found)`
      );
    }
  } else if (resolvedConfig.hasChutes && (resolvedConfig.availableChutesFreeModels?.length ?? 0) > 0) {
    const availableChutes = resolvedConfig.availableChutesFreeModels ?? [];
    resolvedConfig.selectedChutesPrimaryModel = resolvedConfig.selectedChutesPrimaryModel ?? pickBestCodingChutesModel(availableChutes)?.model;
    resolvedConfig.selectedChutesSecondaryModel = resolvedConfig.selectedChutesSecondaryModel ?? pickSupportChutesModel(
      availableChutes,
      resolvedConfig.selectedChutesPrimaryModel
    )?.model ?? resolvedConfig.selectedChutesPrimaryModel;
    printStep(
      step++,
      totalSteps,
      "Using previously refreshed Chutes free model list..."
    );
    printSuccess(
      `Chutes models ready (${availableChutes.length} models found)`
    );
  }
  printStep(step++, totalSteps, "Adding miya plugin...");
  const pluginResult = await addPluginToOpenCodeConfig();
  if (!handleStepResult(pluginResult, "Plugin added")) return 1;
  if (resolvedConfig.hasAntigravity) {
    printStep(step++, totalSteps, "Adding Antigravity plugin...");
    const antigravityPluginResult = addAntigravityPlugin();
    if (!handleStepResult(antigravityPluginResult, "Antigravity plugin added"))
      return 1;
    printStep(step++, totalSteps, "Configuring Google Provider...");
    const googleProviderResult = addGoogleProvider();
    if (!handleStepResult(googleProviderResult, "Google Provider configured"))
      return 1;
  }
  if (resolvedConfig.hasChutes) {
    printStep(step++, totalSteps, "Configuring Chutes Provider...");
    const chutesProviderResult = addChutesProvider();
    if (!handleStepResult(chutesProviderResult, "Chutes Provider configured"))
      return 1;
  }
  if (hasAnyEnabledProvider) {
    printStep(step++, totalSteps, "Resolving dynamic model assignments...");
    const catalogDiscovery = await discoverModelCatalog();
    if (catalogDiscovery.models.length === 0) {
      printWarning(
        catalogDiscovery.error ?? "Unable to discover model catalog. Falling back to static mappings."
      );
    } else {
      const dynamicPlan = buildDynamicModelPlan(
        catalogDiscovery.models,
        resolvedConfig
      );
      if (!dynamicPlan) {
        printWarning(
          "Dynamic planner found no suitable models. Using static mappings."
        );
      } else {
        resolvedConfig.dynamicModelPlan = dynamicPlan;
        printSuccess(
          `Dynamic assignments ready (${Object.keys(dynamicPlan.agents).length} agents)`
        );
      }
    }
  }
  printStep(step++, totalSteps, "Disabling OpenCode default agents...");
  const agentResult = disableDefaultAgents();
  if (!handleStepResult(agentResult, "Default agents disabled")) return 1;
  printStep(step++, totalSteps, "Writing miya configuration...");
  const liteResult = writeLiteConfig(resolvedConfig);
  if (!handleStepResult(liteResult, "Config written")) return 1;
  if (resolvedConfig.installSkills) {
    printStep(step++, totalSteps, "Installing recommended skills...");
    let skillsInstalled = 0;
    for (const skill of RECOMMENDED_SKILLS) {
      printInfo(`Installing ${skill.name}...`);
      if (installSkill(skill)) {
        printSuccess(`Installed: ${skill.name}`);
        skillsInstalled++;
      } else {
        printWarning(`Failed to install: ${skill.name}`);
      }
    }
    printSuccess(
      `${skillsInstalled}/${RECOMMENDED_SKILLS.length} skills installed`
    );
  }
  if (resolvedConfig.installCustomSkills) {
    printStep(step++, totalSteps, "Installing custom skills...");
    let customSkillsInstalled = 0;
    for (const skill of CUSTOM_SKILLS) {
      printInfo(`Installing ${skill.name}...`);
      if (installCustomSkill(skill)) {
        printSuccess(`Installed: ${skill.name}`);
        customSkillsInstalled++;
      } else {
        printWarning(`Failed to install: ${skill.name}`);
      }
    }
    printSuccess(
      `${customSkillsInstalled}/${CUSTOM_SKILLS.length} custom skills installed`
    );
  }
  console.log();
  console.log(formatConfigSummary(resolvedConfig));
  console.log();
  printAgentModels(resolvedConfig);
  if (!resolvedConfig.hasKimi && !resolvedConfig.hasOpenAI && !resolvedConfig.hasAnthropic && !resolvedConfig.hasCopilot && !resolvedConfig.hasZaiPlan && !resolvedConfig.hasAntigravity && !resolvedConfig.hasChutes) {
    printWarning(
      "No providers configured. Zen Big Pickle models will be used as fallback."
    );
  }
  console.log(
    `${SYMBOLS.star} ${BOLD}${GREEN}${isUpdate ? "Configuration updated!" : "Installation complete!"}${RESET}`
  );
  console.log();
  console.log(`${BOLD}Next steps:${RESET}`);
  console.log();
  let nextStep = 1;
  if (resolvedConfig.hasKimi || resolvedConfig.hasOpenAI || resolvedConfig.hasAnthropic || resolvedConfig.hasCopilot || resolvedConfig.hasZaiPlan || resolvedConfig.hasAntigravity || resolvedConfig.hasChutes) {
    console.log(`  ${nextStep++}. Authenticate with your providers:`);
    console.log(`     ${BLUE}$ opencode auth login${RESET}`);
    if (resolvedConfig.hasKimi) {
      console.log();
      console.log(`     Then select ${BOLD}Kimi For Coding${RESET} provider.`);
    }
    if (resolvedConfig.hasAntigravity) {
      console.log();
      console.log(`     Then select ${BOLD}google${RESET} provider.`);
    }
    if (resolvedConfig.hasAnthropic) {
      console.log();
      console.log(`     Then select ${BOLD}anthropic${RESET} provider.`);
    }
    if (resolvedConfig.hasCopilot) {
      console.log();
      console.log(`     Then select ${BOLD}github-copilot${RESET} provider.`);
    }
    if (resolvedConfig.hasZaiPlan) {
      console.log();
      console.log(`     Then select ${BOLD}zai-coding-plan${RESET} provider.`);
    }
    if (resolvedConfig.hasChutes) {
      console.log();
      console.log(`     Then set ${BOLD}CHUTES_API_KEY${RESET} in your shell.`);
    }
    console.log();
  }
  if (resolvedConfig.hasTmux) {
    console.log(`  ${nextStep++}. Run OpenCode inside tmux:`);
    console.log(`     ${BLUE}$ tmux${RESET}`);
    console.log(`     ${BLUE}$ opencode${RESET}`);
  } else {
    console.log(`  ${nextStep++}. Start OpenCode:`);
    console.log(`     ${BLUE}$ opencode${RESET}`);
  }
  console.log();
  return 0;
}
async function install(args) {
  const isolatedHome = applyIsolatedConfigHomeIfNeeded(args.isolated === "yes");
  if (isolatedHome) {
    printInfo(`Isolated mode enabled: XDG_CONFIG_HOME=${isolatedHome}`);
  }
  if (!args.tui) {
    const requiredArgs = [
      "kimi",
      "openai",
      "anthropic",
      "copilot",
      "zaiPlan",
      "antigravity",
      "chutes",
      "tmux"
    ];
    const errors = requiredArgs.filter((key) => {
      const value = args[key];
      return value === void 0 || !["yes", "no"].includes(value);
    });
    if (errors.length > 0) {
      printHeader(false);
      printError("Missing or invalid arguments:");
      for (const key of errors) {
        const flagName = key === "zaiPlan" ? "zai-plan" : key;
        console.log(`  ${SYMBOLS.bullet} --${flagName}=<yes|no>`);
      }
      console.log();
      printInfo(
        "Usage: miya install --no-tui --kimi=<yes|no> --openai=<yes|no> --anthropic=<yes|no> --copilot=<yes|no> --zai-plan=<yes|no> --antigravity=<yes|no> --chutes=<yes|no> --tmux=<yes|no> [--isolated=<yes|no>]"
      );
      console.log();
      return 1;
    }
    return runInstall(argsToConfig(args));
  }
  const detected = detectCurrentConfig();
  printHeader(detected.isInstalled);
  printStep(1, 1, "Checking OpenCode installation...");
  const { ok } = await checkOpenCodeInstalled();
  if (!ok) return 1;
  console.log();
  const config3 = await runInteractiveMode(detected);
  return runInstall(config3);
}

// src/nodes/client.ts
init_daemon();
init_utils2();
init_workflow();
import { randomUUID as randomUUID19 } from "node:crypto";
import * as fs43 from "node:fs";
import * as os6 from "node:os";
import * as path43 from "node:path";
var DEFAULT_CAPABILITIES = ["system.info", "system.which", "system.run"];
function runtimeDir(projectDir) {
  return path43.join(getMiyaRuntimeDir(projectDir), "node-host");
}
function approvalFile(projectDir) {
  return path43.join(runtimeDir(projectDir), "approval-rules.json");
}
function historyFile(projectDir) {
  return path43.join(runtimeDir(projectDir), "invocation-history.jsonl");
}
function ensureRuntimeDir(projectDir) {
  fs43.mkdirSync(runtimeDir(projectDir), { recursive: true });
}
function loadApprovalConfig(projectDir) {
  ensureRuntimeDir(projectDir);
  const file3 = approvalFile(projectDir);
  if (!fs43.existsSync(file3)) {
    const defaults = {
      allowAllReadOnly: true,
      requireExplicitForRun: true,
      allow: [
        { capability: "system.run", pattern: "^echo\\b" },
        { capability: "system.run", pattern: "^pwd\\b" },
        { capability: "system.run", pattern: "^dir\\b" },
        { capability: "system.run", pattern: "^ls\\b" }
      ],
      deny: [
        { capability: "system.run", pattern: "(?i)\\brm\\s+-rf\\b" },
        { capability: "system.run", pattern: "(?i)\\bdel\\b" },
        { capability: "system.run", pattern: "(?i)\\bformat\\b" }
      ]
    };
    fs43.writeFileSync(file3, `${JSON.stringify(defaults, null, 2)}
`, "utf-8");
    return defaults;
  }
  try {
    const parsed = JSON.parse(fs43.readFileSync(file3, "utf-8"));
    return {
      allowAllReadOnly: parsed.allowAllReadOnly ?? true,
      requireExplicitForRun: parsed.requireExplicitForRun ?? true,
      allow: Array.isArray(parsed.allow) ? parsed.allow : [],
      deny: Array.isArray(parsed.deny) ? parsed.deny : []
    };
  } catch {
    return {
      allowAllReadOnly: true,
      requireExplicitForRun: true,
      allow: [],
      deny: []
    };
  }
}
function evaluateRule(rule, capability, payload) {
  if (rule.capability !== capability) return false;
  if (!rule.pattern) return true;
  try {
    return new RegExp(rule.pattern).test(payload);
  } catch {
    return false;
  }
}
function isAllowedByLocalPolicy(config3, capability, args) {
  const payload = JSON.stringify(args ?? {});
  if (config3.deny.some((rule) => evaluateRule(rule, capability, payload))) {
    return { ok: false, reason: "blocked_by_local_deny_rule" };
  }
  if (config3.allowAllReadOnly && (capability === "system.info" || capability === "system.which")) {
    return { ok: true };
  }
  if (capability === "system.run" && config3.requireExplicitForRun) {
    const allowed = config3.allow.some((rule) => evaluateRule(rule, capability, payload));
    return allowed ? { ok: true } : { ok: false, reason: "system.run_requires_allow_rule" };
  }
  if (config3.allow.some((rule) => evaluateRule(rule, capability, payload))) {
    return { ok: true };
  }
  return { ok: false, reason: "no_matching_allow_rule" };
}
function appendHistory(projectDir, row) {
  ensureRuntimeDir(projectDir);
  fs43.appendFileSync(historyFile(projectDir), `${JSON.stringify(row)}
`, "utf-8");
}
function runShellCommand(command, timeoutMs) {
  const cmd = process.platform === "win32" ? ["powershell", "-NoProfile", "-Command", command] : ["sh", "-lc", command];
  const proc = runProcessSync(cmd[0], cmd.slice(1), {
    timeout: Math.max(1e3, Math.min(timeoutMs, 10 * 60 * 1e3))
  });
  return {
    ok: proc.exitCode === 0 && !proc.timedOut,
    exitCode: proc.exitCode,
    stdout: proc.stdout,
    stderr: proc.stderr
  };
}
async function executeCapability(projectDir, payload) {
  if (payload.capability === "system.info") {
    return {
      ok: true,
      result: {
        platform: process.platform,
        arch: process.arch,
        hostname: os6.hostname(),
        cpus: os6.cpus().length,
        memory: os6.totalmem()
      }
    };
  }
  if (payload.capability === "system.which") {
    const binary = typeof payload.args.binary === "string" ? payload.args.binary : "";
    if (!binary) return { ok: false, error: "missing_binary" };
    const cmd = process.platform === "win32" ? `where ${binary}` : `which ${binary}`;
    const result = runShellCommand(cmd, 1e4);
    return {
      ok: result.ok,
      result: result.ok ? { binary, path: result.stdout.trim() } : void 0,
      error: result.ok ? void 0 : result.stderr.trim() || "binary_not_found"
    };
  }
  if (payload.capability === "system.run") {
    const command = typeof payload.args.command === "string" ? payload.args.command : "";
    const timeoutMs = typeof payload.args.timeoutMs === "number" ? Number(payload.args.timeoutMs) : 12e4;
    if (!command) return { ok: false, error: "missing_command" };
    const daemon = getMiyaClient(projectDir);
    const result = await daemon.runIsolatedProcess({
      kind: "shell.exec",
      command: process.platform === "win32" ? "powershell" : "sh",
      args: process.platform === "win32" ? ["-NoProfile", "-Command", command] : ["-lc", command],
      timeoutMs,
      resource: {
        priority: 70,
        vramMB: 0
      },
      metadata: {
        capability: payload.capability
      }
    });
    return {
      ok: result.exitCode === 0 && !result.timedOut,
      result: {
        exitCode: result.exitCode,
        stdout: result.stdout.trim(),
        stderr: result.stderr.trim()
      },
      error: result.exitCode === 0 && !result.timedOut ? void 0 : result.timedOut ? "timeout" : `exit_${result.exitCode}`
    };
  }
  if (payload.capability === "canvas.render") {
    const content = typeof payload.args.content === "string" ? payload.args.content : "";
    if (!content) return { ok: false, error: "missing_canvas_content" };
    const canvasDir = path43.join(runtimeDir(projectDir), "canvas");
    fs43.mkdirSync(canvasDir, { recursive: true });
    const file3 = path43.join(canvasDir, `canvas-${Date.now()}.txt`);
    fs43.writeFileSync(file3, content, "utf-8");
    return {
      ok: true,
      result: {
        saved: true,
        path: file3
      }
    };
  }
  return { ok: false, error: `unsupported_capability:${payload.capability}` };
}
async function sendFrame(socket, frame) {
  socket.send(JSON.stringify(frame));
}
async function runNodeHost(options) {
  const projectDir = options.projectDir;
  const nodeID = options.nodeID || process.env.MIYA_NODE_ID || `node-${os6.hostname()}-${randomUUID19().slice(0, 8)}`;
  const deviceID = options.deviceID || process.env.MIYA_DEVICE_ID || `${os6.hostname()}-${process.platform}-${process.arch}`;
  const capabilities = [...new Set(options.capabilities ?? DEFAULT_CAPABILITIES)];
  const nodeType = options.nodeType ?? "cli";
  const wsUrl = `${options.gatewayUrl.replace(/^http/, "ws")}/ws`;
  const gatewayToken = process.env.MIYA_GATEWAY_TOKEN;
  const nodeToken = options.nodeToken || process.env.MIYA_NODE_TOKEN;
  let stopRequested = false;
  let socket;
  let reconnectTimer;
  let heartbeatTimer;
  const connect = async () => {
    if (stopRequested) return;
    socket = new WebSocket(wsUrl);
    socket.onopen = () => {
      void sendFrame(socket, {
        type: "hello",
        role: "node",
        protocolVersion: "1.0",
        clientID: nodeID,
        auth: gatewayToken ? { token: gatewayToken } : void 0,
        capabilities
      });
      void sendFrame(socket, {
        type: "request",
        id: `register-${Date.now()}`,
        method: "nodes.register",
        params: {
          nodeID,
          deviceID,
          type: nodeType,
          token: nodeToken,
          platform: process.platform,
          capabilities,
          permissions: options.permissions
        }
      });
      if (heartbeatTimer) clearInterval(heartbeatTimer);
      heartbeatTimer = setInterval(() => {
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        void sendFrame(socket, {
          type: "request",
          id: `hb-${Date.now()}`,
          method: "nodes.heartbeat",
          params: {
            nodeID
          }
        });
      }, 3e4);
      void sendFrame(socket, {
        type: "request",
        id: `sub-${Date.now()}`,
        method: "gateway.subscribe",
        params: { events: ["*"] }
      });
    };
    socket.onmessage = (event) => {
      void (async () => {
        const text = String(event.data ?? "");
        if (!text.trim()) return;
        const frame = JSON.parse(text);
        if (frame.type !== "event" || frame.event !== "node.invoke.request") return;
        const payload = frame.payload;
        if (!payload || payload.nodeID !== nodeID) return;
        const policy = loadApprovalConfig(projectDir);
        const allowed = isAllowedByLocalPolicy(policy, payload.capability, payload.args);
        let response;
        if (!allowed.ok) {
          response = { ok: false, error: allowed.reason ?? "blocked_by_local_policy" };
        } else {
          response = await executeCapability(projectDir, payload);
        }
        appendHistory(projectDir, {
          at: (/* @__PURE__ */ new Date()).toISOString(),
          nodeID,
          invokeID: payload.id,
          capability: payload.capability,
          args: payload.args,
          ok: response.ok,
          error: response.error
        });
        await sendFrame(socket, {
          type: "request",
          id: `invoke-result-${payload.id}`,
          method: "nodes.invoke.result",
          params: {
            invokeID: payload.id,
            ok: response.ok,
            result: response.result,
            error: response.error
          }
        });
      })();
    };
    socket.onclose = () => {
      if (stopRequested) return;
      if (heartbeatTimer) {
        clearInterval(heartbeatTimer);
        heartbeatTimer = void 0;
      }
      reconnectTimer = setTimeout(() => {
        void connect();
      }, 3e3);
    };
    socket.onerror = () => {
      try {
        socket?.close();
      } catch {
      }
    };
  };
  await connect();
  const shutdown = () => {
    stopRequested = true;
    if (reconnectTimer) clearTimeout(reconnectTimer);
    if (heartbeatTimer) clearInterval(heartbeatTimer);
    try {
      socket?.close();
    } catch {
    }
  };
  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
  await new Promise((resolve4) => {
    const timer = setInterval(() => {
      if (stopRequested) {
        clearInterval(timer);
        resolve4();
      }
    }, 200);
  });
}

// src/cli/index.ts
init_policy2();
function parseInstallArgs(args) {
  const result = {
    tui: true
  };
  for (const arg of args) {
    if (arg === "--no-tui") {
      result.tui = false;
    } else if (arg.startsWith("--kimi=")) {
      result.kimi = arg.split("=")[1];
    } else if (arg.startsWith("--openai=")) {
      result.openai = arg.split("=")[1];
    } else if (arg.startsWith("--anthropic=")) {
      result.anthropic = arg.split("=")[1];
    } else if (arg.startsWith("--copilot=")) {
      result.copilot = arg.split("=")[1];
    } else if (arg.startsWith("--zai-plan=")) {
      result.zaiPlan = arg.split("=")[1];
    } else if (arg.startsWith("--antigravity=")) {
      result.antigravity = arg.split("=")[1];
    } else if (arg.startsWith("--chutes=")) {
      result.chutes = arg.split("=")[1];
    } else if (arg.startsWith("--tmux=")) {
      result.tmux = arg.split("=")[1];
    } else if (arg.startsWith("--skills=")) {
      result.skills = arg.split("=")[1];
    } else if (arg.startsWith("--opencode-free=")) {
      result.opencodeFree = arg.split("=")[1];
    } else if (arg.startsWith("--opencode-free-model=")) {
      result.opencodeFreeModel = arg.split("=")[1];
    } else if (arg.startsWith("--isolated=")) {
      result.isolated = arg.split("=")[1];
    }
  }
  return result;
}
function printHelp() {
  console.log(`
miya cli

Usage:
  miya install [OPTIONS]
  miya gateway <start|serve|terminal|status|doctor|shutdown|autostart>
  miya sessions <list|get|send|policy>
  miya channels <list|status|pairs|approve|reject|send>
  miya nodes <list|status|describe|pairs|approve|reject|invoke>
  miya skills <status|enable|disable|install|update>
  miya sync <list|pull|diff|apply|rollback>
  miya cron <list|runs|add|run|remove|approvals|approve|reject>
  miya voice <status|wake-on|wake-off|talk-start|talk-stop|ingest|history|clear>
  miya canvas <status|list|get|open|render|close>
  miya companion <status|wizard|profile|memory-add|memory-list|asset-add|asset-list|reset>

Examples:
  miya gateway status
  miya gateway terminal
  miya gateway autostart install
  miya sessions send webchat:main "hello"
  miya channels send telegram 123456 "hi"
  miya nodes invoke node-1 system.run '{"command":"pwd"}'
  miya sync list
  miya node-host --gateway http://127.0.0.1:17321
  miya install --no-tui --kimi=yes --openai=no --anthropic=no --copilot=no --zai-plan=no --antigravity=no --chutes=no --tmux=no --skills=yes --isolated=yes
`);
}
var ANSI = {
  dim: "\x1B[90m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  cyan: "\x1B[36m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  reset: "\x1B[0m"
};
function supportsAnsi() {
  if (!process.stdout.isTTY) return false;
  if (process.platform !== "win32") return true;
  return process.env.FORCE_COLOR === "1" || process.env.WT_SESSION !== void 0 || process.env.TERM_PROGRAM === "vscode";
}
function color(text, value) {
  if (!supportsAnsi()) return text;
  return `${value}${text}${ANSI.reset}`;
}
function formatClock(ts) {
  const parsed = new Date(ts);
  if (Number.isNaN(parsed.getTime())) return ts;
  const hh = String(parsed.getHours()).padStart(2, "0");
  const mm = String(parsed.getMinutes()).padStart(2, "0");
  const ss = String(parsed.getSeconds()).padStart(2, "0");
  return `${hh}:${mm}:${ss}`;
}
function gatewayLogFilePath() {
  return path44.join(os7.tmpdir(), "miya.log");
}
function normalizeLogCategory(input) {
  const match = /^\[([^\]]+)\]/.exec(input.trim());
  return match ? match[1].toLowerCase() : "log";
}
function colorByCategory(message) {
  const category = normalizeLogCategory(message);
  if (category.includes("error") || category.includes("failed")) return ANSI.red;
  if (category.includes("warn")) return ANSI.yellow;
  if (category.includes("gateway")) return ANSI.cyan;
  if (category.includes("daemon")) return ANSI.magenta;
  return ANSI.green;
}
function readTailLines(file3, limit = 80) {
  if (!fs44.existsSync(file3)) return [];
  const text = fs44.readFileSync(file3, "utf-8");
  const all = text.split(/\r?\n/).filter((line) => line.trim().length > 0);
  if (all.length <= limit) return all;
  return all.slice(all.length - limit);
}
function formatGatewayConsoleLine(raw) {
  const parsed = /^\[([^\]]+)\]\s(.*)$/.exec(raw);
  if (!parsed) return raw;
  const [, ts, message] = parsed;
  const clock = color(formatClock(ts), ANSI.dim);
  const coloredMessage = color(message, colorByCategory(message));
  return `${clock} ${coloredMessage}`;
}
function resolveGatewayCliScript(workspace) {
  const distCli = path44.join(workspace, "dist", "cli", "index.js");
  if (fs44.existsSync(distCli)) {
    return distCli;
  }
  const selfCli = resolveCliScriptPath();
  if (selfCli.endsWith(".js")) {
    return selfCli;
  }
  return null;
}
function startGatewayLogTail(file3, onLine) {
  let cursor = 0;
  let partial3 = "";
  let timer;
  const maxChunkBytes = 256 * 1024;
  const consume = (chunk) => {
    partial3 += chunk;
    const lines = partial3.split(/\r?\n/);
    partial3 = lines.pop() ?? "";
    for (const line of lines) {
      if (line.trim().length > 0) onLine(line);
    }
  };
  const poll = () => {
    if (!fs44.existsSync(file3)) return;
    const stat = fs44.statSync(file3);
    if (stat.size < cursor) {
      cursor = 0;
      partial3 = "";
    }
    if (stat.size === cursor) return;
    let remaining = stat.size - cursor;
    if (remaining <= 0) return;
    const fd = fs44.openSync(file3, "r");
    try {
      while (remaining > 0) {
        const chunkSize = Math.min(remaining, maxChunkBytes);
        const chunk = Buffer.alloc(chunkSize);
        const bytesRead = fs44.readSync(fd, chunk, 0, chunkSize, cursor);
        if (bytesRead <= 0) break;
        cursor += bytesRead;
        remaining -= bytesRead;
        consume(chunk.subarray(0, bytesRead).toString("utf-8"));
      }
    } finally {
      fs44.closeSync(fd);
    }
  };
  if (fs44.existsSync(file3)) {
    const stat = fs44.statSync(file3);
    cursor = stat.size;
  }
  timer = setInterval(() => {
    try {
      poll();
    } catch {
    }
  }, 350);
  return () => {
    if (timer) clearInterval(timer);
    timer = void 0;
  };
}
function windowsStartupDir() {
  if (process.platform !== "win32") return null;
  const appData = process.env.APPDATA?.trim();
  if (!appData) return null;
  return path44.join(appData, "Microsoft", "Windows", "Start Menu", "Programs", "Startup");
}
function gatewayAutostartScriptPath() {
  const startup = windowsStartupDir();
  if (!startup) return "";
  return path44.join(startup, "miya-gateway-terminal.cmd");
}
function gatewayAutostartVbsPath() {
  const startup = windowsStartupDir();
  if (!startup) return "";
  return path44.join(startup, "miya-gateway-autostart.vbs");
}
function gatewayAutostartLauncherPath(workspace) {
  return path44.join(workspace, ".opencode", "miya", "autostart", "miya-gateway-autostart.cmd");
}
function gatewayAutostartMetaFile(workspace) {
  return path44.join(workspace, ".opencode", "miya", "autostart", "gateway-autostart.json");
}
function quoteForCmd(value) {
  return `"${value.replace(/"/g, '""')}"`;
}
function renderGatewayAutostartScript(input) {
  const nodeArgs = [
    quoteForCmd(input.cliScript),
    `gateway ${input.mode}`,
    `--workspace ${quoteForCmd(input.workspace)}`
  ].filter(Boolean).join(" ");
  return [
    "@echo off",
    "setlocal",
    `cd /d ${quoteForCmd(input.workspace)}`,
    'set "MIYA_AUTO_UI_OPEN=0"',
    'set "MIYA_DOCK_AUTO_LAUNCH=0"',
    'set "MIYA_GATEWAY_CLI_START_ENABLE=1"',
    `${quoteForCmd(input.nodeBinary)} ${nodeArgs}`,
    "endlocal",
    ""
  ].join("\r\n");
}
function renderGatewayAutostartVbs(launcherPath) {
  const escaped = launcherPath.replace(/"/g, '""');
  return [
    'Set shell = CreateObject("WScript.Shell")',
    `shell.Run Chr(34) & "${escaped}" & Chr(34), 0, False`,
    "Set shell = Nothing",
    ""
  ].join("\r\n");
}
function readAutostartMode(workspace) {
  const file3 = gatewayAutostartMetaFile(workspace);
  if (!fs44.existsSync(file3)) return "unknown";
  try {
    const parsed = JSON.parse(fs44.readFileSync(file3, "utf-8"));
    if (parsed.mode === "serve" || parsed.mode === "terminal") return parsed.mode;
    return "unknown";
  } catch {
    return "unknown";
  }
}
function terminalLockFilePath(workspace) {
  return path44.join(workspace, ".opencode", "miya", "gateway-terminal.lock.json");
}
function acquireTerminalLock(workspace) {
  const lockFile = terminalLockFilePath(workspace);
  if (fs44.existsSync(lockFile)) {
    try {
      const parsed = JSON.parse(fs44.readFileSync(lockFile, "utf-8"));
      const pid = Number(parsed.pid);
      if (Number.isFinite(pid) && pid > 0 && isPidAlive2(pid)) {
        return { ok: false, ownerPid: pid };
      }
    } catch {
    }
  }
  if (!fs44.existsSync(path44.dirname(lockFile))) {
    fs44.mkdirSync(path44.dirname(lockFile), { recursive: true });
  }
  fs44.writeFileSync(
    lockFile,
    `${JSON.stringify({ pid: process.pid, startedAt: (/* @__PURE__ */ new Date()).toISOString() }, null, 2)}
`,
    "utf-8"
  );
  return { ok: true };
}
function releaseTerminalLock(workspace) {
  const lockFile = terminalLockFilePath(workspace);
  try {
    const parsed = JSON.parse(fs44.readFileSync(lockFile, "utf-8"));
    if (Number(parsed.pid) !== process.pid) return;
  } catch {
  }
  try {
    fs44.unlinkSync(lockFile);
  } catch {
  }
}
function runtimeGatewayFile(cwd) {
  return path44.join(cwd, ".opencode", "miya", "gateway.json");
}
function runtimeGatewayStartGuardFile(cwd) {
  return path44.join(cwd, ".opencode", "miya", "gateway-start.guard.json");
}
function readGatewayStartGuard(cwd) {
  const file3 = runtimeGatewayStartGuardFile(cwd);
  if (!fs44.existsSync(file3)) return null;
  try {
    const parsed = JSON.parse(fs44.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object") return null;
    if (parsed.status !== "idle" && parsed.status !== "starting" && parsed.status !== "failed") {
      return null;
    }
    if (!parsed.updatedAt || !Number.isFinite(Date.parse(parsed.updatedAt))) return null;
    return parsed;
  } catch {
    return null;
  }
}
function writeGatewayStartGuard(cwd, guard) {
  const file3 = runtimeGatewayStartGuardFile(cwd);
  fs44.mkdirSync(path44.dirname(file3), { recursive: true });
  fs44.writeFileSync(file3, `${JSON.stringify(guard, null, 2)}
`, "utf-8");
}
function resolveWorkspaceDir(cwd) {
  const hasRuntimeState = fs44.existsSync(path44.join(cwd, ".opencode", "miya"));
  const hasSourceEntry = fs44.existsSync(path44.join(cwd, "src", "index.ts"));
  if (hasRuntimeState || hasSourceEntry) {
    return cwd;
  }
  const nested = path44.join(cwd, "miya-src");
  if (fs44.existsSync(path44.join(nested, "src", "index.ts"))) {
    return nested;
  }
  return cwd;
}
function resolveNodeBinary2() {
  const configured = process.env.MIYA_NODE_BIN?.trim();
  const windowsNodeCandidates = process.platform === "win32" ? [
    path44.join(process.env.ProgramFiles ?? "C:\\Program Files", "nodejs", "node.exe"),
    path44.join(
      process.env["ProgramFiles(x86)"] ?? "C:\\Program Files (x86)",
      "nodejs",
      "node.exe"
    ),
    path44.join(process.env.LOCALAPPDATA ?? "", "Programs", "nodejs", "node.exe")
  ] : [];
  const candidates = [
    configured || null,
    (() => {
      const execBase = path44.basename(process.execPath).toLowerCase();
      return execBase === "node" || execBase === "node.exe" ? process.execPath : null;
    })(),
    ...windowsNodeCandidates,
    process.platform === "win32" ? "node.exe" : "node"
  ].filter((item) => Boolean(item));
  for (const candidate of candidates) {
    try {
      const probe = spawnSync8(candidate, ["--version"], {
        stdio: ["ignore", "ignore", "ignore"],
        timeout: 2e3,
        windowsHide: true
      });
      if (probe.status === 0) return candidate;
    } catch {
    }
  }
  return null;
}
function resolveCliScriptPath() {
  return fileURLToPath5(import.meta.url);
}
function clearGatewayStateFile2(cwd) {
  try {
    fs44.unlinkSync(runtimeGatewayFile(cwd));
  } catch {
  }
}
function readGatewayUrl(cwd) {
  const file3 = runtimeGatewayFile(cwd);
  if (!fs44.existsSync(file3)) return null;
  try {
    const parsed = JSON.parse(fs44.readFileSync(file3, "utf-8"));
    return parsed.url ?? null;
  } catch {
    return null;
  }
}
function candidateGatewayRuntimeDirs(cwd) {
  const workspace = resolveWorkspaceDir(cwd);
  if (workspace === cwd) return [cwd];
  return [workspace, cwd];
}
function isPidAlive2(pid) {
  if (!Number.isFinite(pid) || pid <= 0) return false;
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function readGatewayState(cwd) {
  const file3 = runtimeGatewayFile(cwd);
  if (!fs44.existsSync(file3)) return null;
  try {
    const parsed = JSON.parse(fs44.readFileSync(file3, "utf-8"));
    const url3 = String(parsed.url ?? "").trim();
    const pid = Number(parsed.pid);
    if (!url3 || !Number.isFinite(pid)) return null;
    return { url: url3, pid };
  } catch {
    return null;
  }
}
async function waitGatewayReady(cwd, timeoutMs = 15e3) {
  const startedAt = Date.now();
  while (Date.now() - startedAt < timeoutMs) {
    const state = readGatewayState(cwd);
    if (state && isPidAlive2(state.pid)) {
      try {
        await callGatewayMethod(state.url, "gateway.status.get", {});
        return true;
      } catch {
      }
    }
    await new Promise((resolve4) => setTimeout(resolve4, 400));
  }
  return false;
}
async function runGatewayStart(cwd) {
  const workspace = resolveWorkspaceDir(cwd);
  const guard = readGatewayStartGuard(workspace);
  const now = Date.now();
  if (guard?.status === "starting") {
    const ageMs = now - Date.parse(guard.updatedAt);
    if (ageMs < 3e4) {
      return {
        ok: false,
        workspace,
        reason: "guard_starting",
        detail: `gateway_start_guard_active ageMs=${ageMs}`
      };
    }
  }
  if (guard?.cooldownUntil && now < Date.parse(guard.cooldownUntil)) {
    return {
      ok: false,
      workspace,
      reason: "guard_cooldown",
      detail: `cooldown_until=${guard.cooldownUntil}`
    };
  }
  writeGatewayStartGuard(workspace, {
    status: "starting",
    updatedAt: new Date(now).toISOString()
  });
  const nodeBinary = resolveNodeBinary2();
  if (!nodeBinary) {
    writeGatewayStartGuard(workspace, {
      status: "failed",
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      cooldownUntil: new Date(Date.now() + 6e4).toISOString()
    });
    return {
      ok: false,
      workspace,
      reason: "node_not_found",
      detail: "Cannot resolve a runnable Node.js binary."
    };
  }
  const cliScript = resolveGatewayCliScript(workspace);
  if (!cliScript) {
    writeGatewayStartGuard(workspace, {
      status: "failed",
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      cooldownUntil: new Date(Date.now() + 6e4).toISOString()
    });
    return {
      ok: false,
      workspace,
      reason: "cli_js_not_found",
      detail: "Cannot resolve dist/cli/index.js for node startup. Run `npm run build` first."
    };
  }
  const nodeArgs = [
    cliScript,
    "gateway",
    "serve",
    "--workspace",
    workspace
  ];
  for (let attempt = 0; attempt < 2; attempt += 1) {
    try {
      const proc = spawn4(nodeBinary, nodeArgs, {
        cwd: workspace,
        detached: true,
        stdio: "ignore",
        windowsHide: true,
        env: {
          ...process.env,
          MIYA_AUTO_UI_OPEN: "0",
          MIYA_DOCK_AUTO_LAUNCH: "0"
        }
      });
      proc.unref();
    } catch (error92) {
      writeGatewayStartGuard(workspace, {
        status: "failed",
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        cooldownUntil: new Date(Date.now() + 6e4).toISOString()
      });
      return {
        ok: false,
        workspace,
        reason: "spawn_failed",
        detail: error92 instanceof Error ? error92.message : String(error92)
      };
    }
    if (await waitGatewayReady(workspace, 15e3)) {
      writeGatewayStartGuard(workspace, {
        status: "idle",
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
      return {
        ok: true,
        workspace,
        url: readGatewayUrl(workspace) ?? void 0,
        reason: "started"
      };
    }
    clearGatewayStateFile2(workspace);
  }
  writeGatewayStartGuard(workspace, {
    status: "failed",
    updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    cooldownUntil: new Date(Date.now() + 6e4).toISOString()
  });
  return {
    ok: false,
    workspace,
    reason: "start_timeout",
    detail: "Gateway did not become ready within timeout window."
  };
}
async function callGatewayMethod(url3, method, params) {
  const wsUrl = url3.replace(/^http/, "ws");
  const socket = new WebSocket(`${wsUrl}/ws`);
  return await new Promise((resolve4, reject) => {
    const timeout = setTimeout(() => {
      try {
        socket.close();
      } catch {
      }
      reject(new Error("gateway_timeout"));
    }, 1e4);
    socket.addEventListener("open", () => {
      const token = process.env.MIYA_GATEWAY_TOKEN;
      socket.send(
        JSON.stringify({
          type: "hello",
          role: "admin",
          protocolVersion: "1.0",
          auth: token ? { token } : void 0
        })
      );
      socket.send(
        JSON.stringify({
          type: "request",
          id: "cli-1",
          method,
          params
        })
      );
    });
    socket.addEventListener("message", (event) => {
      try {
        const frame = JSON.parse(String(event.data));
        if (frame.type !== "response" || frame.id !== "cli-1") return;
        clearTimeout(timeout);
        socket.close();
        if (frame.ok) {
          resolve4(frame.result);
        } else {
          reject(new Error(frame.error?.message ?? "gateway_method_failed"));
        }
      } catch (error92) {
        clearTimeout(timeout);
        reject(error92 instanceof Error ? error92 : new Error(String(error92)));
      }
    });
    socket.addEventListener("error", () => {
      clearTimeout(timeout);
      reject(new Error("gateway_socket_error"));
    });
  });
}
async function ensureGatewayUrl(cwd, autoStart = true) {
  const candidateDirs = candidateGatewayRuntimeDirs(cwd);
  for (const dir of candidateDirs) {
    const url3 = readGatewayUrl(dir);
    if (!url3) continue;
    try {
      await callGatewayMethod(url3, "gateway.status.get", {});
      return url3;
    } catch {
      clearGatewayStateFile2(dir);
    }
  }
  if (autoStart && (await runGatewayStart(cwd)).ok) {
    for (const dir of candidateDirs) {
      const url3 = readGatewayUrl(dir);
      if (!url3) continue;
      try {
        await callGatewayMethod(url3, "gateway.status.get", {});
        return url3;
      } catch {
        clearGatewayStateFile2(dir);
      }
    }
  }
  throw new Error("gateway_unavailable");
}
async function runGatewayServe(cwd, args) {
  const workspace = readFlagValue(args, "--workspace") ?? resolveWorkspaceDir(cwd);
  const { ensureGatewayRunning: ensureGatewayRunning2, stopGateway: stopGateway2 } = await Promise.resolve().then(() => (init_gateway(), gateway_exports));
  try {
    const state = ensureGatewayRunning2(workspace);
    console.log(JSON.stringify(state, null, 2));
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    if (message === "gateway_owned_by_other_process") {
      return 0;
    }
    throw error92;
  }
  await new Promise((resolve4) => {
    const stop = () => {
      try {
        stopGateway2(workspace);
      } finally {
        resolve4();
      }
    };
    process.once("SIGINT", stop);
    process.once("SIGTERM", stop);
  });
  return 0;
}
async function runGatewayTerminal(cwd, args) {
  const workspace = readFlagValue(args, "--workspace") ?? resolveWorkspaceDir(cwd);
  const lock = acquireTerminalLock(workspace);
  if (!lock.ok) {
    console.log(
      JSON.stringify(
        {
          ok: true,
          skipped: true,
          reason: "terminal_already_running",
          ownerPid: lock.ownerPid ?? null
        },
        null,
        2
      )
    );
    return 0;
  }
  const { ensureGatewayRunning: ensureGatewayRunning2, stopGateway: stopGateway2, isGatewayOwner: isGatewayOwner2 } = await Promise.resolve().then(() => (init_gateway(), gateway_exports));
  let ownRuntime = false;
  try {
    ensureGatewayRunning2(workspace);
    ownRuntime = isGatewayOwner2(workspace);
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    if (message !== "gateway_owned_by_other_process") {
      throw error92;
    }
    ownRuntime = false;
  }
  const state = readGatewayState(workspace);
  const logFile2 = gatewayLogFilePath();
  console.log(
    color(
      `Miya Gateway Terminal - ${ownRuntime ? "owner" : "follower"} mode`,
      ANSI.cyan
    )
  );
  if (state) {
    console.log(
      `${color("url", ANSI.dim)}=${state.url} ${color("pid", ANSI.dim)}=${state.pid} ${color("log", ANSI.dim)}=${logFile2}`
    );
  } else {
    console.log(`${color("log", ANSI.dim)}=${logFile2}`);
  }
  const tailLines = readTailLines(logFile2, 80);
  if (tailLines.length > 0) {
    for (const line of tailLines) {
      console.log(formatGatewayConsoleLine(line));
    }
  } else {
    console.log(color("[gateway] waiting for runtime log stream...", ANSI.dim));
  }
  const stopTail = startGatewayLogTail(logFile2, (line) => {
    console.log(formatGatewayConsoleLine(line));
  });
  await new Promise((resolve4) => {
    const stop = () => {
      stopTail();
      releaseTerminalLock(workspace);
      if (ownRuntime) {
        try {
          stopGateway2(workspace);
        } catch {
        }
      }
      resolve4();
    };
    process.once("SIGINT", stop);
    process.once("SIGTERM", stop);
  });
  return 0;
}
async function runGatewayAutostart(cwd, args) {
  const action = args[0] ?? "status";
  const workspace = readFlagValue(args, "--workspace") ?? resolveWorkspaceDir(cwd);
  const modeRaw = (readFlagValue(args, "--mode") ?? "serve").trim().toLowerCase();
  const mode = modeRaw === "terminal" ? "terminal" : "serve";
  const startupDir = windowsStartupDir();
  if (!startupDir) {
    console.error("gateway_autostart_unsupported_platform");
    return 2;
  }
  const legacyScriptFile = gatewayAutostartScriptPath();
  const startupVbs = gatewayAutostartVbsPath();
  const launcherFile = gatewayAutostartLauncherPath(workspace);
  const metaFile = gatewayAutostartMetaFile(workspace);
  if (!startupVbs) {
    console.error("gateway_autostart_startup_dir_unavailable");
    return 2;
  }
  if (action === "status") {
    const exists = fs44.existsSync(startupVbs);
    const launcherExists = fs44.existsSync(launcherFile);
    const legacyExists = fs44.existsSync(legacyScriptFile);
    console.log(
      JSON.stringify(
        {
          ok: true,
          action,
          exists,
          launcherExists,
          legacyExists,
          mode: readAutostartMode(workspace),
          startupDir,
          startupVbs,
          launcherFile,
          workspace
        },
        null,
        2
      )
    );
    return 0;
  }
  if (action === "remove" || action === "uninstall") {
    const existed = fs44.existsSync(startupVbs) || fs44.existsSync(launcherFile) || fs44.existsSync(legacyScriptFile);
    try {
      fs44.unlinkSync(startupVbs);
    } catch {
    }
    try {
      fs44.unlinkSync(launcherFile);
    } catch {
    }
    try {
      fs44.unlinkSync(metaFile);
    } catch {
    }
    try {
      fs44.unlinkSync(legacyScriptFile);
    } catch {
    }
    console.log(
      JSON.stringify(
        {
          ok: true,
          action: "remove",
          removed: existed,
          startupVbs,
          launcherFile,
          legacyScriptFile
        },
        null,
        2
      )
    );
    return 0;
  }
  if (action === "install") {
    const nodeBinary = resolveNodeBinary2();
    if (!nodeBinary) {
      console.log(
        JSON.stringify(
          {
            ok: false,
            action,
            reason: "node_not_found",
            detail: "Cannot resolve a runnable Node.js binary."
          },
          null,
          2
        )
      );
      return 1;
    }
    const cliScript = resolveGatewayCliScript(workspace);
    if (!cliScript) {
      console.log(
        JSON.stringify(
          {
            ok: false,
            action,
            reason: "cli_js_not_found",
            detail: "Cannot resolve dist/cli/index.js for node autostart. Run `npm run build` first."
          },
          null,
          2
        )
      );
      return 1;
    }
    const scriptText = renderGatewayAutostartScript({
      workspace,
      nodeBinary,
      cliScript,
      mode
    });
    if (!fs44.existsSync(path44.dirname(launcherFile))) {
      fs44.mkdirSync(path44.dirname(launcherFile), { recursive: true });
    }
    fs44.writeFileSync(launcherFile, scriptText, "utf-8");
    fs44.writeFileSync(startupVbs, renderGatewayAutostartVbs(launcherFile), "utf-8");
    fs44.writeFileSync(
      metaFile,
      `${JSON.stringify(
        {
          mode,
          installedAt: (/* @__PURE__ */ new Date()).toISOString(),
          launcherFile,
          startupVbs
        },
        null,
        2
      )}
`,
      "utf-8"
    );
    try {
      fs44.unlinkSync(legacyScriptFile);
    } catch {
    }
    console.log(
      JSON.stringify(
        {
          ok: true,
          action,
          installed: true,
          mode,
          startupVbs,
          launcherFile,
          startupDir,
          workspace,
          nodeBinary,
          cliScript
        },
        null,
        2
      )
    );
    return 0;
  }
  throw new Error(`unknown_gateway_autostart_action:${action}`);
}
async function runGatewayCommand(cwd, args) {
  const action = args[0] ?? "status";
  if (action === "start") {
    const allowCliStart = args.includes("--force") || process.env.MIYA_GATEWAY_CLI_START_ENABLE === "1";
    if (!allowCliStart) {
      console.error(
        "gateway_start_blocked:safety_guard (use `miya gateway start --force` or set MIYA_GATEWAY_CLI_START_ENABLE=1)"
      );
      return 2;
    }
    const result = await runGatewayStart(cwd);
    const output = {
      ok: result.ok,
      reason: result.reason,
      workspace: result.workspace,
      url: result.url ?? null,
      detail: result.detail ?? null
    };
    console.log(JSON.stringify(output, null, 2));
    return result.ok ? 0 : 1;
  }
  if (action === "serve") {
    return await runGatewayServe(cwd, args.slice(1));
  }
  if (action === "terminal") {
    return await runGatewayTerminal(cwd, args.slice(1));
  }
  if (action === "autostart") {
    return await runGatewayAutostart(cwd, args.slice(1));
  }
  let url3 = "";
  try {
    url3 = await ensureGatewayUrl(cwd, false);
  } catch (error92) {
    if (action === "shutdown") {
      console.log(JSON.stringify({ ok: true, stopped: false, reason: "not_running" }, null, 2));
      return 0;
    }
    throw error92;
  }
  if (action === "status") {
    const result = await callGatewayMethod(url3, "gateway.status.get", {});
    console.log(JSON.stringify(result, null, 2));
    return 0;
  }
  if (action === "doctor") {
    const result = await callGatewayMethod(url3, "doctor.run", {});
    console.log(JSON.stringify(result, null, 2));
    return 0;
  }
  if (action === "shutdown") {
    const result = await callGatewayMethod(url3, "gateway.shutdown", {});
    console.log(JSON.stringify(result, null, 2));
    return 0;
  }
  throw new Error(`unknown_gateway_action:${action}`);
}
async function runSubcommand(cwd, top, args) {
  const url3 = await ensureGatewayUrl(cwd);
  const workspace = resolveWorkspaceDir(cwd);
  const withPolicyHash = (params2) => ({
    ...params2,
    policyHash: currentPolicyHash(workspace)
  });
  const method = (() => {
    if (top === "sessions") {
      const action = args[0] ?? "list";
      if (action === "list") return ["sessions.list", {}];
      if (action === "get") return ["sessions.get", { sessionID: args[1] }];
      if (action === "send")
        return [
          "sessions.send",
          {
            sessionID: args[1],
            text: args[2],
            source: args[3] ?? "cli"
          }
        ];
      if (action === "policy")
        return [
          "sessions.policy.set",
          {
            sessionID: args[1],
            activation: args[2],
            reply: args[3]
          }
        ];
    }
    if (top === "channels") {
      const action = args[0] ?? "status";
      if (action === "list") return ["channels.list", {}];
      if (action === "status") return ["channels.status", {}];
      if (action === "pairs") return ["channels.pair.list", { status: args[1] }];
      if (action === "approve") return ["channels.pair.approve", { pairID: args[1] }];
      if (action === "reject") return ["channels.pair.reject", { pairID: args[1] }];
      if (action === "send")
        return [
          "channels.message.send",
          {
            channel: args[1],
            destination: args[2],
            text: args[3],
            sessionID: args[4] ?? "main"
          }
        ];
    }
    if (top === "nodes") {
      const action = args[0] ?? "status";
      if (action === "list") return ["nodes.list", {}];
      if (action === "status") return ["nodes.status", {}];
      if (action === "describe") return ["nodes.describe", { nodeID: args[1] }];
      if (action === "pairs") return ["nodes.pair.list", { status: args[1] }];
      if (action === "approve") return ["nodes.pair.approve", { pairID: args[1] }];
      if (action === "reject") return ["nodes.pair.reject", { pairID: args[1] }];
      if (action === "invoke")
        return [
          "nodes.invoke",
          {
            nodeID: args[1],
            capability: args[2],
            args: args[3] ? JSON.parse(args[3]) : {},
            sessionID: args[4] ?? "main"
          }
        ];
    }
    if (top === "skills") {
      const action = args[0] ?? "status";
      if (action === "status") return ["skills.status", {}];
      if (action === "enable") return ["skills.enable", { skillID: args[1] }];
      if (action === "disable") return ["skills.disable", { skillID: args[1] }];
      if (action === "install")
        return [
          "skills.install",
          withPolicyHash({
            repo: args[1],
            targetName: args[2],
            sessionID: args[3] ?? "main"
          })
        ];
      if (action === "update")
        return [
          "skills.update",
          withPolicyHash({
            dir: args[1],
            sessionID: args[2] ?? "main"
          })
        ];
    }
    if (top === "sync") {
      const action = args[0] ?? "list";
      if (action === "list") return ["miya.sync.list", {}];
      if (action === "diff") return ["miya.sync.diff", { sourcePackID: args[1] }];
      if (action === "pull")
        return [
          "miya.sync.pull",
          withPolicyHash({
            sourcePackID: args[1],
            sessionID: args[2] ?? "main"
          })
        ];
      if (action === "apply")
        return [
          "miya.sync.apply",
          withPolicyHash({
            sourcePackID: args[1],
            revision: args[2],
            sessionID: args[3] ?? "main"
          })
        ];
      if (action === "rollback")
        return [
          "miya.sync.rollback",
          withPolicyHash({
            sourcePackID: args[1],
            sessionID: args[2] ?? "main"
          })
        ];
    }
    if (top === "cron") {
      const action = args[0] ?? "list";
      if (action === "list") return ["cron.list", {}];
      if (action === "runs") return ["cron.runs.list", { limit: Number(args[1] ?? 50) }];
      if (action === "add")
        return [
          "cron.add",
          {
            name: args[1],
            time: args[2],
            command: args[3],
            requireApproval: args[4] === "true"
          }
        ];
      if (action === "run") return ["cron.run.now", { jobID: args[1] }];
      if (action === "remove") return ["cron.remove", { jobID: args[1] }];
      if (action === "approvals") return ["cron.approvals.list", {}];
      if (action === "approve") return ["cron.approvals.approve", { approvalID: args[1] }];
      if (action === "reject") return ["cron.approvals.reject", { approvalID: args[1] }];
    }
    if (top === "voice") {
      const action = args[0] ?? "status";
      if (action === "status") return ["voice.status", {}];
      if (action === "wake-on") return ["voice.wake.enable", {}];
      if (action === "wake-off") return ["voice.wake.disable", {}];
      if (action === "talk-start") return ["voice.talk.start", { sessionID: args[1] }];
      if (action === "talk-stop") return ["voice.talk.stop", {}];
      if (action === "ingest")
        return [
          "voice.input.ingest",
          {
            text: args[1],
            mediaID: args[2],
            source: args[3] ?? "manual",
            sessionID: args[4] ?? "main"
          }
        ];
      if (action === "history") return ["voice.history.list", { limit: Number(args[1] ?? 50) }];
      if (action === "clear") return ["voice.history.clear", {}];
    }
    if (top === "canvas") {
      const action = args[0] ?? "status";
      if (action === "status") return ["canvas.status", {}];
      if (action === "list") return ["canvas.list", {}];
      if (action === "get") return ["canvas.get", { docID: args[1] }];
      if (action === "open")
        return [
          "canvas.open",
          {
            title: args[1],
            type: args[2] ?? "markdown",
            content: args[3] ?? ""
          }
        ];
      if (action === "render")
        return [
          "canvas.render",
          {
            docID: args[1],
            content: args[2],
            merge: args[3] === "true"
          }
        ];
      if (action === "close") return ["canvas.close", { docID: args[1] }];
    }
    if (top === "companion") {
      const action = args[0] ?? "status";
      if (action === "status") return ["companion.status", {}];
      if (action === "wizard") return ["companion.wizard.start", {}];
      if (action === "profile")
        return [
          "companion.profile.update",
          {
            name: args[1],
            relationship: args[2],
            persona: args[3],
            style: args[4],
            enabled: args[5] === "true"
          }
        ];
      if (action === "memory-add") return ["companion.memory.add", { fact: args[1] }];
      if (action === "memory-list") return ["companion.memory.list", {}];
      if (action === "asset-add")
        return [
          "companion.asset.add",
          {
            type: args[1],
            pathOrUrl: args[2],
            label: args[3]
          }
        ];
      if (action === "asset-list") return ["companion.asset.list", {}];
      if (action === "reset") return ["companion.reset", {}];
    }
    return null;
  })();
  if (!method) {
    throw new Error(`unknown_subcommand:${top}`);
  }
  const [methodName, params] = method;
  const result = await callGatewayMethod(url3, methodName, params);
  console.log(JSON.stringify(result, null, 2));
  return 0;
}
function readFlagValue(args, key) {
  const direct = args.find((item) => item.startsWith(`${key}=`));
  if (direct) return direct.slice(key.length + 1);
  const index = args.indexOf(key);
  if (index >= 0 && index < args.length - 1) {
    return args[index + 1];
  }
  return void 0;
}
async function runNodeHostCommand(cwd, args) {
  const gateway = readFlagValue(args, "--gateway") ?? await ensureGatewayUrl(cwd);
  const nodeID = readFlagValue(args, "--node-id");
  const deviceID = readFlagValue(args, "--device-id");
  const capabilitiesValue = readFlagValue(args, "--capabilities");
  const capabilities = capabilitiesValue ? capabilitiesValue.split(",").map((item) => item.trim()).filter(Boolean) : void 0;
  await runNodeHost({
    projectDir: cwd,
    gatewayUrl: gateway,
    nodeID,
    deviceID,
    capabilities
  });
  return 0;
}
async function main() {
  const args = process.argv.slice(2);
  const cwd = process.cwd();
  if (args.length === 0 || args[0] === "install") {
    const installArgs = parseInstallArgs(args.slice(args[0] === "install" ? 1 : 0));
    const exitCode = await install(installArgs);
    process.exit(exitCode);
  }
  if (args[0] === "-h" || args[0] === "--help") {
    printHelp();
    process.exit(0);
  }
  if (args[0] === "gateway") {
    const exitCode = await runGatewayCommand(cwd, args.slice(1));
    process.exit(exitCode);
  }
  if (args[0] === "node-host") {
    const exitCode = await runNodeHostCommand(cwd, args.slice(1));
    process.exit(exitCode);
  }
  const top = args[0];
  if (top === "sessions" || top === "channels" || top === "nodes" || top === "skills" || top === "sync" || top === "cron" || top === "voice" || top === "canvas" || top === "companion") {
    const exitCode = await runSubcommand(cwd, top, args.slice(1));
    process.exit(exitCode);
  }
  throw new Error(`unknown_command:${args[0]}`);
}
main().catch((error92) => {
  console.error(error92 instanceof Error ? error92.message : String(error92));
  process.exit(1);
});
