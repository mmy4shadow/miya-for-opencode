#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// src/config/constants.ts
var AGENT_ALIASES, SUBAGENT_NAMES, ORCHESTRATOR_NAME = "1-task-manager", CODE_SIMPLICITY_REVIEWER_NAME = "7-code-simplicity-reviewer", ALL_AGENT_NAMES, DEFAULT_MODELS, DEFAULT_TIMEOUT_MS, MAX_POLL_TIME_MS;
var init_constants = __esm(() => {
  AGENT_ALIASES = {
    orchestrator: "1-task-manager",
    explorer: "2-code-search",
    librarian: "3-docs-helper",
    oracle: "4-architecture-advisor",
    fixer: "5-code-fixer",
    designer: "6-ui-designer",
    "code-simplicity-reviewer": "7-code-simplicity-reviewer",
    simplicity_reviewer: "7-code-simplicity-reviewer",
    explore: "2-code-search",
    "frontend-ui-ux-engineer": "6-ui-designer",
    "4-code-fixer": "5-code-fixer",
    "5-ui-designer": "6-ui-designer",
    "6-architecture-advisor": "4-architecture-advisor"
  };
  SUBAGENT_NAMES = [
    "2-code-search",
    "3-docs-helper",
    "4-architecture-advisor",
    "5-code-fixer",
    "6-ui-designer"
  ];
  ALL_AGENT_NAMES = [
    ORCHESTRATOR_NAME,
    ...SUBAGENT_NAMES,
    CODE_SIMPLICITY_REVIEWER_NAME
  ];
  DEFAULT_MODELS = {
    "1-task-manager": "openrouter/moonshotai/kimi-k2.5",
    "2-code-search": "openrouter/moonshotai/kimi-k2.5",
    "3-docs-helper": "openrouter/moonshotai/kimi-k2.5",
    "4-architecture-advisor": "openrouter/moonshotai/kimi-k2.5",
    "5-code-fixer": "openrouter/z-ai/glm-5",
    "6-ui-designer": "openrouter/z-ai/glm-5",
    "7-code-simplicity-reviewer": "openrouter/z-ai/glm-5"
  };
  DEFAULT_TIMEOUT_MS = 2 * 60 * 1000;
  MAX_POLL_TIME_MS = 5 * 60 * 1000;
});

// src/workflow/state.ts
import * as fs from "node:fs";
import * as path from "node:path";
function getMiyaRuntimeDir(projectDir) {
  return path.join(projectDir, ".opencode", "miya");
}
function getLoopStatePath(projectDir) {
  return path.join(getMiyaRuntimeDir(projectDir), "loop-state.json");
}
function readStateFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return { sessions: {} };
  }
  try {
    const raw = fs.readFileSync(filePath, "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    return { sessions: parsed.sessions };
  } catch {
    return { sessions: {} };
  }
}
function getSessionState(projectDir, sessionID) {
  const filePath = getLoopStatePath(projectDir);
  const state = readStateFile(filePath);
  const current = state.sessions[sessionID];
  if (!current) {
    return { ...DEFAULT_STATE };
  }
  return {
    ...DEFAULT_STATE,
    ...current
  };
}
var DEFAULT_STATE;
var init_state = __esm(() => {
  DEFAULT_STATE = {
    loopEnabled: true,
    autoContinue: true,
    maxIterationsPerWindow: 8,
    iterationCompleted: 0,
    windowStartIteration: 0,
    awaitingConfirmation: false,
    strictQualityGate: false,
    lastDone: [],
    lastMissing: [],
    lastUnresolved: [],
    autoContinueIteration: -1,
    autoContinueAt: new Date(0).toISOString(),
    updatedAt: new Date(0).toISOString()
  };
});

// src/workflow/saves.ts
var init_saves = () => {};

// src/workflow/index.ts
var init_workflow = __esm(() => {
  init_state();
  init_saves();
});

// src/config/agent-model-persistence.ts
import * as fs2 from "node:fs";
import * as path2 from "node:path";
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function filePath(projectDir) {
  return path2.join(getMiyaRuntimeDir(projectDir), "agent-runtime.json");
}
function legacyFilePath(projectDir) {
  return path2.join(getMiyaRuntimeDir(projectDir), "agent-models.json");
}
function normalizeAgentName(name) {
  const trimmed = name.trim();
  if (!trimmed)
    return null;
  const canonical = AGENT_ALIASES[trimmed] ?? trimmed;
  return KNOWN_AGENT_NAMES.has(canonical) ? canonical : null;
}
function normalizeModelRef(value) {
  if (typeof value === "string") {
    const text = value.trim();
    const slash = text.indexOf("/");
    if (slash <= 0 || slash >= text.length - 1) {
      return null;
    }
    return text;
  }
  if (isObject(value)) {
    const providerID = String(value.providerID ?? "").trim();
    const modelID = String(value.modelID ?? "").trim();
    if (!providerID || !modelID)
      return null;
    return `${providerID}/${modelID}`;
  }
  return null;
}
function parsePersistedModel(value) {
  return normalizeModelRef(value) ?? (isObject(value) ? normalizeModelRef(value.model) : null);
}
function normalizeProviderID(value) {
  const text = String(value ?? "").trim();
  return text || undefined;
}
function normalizeStringValue(value) {
  const text = String(value ?? "").trim();
  return text || undefined;
}
function normalizeOptions(value) {
  if (!isObject(value))
    return;
  return JSON.parse(JSON.stringify(value));
}
function normalizeAgentRuntimeEntry(value) {
  if (!isObject(value))
    return null;
  const model = parsePersistedModel(value.model ?? value);
  const variant = normalizeStringValue(value.variant);
  const providerID = normalizeProviderID(value.providerID) ?? (model ? normalizeProviderID(model.split("/")[0]) : undefined);
  const options = normalizeOptions(value.options ?? value.providerOptions);
  const apiKey = normalizeStringValue(value.apiKey);
  const baseURL = normalizeStringValue(value.baseURL);
  if (!model && !variant && !providerID && !options && !apiKey && !baseURL) {
    return null;
  }
  return {
    model: model ?? undefined,
    variant,
    providerID,
    options,
    apiKey,
    baseURL,
    updatedAt: normalizeStringValue(value.updatedAt) ?? new Date().toISOString()
  };
}
function readLegacyModels(projectDir) {
  const file = legacyFilePath(projectDir);
  if (!fs2.existsSync(file))
    return {};
  try {
    const raw = fs2.readFileSync(file, "utf-8");
    const parsed = JSON.parse(raw);
    if (!isObject(parsed.agents))
      return {};
    const result = {};
    for (const [rawAgentName, rawModel] of Object.entries(parsed.agents)) {
      const agentName = normalizeAgentName(rawAgentName);
      const model = parsePersistedModel(rawModel);
      if (!agentName || !model)
        continue;
      result[agentName] = model;
    }
    return result;
  } catch {
    return {};
  }
}
function normalizeRuntimeState(projectDir, parsed) {
  if (!parsed || !isObject(parsed.agents)) {
    const legacy = readLegacyModels(projectDir);
    const agentsFromLegacy = {};
    for (const [agentName, model] of Object.entries(legacy)) {
      agentsFromLegacy[agentName] = {
        model,
        providerID: model.split("/")[0],
        updatedAt: new Date().toISOString()
      };
    }
    return {
      version: AGENT_RUNTIME_VERSION,
      revision: 0,
      updatedAt: new Date().toISOString(),
      agents: agentsFromLegacy
    };
  }
  const agents = {};
  for (const [rawAgentName, rawEntry] of Object.entries(parsed.agents)) {
    const agentName = normalizeAgentName(rawAgentName);
    if (!agentName)
      continue;
    const entry = normalizeAgentRuntimeEntry(rawEntry);
    if (!entry)
      continue;
    agents[agentName] = entry;
  }
  const activeAgentId = normalizeAgentName(String(parsed.activeAgentId ?? "")) ?? undefined;
  return {
    version: AGENT_RUNTIME_VERSION,
    revision: Number(parsed.revision ?? 0) || 0,
    updatedAt: normalizeStringValue(parsed.updatedAt) ?? new Date().toISOString(),
    activeAgentId,
    agents
  };
}
function readRuntimeState(projectDir) {
  const file = filePath(projectDir);
  if (!fs2.existsSync(file)) {
    const migrated = normalizeRuntimeState(projectDir, null);
    if (Object.keys(migrated.agents).length > 0 || fs2.existsSync(legacyFilePath(projectDir))) {
      const runtimeToWrite = {
        ...migrated,
        revision: migrated.revision > 0 ? migrated.revision : 1,
        updatedAt: new Date().toISOString()
      };
      writeRuntimeStateAtomic(projectDir, runtimeToWrite);
      return runtimeToWrite;
    }
    return migrated;
  }
  try {
    const raw = fs2.readFileSync(file, "utf-8");
    const parsed = JSON.parse(raw);
    return normalizeRuntimeState(projectDir, parsed);
  } catch {
    return normalizeRuntimeState(projectDir, null);
  }
}
function writeRuntimeStateAtomic(projectDir, runtime) {
  const file = filePath(projectDir);
  fs2.mkdirSync(path2.dirname(file), { recursive: true });
  const orderedAgents = Object.fromEntries(Object.keys(runtime.agents).sort((a, b) => a.localeCompare(b)).map((key) => [key, runtime.agents[key]]));
  const payload = {
    version: AGENT_RUNTIME_VERSION,
    revision: runtime.revision,
    updatedAt: runtime.updatedAt,
    activeAgentId: runtime.activeAgentId,
    agents: orderedAgents
  };
  const tmp = `${file}.tmp.${process.pid}.${Date.now()}`;
  fs2.writeFileSync(tmp, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
  fs2.renameSync(tmp, file);
}
function readPersistedAgentRuntime(projectDir) {
  const runtime = readRuntimeState(projectDir);
  return {
    activeAgentId: runtime.activeAgentId,
    revision: runtime.revision,
    agents: runtime.agents
  };
}
function normalizeSelectionInput(input) {
  const agentName = normalizeAgentName(input.agentName);
  if (!agentName)
    return null;
  const model = normalizeModelRef(input.model);
  const variant = normalizeStringValue(input.variant);
  const providerID = normalizeProviderID(input.providerID) ?? (model ? normalizeProviderID(model.split("/")[0]) : undefined);
  const options = normalizeOptions(input.options);
  const apiKey = normalizeStringValue(input.apiKey);
  const baseURL = normalizeStringValue(input.baseURL);
  const entryPatch = {};
  if (model)
    entryPatch.model = model;
  if (variant)
    entryPatch.variant = variant;
  if (providerID)
    entryPatch.providerID = providerID;
  if (options)
    entryPatch.options = options;
  if (apiKey)
    entryPatch.apiKey = apiKey;
  if (baseURL)
    entryPatch.baseURL = baseURL;
  const activeAgentId = normalizeAgentName(String(input.activeAgentId ?? "")) ?? undefined;
  if (Object.keys(entryPatch).length === 0 && !activeAgentId)
    return null;
  return {
    agentName,
    entryPatch,
    activeAgentId
  };
}
function persistAgentRuntimeSelection(projectDir, input) {
  const normalized = normalizeSelectionInput(input);
  if (!normalized)
    return false;
  for (let attempt = 0;attempt < MAX_WRITE_RETRIES; attempt += 1) {
    const base = readRuntimeState(projectDir);
    const currentEntry = base.agents[normalized.agentName];
    const mergedEntry = {
      ...currentEntry ?? {},
      ...normalized.entryPatch
    };
    const previousComparable = JSON.stringify({
      ...currentEntry ?? {},
      updatedAt: undefined
    });
    const nextComparable = JSON.stringify({
      ...mergedEntry,
      updatedAt: undefined
    });
    const nextEntry = {
      ...currentEntry ?? { updatedAt: new Date().toISOString() },
      ...normalized.entryPatch,
      updatedAt: new Date().toISOString()
    };
    const entryUnchanged = previousComparable === nextComparable;
    const activeUnchanged = normalized.activeAgentId === undefined || base.activeAgentId === normalized.activeAgentId;
    if (entryUnchanged && activeUnchanged) {
      return false;
    }
    const latest = readRuntimeState(projectDir);
    if (latest.revision !== base.revision) {
      continue;
    }
    const nextState = {
      ...latest,
      revision: latest.revision + 1,
      updatedAt: new Date().toISOString(),
      activeAgentId: normalized.activeAgentId ?? latest.activeAgentId,
      agents: {
        ...latest.agents,
        [normalized.agentName]: nextEntry
      }
    };
    writeRuntimeStateAtomic(projectDir, nextState);
    return true;
  }
  return false;
}
function removePersistedAgentRuntimeSelection(projectDir, agentName, options) {
  const canonicalAgentName = normalizeAgentName(agentName);
  if (!canonicalAgentName)
    return false;
  const requestedActiveAgentId = normalizeAgentName(String(options?.activeAgentId ?? "")) ?? undefined;
  for (let attempt = 0;attempt < MAX_WRITE_RETRIES; attempt += 1) {
    const base = readRuntimeState(projectDir);
    const hadEntry = Boolean(base.agents[canonicalAgentName]);
    const nextActiveAgentId = requestedActiveAgentId ?? (options?.clearActive && base.activeAgentId === canonicalAgentName ? undefined : base.activeAgentId);
    if (!hadEntry && nextActiveAgentId === base.activeAgentId) {
      return false;
    }
    const latest = readRuntimeState(projectDir);
    if (latest.revision !== base.revision) {
      continue;
    }
    const nextAgents = { ...latest.agents };
    delete nextAgents[canonicalAgentName];
    const nextState = {
      ...latest,
      revision: latest.revision + 1,
      updatedAt: new Date().toISOString(),
      activeAgentId: nextActiveAgentId,
      agents: nextAgents
    };
    writeRuntimeStateAtomic(projectDir, nextState);
    return true;
  }
  return false;
}
var KNOWN_AGENT_NAMES, AGENT_RUNTIME_VERSION = 1, MAX_WRITE_RETRIES = 4;
var init_agent_model_persistence = __esm(() => {
  init_workflow();
  init_constants();
  KNOWN_AGENT_NAMES = new Set(ALL_AGENT_NAMES);
});

// node_modules/zod/v4/core/core.js
function $constructor(name, initializer, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: new Set
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0;i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm(() => {
  NEVER = Object.freeze({
    status: "aborted"
  });
  $brand = Symbol("zod_brand");
  $ZodAsyncError = class $ZodAsyncError extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  $ZodEncodeError = class $ZodEncodeError extends Error {
    constructor(name) {
      super(`Encountered unidirectional transform during encode: ${name}`);
      this.name = "ZodEncodeError";
    }
  };
  globalConfig = {};
});

// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  slugify: () => slugify,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  parsedType: () => parsedType,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject2,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path3) {
  if (!path3)
    return obj;
  return path3.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path3, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path3);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES;
var init_util = __esm(() => {
  EVALUATING = Symbol("evaluating");
  captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
  allowsEval = cached(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  propertyKeyTypes = new Set(["string", "number", "symbol"]);
  primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
});

// node_modules/zod/v4/core/errors.js
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error2, path3 = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path3, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path3 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path3) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`✖ ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  → at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
}, $ZodError, $ZodRealError;
var init_errors = __esm(() => {
  init_core();
  init_util();
  $ZodError = $constructor("$ZodError", initializer);
  $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
});

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
}, parse, _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
}, parseAsync, _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
}, safeParse, _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
}, safeParseAsync, _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
}, encode, _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
}, decode, _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
}, encodeAsync, _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
}, decodeAsync, _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
}, safeEncode, _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
}, safeDecode, _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
}, safeEncodeAsync, _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
}, safeDecodeAsync;
var init_parse = __esm(() => {
  init_core();
  init_errors();
  init_util();
  parse = /* @__PURE__ */ _parse($ZodRealError);
  parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
  safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
  safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  encode = /* @__PURE__ */ _encode($ZodRealError);
  decode = /* @__PURE__ */ _decode($ZodRealError);
  encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
  decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
  safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
  safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
  safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
  safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
});

// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  mac: () => mac,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, ipv4, ipv6, mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`, date, string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm(() => {
  init_util();
  cuid = /^[cC][^\s-]{8,}$/;
  cuid2 = /^[0-9a-z]+$/;
  ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  xid = /^[0-9a-vA-V]{20}$/;
  ksuid = /^[A-Za-z0-9]{27}$/;
  nanoid = /^[a-zA-Z0-9_-]{21}$/;
  duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  uuid4 = /* @__PURE__ */ uuid(4);
  uuid6 = /* @__PURE__ */ uuid(6);
  uuid7 = /* @__PURE__ */ uuid(7);
  email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  idnEmail = unicodeEmail;
  browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
  cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  base64url = /^[A-Za-z0-9_-]*$/;
  hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  e164 = /^\+[1-9]\d{6,14}$/;
  date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
  bigint = /^-?\d+n?$/;
  integer = /^-?\d+$/;
  number = /^-?\d+(?:\.\d+)?$/;
  boolean = /^(?:true|false)$/i;
  _null = /^null$/i;
  _undefined = /^undefined$/i;
  lowercase = /^[^A-Z]*$/;
  uppercase = /^[^a-z]*$/;
  hex = /^[0-9a-fA-F]*$/;
  md5_hex = /^[0-9a-fA-F]{32}$/;
  md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
  md5_base64url = /* @__PURE__ */ fixedBase64url(22);
  sha1_hex = /^[0-9a-fA-F]{40}$/;
  sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
  sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
  sha256_hex = /^[0-9a-fA-F]{64}$/;
  sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
  sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
  sha384_hex = /^[0-9a-fA-F]{96}$/;
  sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
  sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
  sha512_hex = /^[0-9a-fA-F]{128}$/;
  sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
  sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm(() => {
  init_core();
  init_regexes();
  init_util();
  $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
    var _a;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a = inst._zod).onattach ?? (_a.onattach = []);
  });
  numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a;
      (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size)
        return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin(input),
        ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = new Set);
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a = inst._zod).check ?? (_a.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b = inst._zod).check ?? (_b.check = () => {});
  });
  $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run({
        value: payload.value[def.property],
        issues: []
      }, {});
      if (result instanceof Promise) {
        return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  });
  $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type))
        return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm(() => {
  version = {
    major: 4,
    minor: 3,
    patch: 6
  };
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = new Map;
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodXor, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodExactOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm(() => {
  init_checks();
  init_core();
  init_parse();
  init_regexes();
  init_util();
  init_versions();
  init_util();
  $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
    var _a;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version;
    const checks = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks.unshift(inst);
    }
    for (const ch of checks) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks.length === 0) {
      (_a = inst._zod).deferred ?? (_a.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks2, ctx) => {
        let isAborted = aborted(payload);
        let asyncResult;
        for (const ch of checks2) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError;
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      const handleCanaryResult = (canary, payload, ctx) => {
        if (aborted(canary)) {
          canary.aborted = true;
          return canary;
        }
        const checkResult = runChecks(payload, checks, ctx);
        if (checkResult instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError;
          return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
        }
        return inst._zod.parse(checkResult, ctx);
      };
      inst._zod.run = (payload, ctx) => {
        if (ctx.skipChecks) {
          return inst._zod.parse(payload, ctx);
        }
        if (ctx.direction === "backward") {
          const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
          if (canary instanceof Promise) {
            return canary.then((canary2) => {
              return handleCanaryResult(canary2, payload, ctx);
            });
          }
          return handleCanaryResult(canary, payload, ctx);
        }
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError;
          return result.then((result2) => runChecks(result2, checks, ctx));
        }
        return runChecks(result, checks, ctx);
      };
    }
    defineLazy(inst, "~standard", () => ({
      validate: (value) => {
        try {
          const r = safeParse(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    }));
  });
  $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {}
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
  });
  $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === undefined)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid(v));
    } else
      def.pattern ?? (def.pattern = uuid());
    $ZodStringFormat.init(inst, def);
  });
  $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
  });
  $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const trimmed = payload.value.trim();
        const url = new URL(trimmed);
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: def.hostname.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.normalize) {
          payload.value = url.href;
        } else {
          payload.value = trimmed;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
  });
  $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
  });
  $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime(def));
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date);
    $ZodStringFormat.init(inst, def);
  });
  $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time(def));
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration);
    $ZodStringFormat.init(inst, def);
  });
  $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv4`;
  });
  $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv6`;
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
    def.pattern ?? (def.pattern = mac(def.delimiter));
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `mac`;
  });
  $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      const parts = payload.value.split("/");
      try {
        if (parts.length !== 2)
          throw new Error;
        const [address, prefix] = parts;
        if (!prefix)
          throw new Error;
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error;
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error;
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64";
    inst._zod.check = (payload) => {
      if (isValidBase64(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64url";
    inst._zod.check = (payload) => {
      if (isValidBase64URL(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
  });
  $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def);
  });
  $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = bigint;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {}
      if (typeof payload.value === "bigint")
        return payload;
      payload.issues.push({
        expected: "bigint",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
    $ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def);
  });
  $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "symbol")
        return payload;
      payload.issues.push({
        expected: "symbol",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _undefined;
    inst._zod.values = new Set([undefined]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _null;
    inst._zod.values = new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "void",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {}
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate)
        return payload;
      payload.issues.push({
        expected: "date",
        code: "invalid_type",
        input,
        ...isDate ? { received: "Invalid Date" } : {},
        inst
      });
      return payload;
    };
  });
  $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0;i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
        } else {
          handleArrayResult(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
    $ZodType.init(inst, def);
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
      const sh = def.shape;
      Object.defineProperty(def, "shape", {
        get: () => {
          const newSh = { ...sh };
          Object.defineProperty(def, "shape", {
            value: newSh
          });
          return newSh;
        }
      });
    }
    const _normalized = cached(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = new Set);
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const isObject3 = isObject2;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = {};
      const proms = [];
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const isOptionalOut = el._zod.optout === "optional";
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
        } else {
          handlePropertyResult(r, payload, key, input, isOptionalOut);
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
  });
  $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
      const doc = new Doc(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id = ids[key];
        const k = esc(key);
        const schema = shape[key];
        const isOptionalOut = schema?._zod?.optout === "optional";
        doc.write(`const ${id} = ${parseStr(key)};`);
        if (isOptionalOut) {
          doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        } else {
          doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject3 = isObject2;
    const jit = !globalConfig.jitless;
    const allowsEval2 = allowsEval;
    const fastEnabled = jit && allowsEval2.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall)
          return payload;
        return handleCatchall([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  });
  $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return;
    });
    defineLazy(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
      }
      return;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
    $ZodUnion.init(inst, def);
    def.inclusive = false;
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          results.push(result);
        }
      }
      if (!async)
        return handleExclusiveUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleExclusiveUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
    def.inclusive = false;
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = new Set;
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached(() => {
      const opts = def.options;
      const map = new Map;
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map.set(v, o);
        }
      }
      return map;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults(payload, left2, right2);
        });
      }
      return handleIntersectionResults(payload, left, right);
    };
  });
  $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: "tuple",
          code: "invalid_type"
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
            input,
            inst,
            origin: "array"
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) {
          if (i >= optStart)
            continue;
        }
        const result = item._zod.run({
          value: input[i],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run({
            value: el,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      const values = def.keyType._zod.values;
      if (values) {
        payload.value = {};
        const recordKeys = new Set;
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            recordKeys.add(typeof key === "number" ? key.toString() : key);
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!recordKeys.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
          if (checkNumericKey) {
            const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
            if (retryResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (retryResult.issues.length === 0) {
              keyResult = retryResult;
            }
          }
          if (keyResult.issues.length) {
            if (def.mode === "loose") {
              payload.value[key] = input[key];
            } else {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key,
                path: [key],
                inst
              });
            }
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: "map",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      payload.value = new Map;
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
            handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
          }));
        } else {
          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: "set",
          code: "invalid_type"
        });
        return payload;
      }
      const proms = [];
      payload.value = new Set;
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleSetResult(result2, payload)));
        } else
          handleSetResult(result, payload);
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (valuesSet.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
      throw new Error("Cannot create literal schema with no valid values");
    }
    const values = new Set(def.values);
    inst._zod.values = values;
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input instanceof File)
        return payload;
      payload.issues.push({
        expected: "file",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError;
      }
      payload.value = _out;
      return payload;
    };
  });
  $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r) => handleOptionalResult(r, payload.value));
        return handleOptionalResult(result, payload.value);
      }
      if (payload.value === undefined) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
    inst._zod.parse = (payload, ctx) => {
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
    });
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult(result2, def));
      }
      return handleDefaultResult(result, def);
    };
  });
  $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult(result2, inst));
      }
      return handleNonOptionalResult(result, inst);
    };
  });
  $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError("ZodSuccess");
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
  $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "nan",
          code: "invalid_type"
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handlePipeResult(right2, def.in, ctx));
        }
        return handlePipeResult(right, def.in, ctx);
      }
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult(left2, def.out, ctx));
      }
      return handlePipeResult(left, def.out, ctx);
    };
  });
  $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handleCodecAResult(left2, def, ctx));
        }
        return handleCodecAResult(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handleCodecAResult(right2, def, ctx));
        }
        return handleCodecAResult(right, def, ctx);
      }
    };
  });
  $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
    defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult);
      }
      return handleReadonlyResult(result);
    };
  });
  $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes.has(typeof part)) {
        regexParts.push(escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "string",
          code: "invalid_type"
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
      if (typeof func !== "function") {
        throw new Error("implement() must be called with a function");
      }
      return function(...args) {
        const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = (func) => {
      if (typeof func !== "function") {
        throw new Error("implementAsync() must be called with a function");
      }
      return async function(...args) {
        const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "function") {
        payload.issues.push({
          code: "invalid_type",
          expected: "function",
          input: payload.value,
          inst
        });
        return payload;
      }
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: "function",
          input: new $ZodTuple({
            type: "tuple",
            items: args[0],
            rest: args[1]
          }),
          output: inst._def.output
        });
      }
      return new F({
        type: "function",
        input: args[0],
        output: inst._def.output
      });
    };
    inst.output = (output) => {
      const F = inst.constructor;
      return new F({
        type: "function",
        input: inst._def.input,
        output
      });
    };
    return inst;
  });
  $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
  $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "innerType", () => def.getter());
    defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
    defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
    defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);
    defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
  $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult(r2, payload, input, inst));
      }
      handleRefineResult(r, payload, input, inst);
      return;
    };
  });
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error = () => {
  const Sizable = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `مدخلات غير مقبولة: يفترض إدخال instanceof ${issue2.expected}، ولكن تم إدخال ${received}`;
        }
        return `مدخلات غير مقبولة: يفترض إدخال ${expected}، ولكن تم إدخال ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `مدخلات غير مقبولة: يفترض إدخال ${stringifyPrimitive(issue2.values[0])}`;
        return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
        return `أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `نَص غير مقبول: يجب أن يبدأ بـ "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue2.divisor}`;
      case "unrecognized_keys":
        return `معرف${issue2.keys.length > 1 ? "ات" : ""} غريب${issue2.keys.length > 1 ? "ة" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${issue2.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${issue2.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
var init_ar = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanlış dəyər: gözlənilən instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanlış dəyər: gözlənilən ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanlış dəyər: gözlənilən ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
        if (_issue.format === "ends_with")
          return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
        if (_issue.format === "includes")
          return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
        if (_issue.format === "regex")
          return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
        return `Yanlış ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${issue2.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${issue2.origin} daxilində yanlış dəyər`;
      default:
        return `Yanlış dəyər`;
    }
  };
};
var init_az = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "лік",
    array: "масіў"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Няправільны ўвод: чакаўся instanceof ${issue2.expected}, атрымана ${received}`;
        }
        return `Няправільны ўвод: чакаўся ${expected}, атрымана ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Няправільны ўвод: чакалася ${stringifyPrimitive(issue2.values[0])}`;
        return `Няправільны варыянт: чакаўся адзін з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна быць ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта малы: чакалася, што ${issue2.origin} павінна ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Занадта малы: чакалася, што ${issue2.origin} павінна быць ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
        return `Няправільны ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${issue2.keys.length > 1 ? "ключы" : "ключ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${issue2.origin}`;
      default:
        return `Няправільны ўвод`;
    }
  };
};
var init_be = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error4()
  };
}
var error4 = () => {
  const Sizable = {
    string: { unit: "символа", verb: "да съдържа" },
    file: { unit: "байта", verb: "да съдържа" },
    array: { unit: "елемента", verb: "да съдържа" },
    set: { unit: "елемента", verb: "да съдържа" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "вход",
    email: "имейл адрес",
    url: "URL",
    emoji: "емоджи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO време",
    date: "ISO дата",
    time: "ISO време",
    duration: "ISO продължителност",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "base64-кодиран низ",
    base64url: "base64url-кодиран низ",
    json_string: "JSON низ",
    e164: "E.164 номер",
    jwt: "JWT",
    template_literal: "вход"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "число",
    array: "масив"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Невалиден вход: очакван instanceof ${issue2.expected}, получен ${received}`;
        }
        return `Невалиден вход: очакван ${expected}, получен ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Невалиден вход: очакван ${stringifyPrimitive(issue2.values[0])}`;
        return `Невалидна опция: очаквано едно от ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Твърде голямо: очаква се ${issue2.origin ?? "стойност"} да съдържа ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елемента"}`;
        return `Твърде голямо: очаква се ${issue2.origin ?? "стойност"} да бъде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Твърде малко: очаква се ${issue2.origin} да съдържа ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Твърде малко: очаква се ${issue2.origin} да бъде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Невалиден низ: трябва да започва с "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Невалиден низ: трябва да завършва с "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Невалиден низ: трябва да включва "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Невалиден низ: трябва да съвпада с ${_issue.pattern}`;
        let invalid_adj = "Невалиден";
        if (_issue.format === "emoji")
          invalid_adj = "Невалидно";
        if (_issue.format === "datetime")
          invalid_adj = "Невалидно";
        if (_issue.format === "date")
          invalid_adj = "Невалидна";
        if (_issue.format === "time")
          invalid_adj = "Невалидно";
        if (_issue.format === "duration")
          invalid_adj = "Невалидна";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Невалидно число: трябва да бъде кратно на ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Неразпознат${issue2.keys.length > 1 ? "и" : ""} ключ${issue2.keys.length > 1 ? "ове" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Невалиден ключ в ${issue2.origin}`;
      case "invalid_union":
        return "Невалиден вход";
      case "invalid_element":
        return `Невалидна стойност в ${issue2.origin}`;
      default:
        return `Невалиден вход`;
    }
  };
};
var init_bg = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error5()
  };
}
var error5 = () => {
  const Sizable = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus invàlid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus invàlid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invàlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opció invàlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a màxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingués ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mínim" : "més de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingués ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invàlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
        return `Format invàlid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      case "invalid_element":
        return `Element invàlid a ${issue2.origin}`;
      default:
        return `Entrada invàlida`;
    }
  };
};
var init_ca = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error6()
  };
}
var error6 = () => {
  const Sizable = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "číslo",
    string: "řetězec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatný vstup: očekáváno instanceof ${issue2.expected}, obdrženo ${received}`;
        }
        return `Neplatný vstup: očekáváno ${expected}, obdrženo ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatný vstup: očekáváno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatná možnost: očekávána jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
        return `Neplatný formát ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${issue2.origin}`;
      default:
        return `Neplatný vstup`;
    }
  };
};
var init_cs = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error7()
  };
}
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslæt",
    date: "ISO-dato",
    time: "ISO-klokkeslæt",
    duration: "ISO-varighed",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "sæt",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig værdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af følgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal være deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøgle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig værdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
var init_da = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error8()
  };
}
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ungültige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ungültige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungültige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungültige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungültiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungültig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${issue2.origin}`;
      default:
        return `Ungültige Eingabe`;
    }
  };
};
var init_de = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error9()
  };
}
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
var init_en = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error10()
  };
}
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendiĝis instanceof ${issue2.expected}, riceviĝis ${received}`;
        }
        return `Nevalida enigo: atendiĝis ${expected}, riceviĝis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiĝis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiĝis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiĝis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiĝis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciĝi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiĝi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} ŝlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
var init_eo = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error11()
  };
}
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "número",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "número grande",
    symbol: "símbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "función",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeración",
    union: "unión",
    literal: "literal",
    promise: "promesa",
    void: "vacío",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inválida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inválida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opción inválida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado pequeño: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeño: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inválida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
        return `Inválido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inválida`;
    }
  };
};
var init_es = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error12()
  };
}
var error12 = () => {
  const Sizable = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "عدد",
    array: "آرایه"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `ورودی نامعتبر: می‌بایست instanceof ${issue2.expected} می‌بود، ${received} دریافت شد`;
        }
        return `ورودی نامعتبر: می‌بایست ${expected} می‌بود، ${received} دریافت شد`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ورودی نامعتبر: می‌بایست ${stringifyPrimitive(issue2.values[0])} می‌بود`;
        }
        return `گزینه نامعتبر: می‌بایست یکی از ${joinValues(issue2.values, "|")} می‌بود`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
        }
        return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} باشد`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} باشد`;
        }
        return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
        }
        if (_issue.format === "ends_with") {
          return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
        }
        if (_issue.format === "includes") {
          return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
        }
        if (_issue.format === "regex") {
          return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${issue2.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${issue2.keys.length > 1 ? "های" : ""} ناشناس: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${issue2.origin}`;
      case "invalid_union":
        return `ورودی نامعتبر`;
      case "invalid_element":
        return `مقدار نامعتبر در ${issue2.origin}`;
      default:
        return `ورودی نامعتبر`;
    }
  };
};
var init_fa = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error13()
  };
}
var error13 = () => {
  const Sizable = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syöte: täytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: täytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon täytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon täytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syöte`;
    }
  };
};
var init_fi = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error14()
  };
}
var error14 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrée invalide : instanceof ${issue2.expected} attendu, ${received} reçu`;
        }
        return `Entrée invalide : ${expected} attendu, ${received} reçu`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit être ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit être ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
var init_fr = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
var error15 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrée invalide : attendu instanceof ${issue2.expected}, reçu ${received}`;
        }
        return `Entrée invalide : attendu ${expected}, reçu ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "≤" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "≥" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
var init_fr_CA = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error16()
  };
}
var error16 = () => {
  const TypeNames = {
    string: { label: "מחרוזת", gender: "f" },
    number: { label: "מספר", gender: "m" },
    boolean: { label: "ערך בוליאני", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "תאריך", gender: "m" },
    array: { label: "מערך", gender: "m" },
    object: { label: "אובייקט", gender: "m" },
    null: { label: "ערך ריק (null)", gender: "m" },
    undefined: { label: "ערך לא מוגדר (undefined)", gender: "m" },
    symbol: { label: "סימבול (Symbol)", gender: "m" },
    function: { label: "פונקציה", gender: "f" },
    map: { label: "מפה (Map)", gender: "f" },
    set: { label: "קבוצה (Set)", gender: "f" },
    file: { label: "קובץ", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "ערך לא ידוע", gender: "m" },
    value: { label: "ערך", gender: "m" }
  };
  const Sizable = {
    string: { unit: "תווים", shortLabel: "קצר", longLabel: "ארוך" },
    file: { unit: "בייטים", shortLabel: "קטן", longLabel: "גדול" },
    array: { unit: "פריטים", shortLabel: "קטן", longLabel: "גדול" },
    set: { unit: "פריטים", shortLabel: "קטן", longLabel: "גדול" },
    number: { unit: "", shortLabel: "קטן", longLabel: "גדול" }
  };
  const typeEntry = (t) => t ? TypeNames[t] : undefined;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `ה${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "צריכה להיות" : "צריך להיות";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "קלט", gender: "m" },
    email: { label: "כתובת אימייל", gender: "f" },
    url: { label: "כתובת רשת", gender: "f" },
    emoji: { label: "אימוג'י", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "תאריך וזמן ISO", gender: "m" },
    date: { label: "תאריך ISO", gender: "m" },
    time: { label: "זמן ISO", gender: "m" },
    duration: { label: "משך זמן ISO", gender: "m" },
    ipv4: { label: "כתובת IPv4", gender: "f" },
    ipv6: { label: "כתובת IPv6", gender: "f" },
    cidrv4: { label: "טווח IPv4", gender: "m" },
    cidrv6: { label: "טווח IPv6", gender: "m" },
    base64: { label: "מחרוזת בבסיס 64", gender: "f" },
    base64url: { label: "מחרוזת בבסיס 64 לכתובות רשת", gender: "f" },
    json_string: { label: "מחרוזת JSON", gender: "f" },
    e164: { label: "מספר E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "קלט", gender: "m" },
    includes: { label: "קלט", gender: "m" },
    lowercase: { label: "קלט", gender: "m" },
    starts_with: { label: "קלט", gender: "m" },
    uppercase: { label: "קלט", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `קלט לא תקין: צריך להיות instanceof ${issue2.expected}, התקבל ${received}`;
        }
        return `קלט לא תקין: צריך להיות ${expected}, התקבל ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `ערך לא תקין: הערך חייב להיות ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `ערך לא תקין: האפשרויות המתאימות הן ${stringified[0]} או ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `ערך לא תקין: האפשרויות המתאימות הן ${restValues} או ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "ארוך"} מדי: ${subject} צריכה להכיל ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "או פחות" : "לכל היותר"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `קטן או שווה ל-${issue2.maximum}` : `קטן מ-${issue2.maximum}`;
          return `גדול מדי: ${subject} צריך להיות ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "צריכה" : "צריך";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} או פחות` : `פחות מ-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `גדול מדי: ${subject} ${verb} להכיל ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} מדי: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "גדול"} מדי: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "קצר"} מדי: ${subject} צריכה להכיל ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "או יותר" : "לפחות"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `גדול או שווה ל-${issue2.minimum}` : `גדול מ-${issue2.minimum}`;
          return `קטן מדי: ${subject} צריך להיות ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "צריכה" : "צריך";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "לפחות פריט אחד" : "לפחות פריט אחד";
            return `קטן מדי: ${subject} ${verb} להכיל ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} או יותר` : `יותר מ-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `קטן מדי: ${subject} ${verb} להכיל ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} מדי: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "קטן"} מדי: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `המחרוזת חייבת להתחיל ב "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `המחרוזת חייבת להסתיים ב "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `המחרוזת חייבת לכלול "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `המחרוזת חייבת להתאים לתבנית ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "תקינה" : "תקין";
        return `${noun} לא ${adjective}`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${issue2.divisor}`;
      case "unrecognized_keys":
        return `מפתח${issue2.keys.length > 1 ? "ות" : ""} לא מזוה${issue2.keys.length > 1 ? "ים" : "ה"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `שדה לא תקין באובייקט`;
      }
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `ערך לא תקין ב${place}`;
      }
      default:
        return `קלט לא תקין`;
    }
  };
};
var init_he = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error17()
  };
}
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "szám",
    array: "tömb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Érvénytelen bemenet: a várt érték instanceof ${issue2.expected}, a kapott érték ${received}`;
        }
        return `Érvénytelen bemenet: a várt érték ${expected}, a kapott érték ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Érvénytelen bemenet: a várt érték ${stringifyPrimitive(issue2.values[0])}`;
        return `Érvénytelen opció: valamelyik érték várt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Túl nagy: ${issue2.origin ?? "érték"} mérete túl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Túl nagy: a bemeneti érték ${issue2.origin ?? "érték"} túl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Túl kicsi: a bemeneti érték ${issue2.origin} mérete túl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Túl kicsi: a bemeneti érték ${issue2.origin} túl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
        if (_issue.format === "ends_with")
          return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
        if (_issue.format === "includes")
          return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
        return `Érvénytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${issue2.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${issue2.origin}`;
      default:
        return `Érvénytelen bemenet`;
    }
  };
};
var init_hu = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["ա", "ե", "ը", "ի", "ո", "ու", "օ"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "ն" : "ը");
}
function hy_default() {
  return {
    localeError: error18()
  };
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "նշան",
        many: "նշաններ"
      },
      verb: "ունենալ"
    },
    file: {
      unit: {
        one: "բայթ",
        many: "բայթեր"
      },
      verb: "ունենալ"
    },
    array: {
      unit: {
        one: "տարր",
        many: "տարրեր"
      },
      verb: "ունենալ"
    },
    set: {
      unit: {
        one: "տարր",
        many: "տարրեր"
      },
      verb: "ունենալ"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "մուտք",
    email: "էլ. հասցե",
    url: "URL",
    emoji: "էմոջի",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ամսաթիվ և ժամ",
    date: "ISO ամսաթիվ",
    time: "ISO ժամ",
    duration: "ISO տևողություն",
    ipv4: "IPv4 հասցե",
    ipv6: "IPv6 հասցե",
    cidrv4: "IPv4 միջակայք",
    cidrv6: "IPv6 միջակայք",
    base64: "base64 ձևաչափով տող",
    base64url: "base64url ձևաչափով տող",
    json_string: "JSON տող",
    e164: "E.164 համար",
    jwt: "JWT",
    template_literal: "մուտք"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "թիվ",
    array: "զանգված"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Սխալ մուտքագրում․ սպասվում էր instanceof ${issue2.expected}, ստացվել է ${received}`;
        }
        return `Սխալ մուտքագրում․ սպասվում էր ${expected}, ստացվել է ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Սխալ մուտքագրում․ սպասվում էր ${stringifyPrimitive(issue2.values[1])}`;
        return `Սխալ տարբերակ․ սպասվում էր հետևյալներից մեկը՝ ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `Չափազանց մեծ արժեք․ սպասվում է, որ ${withDefiniteArticle(issue2.origin ?? "արժեք")} կունենա ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Չափազանց մեծ արժեք․ սպասվում է, որ ${withDefiniteArticle(issue2.origin ?? "արժեք")} լինի ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `Չափազանց փոքր արժեք․ սպասվում է, որ ${withDefiniteArticle(issue2.origin)} կունենա ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Չափազանց փոքր արժեք․ սպասվում է, որ ${withDefiniteArticle(issue2.origin)} լինի ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Սխալ տող․ պետք է սկսվի "${_issue.prefix}"-ով`;
        if (_issue.format === "ends_with")
          return `Սխալ տող․ պետք է ավարտվի "${_issue.suffix}"-ով`;
        if (_issue.format === "includes")
          return `Սխալ տող․ պետք է պարունակի "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Սխալ տող․ պետք է համապատասխանի ${_issue.pattern} ձևաչափին`;
        return `Սխալ ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Սխալ թիվ․ պետք է բազմապատիկ լինի ${issue2.divisor}-ի`;
      case "unrecognized_keys":
        return `Չճանաչված բանալի${issue2.keys.length > 1 ? "ներ" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Սխալ բանալի ${withDefiniteArticle(issue2.origin)}-ում`;
      case "invalid_union":
        return "Սխալ մուտքագրում";
      case "invalid_element":
        return `Սխալ արժեք ${withDefiniteArticle(issue2.origin)}-ում`;
      default:
        return `Սխալ մուտքագրում`;
    }
  };
};
var init_hy = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error19()
  };
}
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
var init_id = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error20()
  };
}
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "að hafa" },
    file: { unit: "bæti", verb: "að hafa" },
    array: { unit: "hluti", verb: "að hafa" },
    set: { unit: "hluti", verb: "að hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefslóð",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tími",
    date: "ISO dagsetning",
    time: "ISO tími",
    duration: "ISO tímalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tölugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "númer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: Þú slóst inn ${received} þar sem á að vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: Þú slóst inn ${received} þar sem á að vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert ráð fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `Ógilt val: má vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of stórt: gert er ráð fyrir að ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of stórt: gert er ráð fyrir að ${issue2.origin ?? "gildi"} sé ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of lítið: gert er ráð fyrir að ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lítið: gert er ráð fyrir að ${issue2.origin} sé ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ógildur strengur: verður að byrja á "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ógildur strengur: verður að enda á "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ógildur strengur: verður að innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ógildur strengur: verður að fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Röng tala: verður að vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Óþekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill í ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi í ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
var init_is = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error21()
  };
}
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
var init_it = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error22()
  };
}
var error22 = () => {
  const Sizable = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "数値",
    array: "配列"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `無効な入力: instanceof ${issue2.expected}が期待されましたが、${received}が入力されました`;
        }
        return `無効な入力: ${expected}が期待されましたが、${received}が入力されました`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無効な入力: ${stringifyPrimitive(issue2.values[0])}が期待されました`;
        return `無効な選択: ${joinValues(issue2.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const adj = issue2.inclusive ? "以下である" : "より小さい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${sizing.unit ?? "要素"}${adj}必要があります`;
        return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${adj}必要があります`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "以上である" : "より大きい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${sizing.unit}${adj}必要があります`;
        return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${adj}必要があります`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
        if (_issue.format === "ends_with")
          return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
        if (_issue.format === "includes")
          return `無効な文字列: "${_issue.includes}"を含む必要があります`;
        if (_issue.format === "regex")
          return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
        return `無効な${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${issue2.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${issue2.keys.length > 1 ? "群" : ""}: ${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${issue2.origin}内の無効な値`;
      default:
        return `無効な入力`;
    }
  };
};
var init_ja = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error23()
  };
}
var error23 = () => {
  const Sizable = {
    string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" },
    file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" },
    array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" },
    set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "შეყვანა",
    email: "ელ-ფოსტის მისამართი",
    url: "URL",
    emoji: "ემოჯი",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "თარიღი-დრო",
    date: "თარიღი",
    time: "დრო",
    duration: "ხანგრძლივობა",
    ipv4: "IPv4 მისამართი",
    ipv6: "IPv6 მისამართი",
    cidrv4: "IPv4 დიაპაზონი",
    cidrv6: "IPv6 დიაპაზონი",
    base64: "base64-კოდირებული სტრინგი",
    base64url: "base64url-კოდირებული სტრინგი",
    json_string: "JSON სტრინგი",
    e164: "E.164 ნომერი",
    jwt: "JWT",
    template_literal: "შეყვანა"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "რიცხვი",
    string: "სტრინგი",
    boolean: "ბულეანი",
    function: "ფუნქცია",
    array: "მასივი"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `არასწორი შეყვანა: მოსალოდნელი instanceof ${issue2.expected}, მიღებული ${received}`;
        }
        return `არასწორი შეყვანა: მოსალოდნელი ${expected}, მიღებული ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `არასწორი შეყვანა: მოსალოდნელი ${stringifyPrimitive(issue2.values[0])}`;
        return `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${joinValues(issue2.values, "|")}-დან`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ზედმეტად დიდი: მოსალოდნელი ${issue2.origin ?? "მნიშვნელობა"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `ზედმეტად დიდი: მოსალოდნელი ${issue2.origin ?? "მნიშვნელობა"} იყოს ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ზედმეტად პატარა: მოსალოდნელი ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `ზედმეტად პატარა: მოსალოდნელი ${issue2.origin} იყოს ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `არასწორი სტრინგი: უნდა იწყებოდეს "${_issue.prefix}"-ით`;
        }
        if (_issue.format === "ends_with")
          return `არასწორი სტრინგი: უნდა მთავრდებოდეს "${_issue.suffix}"-ით`;
        if (_issue.format === "includes")
          return `არასწორი სტრინგი: უნდა შეიცავდეს "${_issue.includes}"-ს`;
        if (_issue.format === "regex")
          return `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${_issue.pattern}`;
        return `არასწორი ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `არასწორი რიცხვი: უნდა იყოს ${issue2.divisor}-ის ჯერადი`;
      case "unrecognized_keys":
        return `უცნობი გასაღებ${issue2.keys.length > 1 ? "ები" : "ი"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `არასწორი გასაღები ${issue2.origin}-ში`;
      case "invalid_union":
        return "არასწორი შეყვანა";
      case "invalid_element":
        return `არასწორი მნიშვნელობა ${issue2.origin}-ში`;
      default:
        return `არასწორი შეყვანა`;
    }
  };
};
var init_ka = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error24()
  };
}
var error24 = () => {
  const Sizable = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "លេខ",
    array: "អារេ (Array)",
    null: "គ្មានតម្លៃ (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ instanceof ${issue2.expected} ប៉ុន្តែទទួលបាន ${received}`;
        }
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${expected} ប៉ុន្តែទទួលបាន ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${stringifyPrimitive(issue2.values[0])}`;
        return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "ធាតុ"}`;
        return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;
        return `មិនត្រឹមត្រូវ៖ ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue2.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      case "invalid_union":
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      default:
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
    }
  };
};
var init_km = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm(() => {
  init_km();
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error25()
  };
}
var error25 = () => {
  const Sizable = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `잘못된 입력: 예상 타입은 instanceof ${issue2.expected}, 받은 타입은 ${received}입니다`;
        }
        return `잘못된 입력: 예상 타입은 ${expected}, 받은 타입은 ${received}입니다`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `잘못된 입력: 값은 ${stringifyPrimitive(issue2.values[0])} 이어야 합니다`;
        return `잘못된 옵션: ${joinValues(issue2.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const adj = issue2.inclusive ? "이하" : "미만";
        const suffix = adj === "미만" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing)
          return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "이상" : "초과";
        const suffix = adj === "이상" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing) {
          return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
        }
        if (_issue.format === "ends_with")
          return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
        if (_issue.format === "includes")
          return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
        if (_issue.format === "regex")
          return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
        return `잘못된 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${issue2.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${issue2.origin}`;
      case "invalid_union":
        return `잘못된 입력`;
      case "invalid_element":
        return `잘못된 값: ${issue2.origin}`;
      default:
        return `잘못된 입력`;
    }
  };
};
var init_ko = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error26()
  };
}
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
}, error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simbolių"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne ilgesnė kaip",
          notInclusive: "turi būti trumpesnė kaip"
        },
        bigger: {
          inclusive: "turi būti ne trumpesnė kaip",
          notInclusive: "turi būti ilgesnė kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "baitų"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne didesnis kaip",
          notInclusive: "turi būti mažesnis kaip"
        },
        bigger: {
          inclusive: "turi būti ne mažesnis kaip",
          notInclusive: "turi būti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "įvestis",
    email: "el. pašto adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukmė",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 užkoduota eilutė",
    base64url: "base64url užkoduota eilutė",
    json_string: "JSON eilutė",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "įvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skaičius",
    bigint: "sveikasis skaičius",
    string: "eilutė",
    boolean: "loginė reikšmė",
    undefined: "neapibrėžta reikšmė",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulinė reikšmė"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tikėtasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tikėtasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo būti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo būti vienas iš ${joinValues(issue2.values, "|")} pasirinkimų`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "mažesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi būti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue2.inclusive ? "ne mažesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi būti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilutė privalo prasidėti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilutė privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilutė privalo įtraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilutė privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaičius privalo būti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpažint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga įvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi klaidingą įvestį`;
      }
      default:
        return "Klaidinga įvestis";
    }
  };
};
var init_lt = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error27()
  };
}
var error27 = () => {
  const Sizable = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "број",
    array: "низа"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Грешен внес: се очекува instanceof ${issue2.expected}, примено ${received}`;
        }
        return `Грешен внес: се очекува ${expected}, примено ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Грешана опција: се очекува една ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да има ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементи"}`;
        return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да биде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Премногу мал: се очекува ${issue2.origin} да има ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Премногу мал: се очекува ${issue2.origin} да биде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${issue2.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${issue2.origin}`;
      default:
        return `Грешен внес`;
    }
  };
};
var init_mk = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error28()
  };
}
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
var init_ms = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error29()
  };
}
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht één van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
var init_nl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error30()
  };
}
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: må starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: må ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: må inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
var init_no = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error31()
  };
}
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Fâsit giren: umulan instanceof ${issue2.expected}, alınan ${received}`;
        }
        return `Fâsit giren: umulan ${expected}, alınan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fâsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fâsit tercih: mûteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
        return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
        }
        return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
        if (_issue.format === "ends_with")
          return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
        if (_issue.format === "regex")
          return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
        return `Fâsit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${issue2.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${issue2.origin} için tanınmayan kıymet var.`;
      default:
        return `Kıymet tanınamadı.`;
    }
  };
};
var init_ota = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error32()
  };
}
var error32 = () => {
  const Sizable = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "عدد",
    array: "ارې"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `ناسم ورودي: باید instanceof ${issue2.expected} وای, مګر ${received} ترلاسه شو`;
        }
        return `ناسم ورودي: باید ${expected} وای, مګر ${received} ترلاسه شو`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ناسم ورودي: باید ${stringifyPrimitive(issue2.values[0])} وای`;
        }
        return `ناسم انتخاب: باید یو له ${joinValues(issue2.values, "|")} څخه وای`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصرونه"} ولري`;
        }
        return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} وي`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} ولري`;
        }
        return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ناسم متن: باید د "${_issue.prefix}" سره پیل شي`;
        }
        if (_issue.format === "ends_with") {
          return `ناسم متن: باید د "${_issue.suffix}" سره پای ته ورسيږي`;
        }
        if (_issue.format === "includes") {
          return `ناسم متن: باید "${_issue.includes}" ولري`;
        }
        if (_issue.format === "regex") {
          return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${issue2.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${issue2.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${issue2.origin} کې`;
      case "invalid_union":
        return `ناسمه ورودي`;
      case "invalid_element":
        return `ناسم عنصر په ${issue2.origin} کې`;
      default:
        return `ناسمه ورودي`;
    }
  };
};
var init_ps = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error33()
  };
}
var error33 = () => {
  const Sizable = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawidłowe dane wejściowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawidłowe dane wejściowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidłowe dane wejściowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za duża wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt duż(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za mała wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt mał(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
        return `Nieprawidłow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${issue2.origin}`;
      default:
        return `Nieprawidłowe dane wejściowe`;
    }
  };
};
var init_pl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error34()
  };
}
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "número",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inválido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inválido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opção inválida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inválido: deve começar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inválido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inválido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${issue2.origin}`;
      default:
        return `Campo inválido`;
    }
  };
};
var init_pt = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error35()
  };
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "число",
    array: "массив"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Неверный ввод: ожидалось instanceof ${issue2.expected}, получено ${received}`;
        }
        return `Неверный ввод: ожидалось ${expected}, получено ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неверный ввод: ожидалось ${stringifyPrimitive(issue2.values[0])}`;
        return `Неверный вариант: ожидалось одно из ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет иметь ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет иметь ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неверная строка: должна содержать "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
        return `Неверный ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${issue2.keys.length > 1 ? "ые" : "ый"} ключ${issue2.keys.length > 1 ? "и" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${issue2.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${issue2.origin}`;
      default:
        return `Неверные входные данные`;
    }
  };
};
var init_ru = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error36()
  };
}
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "število",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pričakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pričakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pričakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna možnost: pričakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pričakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pričakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i ključi" : " ključ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
var init_sl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error37()
  };
}
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: förväntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: förväntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: förväntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: förväntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För stor(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `För stor(t): förväntat ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig sträng: måste börja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig sträng: måste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig sträng: måste innehålla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig sträng: måste matcha mönstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${issue2.origin ?? "värdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
var init_sv = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error38()
  };
}
var error38 = () => {
  const Sizable = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "எண்",
    array: "அணி",
    null: "வெறுமை"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது instanceof ${issue2.expected}, பெறப்பட்டது ${received}`;
        }
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${expected}, பெறப்பட்டது ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${stringifyPrimitive(issue2.values[0])}`;
        return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${joinValues(issue2.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
        }
        return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`;
        }
        return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
        if (_issue.format === "ends_with")
          return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
        if (_issue.format === "includes")
          return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
        if (_issue.format === "regex")
          return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
        return `தவறான ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${issue2.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${issue2.keys.length > 1 ? "கள்" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${issue2.origin} இல் தவறான மதிப்பு`;
      default:
        return `தவறான உள்ளீடு`;
    }
  };
};
var init_ta = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error39()
  };
}
var error39 = () => {
  const Sizable = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "ตัวเลข",
    array: "อาร์เรย์ (Array)",
    null: "ไม่มีค่า (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น instanceof ${issue2.expected} แต่ได้รับ ${received}`;
        }
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${expected} แต่ได้รับ ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ค่าไม่ถูกต้อง: ควรเป็น ${stringifyPrimitive(issue2.values[0])}`;
        return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "ไม่เกิน" : "น้อยกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
        return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "อย่างน้อย" : "มากกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
        if (_issue.format === "regex")
          return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
        return `รูปแบบไม่ถูกต้อง: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue2.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${issue2.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${issue2.origin}`;
      default:
        return `ข้อมูลไม่ถูกต้อง`;
    }
  };
};
var init_th = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error40()
  };
}
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Geçersiz değer: beklenen instanceof ${issue2.expected}, alınan ${received}`;
        }
        return `Geçersiz değer: beklenen ${expected}, alınan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geçersiz değer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "öğe"}`;
        return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
        if (_issue.format === "ends_with")
          return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geçersiz metin: "${_issue.includes}" içermeli`;
        if (_issue.format === "regex")
          return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
        return `Geçersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${issue2.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${issue2.origin} içinde geçersiz değer`;
      default:
        return `Geçersiz değer`;
    }
  };
};
var init_tr = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error41()
  };
}
var error41 = () => {
  const Sizable = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "число",
    array: "масив"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Неправильні вхідні дані: очікується instanceof ${issue2.expected}, отримано ${received}`;
        }
        return `Неправильні вхідні дані: очікується ${expected}, отримано ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неправильні вхідні дані: очікується ${stringifyPrimitive(issue2.values[0])}`;
        return `Неправильна опція: очікується одне з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементів"}`;
        return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} буде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Занадто мале: очікується, що ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Занадто мале: очікується, що ${issue2.origin} буде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неправильний рядок: повинен містити "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
        return `Неправильний ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${issue2.keys.length > 1 ? "і" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${issue2.origin}`;
      default:
        return `Неправильні вхідні дані`;
    }
  };
};
var init_uk = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm(() => {
  init_uk();
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error42()
  };
}
var error42 = () => {
  const Sizable = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "نمبر",
    array: "آرے",
    null: "نل"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `غلط ان پٹ: instanceof ${issue2.expected} متوقع تھا، ${received} موصول ہوا`;
        }
        return `غلط ان پٹ: ${expected} متوقع تھا، ${received} موصول ہوا`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `غلط ان پٹ: ${stringifyPrimitive(issue2.values[0])} متوقع تھا`;
        return `غلط آپشن: ${joinValues(issue2.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کے ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
        return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کا ${adj}${issue2.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `بہت چھوٹا: ${issue2.origin} کے ${adj}${issue2.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
        }
        return `بہت چھوٹا: ${issue2.origin} کا ${adj}${issue2.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
        }
        if (_issue.format === "ends_with")
          return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
        if (_issue.format === "includes")
          return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
        if (_issue.format === "regex")
          return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
        return `غلط ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${issue2.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${issue2.keys.length > 1 ? "ز" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `${issue2.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${issue2.origin} میں غلط ویلیو`;
      default:
        return `غلط ان پٹ`;
    }
  };
};
var init_ur = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/uz.js
function uz_default() {
  return {
    localeError: error43()
  };
}
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo‘lishi kerak" },
    file: { unit: "bayt", verb: "bo‘lishi kerak" },
    array: { unit: "element", verb: "bo‘lishi kerak" },
    set: { unit: "element", verb: "bo‘lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto‘g‘ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto‘g‘ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto‘g‘ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto‘g‘ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto‘g‘ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto‘g‘ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto‘g‘ri satr: "${_issue.includes}" ni o‘z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto‘g‘ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto‘g‘ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto‘g‘ri raqam: ${issue2.divisor} ning karralisi bo‘lishi kerak`;
      case "unrecognized_keys":
        return `Noma’lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto‘g‘ri`;
      case "invalid_union":
        return "Noto‘g‘ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto‘g‘ri qiymat`;
      default:
        return `Noto‘g‘ri kirish`;
    }
  };
};
var init_uz = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error44()
  };
}
var error44 = () => {
  const Sizable = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "số",
    array: "mảng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Đầu vào không hợp lệ: mong đợi instanceof ${issue2.expected}, nhận được ${received}`;
        }
        return `Đầu vào không hợp lệ: mong đợi ${expected}, nhận được ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Đầu vào không hợp lệ: mong đợi ${stringifyPrimitive(issue2.values[0])}`;
        return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
        return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Quá nhỏ: mong đợi ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Quá nhỏ: mong đợi ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${issue2.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${issue2.origin}`;
      default:
        return `Đầu vào không hợp lệ`;
    }
  };
};
var init_vi = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
var error45 = () => {
  const Sizable = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "数字",
    array: "数组",
    null: "空值(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `无效输入：期望 instanceof ${issue2.expected}，实际接收 ${received}`;
        }
        return `无效输入：期望 ${expected}，实际接收 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `无效输入：期望 ${stringifyPrimitive(issue2.values[0])}`;
        return `无效选项：期望以下之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "个元素"}`;
        return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `无效字符串：必须以 "${_issue.prefix}" 开头`;
        if (_issue.format === "ends_with")
          return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
        if (_issue.format === "includes")
          return `无效字符串：必须包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
        return `无效${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${issue2.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${issue2.origin} 中包含无效值(value)`;
      default:
        return `无效输入`;
    }
  };
};
var init_zh_CN = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
var error46 = () => {
  const Sizable = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `無效的輸入值：預期為 instanceof ${issue2.expected}，但收到 ${received}`;
        }
        return `無效的輸入值：預期為 ${expected}，但收到 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無效的輸入值：預期為 ${stringifyPrimitive(issue2.values[0])}`;
        return `無效的選項：預期為以下其中之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "個元素"}`;
        return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
        }
        if (_issue.format === "ends_with")
          return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
        if (_issue.format === "includes")
          return `無效的字串：必須包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `無效的字串：必須符合格式 ${_issue.pattern}`;
        return `無效的 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${issue2.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${issue2.keys.length > 1 ? "們" : ""}：${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${issue2.origin} 中有無效的值`;
      default:
        return `無效的輸入值`;
    }
  };
};
var init_zh_TW = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error47()
  };
}
var error47 = () => {
  const Sizable = {
    string: { unit: "àmi", verb: "ní" },
    file: { unit: "bytes", verb: "ní" },
    array: { unit: "nkan", verb: "ní" },
    set: { unit: "nkan", verb: "ní" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "ẹ̀rọ ìbáwọlé",
    email: "àdírẹ́sì ìmẹ́lì",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "àkókò ISO",
    date: "ọjọ́ ISO",
    time: "àkókò ISO",
    duration: "àkókò tó pé ISO",
    ipv4: "àdírẹ́sì IPv4",
    ipv6: "àdírẹ́sì IPv6",
    cidrv4: "àgbègbè IPv4",
    cidrv6: "àgbègbè IPv6",
    base64: "ọ̀rọ̀ tí a kọ́ ní base64",
    base64url: "ọ̀rọ̀ base64url",
    json_string: "ọ̀rọ̀ JSON",
    e164: "nọ́mbà E.164",
    jwt: "JWT",
    template_literal: "ẹ̀rọ ìbáwọlé"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nọ́mbà",
    array: "akopọ"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ìbáwọlé aṣìṣe: a ní láti fi instanceof ${issue2.expected}, àmọ̀ a rí ${received}`;
        }
        return `Ìbáwọlé aṣìṣe: a ní láti fi ${expected}, àmọ̀ a rí ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ìbáwọlé aṣìṣe: a ní láti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tó pọ̀ jù: a ní láti jẹ́ pé ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `Tó pọ̀ jù: a ní láti jẹ́ ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kéré ju: a ní láti jẹ́ pé ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kéré ju: a ní láti jẹ́ ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${_issue.pattern}`;
        return `Aṣìṣe: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Bọtìnì àìmọ̀: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Bọtìnì aṣìṣe nínú ${issue2.origin}`;
      case "invalid_union":
        return "Ìbáwọlé aṣìṣe";
      case "invalid_element":
        return `Iye aṣìṣe nínú ${issue2.origin}`;
      default:
        return "Ìbáwọlé aṣìṣe";
    }
  };
};
var init_yo = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  uz: () => uz_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hy: () => hy_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  bg: () => bg_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});
var init_locales = __esm(() => {
  init_ar();
  init_az();
  init_be();
  init_bg();
  init_ca();
  init_cs();
  init_da();
  init_de();
  init_en();
  init_eo();
  init_es();
  init_fa();
  init_fi();
  init_fr();
  init_fr_CA();
  init_he();
  init_hu();
  init_hy();
  init_id();
  init_is();
  init_it();
  init_ja();
  init_ka();
  init_kh();
  init_km();
  init_ko();
  init_lt();
  init_mk();
  init_ms();
  init_nl();
  init_no();
  init_ota();
  init_ps();
  init_pl();
  init_pt();
  init_ru();
  init_sl();
  init_sv();
  init_ta();
  init_th();
  init_tr();
  init_ua();
  init_uk();
  init_ur();
  init_uz();
  init_vi();
  init_zh_CN();
  init_zh_TW();
  init_yo();
});

// node_modules/zod/v4/core/registries.js
class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var _a, $output, $input, globalRegistry;
var init_registries = __esm(() => {
  $output = Symbol("ZodOutput");
  $input = Symbol("ZodInput");
  (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
  globalRegistry = globalThis.__zod_globalRegistry;
});

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm(() => {
  init_checks();
  init_registries();
  init_schemas();
  init_util();
  TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
  };
});

// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {}),
    io: params?.io ?? "output",
    counter: 0,
    seen: new Map,
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? undefined
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = new Map;
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {} else {}
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {} else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
}, createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var init_to_json_schema = __esm(() => {
  init_registries();
});

// node_modules/zod/v4/core/json-schema-processors.js
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
var formatMap, stringProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  json.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minLength = minimum;
  if (typeof maximum === "number")
    json.maxLength = maximum;
  if (format) {
    json.format = formatMap[format] ?? format;
    if (json.format === "")
      delete json.format;
    if (format === "time") {
      delete json.format;
    }
  }
  if (contentEncoding)
    json.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
}, numberProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json.type = "integer";
  else
    json.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.minimum = exclusiveMinimum;
      json.exclusiveMinimum = true;
    } else {
      json.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json.minimum;
      else
        delete json.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.maximum = exclusiveMaximum;
      json.exclusiveMaximum = true;
    } else {
      json.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json.maximum;
      else
        delete json.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json.multipleOf = multipleOf;
}, booleanProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
}, bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
}, symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
}, nullProcessor = (_schema, ctx, json, _params) => {
  if (ctx.target === "openapi-3.0") {
    json.type = "string";
    json.nullable = true;
    json.enum = [null];
  } else {
    json.type = "null";
  }
}, undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
}, voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
}, neverProcessor = (_schema, _ctx, json, _params) => {
  json.not = {};
}, anyProcessor = (_schema, _ctx, _json, _params) => {}, unknownProcessor = (_schema, _ctx, _json, _params) => {}, dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
}, enumProcessor = (schema, _ctx, json, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json.type = "number";
  if (values.every((v) => typeof v === "string"))
    json.type = "string";
  json.enum = values;
}, literalProcessor = (schema, ctx, json, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === undefined) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {}
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {} else if (vals.length === 1) {
    const val = vals[0];
    json.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.enum = [val];
    } else {
      json.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json.type = "boolean";
    if (vals.every((v) => v === null))
      json.type = "null";
    json.enum = vals;
  }
}, nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
}, templateLiteralProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
}, fileProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const file = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== undefined)
    file.minLength = minimum;
  if (maximum !== undefined)
    file.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file.contentMediaType = mime[0];
      Object.assign(_json, file);
    } else {
      Object.assign(_json, file);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file);
  }
}, successProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
}, customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
}, functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
}, transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
}, mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
}, setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
}, arrayProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
  json.type = "array";
  json.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, objectProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  json.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === undefined;
    } else {
      return v.optout === undefined;
    }
  }));
  if (requiredKeys.size > 0) {
    json.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json.additionalProperties = false;
  } else if (def.catchall) {
    json.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
}, unionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json.oneOf = options;
  } else {
    json.anyOf = options;
  }
}, intersectionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json.allOf = allOf;
}, tupleProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json.prefixItems = prefixItems;
    if (rest) {
      json.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json.items.anyOf.push(rest);
    }
    json.minItems = prefixItems.length;
    if (!rest) {
      json.maxItems = prefixItems.length;
    }
  } else {
    json.items = prefixItems;
    if (rest) {
      json.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
}, recordProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json.patternProperties = {};
    for (const pattern of patterns) {
      json.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json.required = validKeyValues;
    }
  }
}, nullableProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json.nullable = true;
  } else {
    json.anyOf = [inner, { type: "null" }];
  }
}, nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, defaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.default = JSON.parse(JSON.stringify(def.defaultValue));
}, prefaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
}, catchProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(undefined);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json.default = catchValue;
}, pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, readonlyProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.readOnly = true;
}, promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, allProcessors;
var init_json_schema_processors = __esm(() => {
  init_to_json_schema();
  init_util();
  formatMap = {
    guid: "uuid",
    url: "uri",
    datetime: "date-time",
    json_string: "json-string",
    regex: ""
  };
  allProcessors = {
    string: stringProcessor,
    number: numberProcessor,
    boolean: booleanProcessor,
    bigint: bigintProcessor,
    symbol: symbolProcessor,
    null: nullProcessor,
    undefined: undefinedProcessor,
    void: voidProcessor,
    never: neverProcessor,
    any: anyProcessor,
    unknown: unknownProcessor,
    date: dateProcessor,
    enum: enumProcessor,
    literal: literalProcessor,
    nan: nanProcessor,
    template_literal: templateLiteralProcessor,
    file: fileProcessor,
    success: successProcessor,
    custom: customProcessor,
    function: functionProcessor,
    transform: transformProcessor,
    map: mapProcessor,
    set: setProcessor,
    array: arrayProcessor,
    object: objectProcessor,
    union: unionProcessor,
    intersection: intersectionProcessor,
    tuple: tupleProcessor,
    record: recordProcessor,
    nullable: nullableProcessor,
    nonoptional: nonoptionalProcessor,
    default: defaultProcessor,
    prefault: prefaultProcessor,
    catch: catchProcessor,
    pipe: pipeProcessor,
    readonly: readonlyProcessor,
    promise: promiseProcessor,
    optional: optionalProcessor,
    lazy: lazyProcessor
  };
});

// node_modules/zod/v4/core/json-schema-generator.js
class JSONSchemaGenerator {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
}
var init_json_schema_generator = __esm(() => {
  init_json_schema_processors();
  init_to_json_schema();
});

// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
var init_json_schema = () => {};

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  process: () => process2,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  meta: () => meta,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  initializeContext: () => initializeContext,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  finalize: () => finalize,
  extractDefs: () => extractDefs,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  describe: () => describe,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  config: () => config,
  clone: () => clone,
  _xor: () => _xor,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _slugify: () => _slugify,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _mac: () => _mac,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXor: () => $ZodXor,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodMAC: () => $ZodMAC,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});
var init_core2 = __esm(() => {
  init_util();
  init_regexes();
  init_locales();
  init_json_schema_processors();
  init_json_schema_generator();
  init_json_schema();
  init_core();
  init_parse();
  init_errors();
  init_schemas();
  init_checks();
  init_versions();
  init_registries();
  init_api();
  init_to_json_schema();
});

// node_modules/zod/v4/classic/checks.js
var exports_checks2 = {};
__export(exports_checks2, {
  uppercase: () => _uppercase,
  trim: () => _trim,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  regex: () => _regex,
  property: () => _property,
  positive: () => _positive,
  overwrite: () => _overwrite,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonnegative: () => _nonnegative,
  negative: () => _negative,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  length: () => _length,
  includes: () => _includes,
  gte: () => _gte,
  gt: () => _gt,
  endsWith: () => _endsWith
});
var init_checks2 = __esm(() => {
  init_core2();
});

// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm(() => {
  init_core2();
  init_schemas2();
  ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
});

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
}, ZodError, ZodRealError;
var init_errors2 = __esm(() => {
  init_core2();
  init_core2();
  init_util();
  ZodError = $constructor("ZodError", initializer2);
  ZodRealError = $constructor("ZodError", initializer2, {
    Parent: Error
  });
});

// node_modules/zod/v4/classic/parse.js
var parse3, parseAsync2, safeParse2, safeParseAsync2, encode2, decode2, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse2 = __esm(() => {
  init_core2();
  init_errors2();
  parse3 = /* @__PURE__ */ _parse(ZodRealError);
  parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
  safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
  safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  encode2 = /* @__PURE__ */ _encode(ZodRealError);
  decode2 = /* @__PURE__ */ _decode(ZodRealError);
  encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
  decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
  safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
  safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
  safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
  safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
});

// node_modules/zod/v4/classic/schemas.js
var exports_schemas2 = {};
__export(exports_schemas2, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  transform: () => transform,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  set: () => set,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  promise: () => promise,
  preprocess: () => preprocess,
  prefault: () => prefault,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  nonoptional: () => nonoptional,
  never: () => never,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  meta: () => meta2,
  map: () => map,
  mac: () => mac2,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  literal: () => literal,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  function: () => _function,
  float64: () => float64,
  float32: () => float32,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  codec: () => codec,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIntersection: () => ZodIntersection,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny
});
function string2(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function mac2(params) {
  return _mac(ZodMAC, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base642(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...exports_util.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...exports_util.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodXor, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodExactOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, describe2, meta2, stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
var init_schemas2 = __esm(() => {
  init_core2();
  init_core2();
  init_json_schema_processors();
  init_to_json_schema();
  init_checks2();
  init_iso();
  init_parse2();
  ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    Object.assign(inst["~standard"], {
      jsonSchema: {
        input: createStandardJSONSchemaMethod(inst, "input"),
        output: createStandardJSONSchemaMethod(inst, "output")
      }
    });
    inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks2) => {
      return inst.clone(exports_util.mergeDefs(def, {
        checks: [
          ...def.checks ?? [],
          ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }), {
        parent: true
      });
    };
    inst.with = inst.check;
    inst.clone = (def2, params) => clone(inst, def2, params);
    inst.brand = () => inst;
    inst.register = (reg, meta2) => {
      reg.add(inst, meta2);
      return inst;
    };
    inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse2(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.encode = (data, params) => encode2(inst, data, params);
    inst.decode = (data, params) => decode2(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
    inst.refine = (check, params) => inst.check(refine(check, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    inst.optional = () => optional(inst);
    inst.exactOptional = () => exactOptional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def2) => _default2(inst, def2);
    inst.prefault = (def2) => prefault(inst, def2);
    inst.catch = (params) => _catch2(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry.get(inst);
      }
      const cl = inst.clone();
      globalRegistry.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    inst.apply = (fn) => fn(inst);
    return inst;
  });
  _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
    inst.slugify = () => inst.check(_slugify());
  });
  ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    inst.datetime = (params) => inst.check(datetime2(params));
    inst.date = (params) => inst.check(date2(params));
    inst.time = (params) => inst.check(time2(params));
    inst.duration = (params) => inst.check(duration2(params));
  });
  ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
  });
  ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
    $ZodMAC.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
    $ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
  });
  ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);
  });
  ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
    $ZodBigInt.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => bigintProcessor(inst, ctx, json, params);
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.positive = (params) => inst.check(_gt(BigInt(0), params));
    inst.negative = (params) => inst.check(_lt(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
  ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
    $ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
  });
  ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
    $ZodSymbol.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => symbolProcessor(inst, ctx, json, params);
  });
  ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
    $ZodUndefined.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => undefinedProcessor(inst, ctx, json, params);
  });
  ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
    $ZodNull.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nullProcessor(inst, ctx, json, params);
  });
  ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
    $ZodAny.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => anyProcessor(inst, ctx, json, params);
  });
  ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
  });
  ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
  });
  ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
    $ZodVoid.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => voidProcessor(inst, ctx, json, params);
  });
  ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
    $ZodDate.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => dateProcessor(inst, ctx, json, params);
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
  });
  ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
    exports_util.defineLazy(inst, "shape", () => {
      return def.shape;
    });
    inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
      return exports_util.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
      return exports_util.safeExtend(inst, incoming);
    };
    inst.merge = (other) => exports_util.merge(inst, other);
    inst.pick = (mask) => exports_util.pick(inst, mask);
    inst.omit = (mask) => exports_util.omit(inst, mask);
    inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
  });
  ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
    inst.options = def.options;
  });
  ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodXor.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
    inst.options = def.options;
  });
  ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
  });
  ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
  });
  ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
    $ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => tupleProcessor(inst, ctx, json, params);
    inst.rest = (rest) => inst.clone({
      ...inst._zod.def,
      rest
    });
  });
  ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => recordProcessor(inst, ctx, json, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
    $ZodMap.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => mapProcessor(inst, ctx, json, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
    $ZodSet.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => setProcessor(inst, ctx, json, params);
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...exports_util.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...exports_util.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
    $ZodLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => literalProcessor(inst, ctx, json, params);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
    $ZodFile.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => fileProcessor(inst, ctx, json, params);
    inst.min = (size, params) => inst.check(_minSize(size, params));
    inst.max = (size, params) => inst.check(_maxSize(size, params));
    inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
  });
  ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(exports_util.issue(issue2, payload.value, def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(exports_util.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
    $ZodExactOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
    $ZodSuccess.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => successProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
    $ZodNaN.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nanProcessor(inst, ctx, json, params);
  });
  ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
    inst.in = def.in;
    inst.out = def.out;
  });
  ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
    ZodPipe.init(inst, def);
    $ZodCodec.init(inst, def);
  });
  ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
    $ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => templateLiteralProcessor(inst, ctx, json, params);
  });
  ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
    $ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => lazyProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.getter();
  });
  ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
    $ZodPromise.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => promiseProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
    $ZodFunction.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => functionProcessor(inst, ctx, json, params);
  });
  ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
  });
  describe2 = describe;
  meta2 = meta;
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodIssueCode, ZodFirstPartyTypeKind;
var init_compat = __esm(() => {
  init_core2();
  ZodIssueCode = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
  };
  (function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
});

// node_modules/zod/v4/classic/from-json-schema.js
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path3 = ref.slice(1).split("/").filter(Boolean);
  if (path3.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path3[0] === defsKey) {
    const key = path3[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== undefined) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== undefined) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== undefined) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== undefined) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== undefined) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2;i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== undefined) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== undefined) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx;i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: new Map,
    processing: new Set,
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
var z, RECOGNIZED_KEYS;
var init_from_json_schema = __esm(() => {
  init_registries();
  init_checks2();
  init_iso();
  init_schemas2();
  z = {
    ...exports_schemas2,
    ...exports_checks2,
    iso: exports_iso
  };
  RECOGNIZED_KEYS = new Set([
    "$schema",
    "$ref",
    "$defs",
    "definitions",
    "$id",
    "id",
    "$comment",
    "$anchor",
    "$vocabulary",
    "$dynamicRef",
    "$dynamicAnchor",
    "type",
    "enum",
    "const",
    "anyOf",
    "oneOf",
    "allOf",
    "not",
    "properties",
    "required",
    "additionalProperties",
    "patternProperties",
    "propertyNames",
    "minProperties",
    "maxProperties",
    "items",
    "prefixItems",
    "additionalItems",
    "minItems",
    "maxItems",
    "uniqueItems",
    "contains",
    "minContains",
    "maxContains",
    "minLength",
    "maxLength",
    "pattern",
    "format",
    "minimum",
    "maximum",
    "exclusiveMinimum",
    "exclusiveMaximum",
    "multipleOf",
    "description",
    "default",
    "contentEncoding",
    "contentMediaType",
    "contentSchema",
    "unevaluatedItems",
    "unevaluatedProperties",
    "if",
    "then",
    "else",
    "dependentSchemas",
    "dependentRequired",
    "nullable",
    "readOnly"
  ]);
});

// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm(() => {
  init_core2();
  init_schemas2();
});

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  meta: () => meta2,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  mac: () => mac2,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  fromJSONSchema: () => fromJSONSchema,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});
var init_external = __esm(() => {
  init_core2();
  init_core2();
  init_en();
  init_core2();
  init_json_schema_processors();
  init_from_json_schema();
  init_locales();
  init_iso();
  init_iso();
  init_coerce();
  init_schemas2();
  init_checks2();
  init_errors2();
  init_parse2();
  init_compat();
  config(en_default());
});

// node_modules/zod/index.js
var init_zod = __esm(() => {
  init_external();
  init_external();
});

// src/config/model-health.ts
import * as fs3 from "node:fs";
import * as os from "node:os";
import * as path3 from "node:path";
function getAuthFileCandidates() {
  const home = os.homedir();
  const candidates = [path3.join(home, ".local", "share", "opencode", "auth.json")];
  if (process.env.XDG_DATA_HOME) {
    candidates.unshift(path3.join(process.env.XDG_DATA_HOME, "opencode", "auth.json"));
  }
  if (process.env.LOCALAPPDATA) {
    candidates.push(path3.join(process.env.LOCALAPPDATA, "opencode", "auth.json"));
  }
  if (process.env.APPDATA) {
    candidates.push(path3.join(process.env.APPDATA, "opencode", "auth.json"));
  }
  return candidates;
}
function readAuthProviders() {
  for (const candidate of getAuthFileCandidates()) {
    try {
      if (!fs3.existsSync(candidate))
        continue;
      const raw = fs3.readFileSync(candidate, "utf-8");
      const parsed = JSON.parse(raw);
      return new Set(Object.keys(parsed));
    } catch {}
  }
  return new Set;
}
function hasProviderEnv(providerID) {
  const envNames = PROVIDER_ENV_MAP[providerID] ?? [];
  return envNames.some((name) => (process.env[name] ?? "").trim().length > 0);
}
function normalizeProviderID2(providerID) {
  return providerID.trim().toLowerCase();
}
function getModelProviderID(model) {
  const slash = model.indexOf("/");
  if (slash === -1)
    return normalizeProviderID2(model);
  return normalizeProviderID2(model.slice(0, slash));
}
function isStrongProviderAvailable(providerID) {
  const normalized = normalizeProviderID2(providerID);
  const authProviders = readAuthProviders();
  return authProviders.has(normalized) || hasProviderEnv(normalized);
}
function isModelLikelyAvailable(model) {
  const providerID = getModelProviderID(model);
  if (STRONG_PROVIDER_IDS.has(providerID)) {
    return isStrongProviderAvailable(providerID);
  }
  if (OPPORTUNISTIC_PROVIDER_IDS.has(providerID)) {
    return true;
  }
  return true;
}
var STRONG_PROVIDER_IDS, OPPORTUNISTIC_PROVIDER_IDS, PROVIDER_ENV_MAP;
var init_model_health = __esm(() => {
  STRONG_PROVIDER_IDS = new Set([
    "openai",
    "openrouter",
    "anthropic",
    "google",
    "chutes",
    "kimi-for-coding",
    "zai-coding-plan",
    "github-copilot"
  ]);
  OPPORTUNISTIC_PROVIDER_IDS = new Set(["opencode"]);
  PROVIDER_ENV_MAP = {
    openai: ["OPENAI_API_KEY"],
    openrouter: ["OPENROUTER_API_KEY"],
    anthropic: ["ANTHROPIC_API_KEY"],
    google: ["GOOGLE_GENERATIVE_AI_API_KEY"],
    chutes: ["CHUTES_API_KEY"],
    "kimi-for-coding": ["KIMI_API_KEY"],
    "zai-coding-plan": ["ZAI_API_KEY"],
    "github-copilot": ["GITHUB_TOKEN", "GITHUB_COPILOT_TOKEN"]
  };
});

// src/settings/registry.ts
function entry(input) {
  return {
    ...input,
    requiresEvidence: input.risk === "HIGH"
  };
}
function cloneValue(value) {
  return JSON.parse(JSON.stringify(value));
}
function keySegments(key) {
  return key.split(".").map((segment) => segment.trim()).filter((segment) => segment.length > 0);
}
function getNestedValue(root, key) {
  if (!root || typeof root !== "object")
    return;
  const segments = keySegments(key);
  let current = root;
  for (const segment of segments) {
    if (!current || typeof current !== "object")
      return;
    current = current[segment];
  }
  return current;
}
function setNestedValue(root, key, value) {
  const segments = keySegments(key);
  if (segments.length === 0)
    return;
  let current = root;
  for (let index = 0;index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const next = current[segment];
    if (!next || typeof next !== "object" || Array.isArray(next)) {
      current[segment] = {};
    }
    current = current[segment];
  }
  current[segments[segments.length - 1]] = value;
}
function leafSchema(entryValue) {
  if (entryValue.type === "boolean")
    return { type: "boolean" };
  if (entryValue.type === "integer") {
    const schema2 = { type: "integer" };
    if (typeof entryValue.minimum === "number")
      schema2.minimum = entryValue.minimum;
    if (typeof entryValue.maximum === "number")
      schema2.maximum = entryValue.maximum;
    return schema2;
  }
  if (entryValue.type === "string")
    return { type: "string" };
  if (entryValue.type === "enum") {
    return { type: "string", enum: [...entryValue.enumValues ?? []] };
  }
  if (entryValue.type === "array")
    return { type: "array" };
  return { type: "object" };
}
function setSchemaAtPath(root, key, schema2) {
  const segments = keySegments(key);
  if (segments.length === 0)
    return;
  let current = root;
  for (let index = 0;index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const existing = current[segment];
    if (!existing || typeof existing !== "object") {
      current[segment] = {
        type: "object",
        additionalProperties: true,
        properties: {}
      };
    }
    const node = current[segment];
    if (!node.properties || typeof node.properties !== "object") {
      node.properties = {};
    }
    current = node.properties;
  }
  current[segments[segments.length - 1]] = schema2;
}
function getSettingEntry(key) {
  return REGISTRY_MAP.get(key);
}
function listSettingEntries() {
  return SETTINGS_REGISTRY.map((item) => cloneValue(item));
}
function buildDefaultConfig() {
  const config2 = {};
  for (const item of SETTINGS_REGISTRY) {
    setNestedValue(config2, item.key, cloneValue(item.defaultValue));
  }
  return config2;
}
function buildRegistryDocument() {
  return {
    version: 1,
    generatedAt: new Date().toISOString(),
    settings: listSettingEntries()
  };
}
function buildSchemaDocument() {
  const rootProperties = {};
  for (const item of SETTINGS_REGISTRY) {
    setSchemaAtPath(rootProperties, item.key, leafSchema(item));
  }
  return {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    title: "Miya Config",
    type: "object",
    additionalProperties: true,
    properties: rootProperties
  };
}
var SETTINGS_REGISTRY, REGISTRY_MAP;
var init_registry = __esm(() => {
  SETTINGS_REGISTRY = [
    entry({
      key: "ui.language",
      type: "enum",
      enumValues: ["zh-CN"],
      defaultValue: "zh-CN",
      risk: "LOW",
      description: "控制台语言。"
    }),
    entry({
      key: "ui.theme",
      type: "enum",
      enumValues: ["dark", "light", "system"],
      defaultValue: "dark",
      risk: "LOW",
      description: "控制台主题。"
    }),
    entry({
      key: "ui.dashboard.openOnStart",
      type: "boolean",
      defaultValue: true,
      risk: "LOW",
      description: "启动时自动打开控制台。"
    }),
    entry({
      key: "ui.dashboard.dockAutoLaunch",
      type: "boolean",
      defaultValue: false,
      risk: "LOW",
      description: "启动时自动拉起 Windows Dock（默认关闭，避免反复拉起）。"
    }),
    entry({
      key: "ui.dashboard.autoOpenCooldownMs",
      type: "integer",
      minimum: 1e4,
      maximum: 1440000,
      defaultValue: 120000,
      risk: "LOW",
      description: "自动打开控制台的跨进程冷却时间（毫秒）。"
    }),
    entry({
      key: "ui.dashboard.startPage",
      type: "enum",
      enumValues: [
        "overview",
        "autopilot",
        "approvals",
        "intake",
        "runtime",
        "jobs",
        "skills",
        "killswitch"
      ],
      defaultValue: "overview",
      risk: "LOW",
      description: "控制台默认首页。"
    }),
    entry({
      key: "ui.dashboard.refreshMs",
      type: "integer",
      minimum: 200,
      maximum: 5000,
      defaultValue: 800,
      risk: "LOW",
      description: "控制台自动刷新间隔（毫秒）。"
    }),
    entry({
      key: "autopilot.enabled",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "是否启用自动循环执行。"
    }),
    entry({
      key: "autopilot.maxCycles",
      type: "integer",
      minimum: 1,
      maximum: 20,
      defaultValue: 8,
      risk: "MED",
      description: "单窗口最大循环轮次（进展驱动+上限约束）。"
    }),
    entry({
      key: "autopilot.noInterruptChat",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "自动执行时尽量不打断主对话。"
    }),
    entry({
      key: "autopilot.stallDetection.enabled",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "启用停滞检测。"
    }),
    entry({
      key: "autopilot.stallDetection.maxNoImprovementCycles",
      type: "integer",
      minimum: 1,
      maximum: 10,
      defaultValue: 3,
      risk: "MED",
      description: "连续无改进轮次阈值。"
    }),
    entry({
      key: "autopilot.iterationDoneRequired",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "每轮必须写入迭代完成记录。"
    }),
    entry({
      key: "approval.mode",
      type: "enum",
      enumValues: ["self"],
      defaultValue: "self",
      risk: "MED",
      description: "审批模式。"
    }),
    entry({
      key: "approval.requireEvidence",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "是否强制证据链。"
    }),
    entry({
      key: "approval.signers",
      type: "object",
      defaultValue: {
        executor: true,
        verifier: true
      },
      risk: "MED",
      description: "审批签字人配置。"
    }),
    entry({
      key: "approval.tier.default",
      type: "enum",
      enumValues: ["LIGHT", "STANDARD", "THOROUGH"],
      defaultValue: "STANDARD",
      risk: "MED",
      description: "默认验证等级。"
    }),
    entry({
      key: "approval.tier.irreversible",
      type: "enum",
      enumValues: ["THOROUGH"],
      defaultValue: "THOROUGH",
      risk: "HIGH",
      description: "不可逆动作必须验证等级。"
    }),
    entry({
      key: "approval.onDeny.activateKillSwitch",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "审批拒绝后是否触发急停。"
    }),
    entry({
      key: "intake.enabled",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "信息闸门总开关。"
    }),
    entry({
      key: "intake.triggers.configChange",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "配置变更是否强制触发信息闸门。"
    }),
    entry({
      key: "intake.triggers.skillOrToolchainChange",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "新增/启用 skill 或工具链是否触发信息闸门。"
    }),
    entry({
      key: "intake.triggers.highRiskAction",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "高风险动作前置学习是否触发信息闸门。"
    }),
    entry({
      key: "intake.triggers.directiveContent",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "网页指令型内容是否触发信息闸门。"
    }),
    entry({
      key: "intake.policy.autoWhitelistOnApprove",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "审批同意后自动加入白名单。"
    }),
    entry({
      key: "intake.policy.autoBlacklistOnReject",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "审批拒绝后自动加入黑名单。"
    }),
    entry({
      key: "intake.policy.defaultRejectScope",
      type: "enum",
      enumValues: ["CONTENT_FINGERPRINT", "PAGE", "PATH_PREFIX", "DOMAIN"],
      defaultValue: "CONTENT_FINGERPRINT",
      risk: "MED",
      description: "拒绝时默认加入黑名单的粒度。"
    }),
    entry({
      key: "intake.policy.allowTrialRunOption",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "审批选项中允许“仅试运行一次”。"
    }),
    entry({
      key: "intake.stats.windowN",
      type: "integer",
      minimum: 3,
      maximum: 50,
      defaultValue: 10,
      risk: "MED",
      description: "来源统计滑动窗口大小 N（按审批事件）。"
    }),
    entry({
      key: "intake.stats.hardDenyWhenUsefulLessThanRejected",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "当 U<R 时默认否决该来源。"
    }),
    entry({
      key: "intake.stats.downrankThresholdRatioX100",
      type: "integer",
      minimum: 100,
      maximum: 500,
      defaultValue: 150,
      risk: "MED",
      description: "降权阈值比率（X100，默认 150 表示 1.5 倍）。"
    }),
    entry({
      key: "intake.stats.downrankExplorePercent",
      type: "integer",
      minimum: 0,
      maximum: 100,
      defaultValue: 30,
      risk: "MED",
      description: "来源降权后探索概率百分比。"
    }),
    entry({
      key: "intake.stats.sourceUnit",
      type: "enum",
      enumValues: ["DOMAIN_PATH_PREFIX", "DOMAIN", "PATH_PREFIX"],
      defaultValue: "DOMAIN_PATH_PREFIX",
      risk: "MED",
      description: "来源统计单元。"
    }),
    entry({
      key: "killswitch.active",
      type: "boolean",
      defaultValue: false,
      risk: "HIGH",
      description: "急停总开关状态。"
    }),
    entry({
      key: "killswitch.lockdownOnHighRisk",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "高风险拒绝后进入锁定。"
    }),
    entry({
      key: "killswitch.unlockPolicy",
      type: "enum",
      enumValues: ["explicit"],
      defaultValue: "explicit",
      risk: "HIGH",
      description: "急停解锁策略。"
    }),
    entry({
      key: "killswitch.stopTargets",
      type: "object",
      defaultValue: {
        desktop: true,
        outbound: true,
        exec: true,
        browser: true,
        voice: false
      },
      risk: "HIGH",
      description: "急停需要停止的目标模块。"
    }),
    entry({
      key: "gateway.bindHost",
      type: "string",
      defaultValue: "127.0.0.1",
      risk: "MED",
      description: "Gateway 绑定地址。"
    }),
    entry({
      key: "gateway.port",
      type: "integer",
      minimum: 1024,
      maximum: 65535,
      defaultValue: 17321,
      risk: "MED",
      description: "Gateway 监听端口。"
    }),
    entry({
      key: "gateway.baseUrl",
      type: "string",
      defaultValue: "http://127.0.0.1:17321",
      risk: "MED",
      description: "Gateway 基础 URL。"
    }),
    entry({
      key: "gateway.wsPath",
      type: "string",
      defaultValue: "/ws",
      risk: "MED",
      description: "Gateway WebSocket 路径。"
    }),
    entry({
      key: "gateway.staticSpa.enabled",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "是否启用静态网页控制台。"
    }),
    entry({
      key: "gateway.auth.mode",
      type: "enum",
      enumValues: ["localToken", "none"],
      defaultValue: "localToken",
      risk: "HIGH",
      description: "Gateway 鉴权模式。"
    }),
    entry({
      key: "runtime.backpressure.max_in_flight",
      type: "integer",
      minimum: 1,
      maximum: 128,
      defaultValue: 8,
      risk: "MED",
      description: "Gateway 最大并发执行数。"
    }),
    entry({
      key: "runtime.backpressure.max_queued",
      type: "integer",
      minimum: 1,
      maximum: 1024,
      defaultValue: 64,
      risk: "MED",
      description: "Gateway 最大排队请求数。"
    }),
    entry({
      key: "runtime.backpressure.queue_timeout_ms",
      type: "integer",
      minimum: 100,
      maximum: 120000,
      defaultValue: 15000,
      risk: "MED",
      description: "Gateway 排队超时时间（毫秒）。"
    }),
    entry({
      key: "runtime.backpressure.daemon_max_pending_requests",
      type: "integer",
      minimum: 4,
      maximum: 1024,
      defaultValue: 64,
      risk: "MED",
      description: "Daemon Launcher 最大挂起请求数。"
    }),
    entry({
      key: "runtime.notifications.job_toast",
      type: "boolean",
      defaultValue: true,
      risk: "LOW",
      description: "任务完成/失败时是否推送 toast 通知。"
    }),
    entry({
      key: "runtime.multimodal.test_mode",
      type: "boolean",
      defaultValue: true,
      risk: "LOW",
      description: "多模态单元测试模式（使用可追溯降级资产）。"
    }),
    entry({
      key: "security.voiceprint.strict",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "声纹校验严格模式开关。"
    }),
    entry({
      key: "skills.enabled",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "是否启用技能系统。"
    }),
    entry({
      key: "skills.packages",
      type: "array",
      defaultValue: [],
      risk: "MED",
      description: "已启用技能包列表。"
    }),
    entry({
      key: "skills.versionLock.enabled",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "技能包版本锁定。"
    }),
    entry({
      key: "skills.compat.openCodeNative",
      type: "boolean",
      defaultValue: true,
      risk: "LOW",
      description: "兼容 OpenCode 原生技能。"
    }),
    entry({
      key: "desktop.enabled",
      type: "boolean",
      defaultValue: false,
      risk: "HIGH",
      description: "桌面自动化开关。"
    }),
    entry({
      key: "desktop.preferUia",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "优先 UIA 自动化。"
    }),
    entry({
      key: "desktop.requirePreSendScreenshotVerify",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "发送前截图核验。"
    }),
    entry({
      key: "desktop.requirePostActionVerify",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "动作后状态核验。"
    }),
    entry({
      key: "desktop.focusPolicy",
      type: "enum",
      enumValues: ["strict", "relaxed"],
      defaultValue: "strict",
      risk: "HIGH",
      description: "桌面焦点策略。"
    }),
    entry({
      key: "outbound.enabled",
      type: "boolean",
      defaultValue: false,
      risk: "HIGH",
      description: "外发消息总开关。"
    }),
    entry({
      key: "outbound.channels",
      type: "object",
      defaultValue: {
        qq: true,
        wechat: true
      },
      risk: "HIGH",
      description: "外发渠道配置（仅 QQ/微信）。"
    }),
    entry({
      key: "outbound.requireDraftInChat",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "外发前先在对话中生成草稿。"
    }),
    entry({
      key: "outbound.requireVerifierSign",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "外发前强制 verifier 签字。"
    }),
    entry({
      key: "voice.enabled",
      type: "boolean",
      defaultValue: false,
      risk: "HIGH",
      description: "语音能力总开关。"
    }),
    entry({
      key: "voice.input.stt",
      type: "enum",
      enumValues: ["local", "off"],
      defaultValue: "local",
      risk: "MED",
      description: "语音输入 STT 模式。"
    }),
    entry({
      key: "voice.output.tts",
      type: "enum",
      enumValues: ["local", "off"],
      defaultValue: "local",
      risk: "MED",
      description: "语音输出 TTS 模式。"
    }),
    entry({
      key: "voice.wakeWord.enabled",
      type: "boolean",
      defaultValue: false,
      risk: "MED",
      description: "唤醒词开关。"
    }),
    entry({
      key: "voice.oneShotMode",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "一句话触发模式。"
    }),
    entry({
      key: "voice.routeToChat",
      type: "boolean",
      defaultValue: true,
      risk: "MED",
      description: "语音输入统一写入会话。"
    }),
    entry({
      key: "git.autoPush.enabled",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "自动推送开关。"
    }),
    entry({
      key: "git.autoPush.remote",
      type: "string",
      defaultValue: "https://github.com/mmy4shadow/miya-for-opencode.git",
      risk: "HIGH",
      description: "自动推送远端仓库。"
    }),
    entry({
      key: "git.autoPush.branchPattern",
      type: "string",
      defaultValue: "refs/heads/miya/<session-id>",
      risk: "HIGH",
      description: "自动推送分支策略。"
    }),
    entry({
      key: "git.autoPush.maxFileSizeMB",
      type: "integer",
      minimum: 1,
      maximum: 50,
      defaultValue: 2,
      risk: "HIGH",
      description: "自动推送单文件大小上限。"
    }),
    entry({
      key: "git.autoPush.blockWhenKillSwitchActive",
      type: "boolean",
      defaultValue: true,
      risk: "HIGH",
      description: "急停时阻断自动推送。"
    }),
    entry({
      key: "git.autoPush.excludeGlobs",
      type: "array",
      defaultValue: [
        ".opencode/**",
        ".venv/**",
        "node_modules/**",
        "**/*.pem",
        "**/*.key",
        "**/.env*"
      ],
      risk: "HIGH",
      description: "自动推送排除列表。"
    })
  ];
  REGISTRY_MAP = new Map(SETTINGS_REGISTRY.map((item) => [item.key, item]));
});

// src/settings/store.ts
import * as fs5 from "node:fs";
import * as path5 from "node:path";
function runtimeFile(projectDir, fileName) {
  return path5.join(getMiyaRuntimeDir(projectDir), fileName);
}
function ensureDir(file2) {
  fs5.mkdirSync(path5.dirname(file2), { recursive: true });
}
function cloneValue2(value) {
  return JSON.parse(JSON.stringify(value));
}
function writeJson(file2, value) {
  ensureDir(file2);
  fs5.writeFileSync(file2, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function readJsonObject(file2) {
  if (!fs5.existsSync(file2))
    return {};
  try {
    const parsed = JSON.parse(fs5.readFileSync(file2, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return {};
    }
    return parsed;
  } catch {
    return {};
  }
}
function riskRank(risk) {
  if (risk === "HIGH")
    return 3;
  if (risk === "MED")
    return 2;
  return 1;
}
function maxRisk(current, next) {
  return riskRank(next) > riskRank(current) ? next : current;
}
function deepEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}
function normalizePathToKey(input) {
  const trimmed = input.trim();
  if (!trimmed)
    return "";
  if (trimmed.startsWith("/")) {
    return trimmed.split("/").map((segment) => segment.trim()).filter((segment) => segment.length > 0).join(".");
  }
  return trimmed;
}
function normalizePatchObject(input) {
  if ("jsonPatch" in input && Array.isArray(input.jsonPatch)) {
    return normalizePatchInput(input.jsonPatch);
  }
  if ("patch" in input && input.patch !== undefined) {
    return normalizePatchInput(input.patch);
  }
  const setRaw = "set" in input && input.set && typeof input.set === "object" ? input.set : null;
  const unsetRaw = "unset" in input && Array.isArray(input.unset) ? input.unset : ("reset" in input) && Array.isArray(input.reset) ? input.reset : null;
  if (setRaw || unsetRaw) {
    const patch2 = {
      set: {},
      unset: []
    };
    const errors3 = [];
    if (setRaw) {
      for (const [key, value] of Object.entries(setRaw)) {
        const normalizedKey = normalizePathToKey(key);
        if (!normalizedKey) {
          errors3.push(`Invalid set key: ${key}`);
          continue;
        }
        patch2.set[normalizedKey] = value;
      }
    }
    if (unsetRaw) {
      for (const key of unsetRaw) {
        const normalizedKey = normalizePathToKey(String(key));
        if (!normalizedKey) {
          errors3.push(`Invalid unset key: ${String(key)}`);
          continue;
        }
        patch2.unset.push(normalizedKey);
      }
    }
    patch2.unset = [...new Set(patch2.unset)];
    return { patch: patch2, errors: errors3 };
  }
  const patch = { set: {}, unset: [] };
  for (const [key, value] of Object.entries(input)) {
    const normalizedKey = normalizePathToKey(key);
    if (!normalizedKey)
      continue;
    patch.set[normalizedKey] = value;
  }
  return { patch, errors: [] };
}
function normalizeJsonPatchArray(input) {
  const patch = { set: {}, unset: [] };
  const errors3 = [];
  for (const item of input) {
    if (!item || typeof item !== "object" || Array.isArray(item)) {
      errors3.push("JSON Patch item must be an object.");
      continue;
    }
    const op = String(item.op ?? "").toLowerCase();
    const pathValue = String(item.path ?? "");
    const key = normalizePathToKey(pathValue);
    if (!key) {
      errors3.push(`JSON Patch path is invalid: ${pathValue}`);
      continue;
    }
    if (op === "remove") {
      patch.unset.push(key);
      continue;
    }
    if (op === "add" || op === "replace" || op === "set") {
      patch.set[key] = item.value;
      continue;
    }
    errors3.push(`Unsupported JSON Patch operation: ${op}`);
  }
  patch.unset = [...new Set(patch.unset)];
  return { patch, errors: errors3 };
}
function validateValueType(entryValue, value) {
  const valueType = entryValue.type;
  if (valueType === "boolean") {
    return typeof value === "boolean" ? null : `Expected boolean for ${entryValue.key}.`;
  }
  if (valueType === "integer") {
    if (typeof value !== "number" || !Number.isInteger(value)) {
      return `Expected integer for ${entryValue.key}.`;
    }
    if (typeof entryValue.minimum === "number" && value < entryValue.minimum) {
      return `${entryValue.key} must be >= ${entryValue.minimum}.`;
    }
    if (typeof entryValue.maximum === "number" && value > entryValue.maximum) {
      return `${entryValue.key} must be <= ${entryValue.maximum}.`;
    }
    return null;
  }
  if (valueType === "string") {
    return typeof value === "string" ? null : `Expected string for ${entryValue.key}.`;
  }
  if (valueType === "enum") {
    if (typeof value !== "string") {
      return `Expected enum string for ${entryValue.key}.`;
    }
    const options = entryValue.enumValues ?? [];
    if (!options.includes(value)) {
      return `${entryValue.key} must be one of: ${options.join(", ")}.`;
    }
    return null;
  }
  if (valueType === "object") {
    return value && typeof value === "object" && !Array.isArray(value) ? null : `Expected object for ${entryValue.key}.`;
  }
  if (valueType === "array") {
    return Array.isArray(value) ? null : `Expected array for ${entryValue.key}.`;
  }
  return `Unsupported type for ${entryValue.key}.`;
}
function mergeConfigWithDefaults(raw) {
  const merged = cloneValue2(raw);
  for (const item of listSettingEntries()) {
    const current = getNestedValue(merged, item.key);
    if (current === undefined) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
      continue;
    }
    const issue2 = validateValueType(item, current);
    if (issue2) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
    }
  }
  return merged;
}
function ensureSettingsFiles(projectDir) {
  const registryPath = runtimeFile(projectDir, "registry.json");
  const schemaPath = runtimeFile(projectDir, "schema.json");
  const configPath = runtimeFile(projectDir, "config.json");
  writeJson(registryPath, buildRegistryDocument());
  writeJson(schemaPath, buildSchemaDocument());
  if (!fs5.existsSync(configPath)) {
    writeJson(configPath, buildDefaultConfig());
    return;
  }
  const raw = readJsonObject(configPath);
  const normalized = mergeConfigWithDefaults(raw);
  writeJson(configPath, normalized);
}
function readConfig(projectDir) {
  ensureSettingsFiles(projectDir);
  const raw = readJsonObject(runtimeFile(projectDir, "config.json"));
  return mergeConfigWithDefaults(raw);
}
function writeConfig2(projectDir, config2) {
  ensureSettingsFiles(projectDir);
  writeJson(runtimeFile(projectDir, "config.json"), mergeConfigWithDefaults(config2));
}
function normalizePatchInput(input) {
  if (!input) {
    return { patch: cloneValue2(EMPTY_PATCH), errors: ["Patch payload is empty."] };
  }
  if (Array.isArray(input)) {
    return normalizeJsonPatchArray(input);
  }
  if (typeof input !== "object") {
    return {
      patch: cloneValue2(EMPTY_PATCH),
      errors: ["Patch payload must be an object or JSON Patch array."]
    };
  }
  return normalizePatchObject(input);
}
function validateConfigPatch(projectDir, patchInput) {
  const currentConfig = readConfig(projectDir);
  const normalized = normalizePatchInput(patchInput);
  const errors3 = [...normalized.errors];
  const warnings = [];
  const changes = [];
  const keysToCheck = [
    ...Object.keys(normalized.patch.set),
    ...normalized.patch.unset
  ];
  const uniqueKeys = [...new Set(keysToCheck)];
  for (const key of uniqueKeys) {
    const setting = getSettingEntry(key);
    if (!setting) {
      errors3.push(`Unknown setting key: ${key}`);
      continue;
    }
    const isReset = normalized.patch.unset.includes(key);
    const nextValue = isReset ? cloneValue2(setting.defaultValue) : normalized.patch.set[key];
    const previousValue = getNestedValue(currentConfig, key);
    const issue2 = validateValueType(setting, nextValue);
    if (issue2) {
      errors3.push(issue2);
      continue;
    }
    if (deepEqual(previousValue, nextValue)) {
      warnings.push(`${key} is unchanged.`);
      continue;
    }
    changes.push({
      key,
      operation: isReset ? "reset" : "set",
      risk: setting.risk,
      description: setting.description,
      previousValue,
      nextValue,
      requiresEvidence: setting.requiresEvidence
    });
  }
  let highestRisk = "LOW";
  for (const change of changes) {
    highestRisk = maxRisk(highestRisk, change.risk);
  }
  if (normalized.patch.set["outbound.enabled"] === true && normalized.patch.set["desktop.requirePreSendScreenshotVerify"] === false) {
    errors3.push("outbound.enabled=true 时不允许将 desktop.requirePreSendScreenshotVerify 设为 false。");
  }
  if (changes.length === 0 && errors3.length === 0) {
    warnings.push("Patch has no effective changes.");
  }
  const requiredSafetyTier = highestRisk === "HIGH" ? "THOROUGH" : highestRisk === "MED" ? "STANDARD" : "LIGHT";
  return {
    ok: errors3.length === 0 && changes.length > 0,
    errors: errors3,
    warnings,
    normalizedPatch: normalized.patch,
    changes,
    maxRisk: highestRisk,
    requiresEvidence: changes.some((change) => change.requiresEvidence),
    requiredSafetyTier
  };
}
function applyConfigPatch(projectDir, validation) {
  const config2 = readConfig(projectDir);
  for (const change of validation.changes) {
    setNestedValue(config2, change.key, cloneValue2(change.nextValue));
  }
  writeConfig2(projectDir, config2);
  return {
    updatedConfig: readConfig(projectDir),
    applied: validation.changes
  };
}
var EMPTY_PATCH;
var init_store = __esm(() => {
  init_workflow();
  init_registry();
  EMPTY_PATCH = { set: {}, unset: [] };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/core.js
function $constructor2(name, initializer3, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = new Set);
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
var NEVER2, $brand2, $ZodAsyncError2, $ZodEncodeError2, globalConfig2;
var init_core3 = __esm(() => {
  NEVER2 = Object.freeze({
    status: "aborted"
  });
  $brand2 = Symbol("zod_brand");
  $ZodAsyncError2 = class $ZodAsyncError2 extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  $ZodEncodeError2 = class $ZodEncodeError2 extends Error {
    constructor(name) {
      super(`Encountered unidirectional transform during encode: ${name}`);
      this.name = "ZodEncodeError";
    }
  };
  globalConfig2 = {};
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/util.js
var exports_util2 = {};
__export(exports_util2, {
  unwrapMessage: () => unwrapMessage2,
  uint8ArrayToHex: () => uint8ArrayToHex2,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url2,
  uint8ArrayToBase64: () => uint8ArrayToBase642,
  stringifyPrimitive: () => stringifyPrimitive2,
  shallowClone: () => shallowClone2,
  safeExtend: () => safeExtend2,
  required: () => required2,
  randomString: () => randomString2,
  propertyKeyTypes: () => propertyKeyTypes2,
  promiseAllObject: () => promiseAllObject2,
  primitiveTypes: () => primitiveTypes2,
  prefixIssues: () => prefixIssues2,
  pick: () => pick2,
  partial: () => partial2,
  optionalKeys: () => optionalKeys2,
  omit: () => omit2,
  objectClone: () => objectClone2,
  numKeys: () => numKeys2,
  nullish: () => nullish3,
  normalizeParams: () => normalizeParams2,
  mergeDefs: () => mergeDefs2,
  merge: () => merge2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  joinValues: () => joinValues2,
  issue: () => issue2,
  isPlainObject: () => isPlainObject2,
  isObject: () => isObject3,
  hexToUint8Array: () => hexToUint8Array2,
  getSizableOrigin: () => getSizableOrigin2,
  getParsedType: () => getParsedType2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getEnumValues: () => getEnumValues2,
  getElementAtPath: () => getElementAtPath2,
  floatSafeRemainder: () => floatSafeRemainder2,
  finalizeIssue: () => finalizeIssue2,
  extend: () => extend2,
  escapeRegex: () => escapeRegex2,
  esc: () => esc2,
  defineLazy: () => defineLazy2,
  createTransparentProxy: () => createTransparentProxy2,
  cloneDef: () => cloneDef2,
  clone: () => clone2,
  cleanRegex: () => cleanRegex2,
  cleanEnum: () => cleanEnum2,
  captureStackTrace: () => captureStackTrace2,
  cached: () => cached2,
  base64urlToUint8Array: () => base64urlToUint8Array2,
  base64ToUint8Array: () => base64ToUint8Array2,
  assignProp: () => assignProp2,
  assertNotEqual: () => assertNotEqual2,
  assertNever: () => assertNever2,
  assertIs: () => assertIs2,
  assertEqual: () => assertEqual2,
  assert: () => assert2,
  allowsEval: () => allowsEval2,
  aborted: () => aborted2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  Class: () => Class2,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {}
function assertNever2(_x) {
  throw new Error;
}
function assert2(_) {}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === undefined;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy2(object2, key, getter) {
  let value = undefined;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING2) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING2;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone2(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs2(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef2(schema2) {
  return mergeDefs2(schema2._zod.def);
}
function getElementAtPath2(obj, path6) {
  if (!path6)
    return obj;
  return path6.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc2(str) {
  return JSON.stringify(str);
}
function isObject3(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject2(o) {
  if (isObject3(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject3(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone2(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick2(schema2, mask) {
  const currDef = schema2._zod.def;
  const def = mergeDefs2(schema2._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function omit2(schema2, mask) {
  const currDef = schema2._zod.def;
  const def = mergeDefs2(schema2._zod.def, {
    get shape() {
      const newShape = { ...schema2._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function extend2(schema2, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks3 = schema2._zod.def.checks;
  const hasChecks = checks3 && checks3.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs2(schema2._zod.def, {
    get shape() {
      const _shape = { ...schema2._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function safeExtend2(schema2, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema2._zod.def,
    get shape() {
      const _shape = { ...schema2._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: schema2._zod.def.checks
  };
  return clone2(schema2, def);
}
function merge2(a, b) {
  const def = mergeDefs2(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone2(a, def);
}
function partial2(Class2, schema2, mask) {
  const def = mergeDefs2(schema2._zod.def, {
    get shape() {
      const oldShape = schema2._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function required2(Class2, schema2, mask) {
  const def = mergeDefs2(schema2._zod.def, {
    get shape() {
      const oldShape = schema2._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema2, def);
}
function aborted2(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues2(path6, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path6);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config3.customError?.(iss)) ?? unwrapMessage2(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array2(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase642(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array2(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array2(base643 + padding);
}
function uint8ArrayToBase64url2(bytes) {
  return uint8ArrayToBase642(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array2(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex2(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class2 {
  constructor(..._args) {}
}
var EVALUATING2, captureStackTrace2, allowsEval2, getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes2, primitiveTypes2, NUMBER_FORMAT_RANGES2, BIGINT_FORMAT_RANGES2;
var init_util2 = __esm(() => {
  EVALUATING2 = Symbol("evaluating");
  captureStackTrace2 = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
  allowsEval2 = cached2(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  propertyKeyTypes2 = new Set(["string", "number", "symbol"]);
  primitiveTypes2 = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  NUMBER_FORMAT_RANGES2 = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  BIGINT_FORMAT_RANGES2 = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/errors.js
function flattenError2(error48, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error48, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue3 of error49.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError2(error48, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = (error49, path6 = []) => {
    var _a2, _b;
    for (const issue3 of error49.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path6, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath2(_path) {
  const segs = [];
  const path6 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path6) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`✖ ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  → at ${toDotPath2(issue3.path)}`);
  }
  return lines.join(`
`);
}
var initializer3 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
}, $ZodError2, $ZodRealError2;
var init_errors3 = __esm(() => {
  init_core3();
  init_util2();
  $ZodError2 = $constructor2("$ZodError", initializer3);
  $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/parse.js
var _parse2 = (_Err) => (schema2, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema2._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, _params?.callee);
    throw e;
  }
  return result.value;
}, parse5, _parseAsync2 = (_Err) => async (schema2, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema2._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, params?.callee);
    throw e;
  }
  return result.value;
}, parseAsync3, _safeParse2 = (_Err) => (schema2, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema2._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, safeParse3, _safeParseAsync2 = (_Err) => async (schema2, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema2._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, safeParseAsync3, _encode2 = (_Err) => (schema2, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse2(_Err)(schema2, value, ctx);
}, encode3, _decode2 = (_Err) => (schema2, value, _ctx) => {
  return _parse2(_Err)(schema2, value, _ctx);
}, decode3, _encodeAsync2 = (_Err) => async (schema2, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync2(_Err)(schema2, value, ctx);
}, encodeAsync3, _decodeAsync2 = (_Err) => async (schema2, value, _ctx) => {
  return _parseAsync2(_Err)(schema2, value, _ctx);
}, decodeAsync3, _safeEncode2 = (_Err) => (schema2, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse2(_Err)(schema2, value, ctx);
}, safeEncode3, _safeDecode2 = (_Err) => (schema2, value, _ctx) => {
  return _safeParse2(_Err)(schema2, value, _ctx);
}, safeDecode3, _safeEncodeAsync2 = (_Err) => async (schema2, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync2(_Err)(schema2, value, ctx);
}, safeEncodeAsync3, _safeDecodeAsync2 = (_Err) => async (schema2, value, _ctx) => {
  return _safeParseAsync2(_Err)(schema2, value, _ctx);
}, safeDecodeAsync3;
var init_parse3 = __esm(() => {
  init_core3();
  init_errors3();
  init_util2();
  parse5 = /* @__PURE__ */ _parse2($ZodRealError2);
  parseAsync3 = /* @__PURE__ */ _parseAsync2($ZodRealError2);
  safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
  safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
  encode3 = /* @__PURE__ */ _encode2($ZodRealError2);
  decode3 = /* @__PURE__ */ _decode2($ZodRealError2);
  encodeAsync3 = /* @__PURE__ */ _encodeAsync2($ZodRealError2);
  decodeAsync3 = /* @__PURE__ */ _decodeAsync2($ZodRealError2);
  safeEncode3 = /* @__PURE__ */ _safeEncode2($ZodRealError2);
  safeDecode3 = /* @__PURE__ */ _safeDecode2($ZodRealError2);
  safeEncodeAsync3 = /* @__PURE__ */ _safeEncodeAsync2($ZodRealError2);
  safeDecodeAsync3 = /* @__PURE__ */ _safeDecodeAsync2($ZodRealError2);
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/regexes.js
var exports_regexes2 = {};
__export(exports_regexes2, {
  xid: () => xid3,
  uuid7: () => uuid72,
  uuid6: () => uuid62,
  uuid4: () => uuid42,
  uuid: () => uuid3,
  uppercase: () => uppercase2,
  unicodeEmail: () => unicodeEmail2,
  undefined: () => _undefined4,
  ulid: () => ulid3,
  time: () => time3,
  string: () => string4,
  sha512_hex: () => sha512_hex2,
  sha512_base64url: () => sha512_base64url2,
  sha512_base64: () => sha512_base642,
  sha384_hex: () => sha384_hex2,
  sha384_base64url: () => sha384_base64url2,
  sha384_base64: () => sha384_base642,
  sha256_hex: () => sha256_hex2,
  sha256_base64url: () => sha256_base64url2,
  sha256_base64: () => sha256_base642,
  sha1_hex: () => sha1_hex2,
  sha1_base64url: () => sha1_base64url2,
  sha1_base64: () => sha1_base642,
  rfc5322Email: () => rfc5322Email2,
  number: () => number4,
  null: () => _null4,
  nanoid: () => nanoid3,
  md5_hex: () => md5_hex2,
  md5_base64url: () => md5_base64url2,
  md5_base64: () => md5_base642,
  lowercase: () => lowercase2,
  ksuid: () => ksuid3,
  ipv6: () => ipv63,
  ipv4: () => ipv43,
  integer: () => integer2,
  idnEmail: () => idnEmail2,
  html5Email: () => html5Email2,
  hostname: () => hostname3,
  hex: () => hex3,
  guid: () => guid3,
  extendedDuration: () => extendedDuration2,
  emoji: () => emoji3,
  email: () => email3,
  e164: () => e1643,
  duration: () => duration3,
  domain: () => domain2,
  datetime: () => datetime3,
  date: () => date5,
  cuid2: () => cuid23,
  cuid: () => cuid5,
  cidrv6: () => cidrv63,
  cidrv4: () => cidrv43,
  browserEmail: () => browserEmail2,
  boolean: () => boolean4,
  bigint: () => bigint4,
  base64url: () => base64url3,
  base64: () => base643
});
function emoji3() {
  return new RegExp(_emoji3, "u");
}
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time4 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time4}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
function fixedBase642(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url2(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid5, cuid23, ulid3, xid3, ksuid3, nanoid3, duration3, extendedDuration2, guid3, uuid3 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, uuid42, uuid62, uuid72, email3, html5Email2, rfc5322Email2, unicodeEmail2, idnEmail2, browserEmail2, _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, ipv43, ipv63, cidrv43, cidrv63, base643, base64url3, hostname3, domain2, e1643, dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`, date5, string4 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, bigint4, integer2, number4, boolean4, _null4, _undefined4, lowercase2, uppercase2, hex3, md5_hex2, md5_base642, md5_base64url2, sha1_hex2, sha1_base642, sha1_base64url2, sha256_hex2, sha256_base642, sha256_base64url2, sha384_hex2, sha384_base642, sha384_base64url2, sha512_hex2, sha512_base642, sha512_base64url2;
var init_regexes2 = __esm(() => {
  cuid5 = /^[cC][^\s-]{8,}$/;
  cuid23 = /^[0-9a-z]+$/;
  ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  xid3 = /^[0-9a-vA-V]{20}$/;
  ksuid3 = /^[A-Za-z0-9]{27}$/;
  nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
  duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  uuid42 = /* @__PURE__ */ uuid3(4);
  uuid62 = /* @__PURE__ */ uuid3(6);
  uuid72 = /* @__PURE__ */ uuid3(7);
  email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  idnEmail2 = unicodeEmail2;
  browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
  cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  base64url3 = /^[A-Za-z0-9_-]*$/;
  hostname3 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  e1643 = /^\+(?:[0-9]){6,14}[0-9]$/;
  date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
  bigint4 = /^-?\d+n?$/;
  integer2 = /^-?\d+$/;
  number4 = /^-?\d+(?:\.\d+)?/;
  boolean4 = /^(?:true|false)$/i;
  _null4 = /^null$/i;
  _undefined4 = /^undefined$/i;
  lowercase2 = /^[^A-Z]*$/;
  uppercase2 = /^[^a-z]*$/;
  hex3 = /^[0-9a-fA-F]*$/;
  md5_hex2 = /^[0-9a-fA-F]{32}$/;
  md5_base642 = /* @__PURE__ */ fixedBase642(22, "==");
  md5_base64url2 = /* @__PURE__ */ fixedBase64url2(22);
  sha1_hex2 = /^[0-9a-fA-F]{40}$/;
  sha1_base642 = /* @__PURE__ */ fixedBase642(27, "=");
  sha1_base64url2 = /* @__PURE__ */ fixedBase64url2(27);
  sha256_hex2 = /^[0-9a-fA-F]{64}$/;
  sha256_base642 = /* @__PURE__ */ fixedBase642(43, "=");
  sha256_base64url2 = /* @__PURE__ */ fixedBase64url2(43);
  sha384_hex2 = /^[0-9a-fA-F]{96}$/;
  sha384_base642 = /* @__PURE__ */ fixedBase642(64, "");
  sha384_base64url2 = /* @__PURE__ */ fixedBase64url2(64);
  sha512_hex2 = /^[0-9a-fA-F]{128}$/;
  sha512_base642 = /* @__PURE__ */ fixedBase642(86, "==");
  sha512_base64url2 = /* @__PURE__ */ fixedBase64url2(86);
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
var $ZodCheck2, numericOriginMap2, $ZodCheckLessThan2, $ZodCheckGreaterThan2, $ZodCheckMultipleOf2, $ZodCheckNumberFormat2, $ZodCheckBigIntFormat2, $ZodCheckMaxSize2, $ZodCheckMinSize2, $ZodCheckSizeEquals2, $ZodCheckMaxLength2, $ZodCheckMinLength2, $ZodCheckLengthEquals2, $ZodCheckStringFormat2, $ZodCheckRegex2, $ZodCheckLowerCase2, $ZodCheckUpperCase2, $ZodCheckIncludes2, $ZodCheckStartsWith2, $ZodCheckEndsWith2, $ZodCheckProperty2, $ZodCheckMimeType2, $ZodCheckOverwrite2;
var init_checks3 = __esm(() => {
  init_core3();
  init_regexes2();
  init_util2();
  $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
    var _a2;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
  });
  numericOriginMap2 = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const origin = numericOriginMap2[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const origin = numericOriginMap2[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a2;
      (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck2.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer2;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inst
        });
      }
    };
  });
  $ZodCheckBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inst
        });
      }
    };
  });
  $ZodCheckMaxSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxSize", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum)
        return;
      payload.issues.push({
        origin: getSizableOrigin2(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMinSize", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum)
        return;
      payload.issues.push({
        origin: getSizableOrigin2(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckSizeEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckSizeEquals", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size)
        return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin2(input),
        ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin2(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin2(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin2(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
    var _a2, _b;
    $ZodCheck2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = new Set);
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b = inst._zod).check ?? (_b.check = () => {});
  });
  $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase2);
    $ZodCheckStringFormat2.init(inst, def);
  });
  $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase2);
    $ZodCheckStringFormat2.init(inst, def);
  });
  $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const escapedRegex = escapeRegex2(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckProperty2 = /* @__PURE__ */ $constructor2("$ZodCheckProperty", (inst, def) => {
    $ZodCheck2.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run({
        value: payload.value[def.property],
        issues: []
      }, {});
      if (result instanceof Promise) {
        return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
      }
      handleCheckPropertyResult2(result, payload, def.property);
      return;
    };
  });
  $ZodCheckMimeType2 = /* @__PURE__ */ $constructor2("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type))
        return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck2.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/doc.js
class Doc2 {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/versions.js
var version2;
var init_versions2 = __esm(() => {
  version2 = {
    major: 4,
    minor: 1,
    patch: 8
  };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/schemas.js
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase642(padded);
}
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult2(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef2(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall2(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
    } else {
      handlePropertyResult2(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted2(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult2(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
function handleDefaultResult2(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult2(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.out, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.in, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult2(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
var $ZodType2, $ZodString2, $ZodStringFormat2, $ZodGUID2, $ZodUUID2, $ZodEmail2, $ZodURL2, $ZodEmoji2, $ZodNanoID2, $ZodCUID3, $ZodCUID22, $ZodULID2, $ZodXID2, $ZodKSUID2, $ZodISODateTime2, $ZodISODate2, $ZodISOTime2, $ZodISODuration2, $ZodIPv42, $ZodIPv62, $ZodCIDRv42, $ZodCIDRv62, $ZodBase642, $ZodBase64URL2, $ZodE1642, $ZodJWT2, $ZodCustomStringFormat2, $ZodNumber2, $ZodNumberFormat2, $ZodBoolean2, $ZodBigInt2, $ZodBigIntFormat2, $ZodSymbol2, $ZodUndefined2, $ZodNull2, $ZodAny2, $ZodUnknown2, $ZodNever2, $ZodVoid2, $ZodDate2, $ZodArray2, $ZodObject2, $ZodObjectJIT2, $ZodUnion2, $ZodDiscriminatedUnion2, $ZodIntersection2, $ZodTuple2, $ZodRecord2, $ZodMap2, $ZodSet2, $ZodEnum2, $ZodLiteral2, $ZodFile2, $ZodTransform2, $ZodOptional2, $ZodNullable2, $ZodDefault2, $ZodPrefault2, $ZodNonOptional2, $ZodSuccess2, $ZodCatch2, $ZodNaN2, $ZodPipe2, $ZodCodec2, $ZodReadonly2, $ZodTemplateLiteral2, $ZodFunction2, $ZodPromise2, $ZodLazy2, $ZodCustom2;
var init_schemas3 = __esm(() => {
  init_checks3();
  init_core3();
  init_parse3();
  init_regexes2();
  init_util2();
  init_versions2();
  init_util2();
  $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
    var _a2;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version2;
    const checks3 = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks3.unshift(inst);
    }
    for (const ch of checks3) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks3.length === 0) {
      (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks4, ctx) => {
        let isAborted = aborted2(payload);
        let asyncResult;
        for (const ch of checks4) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError2;
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted)
                isAborted = aborted2(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted)
              isAborted = aborted2(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      const handleCanaryResult = (canary, payload, ctx) => {
        if (aborted2(canary)) {
          canary.aborted = true;
          return canary;
        }
        const checkResult = runChecks(payload, checks3, ctx);
        if (checkResult instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError2;
          return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
        }
        return inst._zod.parse(checkResult, ctx);
      };
      inst._zod.run = (payload, ctx) => {
        if (ctx.skipChecks) {
          return inst._zod.parse(payload, ctx);
        }
        if (ctx.direction === "backward") {
          const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
          if (canary instanceof Promise) {
            return canary.then((canary2) => {
              return handleCanaryResult(canary2, payload, ctx);
            });
          }
          return handleCanaryResult(canary, payload, ctx);
        }
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError2;
          return result.then((result2) => runChecks(result2, checks3, ctx));
        }
        return runChecks(result, checks3, ctx);
      };
    }
    inst["~standard"] = {
      validate: (value) => {
        try {
          const r = safeParse3(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    };
  });
  $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {}
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat2.init(inst, def);
    $ZodString2.init(inst, def);
  });
  $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === undefined)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid3(v));
    } else
      def.pattern ?? (def.pattern = uuid3());
    $ZodStringFormat2.init(inst, def);
  });
  $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const trimmed = payload.value.trim();
        const url2 = new URL(trimmed);
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url2.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: hostname3.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.normalize) {
          payload.value = url2.href;
        } else {
          payload.value = trimmed;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji3());
    $ZodStringFormat2.init(inst, def);
  });
  $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid5);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid23);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime3(def));
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date5);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time3(def));
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv43);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = `ipv4`;
    });
  });
  $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv63);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = `ipv6`;
    });
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv43);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv63);
    $ZodStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      const parts = payload.value.split("/");
      try {
        if (parts.length !== 2)
          throw new Error;
        const [address, prefix] = parts;
        if (!prefix)
          throw new Error;
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error;
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error;
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base643);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.contentEncoding = "base64";
    });
    inst._zod.check = (payload) => {
      if (isValidBase642(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url3);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
      if (isValidBase64URL2(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e1643);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT2(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number4;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
    $ZodCheckNumberFormat2.init(inst, def);
    $ZodNumber2.init(inst, def);
  });
  $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = boolean4;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodBigInt2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = bigint4;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {}
      if (typeof payload.value === "bigint")
        return payload;
      payload.issues.push({
        expected: "bigint",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
    $ZodCheckBigIntFormat2.init(inst, def);
    $ZodBigInt2.init(inst, def);
  });
  $ZodSymbol2 = /* @__PURE__ */ $constructor2("$ZodSymbol", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "symbol")
        return payload;
      payload.issues.push({
        expected: "symbol",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodUndefined2 = /* @__PURE__ */ $constructor2("$ZodUndefined", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = _undefined4;
    inst._zod.values = new Set([undefined]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = _null4;
    inst._zod.values = new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodAny2 = /* @__PURE__ */ $constructor2("$ZodAny", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodVoid2 = /* @__PURE__ */ $constructor2("$ZodVoid", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "void",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodDate2 = /* @__PURE__ */ $constructor2("$ZodDate", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {}
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate)
        return payload;
      payload.issues.push({
        expected: "date",
        code: "invalid_type",
        input,
        ...isDate ? { received: "Invalid Date" } : {},
        inst
      });
      return payload;
    };
  });
  $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0;i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
        } else {
          handleArrayResult2(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
    $ZodType2.init(inst, def);
    const _normalized = cached2(() => normalizeDef2(def));
    defineLazy2(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = new Set);
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const isObject4 = isObject3;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject4(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = {};
      const proms = [];
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
        } else {
          handlePropertyResult2(r, payload, key, input);
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      return handleCatchall2(proms, input, payload, ctx, _normalized.value, inst);
    };
  });
  $ZodObjectJIT2 = /* @__PURE__ */ $constructor2("$ZodObjectJIT", (inst, def) => {
    $ZodObject2.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached2(() => normalizeDef2(def));
    const generateFastpass = (shape) => {
      const doc2 = new Doc2(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc2(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc2.write(`const input = payload.value;`);
      const ids = Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc2.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id = ids[key];
        const k = esc2(key);
        doc2.write(`const ${id} = ${parseStr(key)};`);
        doc2.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
      doc2.write(`payload.value = newResult;`);
      doc2.write(`return payload;`);
      const fn = doc2.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject4 = isObject3;
    const jit = !globalConfig2.jitless;
    const allowsEval3 = allowsEval2;
    const fastEnabled = jit && allowsEval3.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject4(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall)
          return payload;
        return handleCatchall2([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  });
  $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    defineLazy2(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return;
    });
    defineLazy2(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
      }
      return;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults2(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults2(results2, payload, inst, ctx);
      });
    };
  });
  $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
    $ZodUnion2.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy2(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = new Set;
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached2(() => {
      const opts = def.options;
      const map2 = new Map;
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map2.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map2.set(v, o);
        }
      }
      return map2;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults2(payload, left2, right2);
        });
      }
      return handleIntersectionResults2(payload, left, right);
    };
  });
  $ZodTuple2 = /* @__PURE__ */ $constructor2("$ZodTuple", (inst, def) => {
    $ZodType2.init(inst, def);
    const items = def.items;
    const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: "tuple",
          code: "invalid_type"
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
            input,
            inst,
            origin: "array"
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) {
          if (i >= optStart)
            continue;
        }
        const result = item._zod.run({
          value: input[i],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
        } else {
          handleTupleResult2(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run({
            value: el,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
          } else {
            handleTupleResult2(result, payload, i);
          }
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject2(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      if (def.keyType._zod.values) {
        const values = def.keyType._zod.values;
        payload.value = {};
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues2(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues2(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!values.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (keyResult.issues.length) {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
              input: key,
              path: [key],
              inst
            });
            payload.value[keyResult.value] = keyResult.value;
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodMap2 = /* @__PURE__ */ $constructor2("$ZodMap", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: "map",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      payload.value = new Map;
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
            handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
          }));
        } else {
          handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodSet2 = /* @__PURE__ */ $constructor2("$ZodSet", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: "set",
          code: "invalid_type"
        });
        return payload;
      }
      const proms = [];
      payload.value = new Set;
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleSetResult2(result2, payload)));
        } else
          handleSetResult2(result, payload);
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
    $ZodType2.init(inst, def);
    const values = getEnumValues2(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (valuesSet.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
    $ZodType2.init(inst, def);
    if (def.values.length === 0) {
      throw new Error("Cannot create literal schema with no valid values");
    }
    inst._zod.values = new Set(def.values);
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (inst._zod.values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodFile2 = /* @__PURE__ */ $constructor2("$ZodFile", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input instanceof File)
        return payload;
      payload.issues.push({
        expected: "file",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError2(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError2;
      }
      payload.value = _out;
      return payload;
    };
  });
  $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy2(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    defineLazy2(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r) => handleOptionalResult2(r, payload.value));
        return handleOptionalResult2(result, payload.value);
      }
      if (payload.value === undefined) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy2(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : undefined;
    });
    defineLazy2(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult2(result2, def));
      }
      return handleDefaultResult2(result, def);
    };
  });
  $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult2(result2, inst));
      }
      return handleNonOptionalResult2(result, inst);
    };
  });
  $ZodSuccess2 = /* @__PURE__ */ $constructor2("$ZodSuccess", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError2("ZodSuccess");
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
  $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  $ZodNaN2 = /* @__PURE__ */ $constructor2("$ZodNaN", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "nan",
          code: "invalid_type"
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "values", () => def.in._zod.values);
    defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handlePipeResult2(right2, def.in, ctx));
        }
        return handlePipeResult2(right, def.in, ctx);
      }
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult2(left2, def.out, ctx));
      }
      return handlePipeResult2(left, def.out, ctx);
    };
  });
  $ZodCodec2 = /* @__PURE__ */ $constructor2("$ZodCodec", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "values", () => def.in._zod.values);
    defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handleCodecAResult2(left2, def, ctx));
        }
        return handleCodecAResult2(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handleCodecAResult2(right2, def, ctx));
        }
        return handleCodecAResult2(right, def, ctx);
      }
    };
  });
  $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult2);
      }
      return handleReadonlyResult2(result);
    };
  });
  $ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("$ZodTemplateLiteral", (inst, def) => {
    $ZodType2.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes2.has(typeof part)) {
        regexParts.push(escapeRegex2(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "template_literal",
          code: "invalid_type"
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodFunction2 = /* @__PURE__ */ $constructor2("$ZodFunction", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
      if (typeof func !== "function") {
        throw new Error("implement() must be called with a function");
      }
      return function(...args) {
        const parsedArgs = inst._def.input ? parse5(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse5(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = (func) => {
      if (typeof func !== "function") {
        throw new Error("implementAsync() must be called with a function");
      }
      return async function(...args) {
        const parsedArgs = inst._def.input ? await parseAsync3(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync3(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "function") {
        payload.issues.push({
          code: "invalid_type",
          expected: "function",
          input: payload.value,
          inst
        });
        return payload;
      }
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: "function",
          input: new $ZodTuple2({
            type: "tuple",
            items: args[0],
            rest: args[1]
          }),
          output: inst._def.output
        });
      }
      return new F({
        type: "function",
        input: args[0],
        output: inst._def.output
      });
    };
    inst.output = (output) => {
      const F = inst.constructor;
      return new F({
        type: "function",
        input: inst._def.input,
        output
      });
    };
    return inst;
  });
  $ZodPromise2 = /* @__PURE__ */ $constructor2("$ZodPromise", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
  $ZodLazy2 = /* @__PURE__ */ $constructor2("$ZodLazy", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "innerType", () => def.getter());
    defineLazy2(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
    defineLazy2(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
    defineLazy2(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
    defineLazy2(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
  $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
    $ZodCheck2.init(inst, def);
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
      }
      handleRefineResult2(r, payload, input, inst);
      return;
    };
  });
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ar.js
function ar_default2() {
  return {
    localeError: error48()
  };
}
var error48 = () => {
  const Sizable = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${issue3.expected}، ولكن تم إدخال ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `مدخلات غير مقبولة: يفترض إدخال ${stringifyPrimitive2(issue3.values[0])}`;
        return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` أكبر من اللازم: يفترض أن تكون ${issue3.origin ?? "القيمة"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
        return `أكبر من اللازم: يفترض أن تكون ${issue3.origin ?? "القيمة"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `أصغر من اللازم: يفترض لـ ${issue3.origin} أن يكون ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `أصغر من اللازم: يفترض لـ ${issue3.origin} أن يكون ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `نَص غير مقبول: يجب أن يبدأ بـ "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue3.divisor}`;
      case "unrecognized_keys":
        return `معرف${issue3.keys.length > 1 ? "ات" : ""} غريب${issue3.keys.length > 1 ? "ة" : ""}: ${joinValues2(issue3.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${issue3.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${issue3.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
var init_ar2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/az.js
function az_default2() {
  return {
    localeError: error49()
  };
}
var error49 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${issue3.expected}, daxil olan ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanlış dəyər: gözlənilən ${stringifyPrimitive2(issue3.values[0])}`;
        return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Çox böyük: gözlənilən ${issue3.origin ?? "dəyər"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Çox böyük: gözlənilən ${issue3.origin ?? "dəyər"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Çox kiçik: gözlənilən ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `Çox kiçik: gözlənilən ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
        if (_issue.format === "ends_with")
          return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
        if (_issue.format === "includes")
          return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
        if (_issue.format === "regex")
          return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
        return `Yanlış ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${issue3.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${issue3.origin} daxilində yanlış dəyər`;
      default:
        return `Yanlış dəyər`;
    }
  };
};
var init_az2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/be.js
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default2() {
  return {
    localeError: error50()
  };
}
var error50 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "лік";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масіў";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${issue3.expected}, атрымана ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Няправільны ўвод: чакалася ${stringifyPrimitive2(issue3.values[0])}`;
        return `Няправільны варыянт: чакаўся адзін з ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта вялікі: чакалася, што ${issue3.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `Занадта вялікі: чакалася, што ${issue3.origin ?? "значэнне"} павінна быць ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта малы: чакалася, што ${issue3.origin} павінна ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `Занадта малы: чакалася, што ${issue3.origin} павінна быць ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
        return `Няправільны ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${issue3.keys.length > 1 ? "ключы" : "ключ"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${issue3.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${issue3.origin}`;
      default:
        return `Няправільны ўвод`;
    }
  };
};
var init_be2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ca.js
function ca_default2() {
  return {
    localeError: error51()
  };
}
var error51 = () => {
  const Sizable = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor invàlid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opció invàlida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a màxim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingués ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a mínim" : "més de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingués ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invàlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
        return `Format invàlid per a ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      case "invalid_element":
        return `Element invàlid a ${issue3.origin}`;
      default:
        return `Entrada invàlida`;
    }
  };
};
var init_ca2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/cs.js
function cs_default2() {
  return {
    localeError: error52()
  };
}
var error52 = () => {
  const Sizable = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "číslo";
      }
      case "string": {
        return "řetězec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${issue3.expected}, obdrženo ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatný vstup: očekáváno ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neplatná možnost: očekávána jedna z hodnot ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je příliš velká: ${issue3.origin ?? "hodnota"} musí mít ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš velká: ${issue3.origin ?? "hodnota"} musí být ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je příliš malá: ${issue3.origin ?? "hodnota"} musí mít ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš malá: ${issue3.origin ?? "hodnota"} musí být ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
        return `Neplatný formát ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${issue3.origin}`;
      default:
        return `Neplatný vstup`;
    }
  };
};
var init_cs2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/da.js
function da_default2() {
  return {
    localeError: error53()
  };
}
var error53 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "sæt",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslæt",
    date: "ISO-dato",
    time: "ISO-klokkeslæt",
    duration: "ISO-varighed",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue3.expected)}, fik ${getTypeName(parsedType2(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig værdi: forventede ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af følgende ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal være deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøgle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig værdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
var init_da2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/de.js
function de_default2() {
  return {
    localeError: error54()
  };
}
var error54 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ungültige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ungültige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu groß: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groß: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungültiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungültig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${issue3.origin}`;
      default:
        return `Ungültige Eingabe`;
    }
  };
};
var init_de2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/en.js
function en_default2() {
  return {
    localeError: error55()
  };
}
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error55 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
var init_en2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/eo.js
function eo_default2() {
  return {
    localeError: error56()
  };
}
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error56 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${issue3.expected}, riceviĝis ${parsedType3(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendiĝis ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nevalida opcio: atendiĝis unu el ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendiĝis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiĝis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendiĝis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiĝis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciĝi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiĝi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} ŝlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
var init_eo2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/es.js
function es_default2() {
  return {
    localeError: error57()
  };
}
var error57 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "número",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "número grande",
    symbol: "símbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "función",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeración",
    union: "unión",
    literal: "literal",
    promise: "promesa",
    void: "vacío",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${getTypeName(issue3.expected)}, recibido ${getTypeName(parsedType4(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inválida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opción inválida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `Demasiado pequeño: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeño: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inválida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
        return `Inválido ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${getTypeName(issue3.origin)}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${getTypeName(issue3.origin)}`;
      default:
        return `Entrada inválida`;
    }
  };
};
var init_es2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fa.js
function fa_default2() {
  return {
    localeError: error58()
  };
}
var error58 = () => {
  const Sizable = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرایه";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${issue3.expected} می‌بود، ${parsedType4(issue3.input)} دریافت شد`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `ورودی نامعتبر: می‌بایست ${stringifyPrimitive2(issue3.values[0])} می‌بود`;
        }
        return `گزینه نامعتبر: می‌بایست یکی از ${joinValues2(issue3.values, "|")} می‌بود`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `خیلی بزرگ: ${issue3.origin ?? "مقدار"} باید ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
        }
        return `خیلی بزرگ: ${issue3.origin ?? "مقدار"} باید ${adj}${issue3.maximum.toString()} باشد`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `خیلی کوچک: ${issue3.origin} باید ${adj}${issue3.minimum.toString()} ${sizing.unit} باشد`;
        }
        return `خیلی کوچک: ${issue3.origin} باید ${adj}${issue3.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
        }
        if (_issue.format === "ends_with") {
          return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
        }
        if (_issue.format === "includes") {
          return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
        }
        if (_issue.format === "regex") {
          return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${issue3.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${issue3.keys.length > 1 ? "های" : ""} ناشناس: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${issue3.origin}`;
      case "invalid_union":
        return `ورودی نامعتبر`;
      case "invalid_element":
        return `مقدار نامعتبر در ${issue3.origin}`;
      default:
        return `ورودی نامعتبر`;
    }
  };
};
var init_fa2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fi.js
function fi_default2() {
  return {
    localeError: error59()
  };
}
var error59 = () => {
  const Sizable = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen syöte: täytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
        return `Virheellinen valinta: täytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon täytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon täytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syöte`;
    }
  };
};
var init_fi2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr.js
function fr_default2() {
  return {
    localeError: error60()
  };
}
var error60 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrée invalide : ${issue3.expected} attendu, ${parsedType4(issue3.input)} reçu`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrée invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit être ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit être ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
var init_fr2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default2() {
  return {
    localeError: error61()
  };
}
var error61 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${issue3.expected}, reçu ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrée invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "≤" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "≥" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
var init_fr_CA2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/he.js
function he_default2() {
  return {
    localeError: error62()
  };
}
var error62 = () => {
  const Sizable = {
    string: { unit: "אותיות", verb: "לכלול" },
    file: { unit: "בייטים", verb: "לכלול" },
    array: { unit: "פריטים", verb: "לכלול" },
    set: { unit: "פריטים", verb: "לכלול" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "קלט",
    email: "כתובת אימייל",
    url: "כתובת רשת",
    emoji: "אימוג'י",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "תאריך וזמן ISO",
    date: "תאריך ISO",
    time: "זמן ISO",
    duration: "משך זמן ISO",
    ipv4: "כתובת IPv4",
    ipv6: "כתובת IPv6",
    cidrv4: "טווח IPv4",
    cidrv6: "טווח IPv6",
    base64: "מחרוזת בבסיס 64",
    base64url: "מחרוזת בבסיס 64 לכתובות רשת",
    json_string: "מחרוזת JSON",
    e164: "מספר E.164",
    jwt: "JWT",
    template_literal: "קלט"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `קלט לא תקין: צריך ${issue3.expected}, התקבל ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `קלט לא תקין: צריך ${stringifyPrimitive2(issue3.values[0])}`;
        return `קלט לא תקין: צריך אחת מהאפשרויות  ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `גדול מדי: ${issue3.origin ?? "value"} צריך להיות ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `גדול מדי: ${issue3.origin ?? "value"} צריך להיות ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `קטן מדי: ${issue3.origin} צריך להיות ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `קטן מדי: ${issue3.origin} צריך להיות ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `מחרוזת לא תקינה: חייבת להתחיל ב"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `מחרוזת לא תקינה: חייבת להסתיים ב "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `מחרוזת לא תקינה: חייבת לכלול "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} לא תקין`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${issue3.divisor}`;
      case "unrecognized_keys":
        return `מפתח${issue3.keys.length > 1 ? "ות" : ""} לא מזוה${issue3.keys.length > 1 ? "ים" : "ה"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `מפתח לא תקין ב${issue3.origin}`;
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${issue3.origin}`;
      default:
        return `קלט לא תקין`;
    }
  };
};
var init_he2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/hu.js
function hu_default2() {
  return {
    localeError: error63()
  };
}
var error63 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szám";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tömb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${issue3.expected}, a kapott érték ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Érvénytelen bemenet: a várt érték ${stringifyPrimitive2(issue3.values[0])}`;
        return `Érvénytelen opció: valamelyik érték várt ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Túl nagy: ${issue3.origin ?? "érték"} mérete túl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Túl nagy: a bemeneti érték ${issue3.origin ?? "érték"} túl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Túl kicsi: a bemeneti érték ${issue3.origin} mérete túl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Túl kicsi: a bemeneti érték ${issue3.origin} túl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
        if (_issue.format === "ends_with")
          return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
        if (_issue.format === "includes")
          return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
        return `Érvénytelen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${issue3.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${issue3.origin}`;
      default:
        return `Érvénytelen bemenet`;
    }
  };
};
var init_hu2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/id.js
function id_default2() {
  return {
    localeError: error64()
  };
}
var error64 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
var init_id2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/is.js
function is_default2() {
  return {
    localeError: error65()
  };
}
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "númer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error65 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "að hafa" },
    file: { unit: "bæti", verb: "að hafa" },
    array: { unit: "hluti", verb: "að hafa" },
    set: { unit: "hluti", verb: "að hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefslóð",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tími",
    date: "ISO dagsetning",
    time: "ISO tími",
    duration: "ISO tímalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tölugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Rangt gildi: Þú slóst inn ${parsedType4(issue3.input)} þar sem á að vera ${issue3.expected}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert ráð fyrir ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ógilt val: má vera eitt af eftirfarandi ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of stórt: gert er ráð fyrir að ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of stórt: gert er ráð fyrir að ${issue3.origin ?? "gildi"} sé ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of lítið: gert er ráð fyrir að ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lítið: gert er ráð fyrir að ${issue3.origin} sé ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ógildur strengur: verður að byrja á "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ógildur strengur: verður að enda á "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ógildur strengur: verður að innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ógildur strengur: verður að fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Röng tala: verður að vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Óþekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill í ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi í ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
var init_is2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/it.js
function it_default2() {
  return {
    localeError: error66()
  };
}
var error66 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
var init_it2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ja.js
function ja_default2() {
  return {
    localeError: error67()
  };
}
var error67 = () => {
  const Sizable = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "数値";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "配列";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `無効な入力: ${issue3.expected}が期待されましたが、${parsedType5(issue3.input)}が入力されました`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `無効な入力: ${stringifyPrimitive2(issue3.values[0])}が期待されました`;
        return `無効な選択: ${joinValues2(issue3.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const adj = issue3.inclusive ? "以下である" : "より小さい";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `大きすぎる値: ${issue3.origin ?? "値"}は${issue3.maximum.toString()}${sizing.unit ?? "要素"}${adj}必要があります`;
        return `大きすぎる値: ${issue3.origin ?? "値"}は${issue3.maximum.toString()}${adj}必要があります`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "以上である" : "より大きい";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `小さすぎる値: ${issue3.origin}は${issue3.minimum.toString()}${sizing.unit}${adj}必要があります`;
        return `小さすぎる値: ${issue3.origin}は${issue3.minimum.toString()}${adj}必要があります`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
        if (_issue.format === "ends_with")
          return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
        if (_issue.format === "includes")
          return `無効な文字列: "${_issue.includes}"を含む必要があります`;
        if (_issue.format === "regex")
          return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
        return `無効な${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${issue3.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${issue3.keys.length > 1 ? "群" : ""}: ${joinValues2(issue3.keys, "、")}`;
      case "invalid_key":
        return `${issue3.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${issue3.origin}内の無効な値`;
      default:
        return `無効な入力`;
    }
  };
};
var init_ja2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ka.js
function ka_default2() {
  return {
    localeError: error68()
  };
}
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "რიცხვი";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "მასივი";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "სტრინგი",
    boolean: "ბულეანი",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "ფუნქცია"
  };
  return typeMap[t] ?? t;
}, error68 = () => {
  const Sizable = {
    string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" },
    file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" },
    array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" },
    set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "შეყვანა",
    email: "ელ-ფოსტის მისამართი",
    url: "URL",
    emoji: "ემოჯი",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "თარიღი-დრო",
    date: "თარიღი",
    time: "დრო",
    duration: "ხანგრძლივობა",
    ipv4: "IPv4 მისამართი",
    ipv6: "IPv6 მისამართი",
    cidrv4: "IPv4 დიაპაზონი",
    cidrv6: "IPv6 დიაპაზონი",
    base64: "base64-კოდირებული სტრინგი",
    base64url: "base64url-კოდირებული სტრინგი",
    json_string: "JSON სტრინგი",
    e164: "E.164 ნომერი",
    jwt: "JWT",
    template_literal: "შეყვანა"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `არასწორი შეყვანა: მოსალოდნელი ${issue3.expected}, მიღებული ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `არასწორი შეყვანა: მოსალოდნელი ${stringifyPrimitive2(issue3.values[0])}`;
        return `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${joinValues2(issue3.values, "|")}-დან`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ზედმეტად დიდი: მოსალოდნელი ${issue3.origin ?? "მნიშვნელობა"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `ზედმეტად დიდი: მოსალოდნელი ${issue3.origin ?? "მნიშვნელობა"} იყოს ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `ზედმეტად პატარა: მოსალოდნელი ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `ზედმეტად პატარა: მოსალოდნელი ${issue3.origin} იყოს ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `არასწორი სტრინგი: უნდა იწყებოდეს "${_issue.prefix}"-ით`;
        }
        if (_issue.format === "ends_with")
          return `არასწორი სტრინგი: უნდა მთავრდებოდეს "${_issue.suffix}"-ით`;
        if (_issue.format === "includes")
          return `არასწორი სტრინგი: უნდა შეიცავდეს "${_issue.includes}"-ს`;
        if (_issue.format === "regex")
          return `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${_issue.pattern}`;
        return `არასწორი ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `არასწორი რიცხვი: უნდა იყოს ${issue3.divisor}-ის ჯერადი`;
      case "unrecognized_keys":
        return `უცნობი გასაღებ${issue3.keys.length > 1 ? "ები" : "ი"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `არასწორი გასაღები ${issue3.origin}-ში`;
      case "invalid_union":
        return "არასწორი შეყვანა";
      case "invalid_element":
        return `არასწორი მნიშვნელობა ${issue3.origin}-ში`;
      default:
        return `არასწორი შეყვანა`;
    }
  };
};
var init_ka2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/km.js
function km_default2() {
  return {
    localeError: error69()
  };
}
var error69 = () => {
  const Sizable = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "អារេ (Array)";
        }
        if (data === null) {
          return "គ្មានតម្លៃ (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${issue3.expected} ប៉ុន្តែទទួលបាន ${parsedType6(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${stringifyPrimitive2(issue3.values[0])}`;
        return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `ធំពេក៖ ត្រូវការ ${issue3.origin ?? "តម្លៃ"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "ធាតុ"}`;
        return `ធំពេក៖ ត្រូវការ ${issue3.origin ?? "តម្លៃ"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `តូចពេក៖ ត្រូវការ ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `តូចពេក៖ ត្រូវការ ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;
        return `មិនត្រឹមត្រូវ៖ ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue3.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue3.origin}`;
      case "invalid_union":
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue3.origin}`;
      default:
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
    }
  };
};
var init_km2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/kh.js
function kh_default2() {
  return km_default2();
}
var init_kh2 = __esm(() => {
  init_km2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ko.js
function ko_default2() {
  return {
    localeError: error70()
  };
}
var error70 = () => {
  const Sizable = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${issue3.expected}, 받은 타입은 ${parsedType6(issue3.input)}입니다`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `잘못된 입력: 값은 ${stringifyPrimitive2(issue3.values[0])} 이어야 합니다`;
        return `잘못된 옵션: ${joinValues2(issue3.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const adj = issue3.inclusive ? "이하" : "미만";
        const suffix = adj === "미만" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing)
          return `${issue3.origin ?? "값"}이 너무 큽니다: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "값"}이 너무 큽니다: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "이상" : "초과";
        const suffix = adj === "이상" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing) {
          return `${issue3.origin ?? "값"}이 너무 작습니다: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "값"}이 너무 작습니다: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
        }
        if (_issue.format === "ends_with")
          return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
        if (_issue.format === "includes")
          return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
        if (_issue.format === "regex")
          return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
        return `잘못된 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${issue3.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${issue3.origin}`;
      case "invalid_union":
        return `잘못된 입력`;
      case "invalid_element":
        return `잘못된 값: ${issue3.origin}`;
      default:
        return `잘못된 입력`;
    }
  };
};
var init_ko2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber2(number5) {
  const abs = Math.abs(number5);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default2() {
  return {
    localeError: error71()
  };
}
var parsedType6 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
}, parsedTypeFromType = (t, data = undefined) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skaičius";
    }
    case "bigint": {
      return "sveikasis skaičius";
    }
    case "string": {
      return "eilutė";
    }
    case "boolean": {
      return "loginė reikšmė";
    }
    case "undefined":
    case "void": {
      return "neapibrėžta reikšmė";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === undefined)
        return "nežinomas objektas";
      if (data === null)
        return "nulinė reikšmė";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    case "null": {
      return "nulinė reikšmė";
    }
  }
  return t;
}, capitalizeFirstCharacter2 = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
}, error71 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simbolių"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne ilgesnė kaip",
          notInclusive: "turi būti trumpesnė kaip"
        },
        bigger: {
          inclusive: "turi būti ne trumpesnė kaip",
          notInclusive: "turi būti ilgesnė kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "baitų"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne didesnis kaip",
          notInclusive: "turi būti mažesnis kaip"
        },
        bigger: {
          inclusive: "turi būti ne mažesnis kaip",
          notInclusive: "turi būti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "įvestis",
    email: "el. pašto adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukmė",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 užkoduota eilutė",
    base64url: "base64url užkoduota eilutė",
    json_string: "JSON eilutė",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "įvestis"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue3.input)}, o tikėtasi - ${parsedTypeFromType(issue3.expected)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo būti ${stringifyPrimitive2(issue3.values[0])}`;
        return `Privalo būti vienas iš ${joinValues2(issue3.values, "|")} pasirinkimų`;
      case "too_big": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikšmė")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue3.inclusive ? "ne didesnis kaip" : "mažesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikšmė")} turi būti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikšmė")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue3.inclusive ? "ne mažesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikšmė")} turi būti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilutė privalo prasidėti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilutė privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilutė privalo įtraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilutė privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skaičius privalo būti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpažint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga įvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue3.origin);
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reikšmė")} turi klaidingą įvestį`;
      }
      default:
        return "Klaidinga įvestis";
    }
  };
};
var init_lt2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/mk.js
function mk_default2() {
  return {
    localeError: error72()
  };
}
var error72 = () => {
  const Sizable = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "број";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "низа";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${issue3.expected}, примено ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Грешана опција: се очекува една ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Премногу голем: се очекува ${issue3.origin ?? "вредноста"} да има ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "елементи"}`;
        return `Премногу голем: се очекува ${issue3.origin ?? "вредноста"} да биде ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Премногу мал: се очекува ${issue3.origin} да има ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Премногу мал: се очекува ${issue3.origin} да биде ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${issue3.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${issue3.origin}`;
      default:
        return `Грешен внес`;
    }
  };
};
var init_mk2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ms.js
function ms_default2() {
  return {
    localeError: error73()
  };
}
var error73 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
var init_ms2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/nl.js
function nl_default2() {
  return {
    localeError: error74()
  };
}
var error74 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ongeldige optie: verwacht één van ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
var init_nl2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/no.js
function no_default2() {
  return {
    localeError: error75()
  };
}
var error75 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til å ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til å ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til å ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til å ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: må starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: må ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: må inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
var init_no2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ota.js
function ota_default2() {
  return {
    localeError: error76()
  };
}
var error76 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${issue3.expected}, alınan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Fâsit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Fâsit tercih: mûteberler ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla büyük: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
        return `Fazla büyük: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla küçük: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
        }
        return `Fazla küçük: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
        if (_issue.format === "ends_with")
          return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
        if (_issue.format === "regex")
          return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
        return `Fâsit ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${issue3.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${issue3.origin} için tanınmayan kıymet var.`;
      default:
        return `Kıymet tanınamadı.`;
    }
  };
};
var init_ota2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ps.js
function ps_default2() {
  return {
    localeError: error77()
  };
}
var error77 = () => {
  const Sizable = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "ارې";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${issue3.expected} وای, مګر ${parsedType7(issue3.input)} ترلاسه شو`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `ناسم ورودي: باید ${stringifyPrimitive2(issue3.values[0])} وای`;
        }
        return `ناسم انتخاب: باید یو له ${joinValues2(issue3.values, "|")} څخه وای`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `ډیر لوی: ${issue3.origin ?? "ارزښت"} باید ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "عنصرونه"} ولري`;
        }
        return `ډیر لوی: ${issue3.origin ?? "ارزښت"} باید ${adj}${issue3.maximum.toString()} وي`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `ډیر کوچنی: ${issue3.origin} باید ${adj}${issue3.minimum.toString()} ${sizing.unit} ولري`;
        }
        return `ډیر کوچنی: ${issue3.origin} باید ${adj}${issue3.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `ناسم متن: باید د "${_issue.prefix}" سره پیل شي`;
        }
        if (_issue.format === "ends_with") {
          return `ناسم متن: باید د "${_issue.suffix}" سره پای ته ورسيږي`;
        }
        if (_issue.format === "includes") {
          return `ناسم متن: باید "${_issue.includes}" ولري`;
        }
        if (_issue.format === "regex") {
          return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${issue3.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${issue3.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${issue3.origin} کې`;
      case "invalid_union":
        return `ناسمه ورودي`;
      case "invalid_element":
        return `ناسم عنصر په ${issue3.origin} کې`;
      default:
        return `ناسمه ورودي`;
    }
  };
};
var init_ps2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pl.js
function pl_default2() {
  return {
    localeError: error78()
  };
}
var error78 = () => {
  const Sizable = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawidłowe dane wejściowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za duża wartość: oczekiwano, że ${issue3.origin ?? "wartość"} będzie mieć ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt duż(y/a/e): oczekiwano, że ${issue3.origin ?? "wartość"} będzie wynosić ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za mała wartość: oczekiwano, że ${issue3.origin ?? "wartość"} będzie mieć ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt mał(y/a/e): oczekiwano, że ${issue3.origin ?? "wartość"} będzie wynosić ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
        return `Nieprawidłow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${issue3.origin}`;
      default:
        return `Nieprawidłowe dane wejściowe`;
    }
  };
};
var init_pl2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pt.js
function pt_default2() {
  return {
    localeError: error79()
  };
}
var error79 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "número";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${issue3.expected}, recebido ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inválida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opção inválida: esperada uma das ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto inválido: deve começar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inválido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inválido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${issue3.origin}`;
      default:
        return `Campo inválido`;
    }
  };
};
var init_pt2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ru.js
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default2() {
  return {
    localeError: error80()
  };
}
var error80 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "массив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${issue3.expected}, получено ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Неверный ввод: ожидалось ${stringifyPrimitive2(issue3.values[0])}`;
        return `Неверный вариант: ожидалось одно из ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком большое значение: ожидалось, что ${issue3.origin ?? "значение"} будет иметь ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `Слишком большое значение: ожидалось, что ${issue3.origin ?? "значение"} будет ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${issue3.origin} будет иметь ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${issue3.origin} будет ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неверная строка: должна содержать "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
        return `Неверный ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${issue3.keys.length > 1 ? "ые" : "ый"} ключ${issue3.keys.length > 1 ? "и" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${issue3.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${issue3.origin}`;
      default:
        return `Неверные входные данные`;
    }
  };
};
var init_ru2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sl.js
function sl_default2() {
  return {
    localeError: error81()
  };
}
var error81 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "število";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${issue3.expected}, prejeto ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: pričakovano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neveljavna možnost: pričakovano eno izmed ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: pričakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pričakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: pričakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pričakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i ključi" : " ključ"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
var init_sl2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sv.js
function sv_default2() {
  return {
    localeError: error82()
  };
}
var error82 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${issue3.expected}, fick ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: förväntat ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ogiltigt val: förväntade en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `För stor(t): förväntade ${issue3.origin ?? "värdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `För stor(t): förväntat ${issue3.origin ?? "värdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `För lite(t): förväntade ${issue3.origin ?? "värdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `För lite(t): förväntade ${issue3.origin ?? "värdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig sträng: måste börja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig sträng: måste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig sträng: måste innehålla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig sträng: måste matcha mönstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${issue3.origin ?? "värdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
var init_sv2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ta.js
function ta_default2() {
  return {
    localeError: error83()
  };
}
var error83 = () => {
  const Sizable = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "எண் அல்லாதது" : "எண்";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "அணி";
        }
        if (data === null) {
          return "வெறுமை";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue3.expected}, பெறப்பட்டது ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${stringifyPrimitive2(issue3.values[0])}`;
        return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${joinValues2(issue3.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue3.origin ?? "மதிப்பு"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
        }
        return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue3.origin ?? "மதிப்பு"} ${adj}${issue3.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`;
        }
        return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue3.origin} ${adj}${issue3.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
        if (_issue.format === "ends_with")
          return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
        if (_issue.format === "includes")
          return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
        if (_issue.format === "regex")
          return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
        return `தவறான ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${issue3.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${issue3.keys.length > 1 ? "கள்" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${issue3.origin} இல் தவறான மதிப்பு`;
      default:
        return `தவறான உள்ளீடு`;
    }
  };
};
var init_ta2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/th.js
function th_default2() {
  return {
    localeError: error84()
  };
}
var error84 = () => {
  const Sizable = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "อาร์เรย์ (Array)";
        }
        if (data === null) {
          return "ไม่มีค่า (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue3.expected} แต่ได้รับ ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `ค่าไม่ถูกต้อง: ควรเป็น ${stringifyPrimitive2(issue3.values[0])}`;
        return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "ไม่เกิน" : "น้อยกว่า";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `เกินกำหนด: ${issue3.origin ?? "ค่า"} ควรมี${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
        return `เกินกำหนด: ${issue3.origin ?? "ค่า"} ควรมี${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "อย่างน้อย" : "มากกว่า";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `น้อยกว่ากำหนด: ${issue3.origin} ควรมี${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `น้อยกว่ากำหนด: ${issue3.origin} ควรมี${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
        if (_issue.format === "regex")
          return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
        return `รูปแบบไม่ถูกต้อง: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue3.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${issue3.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${issue3.origin}`;
      default:
        return `ข้อมูลไม่ถูกต้อง`;
    }
  };
};
var init_th2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/tr.js
function tr_default2() {
  return {
    localeError: error85()
  };
}
var parsedType7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error85 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${issue3.expected}, alınan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Geçersiz değer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
        return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Çok büyük: beklenen ${issue3.origin ?? "değer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "öğe"}`;
        return `Çok büyük: beklenen ${issue3.origin ?? "değer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Çok küçük: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `Çok küçük: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
        if (_issue.format === "ends_with")
          return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geçersiz metin: "${_issue.includes}" içermeli`;
        if (_issue.format === "regex")
          return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
        return `Geçersiz ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${issue3.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${issue3.origin} içinde geçersiz değer`;
      default:
        return `Geçersiz değer`;
    }
  };
};
var init_tr2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/uk.js
function uk_default2() {
  return {
    localeError: error86()
  };
}
var error86 = () => {
  const Sizable = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${issue3.expected}, отримано ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Неправильні вхідні дані: очікується ${stringifyPrimitive2(issue3.values[0])}`;
        return `Неправильна опція: очікується одне з ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Занадто велике: очікується, що ${issue3.origin ?? "значення"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "елементів"}`;
        return `Занадто велике: очікується, що ${issue3.origin ?? "значення"} буде ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Занадто мале: очікується, що ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Занадто мале: очікується, що ${issue3.origin} буде ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неправильний рядок: повинен містити "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
        return `Неправильний ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${issue3.keys.length > 1 ? "і" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${issue3.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${issue3.origin}`;
      default:
        return `Неправильні вхідні дані`;
    }
  };
};
var init_uk2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ua.js
function ua_default2() {
  return uk_default2();
}
var init_ua2 = __esm(() => {
  init_uk2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ur.js
function ur_default2() {
  return {
    localeError: error87()
  };
}
var error87 = () => {
  const Sizable = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "نمبر";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرے";
        }
        if (data === null) {
          return "نل";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${issue3.expected} متوقع تھا، ${parsedType8(issue3.input)} موصول ہوا`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `غلط ان پٹ: ${stringifyPrimitive2(issue3.values[0])} متوقع تھا`;
        return `غلط آپشن: ${joinValues2(issue3.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `بہت بڑا: ${issue3.origin ?? "ویلیو"} کے ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
        return `بہت بڑا: ${issue3.origin ?? "ویلیو"} کا ${adj}${issue3.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `بہت چھوٹا: ${issue3.origin} کے ${adj}${issue3.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
        }
        return `بہت چھوٹا: ${issue3.origin} کا ${adj}${issue3.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
        }
        if (_issue.format === "ends_with")
          return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
        if (_issue.format === "includes")
          return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
        if (_issue.format === "regex")
          return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
        return `غلط ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${issue3.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${issue3.keys.length > 1 ? "ز" : ""}: ${joinValues2(issue3.keys, "، ")}`;
      case "invalid_key":
        return `${issue3.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${issue3.origin} میں غلط ویلیو`;
      default:
        return `غلط ان پٹ`;
    }
  };
};
var init_ur2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/vi.js
function vi_default2() {
  return {
    localeError: error88()
  };
}
var error88 = () => {
  const Sizable = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "số";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mảng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${issue3.expected}, nhận được ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Đầu vào không hợp lệ: mong đợi ${stringifyPrimitive2(issue3.values[0])}`;
        return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Quá lớn: mong đợi ${issue3.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
        return `Quá lớn: mong đợi ${issue3.origin ?? "giá trị"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Quá nhỏ: mong đợi ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Quá nhỏ: mong đợi ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${issue3.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${issue3.origin}`;
      default:
        return `Đầu vào không hợp lệ`;
    }
  };
};
var init_vi2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default2() {
  return {
    localeError: error89()
  };
}
var error89 = () => {
  const Sizable = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "非数字(NaN)" : "数字";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "数组";
        }
        if (data === null) {
          return "空值(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `无效输入：期望 ${issue3.expected}，实际接收 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `无效输入：期望 ${stringifyPrimitive2(issue3.values[0])}`;
        return `无效选项：期望以下之一 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `数值过大：期望 ${issue3.origin ?? "值"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "个元素"}`;
        return `数值过大：期望 ${issue3.origin ?? "值"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `数值过小：期望 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `数值过小：期望 ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `无效字符串：必须以 "${_issue.prefix}" 开头`;
        if (_issue.format === "ends_with")
          return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
        if (_issue.format === "includes")
          return `无效字符串：必须包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
        return `无效${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${issue3.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${issue3.origin} 中包含无效值(value)`;
      default:
        return `无效输入`;
    }
  };
};
var init_zh_CN2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default2() {
  return {
    localeError: error90()
  };
}
var error90 = () => {
  const Sizable = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${issue3.expected}，但收到 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `無效的輸入值：預期為 ${stringifyPrimitive2(issue3.values[0])}`;
        return `無效的選項：預期為以下其中之一 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `數值過大：預期 ${issue3.origin ?? "值"} 應為 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "個元素"}`;
        return `數值過大：預期 ${issue3.origin ?? "值"} 應為 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `數值過小：預期 ${issue3.origin} 應為 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `數值過小：預期 ${issue3.origin} 應為 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
        }
        if (_issue.format === "ends_with")
          return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
        if (_issue.format === "includes")
          return `無效的字串：必須包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `無效的字串：必須符合格式 ${_issue.pattern}`;
        return `無效的 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${issue3.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${issue3.keys.length > 1 ? "們" : ""}：${joinValues2(issue3.keys, "、")}`;
      case "invalid_key":
        return `${issue3.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${issue3.origin} 中有無效的值`;
      default:
        return `無效的輸入值`;
    }
  };
};
var init_zh_TW2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/yo.js
function yo_default2() {
  return {
    localeError: error91()
  };
}
var error91 = () => {
  const Sizable = {
    string: { unit: "àmi", verb: "ní" },
    file: { unit: "bytes", verb: "ní" },
    array: { unit: "nkan", verb: "ní" },
    set: { unit: "nkan", verb: "ní" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nọ́mbà";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akopọ";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ẹ̀rọ ìbáwọlé",
    email: "àdírẹ́sì ìmẹ́lì",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "àkókò ISO",
    date: "ọjọ́ ISO",
    time: "àkókò ISO",
    duration: "àkókò tó pé ISO",
    ipv4: "àdírẹ́sì IPv4",
    ipv6: "àdírẹ́sì IPv6",
    cidrv4: "àgbègbè IPv4",
    cidrv6: "àgbègbè IPv6",
    base64: "ọ̀rọ̀ tí a kọ́ ní base64",
    base64url: "ọ̀rọ̀ base64url",
    json_string: "ọ̀rọ̀ JSON",
    e164: "nọ́mbà E.164",
    jwt: "JWT",
    template_literal: "ẹ̀rọ ìbáwọlé"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ìbáwọlé aṣìṣe: a ní láti fi ${issue3.expected}, àmọ̀ a rí ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ìbáwọlé aṣìṣe: a ní láti fi ${stringifyPrimitive2(issue3.values[0])}`;
        return `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tó pọ̀ jù: a ní láti jẹ́ pé ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `Tó pọ̀ jù: a ní láti jẹ́ ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Kéré ju: a ní láti jẹ́ pé ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `Kéré ju: a ní láti jẹ́ ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${_issue.pattern}`;
        return `Aṣìṣe: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Bọtìnì àìmọ̀: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Bọtìnì aṣìṣe nínú ${issue3.origin}`;
      case "invalid_union":
        return "Ìbáwọlé aṣìṣe";
      case "invalid_element":
        return `Iye aṣìṣe nínú ${issue3.origin}`;
      default:
        return "Ìbáwọlé aṣìṣe";
    }
  };
};
var init_yo2 = __esm(() => {
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/index.js
var exports_locales2 = {};
__export(exports_locales2, {
  zhTW: () => zh_TW_default2,
  zhCN: () => zh_CN_default2,
  yo: () => yo_default2,
  vi: () => vi_default2,
  ur: () => ur_default2,
  uk: () => uk_default2,
  ua: () => ua_default2,
  tr: () => tr_default2,
  th: () => th_default2,
  ta: () => ta_default2,
  sv: () => sv_default2,
  sl: () => sl_default2,
  ru: () => ru_default2,
  pt: () => pt_default2,
  ps: () => ps_default2,
  pl: () => pl_default2,
  ota: () => ota_default2,
  no: () => no_default2,
  nl: () => nl_default2,
  ms: () => ms_default2,
  mk: () => mk_default2,
  lt: () => lt_default2,
  ko: () => ko_default2,
  km: () => km_default2,
  kh: () => kh_default2,
  ka: () => ka_default2,
  ja: () => ja_default2,
  it: () => it_default2,
  is: () => is_default2,
  id: () => id_default2,
  hu: () => hu_default2,
  he: () => he_default2,
  frCA: () => fr_CA_default2,
  fr: () => fr_default2,
  fi: () => fi_default2,
  fa: () => fa_default2,
  es: () => es_default2,
  eo: () => eo_default2,
  en: () => en_default2,
  de: () => de_default2,
  da: () => da_default2,
  cs: () => cs_default2,
  ca: () => ca_default2,
  be: () => be_default2,
  az: () => az_default2,
  ar: () => ar_default2
});
var init_locales2 = __esm(() => {
  init_ar2();
  init_az2();
  init_be2();
  init_ca2();
  init_cs2();
  init_da2();
  init_de2();
  init_en2();
  init_eo2();
  init_es2();
  init_fa2();
  init_fi2();
  init_fr2();
  init_fr_CA2();
  init_he2();
  init_hu2();
  init_id2();
  init_is2();
  init_it2();
  init_ja2();
  init_ka2();
  init_kh2();
  init_km2();
  init_ko2();
  init_lt2();
  init_mk2();
  init_ms2();
  init_nl2();
  init_no2();
  init_ota2();
  init_ps2();
  init_pl2();
  init_pt2();
  init_ru2();
  init_sl2();
  init_sv2();
  init_ta2();
  init_th2();
  init_tr2();
  init_ua2();
  init_uk2();
  init_ur2();
  init_vi2();
  init_zh_CN2();
  init_zh_TW2();
  init_yo2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/registries.js
class $ZodRegistry2 {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema2, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema2, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      if (this._idmap.has(meta3.id)) {
        throw new Error(`ID ${meta3.id} already exists in the registry`);
      }
      this._idmap.set(meta3.id, schema2);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema2) {
    const meta3 = this._map.get(schema2);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema2);
    return this;
  }
  get(schema2) {
    const p = schema2._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema2) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema2);
  }
  has(schema2) {
    return this._map.has(schema2);
  }
}
function registry2() {
  return new $ZodRegistry2;
}
var $output2, $input2, globalRegistry2;
var init_registries2 = __esm(() => {
  $output2 = Symbol("ZodOutput");
  $input2 = Symbol("ZodInput");
  globalRegistry2 = /* @__PURE__ */ registry2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
function _undefined5(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _void3(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _positive2(params) {
  return _gt2(0, params);
}
function _negative2(params) {
  return _lt2(0, params);
}
function _nonpositive2(params) {
  return _lte2(0, params);
}
function _nonnegative2(params) {
  return _gte2(0, params);
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _property2(property, schema2, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema: schema2,
    ...normalizeParams2(params)
  });
}
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    ...normalizeParams2(params)
  });
}
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone2(defaultValue);
    }
  });
}
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch3(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema2 = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema2;
}
function _refine2(Class3, fn, _params) {
  const schema2 = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema2;
}
function _superRefine2(fn) {
  const ch = _check2((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue2(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check2(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec2;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec2;
}
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
var TimePrecision2;
var init_api2 = __esm(() => {
  init_checks3();
  init_schemas3();
  init_util2();
  TimePrecision2 = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
  };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator2 {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry2;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema2, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema2._zod.def;
    const formatMap2 = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema2);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema2);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema2, result);
    const overrideSchema = schema2._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema2],
        path: _params.path
      };
      const parent = schema2._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema2._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap2[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema2._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema2._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json2.anyOf = options;
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema2._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues2(def.entries);
            if (values.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [val];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema2._zod.bag;
            if (minimum !== undefined)
              file2.minLength = minimum;
            if (maximum !== undefined)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema2._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema2._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta3 = this.metadataRegistry.get(schema2);
    if (meta3)
      Object.assign(result.schema, meta3);
    if (this.io === "input" && isTransforming2(schema2)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema2);
    return _result.schema;
  }
  emit(schema2, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema2);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry2) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry2[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry2[1].defId ?? entry2[1].schema.id ?? `schema${this.counter++}`;
        entry2[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry2[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry2[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry2) => {
      if (entry2[1].schema.$ref) {
        return;
      }
      const seen = entry2[1];
      const { ref, defId } = makeURI(entry2);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema3 = seen.schema;
      for (const key in schema3) {
        delete schema3[key];
      }
      schema3.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry2 of this.seen.entries()) {
        const seen = entry2[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry2 of this.seen.entries()) {
      const seen = entry2[1];
      if (schema2 === entry2[0]) {
        extractToDef(entry2);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry2[0])?.id;
        if (schema2 !== entry2[0] && ext) {
          extractToDef(entry2);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry2[0])?.id;
      if (id) {
        extractToDef(entry2);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry2);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry2);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema3 = seen.def ?? seen.schema;
      const _cached = { ...schema3 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema3.allOf = schema3.allOf ?? [];
          schema3.allOf.push(refSchema);
        } else {
          Object.assign(schema3, refSchema);
          Object.assign(schema3, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema3,
          path: seen.path ?? []
        });
    };
    for (const entry2 of [...this.seen.entries()].reverse()) {
      flattenRef(entry2[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {} else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema2)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry2 of this.seen.entries()) {
      const seen = entry2[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema2(input, _params) {
  if (input instanceof $ZodRegistry2) {
    const gen2 = new JSONSchemaGenerator2(_params);
    const defs = {};
    for (const entry2 of input._idmap.entries()) {
      const [_, schema2] = entry2;
      gen2.process(schema2);
    }
    const schemas3 = {};
    const external2 = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry2 of input._idmap.entries()) {
      const [key, schema2] = entry2;
      schemas3[key] = gen2.emit(schema2, {
        ..._params,
        external: external2
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas3.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas: schemas3 };
  }
  const gen = new JSONSchemaGenerator2(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema2 = _schema;
  const def = schema2._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming2(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming2(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming2(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming2(item, ctx))
          return true;
      }
      if (def.rest && isTransforming2(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "map": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "set": {
      return isTransforming2(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming2(def.innerType, ctx);
    case "lazy":
      return isTransforming2(def.getter(), ctx);
    case "default": {
      return isTransforming2(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming2(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
var init_to_json_schema2 = __esm(() => {
  init_registries2();
  init_util2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/json-schema.js
var exports_json_schema2 = {};
var init_json_schema2 = () => {};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/index.js
var exports_core4 = {};
__export(exports_core4, {
  version: () => version2,
  util: () => exports_util2,
  treeifyError: () => treeifyError2,
  toJSONSchema: () => toJSONSchema2,
  toDotPath: () => toDotPath2,
  safeParseAsync: () => safeParseAsync3,
  safeParse: () => safeParse3,
  safeEncodeAsync: () => safeEncodeAsync3,
  safeEncode: () => safeEncode3,
  safeDecodeAsync: () => safeDecodeAsync3,
  safeDecode: () => safeDecode3,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  prettifyError: () => prettifyError2,
  parseAsync: () => parseAsync3,
  parse: () => parse5,
  locales: () => exports_locales2,
  isValidJWT: () => isValidJWT2,
  isValidBase64URL: () => isValidBase64URL2,
  isValidBase64: () => isValidBase642,
  globalRegistry: () => globalRegistry2,
  globalConfig: () => globalConfig2,
  formatError: () => formatError2,
  flattenError: () => flattenError2,
  encodeAsync: () => encodeAsync3,
  encode: () => encode3,
  decodeAsync: () => decodeAsync3,
  decode: () => decode3,
  config: () => config2,
  clone: () => clone2,
  _xid: () => _xid2,
  _void: () => _void3,
  _uuidv7: () => _uuidv72,
  _uuidv6: () => _uuidv62,
  _uuidv4: () => _uuidv42,
  _uuid: () => _uuid2,
  _url: () => _url2,
  _uppercase: () => _uppercase2,
  _unknown: () => _unknown2,
  _union: () => _union2,
  _undefined: () => _undefined5,
  _ulid: () => _ulid2,
  _uint64: () => _uint642,
  _uint32: () => _uint322,
  _tuple: () => _tuple2,
  _trim: () => _trim2,
  _transform: () => _transform2,
  _toUpperCase: () => _toUpperCase2,
  _toLowerCase: () => _toLowerCase2,
  _templateLiteral: () => _templateLiteral2,
  _symbol: () => _symbol2,
  _superRefine: () => _superRefine2,
  _success: () => _success2,
  _stringbool: () => _stringbool2,
  _stringFormat: () => _stringFormat2,
  _string: () => _string2,
  _startsWith: () => _startsWith2,
  _size: () => _size2,
  _set: () => _set2,
  _safeParseAsync: () => _safeParseAsync2,
  _safeParse: () => _safeParse2,
  _safeEncodeAsync: () => _safeEncodeAsync2,
  _safeEncode: () => _safeEncode2,
  _safeDecodeAsync: () => _safeDecodeAsync2,
  _safeDecode: () => _safeDecode2,
  _regex: () => _regex2,
  _refine: () => _refine2,
  _record: () => _record2,
  _readonly: () => _readonly2,
  _property: () => _property2,
  _promise: () => _promise2,
  _positive: () => _positive2,
  _pipe: () => _pipe2,
  _parseAsync: () => _parseAsync2,
  _parse: () => _parse2,
  _overwrite: () => _overwrite2,
  _optional: () => _optional2,
  _number: () => _number2,
  _nullable: () => _nullable2,
  _null: () => _null5,
  _normalize: () => _normalize2,
  _nonpositive: () => _nonpositive2,
  _nonoptional: () => _nonoptional2,
  _nonnegative: () => _nonnegative2,
  _never: () => _never2,
  _negative: () => _negative2,
  _nativeEnum: () => _nativeEnum2,
  _nanoid: () => _nanoid2,
  _nan: () => _nan2,
  _multipleOf: () => _multipleOf2,
  _minSize: () => _minSize2,
  _minLength: () => _minLength2,
  _min: () => _gte2,
  _mime: () => _mime2,
  _maxSize: () => _maxSize2,
  _maxLength: () => _maxLength2,
  _max: () => _lte2,
  _map: () => _map2,
  _lte: () => _lte2,
  _lt: () => _lt2,
  _lowercase: () => _lowercase2,
  _literal: () => _literal2,
  _length: () => _length2,
  _lazy: () => _lazy2,
  _ksuid: () => _ksuid2,
  _jwt: () => _jwt2,
  _isoTime: () => _isoTime2,
  _isoDuration: () => _isoDuration2,
  _isoDateTime: () => _isoDateTime2,
  _isoDate: () => _isoDate2,
  _ipv6: () => _ipv62,
  _ipv4: () => _ipv42,
  _intersection: () => _intersection2,
  _int64: () => _int642,
  _int32: () => _int322,
  _int: () => _int2,
  _includes: () => _includes2,
  _guid: () => _guid2,
  _gte: () => _gte2,
  _gt: () => _gt2,
  _float64: () => _float642,
  _float32: () => _float322,
  _file: () => _file2,
  _enum: () => _enum3,
  _endsWith: () => _endsWith2,
  _encodeAsync: () => _encodeAsync2,
  _encode: () => _encode2,
  _emoji: () => _emoji4,
  _email: () => _email2,
  _e164: () => _e1642,
  _discriminatedUnion: () => _discriminatedUnion2,
  _default: () => _default3,
  _decodeAsync: () => _decodeAsync2,
  _decode: () => _decode2,
  _date: () => _date2,
  _custom: () => _custom2,
  _cuid2: () => _cuid22,
  _cuid: () => _cuid3,
  _coercedString: () => _coercedString2,
  _coercedNumber: () => _coercedNumber2,
  _coercedDate: () => _coercedDate2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedBigint: () => _coercedBigint2,
  _cidrv6: () => _cidrv62,
  _cidrv4: () => _cidrv42,
  _check: () => _check2,
  _catch: () => _catch3,
  _boolean: () => _boolean2,
  _bigint: () => _bigint2,
  _base64url: () => _base64url2,
  _base64: () => _base642,
  _array: () => _array2,
  _any: () => _any2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  JSONSchema: () => exports_json_schema2,
  Doc: () => Doc2,
  $output: () => $output2,
  $input: () => $input2,
  $constructor: () => $constructor2,
  $brand: () => $brand2,
  $ZodXID: () => $ZodXID2,
  $ZodVoid: () => $ZodVoid2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUUID: () => $ZodUUID2,
  $ZodURL: () => $ZodURL2,
  $ZodULID: () => $ZodULID2,
  $ZodType: () => $ZodType2,
  $ZodTuple: () => $ZodTuple2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodString: () => $ZodString2,
  $ZodSet: () => $ZodSet2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRealError: () => $ZodRealError2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodPromise: () => $ZodPromise2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPipe: () => $ZodPipe2,
  $ZodOptional: () => $ZodOptional2,
  $ZodObjectJIT: () => $ZodObjectJIT2,
  $ZodObject: () => $ZodObject2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNull: () => $ZodNull2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNever: () => $ZodNever2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNaN: () => $ZodNaN2,
  $ZodMap: () => $ZodMap2,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodLazy: () => $ZodLazy2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodJWT: () => $ZodJWT2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODate: () => $ZodISODate2,
  $ZodIPv6: () => $ZodIPv62,
  $ZodIPv4: () => $ZodIPv42,
  $ZodGUID: () => $ZodGUID2,
  $ZodFunction: () => $ZodFunction2,
  $ZodFile: () => $ZodFile2,
  $ZodError: () => $ZodError2,
  $ZodEnum: () => $ZodEnum2,
  $ZodEncodeError: () => $ZodEncodeError2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEmail: () => $ZodEmail2,
  $ZodE164: () => $ZodE1642,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDate: () => $ZodDate2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodCustom: () => $ZodCustom2,
  $ZodCodec: () => $ZodCodec2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCatch: () => $ZodCatch2,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCUID: () => $ZodCUID3,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBase64: () => $ZodBase642,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodArray: () => $ZodArray2,
  $ZodAny: () => $ZodAny2
});
var init_core4 = __esm(() => {
  init_util2();
  init_regexes2();
  init_locales2();
  init_json_schema2();
  init_core3();
  init_parse3();
  init_errors3();
  init_schemas3();
  init_checks3();
  init_versions2();
  init_registries2();
  init_api2();
  init_to_json_schema2();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/checks.js
var init_checks4 = __esm(() => {
  init_core4();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/iso.js
var exports_iso2 = {};
__export(exports_iso2, {
  time: () => time4,
  duration: () => duration4,
  datetime: () => datetime4,
  date: () => date6,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}
var ZodISODateTime2, ZodISODate2, ZodISOTime2, ZodISODuration2;
var init_iso2 = __esm(() => {
  init_core4();
  init_schemas4();
  ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
    $ZodISODateTime2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
    $ZodISODate2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
    $ZodISOTime2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
    $ZodISODuration2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/errors.js
var initializer4 = (inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError2(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError2(inst, mapper)
    },
    addIssue: {
      value: (issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
}, ZodError2, ZodRealError2;
var init_errors4 = __esm(() => {
  init_core4();
  init_core4();
  init_util2();
  ZodError2 = $constructor2("ZodError", initializer4);
  ZodRealError2 = $constructor2("ZodError", initializer4, {
    Parent: Error
  });
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/parse.js
var parse7, parseAsync4, safeParse4, safeParseAsync4, encode4, decode4, encodeAsync4, decodeAsync4, safeEncode4, safeDecode4, safeEncodeAsync4, safeDecodeAsync4;
var init_parse4 = __esm(() => {
  init_core4();
  init_errors4();
  parse7 = /* @__PURE__ */ _parse2(ZodRealError2);
  parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
  safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
  safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
  encode4 = /* @__PURE__ */ _encode2(ZodRealError2);
  decode4 = /* @__PURE__ */ _decode2(ZodRealError2);
  encodeAsync4 = /* @__PURE__ */ _encodeAsync2(ZodRealError2);
  decodeAsync4 = /* @__PURE__ */ _decodeAsync2(ZodRealError2);
  safeEncode4 = /* @__PURE__ */ _safeEncode2(ZodRealError2);
  safeDecode4 = /* @__PURE__ */ _safeDecode2(ZodRealError2);
  safeEncodeAsync4 = /* @__PURE__ */ _safeEncodeAsync2(ZodRealError2);
  safeDecodeAsync4 = /* @__PURE__ */ _safeDecodeAsync2(ZodRealError2);
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/schemas.js
function string5(params) {
  return _string2(ZodString2, params);
}
function email4(params) {
  return _email2(ZodEmail2, params);
}
function guid4(params) {
  return _guid2(ZodGUID2, params);
}
function uuid5(params) {
  return _uuid2(ZodUUID2, params);
}
function uuidv42(params) {
  return _uuidv42(ZodUUID2, params);
}
function uuidv62(params) {
  return _uuidv62(ZodUUID2, params);
}
function uuidv72(params) {
  return _uuidv72(ZodUUID2, params);
}
function url2(params) {
  return _url2(ZodURL2, params);
}
function httpUrl2(params) {
  return _url2(ZodURL2, {
    protocol: /^https?$/,
    hostname: exports_regexes2.domain,
    ...exports_util2.normalizeParams(params)
  });
}
function emoji4(params) {
  return _emoji4(ZodEmoji2, params);
}
function nanoid4(params) {
  return _nanoid2(ZodNanoID2, params);
}
function cuid6(params) {
  return _cuid3(ZodCUID3, params);
}
function cuid24(params) {
  return _cuid22(ZodCUID22, params);
}
function ulid4(params) {
  return _ulid2(ZodULID2, params);
}
function xid4(params) {
  return _xid2(ZodXID2, params);
}
function ksuid4(params) {
  return _ksuid2(ZodKSUID2, params);
}
function ipv44(params) {
  return _ipv42(ZodIPv42, params);
}
function ipv64(params) {
  return _ipv62(ZodIPv62, params);
}
function cidrv44(params) {
  return _cidrv42(ZodCIDRv42, params);
}
function cidrv64(params) {
  return _cidrv62(ZodCIDRv62, params);
}
function base644(params) {
  return _base642(ZodBase642, params);
}
function base64url4(params) {
  return _base64url2(ZodBase64URL2, params);
}
function e1644(params) {
  return _e1642(ZodE1642, params);
}
function jwt2(params) {
  return _jwt2(ZodJWT2, params);
}
function stringFormat2(format, fnOrRegex, _params = {}) {
  return _stringFormat2(ZodCustomStringFormat2, format, fnOrRegex, _params);
}
function hostname4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hostname", exports_regexes2.hostname, _params);
}
function hex4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hex", exports_regexes2.hex, _params);
}
function hash2(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes2[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat2(ZodCustomStringFormat2, format, regex, params);
}
function number5(params) {
  return _number2(ZodNumber2, params);
}
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
function float322(params) {
  return _float322(ZodNumberFormat2, params);
}
function float642(params) {
  return _float642(ZodNumberFormat2, params);
}
function int322(params) {
  return _int322(ZodNumberFormat2, params);
}
function uint322(params) {
  return _uint322(ZodNumberFormat2, params);
}
function boolean5(params) {
  return _boolean2(ZodBoolean2, params);
}
function bigint5(params) {
  return _bigint2(ZodBigInt2, params);
}
function int642(params) {
  return _int642(ZodBigIntFormat2, params);
}
function uint642(params) {
  return _uint642(ZodBigIntFormat2, params);
}
function symbol2(params) {
  return _symbol2(ZodSymbol2, params);
}
function _undefined6(params) {
  return _undefined5(ZodUndefined2, params);
}
function _null6(params) {
  return _null5(ZodNull2, params);
}
function any2() {
  return _any2(ZodAny2);
}
function unknown2() {
  return _unknown2(ZodUnknown2);
}
function never2(params) {
  return _never2(ZodNever2, params);
}
function _void4(params) {
  return _void3(ZodVoid2, params);
}
function date7(params) {
  return _date2(ZodDate2, params);
}
function array2(element, params) {
  return _array2(ZodArray2, element, params);
}
function keyof2(schema2) {
  const shape = schema2._zod.def.shape;
  return _enum4(Object.keys(shape));
}
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", shape ? exports_util2.objectClone(shape) : {});
      return this.shape;
    },
    ...exports_util2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", exports_util2.objectClone(shape));
      return this.shape;
    },
    catchall: never2(),
    ...exports_util2.normalizeParams(params)
  });
}
function looseObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", exports_util2.objectClone(shape));
      return this.shape;
    },
    catchall: unknown2(),
    ...exports_util2.normalizeParams(params)
  });
}
function union2(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...exports_util2.normalizeParams(params)
  });
}
function discriminatedUnion2(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...exports_util2.normalizeParams(params)
  });
}
function intersection2(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
function tuple2(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...exports_util2.normalizeParams(params)
  });
}
function record2(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function partialRecord2(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = undefined;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function map2(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function set2(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function nativeEnum2(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function literal2(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util2.normalizeParams(params)
  });
}
function file2(params) {
  return _file2(ZodFile2, params);
}
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
function nullable2(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish4(innerType) {
  return optional2(nullable2(innerType));
}
function _default4(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...exports_util2.normalizeParams(params)
  });
}
function success2(innerType) {
  return new ZodSuccess2({
    type: "success",
    innerType
  });
}
function _catch4(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan2(params) {
  return _nan2(ZodNaN2, params);
}
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
  });
}
function codec2(in_, out, params) {
  return new ZodCodec2({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly2(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
function templateLiteral2(parts, params) {
  return new ZodTemplateLiteral2({
    type: "template_literal",
    parts,
    ...exports_util2.normalizeParams(params)
  });
}
function lazy2(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
function promise2(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
function _function2(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple2(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  return _superRefine2(fn);
}
function _instanceof2(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom2({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
function json2(params) {
  const jsonSchema = lazy2(() => {
    return union2([string5(params), number5(), boolean5(), _null6(), array2(jsonSchema), record2(string5(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess2(fn, schema2) {
  return pipe2(transform2(fn), schema2);
}
var ZodType2, _ZodString2, ZodString2, ZodStringFormat2, ZodEmail2, ZodGUID2, ZodUUID2, ZodURL2, ZodEmoji2, ZodNanoID2, ZodCUID3, ZodCUID22, ZodULID2, ZodXID2, ZodKSUID2, ZodIPv42, ZodIPv62, ZodCIDRv42, ZodCIDRv62, ZodBase642, ZodBase64URL2, ZodE1642, ZodJWT2, ZodCustomStringFormat2, ZodNumber2, ZodNumberFormat2, ZodBoolean2, ZodBigInt2, ZodBigIntFormat2, ZodSymbol2, ZodUndefined2, ZodNull2, ZodAny2, ZodUnknown2, ZodNever2, ZodVoid2, ZodDate2, ZodArray2, ZodObject2, ZodUnion2, ZodDiscriminatedUnion2, ZodIntersection2, ZodTuple2, ZodRecord2, ZodMap2, ZodSet2, ZodEnum2, ZodLiteral2, ZodFile2, ZodTransform2, ZodOptional2, ZodNullable2, ZodDefault2, ZodPrefault2, ZodNonOptional2, ZodSuccess2, ZodCatch2, ZodNaN2, ZodPipe2, ZodCodec2, ZodReadonly2, ZodTemplateLiteral2, ZodLazy2, ZodPromise2, ZodFunction2, ZodCustom2, stringbool2 = (...args) => _stringbool2({
  Codec: ZodCodec2,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
var init_schemas4 = __esm(() => {
  init_core4();
  init_core4();
  init_checks4();
  init_iso2();
  init_parse4();
  ZodType2 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
    $ZodType2.init(inst, def);
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks4) => {
      return inst.clone({
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks4.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      });
    };
    inst.clone = (def2, params) => clone2(inst, def2, params);
    inst.brand = () => inst;
    inst.register = (reg, meta3) => {
      reg.add(inst, meta3);
      return inst;
    };
    inst.parse = (data, params) => parse7(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse4(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.encode = (data, params) => encode4(inst, data, params);
    inst.decode = (data, params) => decode4(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync4(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync4(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode4(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode4(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync4(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync4(inst, data, params);
    inst.refine = (check2, params) => inst.check(refine2(check2, params));
    inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite2(fn));
    inst.optional = () => optional2(inst);
    inst.nullable = () => nullable2(inst);
    inst.nullish = () => optional2(nullable2(inst));
    inst.nonoptional = (params) => nonoptional2(inst, params);
    inst.array = () => array2(inst);
    inst.or = (arg) => union2([inst, arg]);
    inst.and = (arg) => intersection2(inst, arg);
    inst.transform = (tx) => pipe2(inst, transform2(tx));
    inst.default = (def2) => _default4(inst, def2);
    inst.prefault = (def2) => prefault2(inst, def2);
    inst.catch = (params) => _catch4(inst, params);
    inst.pipe = (target) => pipe2(inst, target);
    inst.readonly = () => readonly2(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry2.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry2.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry2.get(inst);
      }
      const cl = inst.clone();
      globalRegistry2.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    return inst;
  });
  _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
    $ZodString2.init(inst, def);
    ZodType2.init(inst, def);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex2(...args));
    inst.includes = (...args) => inst.check(_includes2(...args));
    inst.startsWith = (...args) => inst.check(_startsWith2(...args));
    inst.endsWith = (...args) => inst.check(_endsWith2(...args));
    inst.min = (...args) => inst.check(_minLength2(...args));
    inst.max = (...args) => inst.check(_maxLength2(...args));
    inst.length = (...args) => inst.check(_length2(...args));
    inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase2(params));
    inst.uppercase = (params) => inst.check(_uppercase2(params));
    inst.trim = () => inst.check(_trim2());
    inst.normalize = (...args) => inst.check(_normalize2(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase2());
    inst.toUpperCase = () => inst.check(_toUpperCase2());
  });
  ZodString2 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
    $ZodString2.init(inst, def);
    _ZodString2.init(inst, def);
    inst.email = (params) => inst.check(_email2(ZodEmail2, params));
    inst.url = (params) => inst.check(_url2(ZodURL2, params));
    inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
    inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
    inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
    inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
    inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
    inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
    inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
    inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
    inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
    inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
    inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
    inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
    inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
    inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
    inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
    inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
    inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
    inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
    inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
    inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
    inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
    inst.datetime = (params) => inst.check(datetime4(params));
    inst.date = (params) => inst.check(date6(params));
    inst.time = (params) => inst.check(time4(params));
    inst.duration = (params) => inst.check(duration4(params));
  });
  ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    _ZodString2.init(inst, def);
  });
  ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
    $ZodEmail2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
    $ZodGUID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
    $ZodUUID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
    $ZodURL2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
    $ZodEmoji2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
    $ZodNanoID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
    $ZodCUID3.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
    $ZodCUID22.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
    $ZodULID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
    $ZodXID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
    $ZodKSUID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
    $ZodIPv42.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
    $ZodIPv62.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv42.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv62.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
    $ZodBase642.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
    $ZodBase64URL2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
    $ZodE1642.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
    $ZodJWT2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("ZodCustomStringFormat", (inst, def) => {
    $ZodCustomStringFormat2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodNumber2 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
    $ZodNumber2.init(inst, def);
    ZodType2.init(inst, def);
    inst.gt = (value, params) => inst.check(_gt2(value, params));
    inst.gte = (value, params) => inst.check(_gte2(value, params));
    inst.min = (value, params) => inst.check(_gte2(value, params));
    inst.lt = (value, params) => inst.check(_lt2(value, params));
    inst.lte = (value, params) => inst.check(_lte2(value, params));
    inst.max = (value, params) => inst.check(_lte2(value, params));
    inst.int = (params) => inst.check(int2(params));
    inst.safe = (params) => inst.check(int2(params));
    inst.positive = (params) => inst.check(_gt2(0, params));
    inst.nonnegative = (params) => inst.check(_gte2(0, params));
    inst.negative = (params) => inst.check(_lt2(0, params));
    inst.nonpositive = (params) => inst.check(_lte2(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
    inst.step = (value, params) => inst.check(_multipleOf2(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat2.init(inst, def);
    ZodNumber2.init(inst, def);
  });
  ZodBoolean2 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
    $ZodBoolean2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodBigInt2 = /* @__PURE__ */ $constructor2("ZodBigInt", (inst, def) => {
    $ZodBigInt2.init(inst, def);
    ZodType2.init(inst, def);
    inst.gte = (value, params) => inst.check(_gte2(value, params));
    inst.min = (value, params) => inst.check(_gte2(value, params));
    inst.gt = (value, params) => inst.check(_gt2(value, params));
    inst.gte = (value, params) => inst.check(_gte2(value, params));
    inst.min = (value, params) => inst.check(_gte2(value, params));
    inst.lt = (value, params) => inst.check(_lt2(value, params));
    inst.lte = (value, params) => inst.check(_lte2(value, params));
    inst.max = (value, params) => inst.check(_lte2(value, params));
    inst.positive = (params) => inst.check(_gt2(BigInt(0), params));
    inst.negative = (params) => inst.check(_lt2(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_lte2(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_gte2(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
  ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("ZodBigIntFormat", (inst, def) => {
    $ZodBigIntFormat2.init(inst, def);
    ZodBigInt2.init(inst, def);
  });
  ZodSymbol2 = /* @__PURE__ */ $constructor2("ZodSymbol", (inst, def) => {
    $ZodSymbol2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodUndefined2 = /* @__PURE__ */ $constructor2("ZodUndefined", (inst, def) => {
    $ZodUndefined2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodNull2 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
    $ZodNull2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodAny2 = /* @__PURE__ */ $constructor2("ZodAny", (inst, def) => {
    $ZodAny2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodUnknown2 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
    $ZodUnknown2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodNever2 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
    $ZodNever2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodVoid2 = /* @__PURE__ */ $constructor2("ZodVoid", (inst, def) => {
    $ZodVoid2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodDate2 = /* @__PURE__ */ $constructor2("ZodDate", (inst, def) => {
    $ZodDate2.init(inst, def);
    ZodType2.init(inst, def);
    inst.min = (value, params) => inst.check(_gte2(value, params));
    inst.max = (value, params) => inst.check(_lte2(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  ZodArray2 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
    $ZodArray2.init(inst, def);
    ZodType2.init(inst, def);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength2(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
    inst.length = (len, params) => inst.check(_length2(len, params));
    inst.unwrap = () => inst.element;
  });
  ZodObject2 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
    $ZodObjectJIT2.init(inst, def);
    ZodType2.init(inst, def);
    exports_util2.defineLazy(inst, "shape", () => def.shape);
    inst.keyof = () => _enum4(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
      return exports_util2.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
      return exports_util2.safeExtend(inst, incoming);
    };
    inst.merge = (other) => exports_util2.merge(inst, other);
    inst.pick = (mask) => exports_util2.pick(inst, mask);
    inst.omit = (mask) => exports_util2.omit(inst, mask);
    inst.partial = (...args) => exports_util2.partial(ZodOptional2, inst, args[0]);
    inst.required = (...args) => exports_util2.required(ZodNonOptional2, inst, args[0]);
  });
  ZodUnion2 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
    $ZodUnion2.init(inst, def);
    ZodType2.init(inst, def);
    inst.options = def.options;
  });
  ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion2.init(inst, def);
    $ZodDiscriminatedUnion2.init(inst, def);
  });
  ZodIntersection2 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
    $ZodIntersection2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodTuple2 = /* @__PURE__ */ $constructor2("ZodTuple", (inst, def) => {
    $ZodTuple2.init(inst, def);
    ZodType2.init(inst, def);
    inst.rest = (rest) => inst.clone({
      ...inst._zod.def,
      rest
    });
  });
  ZodRecord2 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
    $ZodRecord2.init(inst, def);
    ZodType2.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  ZodMap2 = /* @__PURE__ */ $constructor2("ZodMap", (inst, def) => {
    $ZodMap2.init(inst, def);
    ZodType2.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  ZodSet2 = /* @__PURE__ */ $constructor2("ZodSet", (inst, def) => {
    $ZodSet2.init(inst, def);
    ZodType2.init(inst, def);
    inst.min = (...args) => inst.check(_minSize2(...args));
    inst.nonempty = (params) => inst.check(_minSize2(1, params));
    inst.max = (...args) => inst.check(_maxSize2(...args));
    inst.size = (...args) => inst.check(_size2(...args));
  });
  ZodEnum2 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
    $ZodEnum2.init(inst, def);
    ZodType2.init(inst, def);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum2({
        ...def,
        checks: [],
        ...exports_util2.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum2({
        ...def,
        checks: [],
        ...exports_util2.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  ZodLiteral2 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
    $ZodLiteral2.init(inst, def);
    ZodType2.init(inst, def);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  ZodFile2 = /* @__PURE__ */ $constructor2("ZodFile", (inst, def) => {
    $ZodFile2.init(inst, def);
    ZodType2.init(inst, def);
    inst.min = (size, params) => inst.check(_minSize2(size, params));
    inst.max = (size, params) => inst.check(_maxSize2(size, params));
    inst.mime = (types, params) => inst.check(_mime2(Array.isArray(types) ? types : [types], params));
  });
  ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
    $ZodTransform2.init(inst, def);
    ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward") {
        throw new $ZodEncodeError2(inst.constructor.name);
      }
      payload.addIssue = (issue3) => {
        if (typeof issue3 === "string") {
          payload.issues.push(exports_util2.issue(issue3, payload.value, def));
        } else {
          const _issue = issue3;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(exports_util2.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  ZodOptional2 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
    $ZodOptional2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNullable2 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
    $ZodNullable2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodDefault2 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
    $ZodDefault2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
    $ZodPrefault2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
    $ZodNonOptional2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodSuccess2 = /* @__PURE__ */ $constructor2("ZodSuccess", (inst, def) => {
    $ZodSuccess2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodCatch2 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
    $ZodCatch2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  ZodNaN2 = /* @__PURE__ */ $constructor2("ZodNaN", (inst, def) => {
    $ZodNaN2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
    $ZodPipe2.init(inst, def);
    ZodType2.init(inst, def);
    inst.in = def.in;
    inst.out = def.out;
  });
  ZodCodec2 = /* @__PURE__ */ $constructor2("ZodCodec", (inst, def) => {
    ZodPipe2.init(inst, def);
    $ZodCodec2.init(inst, def);
  });
  ZodReadonly2 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
    $ZodReadonly2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("ZodTemplateLiteral", (inst, def) => {
    $ZodTemplateLiteral2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodLazy2 = /* @__PURE__ */ $constructor2("ZodLazy", (inst, def) => {
    $ZodLazy2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.getter();
  });
  ZodPromise2 = /* @__PURE__ */ $constructor2("ZodPromise", (inst, def) => {
    $ZodPromise2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodFunction2 = /* @__PURE__ */ $constructor2("ZodFunction", (inst, def) => {
    $ZodFunction2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
    $ZodCustom2.init(inst, def);
    ZodType2.init(inst, def);
  });
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/compat.js
function setErrorMap2(map3) {
  config2({
    customError: map3
  });
}
function getErrorMap2() {
  return config2().customError;
}
var ZodIssueCode2, ZodFirstPartyTypeKind2;
var init_compat2 = __esm(() => {
  init_core4();
  ZodIssueCode2 = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
  };
  (function(ZodFirstPartyTypeKind3) {})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/coerce.js
var exports_coerce2 = {};
__export(exports_coerce2, {
  string: () => string6,
  number: () => number6,
  date: () => date8,
  boolean: () => boolean6,
  bigint: () => bigint6
});
function string6(params) {
  return _coercedString2(ZodString2, params);
}
function number6(params) {
  return _coercedNumber2(ZodNumber2, params);
}
function boolean6(params) {
  return _coercedBoolean2(ZodBoolean2, params);
}
function bigint6(params) {
  return _coercedBigint2(ZodBigInt2, params);
}
function date8(params) {
  return _coercedDate2(ZodDate2, params);
}
var init_coerce2 = __esm(() => {
  init_core4();
  init_schemas4();
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
var exports_external2 = {};
__export(exports_external2, {
  xid: () => xid4,
  void: () => _void4,
  uuidv7: () => uuidv72,
  uuidv6: () => uuidv62,
  uuidv4: () => uuidv42,
  uuid: () => uuid5,
  util: () => exports_util2,
  url: () => url2,
  uppercase: () => _uppercase2,
  unknown: () => unknown2,
  union: () => union2,
  undefined: () => _undefined6,
  ulid: () => ulid4,
  uint64: () => uint642,
  uint32: () => uint322,
  tuple: () => tuple2,
  trim: () => _trim2,
  treeifyError: () => treeifyError2,
  transform: () => transform2,
  toUpperCase: () => _toUpperCase2,
  toLowerCase: () => _toLowerCase2,
  toJSONSchema: () => toJSONSchema2,
  templateLiteral: () => templateLiteral2,
  symbol: () => symbol2,
  superRefine: () => superRefine2,
  success: () => success2,
  stringbool: () => stringbool2,
  stringFormat: () => stringFormat2,
  string: () => string5,
  strictObject: () => strictObject2,
  startsWith: () => _startsWith2,
  size: () => _size2,
  setErrorMap: () => setErrorMap2,
  set: () => set2,
  safeParseAsync: () => safeParseAsync4,
  safeParse: () => safeParse4,
  safeEncodeAsync: () => safeEncodeAsync4,
  safeEncode: () => safeEncode4,
  safeDecodeAsync: () => safeDecodeAsync4,
  safeDecode: () => safeDecode4,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  regex: () => _regex2,
  refine: () => refine2,
  record: () => record2,
  readonly: () => readonly2,
  property: () => _property2,
  promise: () => promise2,
  prettifyError: () => prettifyError2,
  preprocess: () => preprocess2,
  prefault: () => prefault2,
  positive: () => _positive2,
  pipe: () => pipe2,
  partialRecord: () => partialRecord2,
  parseAsync: () => parseAsync4,
  parse: () => parse7,
  overwrite: () => _overwrite2,
  optional: () => optional2,
  object: () => object2,
  number: () => number5,
  nullish: () => nullish4,
  nullable: () => nullable2,
  null: () => _null6,
  normalize: () => _normalize2,
  nonpositive: () => _nonpositive2,
  nonoptional: () => nonoptional2,
  nonnegative: () => _nonnegative2,
  never: () => never2,
  negative: () => _negative2,
  nativeEnum: () => nativeEnum2,
  nanoid: () => nanoid4,
  nan: () => nan2,
  multipleOf: () => _multipleOf2,
  minSize: () => _minSize2,
  minLength: () => _minLength2,
  mime: () => _mime2,
  maxSize: () => _maxSize2,
  maxLength: () => _maxLength2,
  map: () => map2,
  lte: () => _lte2,
  lt: () => _lt2,
  lowercase: () => _lowercase2,
  looseObject: () => looseObject2,
  locales: () => exports_locales2,
  literal: () => literal2,
  length: () => _length2,
  lazy: () => lazy2,
  ksuid: () => ksuid4,
  keyof: () => keyof2,
  jwt: () => jwt2,
  json: () => json2,
  iso: () => exports_iso2,
  ipv6: () => ipv64,
  ipv4: () => ipv44,
  intersection: () => intersection2,
  int64: () => int642,
  int32: () => int322,
  int: () => int2,
  instanceof: () => _instanceof2,
  includes: () => _includes2,
  httpUrl: () => httpUrl2,
  hostname: () => hostname4,
  hex: () => hex4,
  hash: () => hash2,
  guid: () => guid4,
  gte: () => _gte2,
  gt: () => _gt2,
  globalRegistry: () => globalRegistry2,
  getErrorMap: () => getErrorMap2,
  function: () => _function2,
  formatError: () => formatError2,
  float64: () => float642,
  float32: () => float322,
  flattenError: () => flattenError2,
  file: () => file2,
  enum: () => _enum4,
  endsWith: () => _endsWith2,
  encodeAsync: () => encodeAsync4,
  encode: () => encode4,
  emoji: () => emoji4,
  email: () => email4,
  e164: () => e1644,
  discriminatedUnion: () => discriminatedUnion2,
  decodeAsync: () => decodeAsync4,
  decode: () => decode4,
  date: () => date7,
  custom: () => custom2,
  cuid2: () => cuid24,
  cuid: () => cuid6,
  core: () => exports_core4,
  config: () => config2,
  coerce: () => exports_coerce2,
  codec: () => codec2,
  clone: () => clone2,
  cidrv6: () => cidrv64,
  cidrv4: () => cidrv44,
  check: () => check2,
  catch: () => _catch4,
  boolean: () => boolean5,
  bigint: () => bigint5,
  base64url: () => base64url4,
  base64: () => base644,
  array: () => array2,
  any: () => any2,
  _function: () => _function2,
  _default: () => _default4,
  _ZodString: () => _ZodString2,
  ZodXID: () => ZodXID2,
  ZodVoid: () => ZodVoid2,
  ZodUnknown: () => ZodUnknown2,
  ZodUnion: () => ZodUnion2,
  ZodUndefined: () => ZodUndefined2,
  ZodUUID: () => ZodUUID2,
  ZodURL: () => ZodURL2,
  ZodULID: () => ZodULID2,
  ZodType: () => ZodType2,
  ZodTuple: () => ZodTuple2,
  ZodTransform: () => ZodTransform2,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodSymbol: () => ZodSymbol2,
  ZodSuccess: () => ZodSuccess2,
  ZodStringFormat: () => ZodStringFormat2,
  ZodString: () => ZodString2,
  ZodSet: () => ZodSet2,
  ZodRecord: () => ZodRecord2,
  ZodRealError: () => ZodRealError2,
  ZodReadonly: () => ZodReadonly2,
  ZodPromise: () => ZodPromise2,
  ZodPrefault: () => ZodPrefault2,
  ZodPipe: () => ZodPipe2,
  ZodOptional: () => ZodOptional2,
  ZodObject: () => ZodObject2,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodNumber: () => ZodNumber2,
  ZodNullable: () => ZodNullable2,
  ZodNull: () => ZodNull2,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNever: () => ZodNever2,
  ZodNanoID: () => ZodNanoID2,
  ZodNaN: () => ZodNaN2,
  ZodMap: () => ZodMap2,
  ZodLiteral: () => ZodLiteral2,
  ZodLazy: () => ZodLazy2,
  ZodKSUID: () => ZodKSUID2,
  ZodJWT: () => ZodJWT2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodIntersection: () => ZodIntersection2,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2,
  ZodIPv6: () => ZodIPv62,
  ZodIPv4: () => ZodIPv42,
  ZodGUID: () => ZodGUID2,
  ZodFunction: () => ZodFunction2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFile: () => ZodFile2,
  ZodError: () => ZodError2,
  ZodEnum: () => ZodEnum2,
  ZodEmoji: () => ZodEmoji2,
  ZodEmail: () => ZodEmail2,
  ZodE164: () => ZodE1642,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodDefault: () => ZodDefault2,
  ZodDate: () => ZodDate2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodCustom: () => ZodCustom2,
  ZodCodec: () => ZodCodec2,
  ZodCatch: () => ZodCatch2,
  ZodCUID2: () => ZodCUID22,
  ZodCUID: () => ZodCUID3,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodBoolean: () => ZodBoolean2,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBigInt: () => ZodBigInt2,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBase64: () => ZodBase642,
  ZodArray: () => ZodArray2,
  ZodAny: () => ZodAny2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  $output: () => $output2,
  $input: () => $input2,
  $brand: () => $brand2
});
var init_external2 = __esm(() => {
  init_core4();
  init_core4();
  init_en2();
  init_core4();
  init_locales2();
  init_iso2();
  init_iso2();
  init_coerce2();
  init_schemas4();
  init_checks4();
  init_errors4();
  init_parse4();
  init_compat2();
  config2(en_default2());
});

// node_modules/@opencode-ai/plugin/node_modules/zod/index.js
var init_zod2 = __esm(() => {
  init_external2();
  init_external2();
});

// node_modules/@opencode-ai/plugin/dist/tool.js
function tool(input) {
  return input;
}
var init_tool = __esm(() => {
  init_zod2();
  tool.schema = exports_external2;
});

// node_modules/@opencode-ai/plugin/dist/index.js
var init_dist = __esm(() => {
  init_tool();
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    CLOSE_TIMEOUT: 30000,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error("Cannot require module "+"bufferutil");})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error("Cannot require module "+"utf-8-validate");})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error92 = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error92);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error92 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error92);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error92 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error92);
          return;
        }
        if (!this._fragmented) {
          const error92 = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error92);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error92 = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error92);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error92 = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error92);
          return;
        }
        if (compressed) {
          const error92 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error92);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error92 = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error92);
          return;
        }
      } else {
        const error92 = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error92);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error92 = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error92);
          return;
        }
      } else if (this._masked) {
        const error92 = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error92);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error92 = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error92);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error92 = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error92);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error92 = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error92);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error92 = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error92);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error92 = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error92);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error92 = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error92);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
  var { isBlob, isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data, options) {
      let mask;
      let merge3 = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge3 = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge3 ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge3) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options, cb) {
      this._bufferedBytes += options[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      }).catch((err) => {
        process.nextTick(onError, this, err, cb);
      });
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._state = DEFAULT;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err, cb) {
    if (typeof cb === "function")
      cb(err);
    for (let i = 0;i < sender._queue.length; i++) {
      const params = sender._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function")
        callback(err);
    }
  }
  function onError(sender, err, cb) {
    callCallbacks(sender, err, cb);
    sender.onerror(err);
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error92) {
          const event = new ErrorEvent("error", {
            error: error92,
            message: error92.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse9(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse: parse9 };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var { isBlob } = require_validation();
  var {
    BINARY_TYPES,
    CLOSE_TIMEOUT,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse: parse9 } = require_extension();
  var { toBuffer } = require_buffer_util();
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket2 extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket2.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._closeTimeout = options.closeTimeout;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket2.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket2.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket2.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket2.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket2.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket2, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket2.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket2.prototype.addEventListener = addEventListener;
  WebSocket2.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket2;
  function initAsClient(websocket, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      closeTimeout: CLOSE_TIMEOUT,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    websocket._closeTimeout = opts.closeTimeout;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket2.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse9(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket2.CLOSING;
    websocket._errorEmitted = true;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket2.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream) {
    stream.resume();
  }
  function senderOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket.readyState === WebSocket2.CLOSED)
      return;
    if (websocket.readyState === WebSocket2.OPEN) {
      websocket._readyState = WebSocket2.CLOSING;
      setCloseTimer(websocket);
    }
    this._socket.end();
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function setCloseTimer(websocket) {
    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), websocket._closeTimeout);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket2.CLOSING;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && this._readableState.length !== 0) {
      const chunk = this.read(this._readableState.length);
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket2.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket2.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket2 = require_websocket();
  var { Duplex } = __require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error92(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error92(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse9(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse: parse9 };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket2 = require_websocket();
  var { CLOSE_TIMEOUT, GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        closeTimeout: CLOSE_TIMEOUT,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket: WebSocket2,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version3 = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version3 !== 13 && version3 !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version3 === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map3) {
    for (const event of Object.keys(map3))
      server.on(event, map3[event]);
    return function removeListeners() {
      for (const event of Object.keys(map3)) {
        server.removeListener(event, map3[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
});

// node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server, wrapper_default;
var init_wrapper = __esm(() => {
  import_stream = __toESM(require_stream(), 1);
  import_receiver = __toESM(require_receiver(), 1);
  import_sender = __toESM(require_sender(), 1);
  import_websocket = __toESM(require_websocket(), 1);
  import_websocket_server = __toESM(require_websocket_server(), 1);
  wrapper_default = import_websocket.default;
});

// src/model/paths.ts
import * as path6 from "node:path";
function normalizeModelRoot(projectDir, root) {
  const trimmed = root.trim();
  if (!trimmed)
    return path6.join(getMiyaDataRootDir(projectDir), "model");
  if (path6.isAbsolute(trimmed))
    return path6.normalize(trimmed);
  return path6.normalize(path6.join(projectDir, trimmed));
}
function getMiyaDataRootDir(projectDir) {
  return path6.join(projectDir, ...MIYA_ROOT_SEGMENTS);
}
function getMiyaModelRootDir(projectDir) {
  const envRoot = process.env[MODEL_ROOT_ENV];
  if (typeof envRoot === "string" && envRoot.trim()) {
    return normalizeModelRoot(projectDir, envRoot);
  }
  return path6.join(getMiyaDataRootDir(projectDir), "model");
}
function getMiyaModelPath(projectDir, ...segments) {
  return path6.join(getMiyaModelRootDir(projectDir), ...segments);
}
function getMiyaVisionTempDir(projectDir, ...segments) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.vision, "lin shi", ...segments);
}
function getMiyaImageTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.image, "lin shi");
}
function getMiyaVoiceTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voice, "lin shi");
}
function getMiyaVoiceprintModelDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, MIYA_MODEL_NAME.eres2net);
}
function getMiyaVoiceprintSampleDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, "ben ren");
}
var MODEL_ROOT_ENV = "MIYA_MODEL_ROOT_DIR", MIYA_ROOT_SEGMENTS, MIYA_MODEL_BRANCH, MIYA_MODEL_NAME;
var init_paths = __esm(() => {
  MIYA_ROOT_SEGMENTS = [".opencode", "miya"];
  MIYA_MODEL_BRANCH = {
    vision: "shi jue",
    image: "tu pian",
    voiceprint: "shi bie",
    voice: "sheng yin"
  };
  MIYA_MODEL_NAME = {
    fluxSchnell: "FLUX.1 schnell",
    fluxKlein: "FLUX.2 [klein] 4B（Apache-2.0）",
    eres2net: "eres2net",
    sovits: "GPT-SoVITS-v2pro-20250604"
  };
});

// src/channel/outbound/shared.ts
import { createHash, randomUUID } from "node:crypto";
import * as fs6 from "node:fs";
function safeValueFromSignal(signal, key) {
  const matched = new RegExp(`${key}=([^|]*)`).exec(signal)?.[1];
  if (matched == null)
    return;
  const text = matched.trim();
  return text.length > 0 ? text : undefined;
}
function deriveDesktopFailureDetail(input) {
  return safeValueFromSignal(input.signal, "error") ?? (input.stderr.trim() || undefined) ?? (input.stdout.trim() || undefined) ?? (input.timedOut ? "timeout" : `exit_${input.exitCode}`);
}
function buildEvidenceDir(projectDir, channel) {
  const root = getMiyaVisionTempDir(projectDir, channel);
  fs6.mkdirSync(root, { recursive: true });
  return root;
}
async function sendDesktopOutbound(input) {
  const destination = input.destination.trim();
  const text = (input.text ?? "").trim();
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = createHash("sha256").update(`${text}||${mediaPath}`).digest("hex");
  const traceID = `desktop_${randomUUID()}`;
  const evidenceDir = buildEvidenceDir(input.projectDir, input.channel);
  if (process.platform !== "win32") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_windows_only",
      receiptStatus: "uncertain",
      failureStep: "preflight.platform",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (process.env.MIYA_UI_AUTOMATION_ENABLED !== "1") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_disabled:set MIYA_UI_AUTOMATION_ENABLED=1",
      receiptStatus: "uncertain",
      failureStep: "preflight.runtime_switch",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (!destination || !text && !mediaPath) {
    return Promise.resolve({
      sent: false,
      message: "invalid_desktop_send_args",
      receiptStatus: "uncertain",
      failureStep: "preflight.args",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  const script = `
$ErrorActionPreference = 'Stop'
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
Add-Type @"
using System;
using System.Runtime.InteropServices;
public static class MiyaInputProbe {
  [StructLayout(LayoutKind.Sequential)]
  public struct POINT { public int X; public int Y; }
  [DllImport("user32.dll")]
  public static extern bool GetCursorPos(out POINT point);
  [DllImport("user32.dll")]
  public static extern short GetAsyncKeyState(int vKey);
}
"@

$destination = $env:MIYA_DESTINATION
$payload = $env:MIYA_MESSAGE
$mediaPath = $env:MIYA_MEDIA_PATH
$appName = $env:MIYA_APP_NAME
$payloadHash = $env:MIYA_PAYLOAD_HASH
$traceId = $env:MIYA_TRACE_ID
$evidenceDir = $env:MIYA_EVIDENCE_DIR
$shell = New-Object -ComObject WScript.Shell

$step = "bootstrap"
$precheck = "unavailable"
$postcheck = "unavailable"
$receipt = "uncertain"
$recipientCheck = "uncertain"
$preShot = ""
$postShot = ""
$windowFingerprint = ""

function Save-Screenshot {
  param([string]$TargetPath)
  try {
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing
    $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
    $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
    $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
    $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)
    $bitmap.Save($TargetPath, [System.Drawing.Imaging.ImageFormat]::Png)
    $graphics.Dispose()
    $bitmap.Dispose()
  } catch {}
}

function Get-CursorPoint {
  $point = New-Object MiyaInputProbe+POINT
  [void][MiyaInputProbe]::GetCursorPos([ref]$point)
  return @{ X = [int]$point.X; Y = [int]$point.Y }
}

function Test-KeyboardActivity {
  $keys = @(0x08,0x09,0x0D,0x10,0x11,0x12,0x1B,0x20,0x25,0x26,0x27,0x28,0x2E,0x5B,0x5C)
  foreach ($vk in $keys) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  for ($vk = 0x30; $vk -le 0x5A; $vk++) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  return $false
}

function Wait-UserInputIdle {
  param([int]$TimeoutMs = 1200, [int]$StableMs = 350, [int]$SampleMs = 60)
  $deadline = (Get-Date).AddMilliseconds($TimeoutMs)
  $idleSince = Get-Date
  $last = Get-CursorPoint
  while ((Get-Date) -lt $deadline) {
    Start-Sleep -Milliseconds $SampleMs
    $curr = Get-CursorPoint
    $moved = ([Math]::Abs($curr.X - $last.X) + [Math]::Abs($curr.Y - $last.Y)) -gt 2
    $typing = Test-KeyboardActivity
    if ($moved -or $typing) {
      $idleSince = Get-Date
      $last = $curr
      continue
    }
    if (((Get-Date) - $idleSince).TotalMilliseconds -ge $StableMs) {
      return $curr
    }
    $last = $curr
  }
  throw "input_mutex_timeout:user_active"
}

function Assert-NoUserInterference {
  param($LockPoint)
  $curr = Get-CursorPoint
  $moved = ([Math]::Abs($curr.X - $LockPoint.X) + [Math]::Abs($curr.Y - $LockPoint.Y)) -gt 6
  if ($moved -or (Test-KeyboardActivity)) {
    throw "input_mutex_timeout:user_interference"
  }
}

try {
  if (-not (Test-Path -LiteralPath $evidenceDir)) {
    New-Item -ItemType Directory -Path $evidenceDir -Force | Out-Null
  }

  $step = "bootstrap.process"
  $lockPoint = Wait-UserInputIdle
$proc = Get-Process -Name $appName -ErrorAction SilentlyContinue | Select-Object -First 1
if (-not $proc) {
  Start-Process -FilePath $appName | Out-Null
  Start-Sleep -Milliseconds 1200
}

$step = "precheck.activate_window"
$activated = $shell.AppActivate($destination)
if (-not $activated) {
  $activated = $shell.AppActivate($appName)
}
if (-not $activated) {
  throw "window_not_found:$destination"
}
$precheck = "window_activated"
Assert-NoUserInterference -LockPoint $lockPoint

$step = "precheck.capture"
$preShot = Join-Path $evidenceDir ($traceId + "_pre.png")
Save-Screenshot -TargetPath $preShot

$activeByDestination = $shell.AppActivate($destination)
if (-not $activeByDestination) {
  $activeByDestination = $false
}
$windowProc = Get-Process -Name $appName -ErrorAction SilentlyContinue | Select-Object -First 1
$windowTitle = ""
if ($windowProc -and $windowProc.MainWindowTitle) {
  $windowTitle = $windowProc.MainWindowTitle
}
$windowFingerprint = ($appName + ":" + [string]($windowProc.Id) + ":" + $windowTitle.Replace('|', '/'))
if ($windowTitle -like ("*" + $destination + "*")) {
  $recipientCheck = "matched"
} elseif ($activeByDestination) {
  $recipientCheck = "matched"
} else {
  $recipientCheck = "uncertain"
}

if ($mediaPath) {
  Assert-NoUserInterference -LockPoint $lockPoint
  $step = "send.media_prepare"
  if (-not (Test-Path -LiteralPath $mediaPath)) {
    throw "media_not_found:$mediaPath"
  }
  $list = New-Object System.Collections.Specialized.StringCollection
  $list.Add($mediaPath) | Out-Null
  $data = New-Object System.Windows.Forms.DataObject
  $data.SetFileDropList($list)
  [System.Windows.Forms.Clipboard]::SetDataObject($data, $true)
  Start-Sleep -Milliseconds 220
  [System.Windows.Forms.SendKeys]::SendWait('^v')
  $step = "send.media_commit"
  Start-Sleep -Milliseconds 220
  [System.Windows.Forms.SendKeys]::SendWait('{ENTER}')
  Start-Sleep -Milliseconds 240
}

if ($payload) {
  Assert-NoUserInterference -LockPoint $lockPoint
  $step = "send.text_prepare"
  Set-Clipboard -Value $payload
  Start-Sleep -Milliseconds 180
  [System.Windows.Forms.SendKeys]::SendWait('^v')
  $step = "send.text_commit"
  Start-Sleep -Milliseconds 120
  [System.Windows.Forms.SendKeys]::SendWait('{ENTER}')
}

$step = "postcheck.activate"
if (-not $shell.AppActivate($appName)) {
  throw "postcheck_window_not_active:$appName"
}
$postcheck = "window_active_after_send"
$receipt = "confirmed"
$step = "postcheck.capture"
$postShot = Join-Path $evidenceDir ($traceId + "_post.png")
Save-Screenshot -TargetPath $postShot

Write-Output ("desktop_send_ok|step=" + $step + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFingerprint.Replace('|', '/') + "|pre_shot=" + $preShot.Replace('|', '/') + "|post_shot=" + $postShot.Replace('|', '/') + "|payload=" + $payloadHash)
exit 0
} catch {
  $err = $_.Exception.Message.Replace('|', '/')
  Write-Output ("desktop_send_fail|step=" + $step + "|error=" + $err + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFingerprint.Replace('|', '/') + "|pre_shot=" + $preShot.Replace('|', '/') + "|post_shot=" + $postShot.Replace('|', '/') + "|payload=" + $payloadHash)
  exit 2
}
`.trim();
  const proc = Bun.spawn(["powershell", "-NoProfile", "-NonInteractive", "-ExecutionPolicy", "Bypass", "-Command", script], {
    env: {
      ...process.env,
      MIYA_DESTINATION: destination,
      MIYA_MESSAGE: text,
      MIYA_MEDIA_PATH: mediaPath,
      MIYA_APP_NAME: input.appName,
      MIYA_PAYLOAD_HASH: payloadHash,
      MIYA_TRACE_ID: traceID,
      MIYA_EVIDENCE_DIR: evidenceDir
    },
    windowsHide: true,
    stdio: ["ignore", "pipe", "pipe"]
  });
  let timedOut = false;
  const timeout = setTimeout(() => {
    timedOut = true;
    try {
      proc.kill("SIGTERM");
    } catch {}
  }, 15000);
  const exitCode = await proc.exited;
  clearTimeout(timeout);
  const stdout = (await new Response(proc.stdout).text()).trim();
  const stderr = (await new Response(proc.stderr).text()).trim();
  const signal = stdout || stderr;
  const precheck = safeValueFromSignal(signal, "pre") ?? "failed";
  const postcheck = safeValueFromSignal(signal, "post") ?? "failed";
  const receipt = safeValueFromSignal(signal, "receipt") === "confirmed" ? "confirmed" : "uncertain";
  const failureStep = safeValueFromSignal(signal, "step") ?? "send.unknown";
  const windowFingerprint = safeValueFromSignal(signal, "window_fp");
  const recipientTextCheckRaw = safeValueFromSignal(signal, "recipient");
  const recipientTextCheck = recipientTextCheckRaw === "matched" || recipientTextCheckRaw === "mismatch" ? recipientTextCheckRaw : "uncertain";
  const preSendScreenshotPath = safeValueFromSignal(signal, "pre_shot");
  const postSendScreenshotPath = safeValueFromSignal(signal, "post_shot");
  const payloadFromSignal = safeValueFromSignal(signal, "payload") ?? payloadHash;
  if (exitCode === 0 && stdout.includes("desktop_send_ok") && !timedOut) {
    return {
      sent: true,
      message: `${input.channel}_desktop_sent`,
      visualPrecheck: precheck,
      visualPostcheck: postcheck,
      receiptStatus: receipt,
      payloadHash: payloadFromSignal,
      windowFingerprint,
      recipientTextCheck,
      preSendScreenshotPath,
      postSendScreenshotPath,
      failureStep
    };
  }
  const detail = deriveDesktopFailureDetail({
    signal,
    stdout,
    stderr,
    timedOut,
    exitCode
  });
  return {
    sent: false,
    message: `${input.channel}_desktop_send_failed:${detail}`,
    visualPrecheck: precheck,
    visualPostcheck: postcheck,
    receiptStatus: receipt,
    failureStep,
    payloadHash: payloadFromSignal,
    windowFingerprint,
    recipientTextCheck,
    preSendScreenshotPath,
    postSendScreenshotPath
  };
}
var init_shared = __esm(() => {
  init_paths();
});

// src/channel/outbound/qq.ts
async function sendQqDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "QQ",
    channel: "qq",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath
  });
}
var init_qq = __esm(() => {
  init_shared();
});

// src/channel/outbound/wechat.ts
async function sendWechatDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "WeChat",
    channel: "wechat",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath
  });
}
var init_wechat = __esm(() => {
  init_shared();
});

// src/security/system-keyring.ts
import { createCipheriv, createDecipheriv, createHash as createHash2, randomBytes } from "node:crypto";
import { spawnSync as spawnSync2 } from "node:child_process";
import * as fs7 from "node:fs";
import * as path7 from "node:path";
function keyFile(projectDir) {
  return path7.join(getMiyaRuntimeDir(projectDir), "security", "master.key");
}
function ensureDir2(file3) {
  fs7.mkdirSync(path7.dirname(file3), { recursive: true });
}
function toBase64(text) {
  return Buffer.from(text, "utf-8").toString("base64");
}
function fromBase64(base645) {
  return Buffer.from(base645, "base64").toString("utf-8");
}
function hasPowerShell() {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const result = spawnSync2(shell, ["-NoProfile", "-NonInteractive", "-Command", "$PSVersionTable.PSVersion.ToString()"], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 1500
  });
  return result.status === 0;
}
function encryptWithDpapi(plainText) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const script = [
    `$plain = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('${toBase64(plainText)}'))`,
    "$secure = ConvertTo-SecureString -String $plain -AsPlainText -Force",
    "ConvertFrom-SecureString -SecureString $secure"
  ].join("; ");
  const result = spawnSync2(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2000
  });
  if (result.status !== 0)
    return null;
  const out = result.stdout.trim();
  return out.length > 0 ? out : null;
}
function decryptWithDpapi(blob) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const escaped = blob.replace(/'/g, "''");
  const script = [
    `$secure = ConvertTo-SecureString '${escaped}'`,
    "$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secure)",
    "$plain = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)",
    "[Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)",
    "[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($plain))"
  ].join("; ");
  const result = spawnSync2(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2000
  });
  if (result.status !== 0)
    return null;
  const out = result.stdout.trim();
  if (!out)
    return null;
  try {
    return fromBase64(out);
  } catch {
    return null;
  }
}
function deriveFallbackKey(projectDir) {
  const file3 = keyFile(projectDir);
  if (fs7.existsSync(file3)) {
    return fs7.readFileSync(file3);
  }
  const entropy = randomBytes(32);
  ensureDir2(file3);
  fs7.writeFileSync(file3, entropy);
  return entropy;
}
function encryptFallback(projectDir, plainText) {
  const key = deriveFallbackKey(projectDir);
  const iv = randomBytes(12);
  const cipher = createCipheriv("aes-256-gcm", createHash2("sha256").update(key).digest(), iv);
  const payload = Buffer.concat([cipher.update(plainText, "utf-8"), cipher.final()]);
  return {
    version: 1,
    alg: "aes256gcm",
    payload: payload.toString("base64"),
    iv: iv.toString("base64"),
    tag: cipher.getAuthTag().toString("base64")
  };
}
function decryptFallback(projectDir, envelope) {
  if (!envelope.iv || !envelope.tag)
    return null;
  try {
    const key = deriveFallbackKey(projectDir);
    const decipher = createDecipheriv("aes-256-gcm", createHash2("sha256").update(key).digest(), Buffer.from(envelope.iv, "base64"));
    decipher.setAuthTag(Buffer.from(envelope.tag, "base64"));
    const plain = Buffer.concat([
      decipher.update(Buffer.from(envelope.payload, "base64")),
      decipher.final()
    ]);
    return plain.toString("utf-8");
  } catch {
    return null;
  }
}
function encodeEnvelope(envelope) {
  return `miya-sec:${Buffer.from(JSON.stringify(envelope), "utf-8").toString("base64")}`;
}
function decodeEnvelope(raw) {
  if (!raw.startsWith("miya-sec:"))
    return null;
  const body = raw.slice("miya-sec:".length);
  try {
    const parsed = JSON.parse(Buffer.from(body, "base64").toString("utf-8"));
    if (!parsed || parsed.version !== 1)
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function encryptSensitiveValue(projectDir, plainText) {
  const normalized = String(plainText ?? "");
  if (!normalized)
    return normalized;
  if (process.platform === "win32" && hasPowerShell()) {
    const dpapi = encryptWithDpapi(normalized);
    if (dpapi) {
      return encodeEnvelope({
        version: 1,
        alg: "dpapi",
        payload: dpapi
      });
    }
  }
  return encodeEnvelope(encryptFallback(projectDir, normalized));
}
function decryptSensitiveValue(projectDir, rawValue) {
  const raw = String(rawValue ?? "");
  if (!raw.startsWith("miya-sec:"))
    return raw;
  const envelope = decodeEnvelope(raw);
  if (!envelope)
    return raw;
  if (envelope.alg === "dpapi") {
    const decoded = decryptWithDpapi(envelope.payload);
    return decoded ?? raw;
  }
  const fallback = decryptFallback(projectDir, envelope);
  return fallback ?? raw;
}
var init_system_keyring = __esm(() => {
  init_workflow();
});

// src/media/store.ts
import * as fs8 from "node:fs";
import * as path8 from "node:path";
import { randomUUID as randomUUID2 } from "node:crypto";
function nowIso() {
  return new Date().toISOString();
}
function mediaDir(projectDir) {
  return path8.join(getMiyaRuntimeDir(projectDir), "media");
}
function mediaIndexFile(projectDir) {
  return path8.join(mediaDir(projectDir), "index.json");
}
function ensureDir3(dirPath) {
  fs8.mkdirSync(dirPath, { recursive: true });
}
function decodeMetadata(projectDir, metadata) {
  if (!metadata || typeof metadata !== "object")
    return metadata;
  if (typeof metadata.secure === "string") {
    try {
      const plain = decryptSensitiveValue(projectDir, metadata.secure);
      const parsed = JSON.parse(plain);
      return parsed;
    } catch {
      return metadata;
    }
  }
  return metadata;
}
function readStore(projectDir) {
  const file3 = mediaIndexFile(projectDir);
  if (!fs8.existsSync(file3)) {
    return { items: {} };
  }
  try {
    const parsed = JSON.parse(fs8.readFileSync(file3, "utf-8"));
    const items = {};
    for (const [id, item] of Object.entries(parsed.items ?? {})) {
      items[id] = {
        ...item,
        source: decryptSensitiveValue(projectDir, String(item.source ?? "")),
        fileName: decryptSensitiveValue(projectDir, String(item.fileName ?? "")),
        localPath: typeof item.localPath === "string" ? decryptSensitiveValue(projectDir, item.localPath) : item.localPath,
        metadata: decodeMetadata(projectDir, item.metadata)
      };
    }
    return { items };
  } catch {
    return { items: {} };
  }
}
function writeStore(projectDir, store) {
  ensureDir3(mediaDir(projectDir));
  const encrypted = { items: {} };
  for (const [id, item] of Object.entries(store.items)) {
    encrypted.items[id] = {
      ...item,
      source: encryptSensitiveValue(projectDir, item.source),
      fileName: encryptSensitiveValue(projectDir, item.fileName),
      localPath: item.localPath ? encryptSensitiveValue(projectDir, item.localPath) : item.localPath,
      metadata: item.metadata ? {
        secure: encryptSensitiveValue(projectDir, JSON.stringify(item.metadata))
      } : item.metadata
    };
  }
  fs8.writeFileSync(mediaIndexFile(projectDir), `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function buildExpiration(ttlHours) {
  const expires = new Date(Date.now() + ttlHours * 3600 * 1000);
  return expires.toISOString();
}
function ingestMedia(projectDir, input) {
  const ttlHours = Math.max(1, input.ttlHours ?? DEFAULT_TTL_HOURS);
  const store = readStore(projectDir);
  const id = `media_${randomUUID2()}`;
  let localPath;
  if (input.contentBase64) {
    const dir = mediaDir(projectDir);
    ensureDir3(dir);
    const ext = path8.extname(input.fileName) || ".bin";
    const filePath2 = path8.join(dir, `${id}${ext}`);
    fs8.writeFileSync(filePath2, Buffer.from(input.contentBase64, "base64"));
    localPath = filePath2;
  }
  const item = {
    id,
    source: input.source,
    kind: input.kind,
    mimeType: input.mimeType,
    fileName: input.fileName,
    localPath,
    sizeBytes: input.sizeBytes,
    createdAt: nowIso(),
    expiresAt: buildExpiration(ttlHours),
    metadata: input.metadata
  };
  store.items[id] = item;
  writeStore(projectDir, store);
  return item;
}
function getMediaItem(projectDir, mediaID) {
  const store = readStore(projectDir);
  return store.items[mediaID] ?? null;
}
function listMediaItems(projectDir, limit = 100) {
  const store = readStore(projectDir);
  return Object.values(store.items).sort((a, b) => Date.parse(b.createdAt) - Date.parse(a.createdAt)).slice(0, Math.max(1, limit));
}
function runMediaGc(projectDir) {
  const store = readStore(projectDir);
  const now = Date.now();
  let removed = 0;
  for (const [id, item] of Object.entries(store.items)) {
    const expired = Date.parse(item.expiresAt) <= now;
    if (!expired)
      continue;
    if (item.localPath && fs8.existsSync(item.localPath)) {
      try {
        fs8.unlinkSync(item.localPath);
      } catch {}
    }
    delete store.items[id];
    removed += 1;
  }
  writeStore(projectDir, store);
  return {
    removed,
    kept: Object.keys(store.items).length
  };
}
var DEFAULT_TTL_HOURS = 24;
var init_store2 = __esm(() => {
  init_workflow();
  init_system_keyring();
});

// src/multimodal/ocr-cache.ts
var init_ocr_cache = __esm(() => {
  init_workflow();
});

// src/multimodal/vision.ts
import * as fs9 from "node:fs";
async function commandExists(command) {
  const probe = process.platform === "win32" ? ["where", command] : ["which", command];
  const proc = Bun.spawn(probe, { stdout: "pipe", stderr: "pipe" });
  let timedOut = false;
  const timer = setTimeout(() => {
    timedOut = true;
    try {
      proc.kill();
    } catch {}
  }, 3000);
  const code = await proc.exited;
  clearTimeout(timer);
  return !timedOut && code === 0;
}
async function runTesseractOcr(imagePath) {
  if (!await commandExists("tesseract"))
    return "";
  const args = process.platform === "win32" ? ["tesseract", imagePath, "stdout", "--psm", "6"] : ["tesseract", imagePath, "stdout", "--psm", "6"];
  const proc = Bun.spawn(args, { stdout: "pipe", stderr: "pipe" });
  let timedOut = false;
  const timer = setTimeout(() => {
    timedOut = true;
    try {
      proc.kill();
    } catch {}
  }, 8000);
  const code = await proc.exited;
  clearTimeout(timer);
  if (timedOut || code !== 0)
    return "";
  return (await new Response(proc.stdout).text()).trim();
}
async function runRemoteVisionInference(imagePath, question) {
  const endpoint = process.env.MIYA_VISION_OCR_ENDPOINT?.trim();
  if (!endpoint)
    return { text: "" };
  if (!fs9.existsSync(imagePath))
    return { text: "" };
  const image = fs9.readFileSync(imagePath);
  const mimeType = imagePath.endsWith(".png") ? "image/png" : imagePath.endsWith(".jpg") || imagePath.endsWith(".jpeg") ? "image/jpeg" : "application/octet-stream";
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        imageBase64: image.toString("base64"),
        mimeType,
        question: question ?? ""
      })
    });
    if (!response.ok)
      return { text: "" };
    const payload = await response.json();
    const text = String(payload.text ?? payload.ocr_text ?? "").trim();
    return {
      text,
      summary: payload.summary ? String(payload.summary) : undefined,
      boxes: Array.isArray(payload.boxes) ? payload.boxes : undefined
    };
  } catch {
    return { text: "" };
  }
}
async function readTextFromImage(imagePath, question) {
  const remote = await runRemoteVisionInference(imagePath, question);
  if (remote.text) {
    return {
      source: "remote_vlm",
      text: remote.text,
      summary: remote.summary,
      boxes: remote.boxes
    };
  }
  const tesseractText = await runTesseractOcr(imagePath);
  if (tesseractText) {
    return {
      source: "tesseract",
      text: tesseractText
    };
  }
  return {
    source: "none",
    text: ""
  };
}
function normalizeCaptureMethod(input) {
  const raw = String(input ?? "").trim().toLowerCase();
  if (!raw)
    return null;
  if (raw === "wgc" || raw === "wgc_hwnd")
    return "wgc_hwnd";
  if (raw === "printwindow" || raw === "print_window")
    return "print_window";
  if (raw === "dxgi" || raw === "dxgi_duplication")
    return "dxgi_duplication";
  if (raw === "uia" || raw === "uia_only")
    return "uia_only";
  if (raw === "unknown")
    return "unknown";
  return null;
}
function parseCaptureMethods(input) {
  const raw = String(input ?? "").trim();
  if (!raw)
    return [...CAPTURE_PRIORITY];
  const methods = raw.split(",").map((item) => normalizeCaptureMethod(item)).filter((item) => Boolean(item) && item !== "unknown");
  if (methods.length === 0)
    return [...CAPTURE_PRIORITY];
  return [...new Set(methods)];
}
function inferCaptureProbeLimitations(input) {
  const signal = `${input.visualPrecheck ?? ""}|${input.visualPostcheck ?? ""}`.toLowerCase();
  const result = [];
  if (!signal.trim())
    return result;
  if (signal.includes("black"))
    result.push("capture_probe_black_screen");
  if (signal.includes("timeout"))
    result.push("capture_probe_timeout");
  if (signal.includes("error") || signal.includes("failed"))
    result.push("capture_probe_error");
  if (signal.includes("occluded"))
    result.push("capture_probe_occluded");
  return [...new Set(result)];
}
function compactOcrText(text) {
  return (text || "").replace(/\s+/g, "").toLowerCase();
}
function parseDesktopOcrSignals(ocrText, expectedRecipient) {
  const normalized = (ocrText || "").replace(/\s+/g, " ").trim();
  const recipient = expectedRecipient.trim();
  const lowered = normalized.toLowerCase();
  const compactNormalized = compactOcrText(normalized);
  const compactRecipient = compactOcrText(recipient);
  const recipientDetected = recipient && (normalized.includes(recipient) || lowered.includes(recipient.toLowerCase()) || compactRecipient.length > 0 && compactNormalized.includes(compactRecipient)) ? recipient : "";
  const sentHints = [
    "发送成功",
    "已发送",
    "sent",
    "delivered",
    "发送",
    "已发出"
  ];
  const failHints = [
    "发送失败",
    "failed",
    "失败",
    "retry",
    "重试",
    "未发送"
  ];
  const hasSent = sentHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const hasFail = failHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const sendStatusDetected = hasFail ? "failed" : hasSent ? "sent" : "uncertain";
  let recipientMatch = "uncertain";
  if (recipientDetected) {
    recipientMatch = "matched";
  } else if (recipient && normalized.length > 0) {
    recipientMatch = "mismatch";
  }
  return {
    recipientDetected,
    recipientMatch,
    sendStatusDetected
  };
}
async function analyzeDesktopOutboundEvidence(input) {
  const capture = resolveCaptureCapability(input);
  const candidates = [
    input.postSendScreenshotPath,
    input.preSendScreenshotPath
  ].filter((item) => typeof item === "string" && fs9.existsSync(item));
  if (candidates.length === 0) {
    const recipientMatch = input.recipientTextCheck ?? "uncertain";
    const sendStatusDetected = input.receiptStatus === "confirmed" ? "sent" : "uncertain";
    return {
      recipientMatch,
      sendStatusDetected,
      ocrSource: "none",
      ocrPreview: "",
      uiStyleMismatch: true,
      retries: 0,
      capture: {
        method: capture.method,
        confidence: capture.confidence,
        limitations: mergeCaptureLimitations(capture.limitations, {
          uiStyleMismatch: true,
          recipientMatch,
          sendStatusDetected
        })
      }
    };
  }
  const isLowConfidenceText = (text) => {
    const trimmed = (text || "").replace(/\s+/g, "");
    if (trimmed.length < 8)
      return true;
    const meaningful = trimmed.replace(/[a-zA-Z0-9\u4e00-\u9fa5]/g, "");
    const noiseRatio = meaningful.length / Math.max(1, trimmed.length);
    return noiseRatio > 0.6;
  };
  let inferred = await readTextFromImage(candidates[0], "识别聊天界面收件人与发送状态");
  let signals = parseDesktopOcrSignals(inferred.text, input.destination);
  let retries = 0;
  let uiStyleMismatch = inferred.source === "none" || signals.recipientMatch !== "matched" && isLowConfidenceText(inferred.text);
  if (candidates.length > 1 && (signals.recipientMatch === "mismatch" || uiStyleMismatch)) {
    const retryInferred = await readTextFromImage(candidates[1], "DPI样式兼容重试：识别聊天界面收件人与发送状态");
    const retrySignals = parseDesktopOcrSignals(retryInferred.text, input.destination);
    retries = 1;
    const retryBetter = retrySignals.recipientMatch === "matched" || retrySignals.sendStatusDetected !== "uncertain" && signals.sendStatusDetected === "uncertain" || !isLowConfidenceText(retryInferred.text) && isLowConfidenceText(inferred.text);
    if (retryBetter) {
      inferred = retryInferred;
      signals = retrySignals;
    }
    uiStyleMismatch = (inferred.source === "none" || isLowConfidenceText(inferred.text)) && signals.recipientMatch !== "matched";
  }
  const mergedRecipient = signals.recipientMatch === "mismatch" && input.recipientTextCheck === "matched" ? "matched" : signals.recipientMatch === "uncertain" ? input.recipientTextCheck ?? "uncertain" : signals.recipientMatch;
  const mergedStatus = signals.sendStatusDetected === "uncertain" ? input.receiptStatus === "confirmed" ? "sent" : "uncertain" : signals.sendStatusDetected;
  const stableRecipient = uiStyleMismatch && mergedRecipient === "mismatch" ? "uncertain" : mergedRecipient;
  const confidence = estimateEvidenceConfidence({
    ocrSource: inferred.source,
    uiStyleMismatch,
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    retries
  });
  const mergedConfidence = Number(Math.min(confidence, capture.confidence).toFixed(2));
  if (mergedConfidence < 0.45) {
    uiStyleMismatch = true;
  }
  return {
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    ocrSource: inferred.source,
    ocrPreview: inferred.text.slice(0, 300),
    uiStyleMismatch,
    retries,
    capture: {
      method: capture.method,
      confidence: mergedConfidence,
      limitations: mergeCaptureLimitations(capture.limitations, {
        uiStyleMismatch,
        recipientMatch: stableRecipient,
        sendStatusDetected: mergedStatus
      })
    }
  };
}
function resolveCaptureCapability(input) {
  const hasScreenshots = typeof input.preSendScreenshotPath === "string" && input.preSendScreenshotPath.length > 0 && fs9.existsSync(input.preSendScreenshotPath) || typeof input.postSendScreenshotPath === "string" && input.postSendScreenshotPath.length > 0 && fs9.existsSync(input.postSendScreenshotPath);
  const supported = parseCaptureMethods(process.env.MIYA_CAPTURE_CAPABILITIES);
  const preferred = CAPTURE_PRIORITY.find((item) => supported.includes(item));
  const requested = normalizeCaptureMethod(process.env.MIYA_CAPTURE_METHOD);
  let method = "unknown";
  if (hasScreenshots) {
    if (requested && supported.includes(requested)) {
      method = requested;
    } else if (preferred) {
      method = preferred;
    } else {
      method = "unknown";
    }
  } else {
    method = supported.includes("uia_only") ? "uia_only" : "unknown";
  }
  const limitations = [];
  limitations.push(...inferCaptureProbeLimitations(input));
  if (!hasScreenshots) {
    limitations.push("no_desktop_screenshot");
  }
  if (requested && requested !== "unknown" && !supported.includes(requested)) {
    limitations.push(`capture_method_not_supported:${requested}`);
  }
  if (hasScreenshots && preferred && method !== "unknown" && method !== preferred) {
    limitations.push(`capture_fallback:${preferred}->${method}`);
  }
  if (!hasScreenshots && preferred && preferred !== "uia_only") {
    limitations.push(`capture_tree_exhausted:${preferred}`);
  }
  if (method === "unknown")
    limitations.push("capture_method_unspecified");
  if (method === "uia_only")
    limitations.push("pixel_evidence_unavailable");
  const baseByMethod = {
    wgc_hwnd: 0.92,
    print_window: 0.84,
    dxgi_duplication: 0.76,
    uia_only: 0.4,
    unknown: 0.24
  };
  let confidence = baseByMethod[method];
  if (!hasScreenshots) {
    confidence = Math.min(confidence, method === "uia_only" ? 0.34 : 0.24);
  }
  if (limitations.includes("capture_probe_black_screen")) {
    confidence = Math.min(confidence, 0.28);
  }
  if (limitations.includes("capture_probe_timeout")) {
    confidence = Math.min(confidence, 0.3);
  }
  if (limitations.includes("capture_probe_error")) {
    confidence = Math.min(confidence, 0.3);
  }
  return {
    method,
    confidence: Number(confidence.toFixed(2)),
    limitations
  };
}
function estimateEvidenceConfidence(input) {
  let score = input.ocrSource === "remote_vlm" ? 0.86 : input.ocrSource === "tesseract" ? 0.72 : 0.35;
  if (input.uiStyleMismatch)
    score -= 0.32;
  if (input.recipientMatch === "matched")
    score += 0.08;
  if (input.sendStatusDetected === "sent" || input.sendStatusDetected === "failed")
    score += 0.04;
  if (input.retries > 0)
    score -= 0.05;
  if (score < 0)
    return 0;
  if (score > 1)
    return 1;
  return Number(score.toFixed(2));
}
function mergeCaptureLimitations(base, input) {
  const result = [...base];
  if (input.uiStyleMismatch)
    result.push("ui_style_mismatch");
  if (input.recipientMatch === "uncertain")
    result.push("recipient_unverified");
  if (input.sendStatusDetected === "uncertain")
    result.push("delivery_unverified");
  return [...new Set(result)];
}
var CAPTURE_PRIORITY;
var init_vision = __esm(() => {
  init_store2();
  init_ocr_cache();
  CAPTURE_PRIORITY = [
    "wgc_hwnd",
    "print_window",
    "dxgi_duplication",
    "uia_only"
  ];
});

// src/channels/policy.ts
function getChannelDirection(channel) {
  return OUTBOUND_ALLOWLIST_CHANNELS.has(channel) ? "OUTBOUND_ALLOWLIST" : "INBOUND_ONLY";
}
function canChannelSend(channel) {
  return getChannelDirection(channel) === "OUTBOUND_ALLOWLIST";
}
function assertChannelCanSend(channel) {
  if (canChannelSend(channel))
    return;
  throw new Error(`channel_send_blocked:${channel}:INBOUND_ONLY channels are receive-only`);
}
var OUTBOUND_ALLOWLIST_CHANNELS;
var init_policy = __esm(() => {
  OUTBOUND_ALLOWLIST_CHANNELS = new Set(["qq", "wechat"]);
});

// src/channels/types.ts
function isChannelName(value) {
  return typeof value === "string" && CHANNEL_NAMES.includes(value);
}
var CHANNEL_NAMES;
var init_types = __esm(() => {
  CHANNEL_NAMES = [
    "qq",
    "wechat",
    "telegram",
    "slack",
    "discord",
    "whatsapp",
    "google_chat",
    "signal",
    "imessage",
    "teams",
    "webchat"
  ];
});

// src/channels/pairing-store.ts
import * as fs10 from "node:fs";
import * as path9 from "node:path";
function nowIso2() {
  return new Date().toISOString();
}
function filePath2(projectDir) {
  return path9.join(getMiyaRuntimeDir(projectDir), "channels.json");
}
function ensureDir4(file3) {
  fs10.mkdirSync(path9.dirname(file3), { recursive: true });
}
function defaultChannelState(name) {
  return {
    name,
    enabled: name === "webchat",
    connected: name === "webchat",
    updatedAt: nowIso2(),
    allowlist: [],
    contactTiers: {}
  };
}
function defaultStore() {
  const channels = {};
  for (const name of CHANNEL_NAMES) {
    channels[name] = defaultChannelState(name);
  }
  return { channels, pairs: [] };
}
function readChannelStore(projectDir) {
  const file3 = filePath2(projectDir);
  if (!fs10.existsSync(file3)) {
    return defaultStore();
  }
  try {
    const parsed = JSON.parse(fs10.readFileSync(file3, "utf-8"));
    const fallback = defaultStore();
    const mergedChannels = {};
    for (const name of CHANNEL_NAMES) {
      const channel = {
        ...fallback.channels[name],
        ...parsed.channels?.[name] ?? {}
      };
      const allowlist = Array.isArray(channel.allowlist) ? channel.allowlist.map((item) => decryptSensitiveValue(projectDir, String(item))) : [];
      const contactTiersRaw = channel.contactTiers && typeof channel.contactTiers === "object" ? channel.contactTiers : {};
      const contactTiers = {};
      for (const [senderID, tier] of Object.entries(contactTiersRaw)) {
        const decoded = decryptSensitiveValue(projectDir, senderID);
        if (tier === "owner" || tier === "friend") {
          contactTiers[decoded] = tier;
        }
      }
      mergedChannels[name] = {
        ...channel,
        allowlist,
        contactTiers
      };
    }
    const pairs = Array.isArray(parsed.pairs) ? parsed.pairs : [];
    return {
      channels: mergedChannels,
      pairs: pairs.map((pair) => ({
        ...pair,
        senderID: decryptSensitiveValue(projectDir, pair.senderID),
        displayName: pair.displayName ? decryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
        messagePreview: pair.messagePreview ? decryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
      }))
    };
  } catch {
    return defaultStore();
  }
}
function writeChannelStore(projectDir, store) {
  const file3 = filePath2(projectDir);
  ensureDir4(file3);
  const encrypted = {
    channels: Object.fromEntries(Object.entries(store.channels).map(([name, state]) => {
      const contactTiers = {};
      for (const [senderID, tier] of Object.entries(state.contactTiers ?? {})) {
        contactTiers[encryptSensitiveValue(projectDir, senderID)] = tier;
      }
      return [
        name,
        {
          ...state,
          allowlist: state.allowlist.map((item) => encryptSensitiveValue(projectDir, item)),
          contactTiers
        }
      ];
    })),
    pairs: store.pairs.map((pair) => ({
      ...pair,
      senderID: encryptSensitiveValue(projectDir, pair.senderID),
      displayName: pair.displayName ? encryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
      messagePreview: pair.messagePreview ? encryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
    }))
  };
  fs10.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function listChannelStates(projectDir) {
  const store = readChannelStore(projectDir);
  return Object.values(store.channels).sort((a, b) => a.name.localeCompare(b.name));
}
function upsertChannelState(projectDir, name, patch) {
  const store = readChannelStore(projectDir);
  const next = {
    ...store.channels[name],
    ...patch,
    name,
    updatedAt: nowIso2()
  };
  store.channels[name] = next;
  writeChannelStore(projectDir, store);
  return next;
}
function ensurePairRequest(projectDir, input) {
  const store = readChannelStore(projectDir);
  const existing = store.pairs.find((item) => item.channel === input.channel && item.senderID === input.senderID && item.status === "pending");
  if (existing)
    return existing;
  const next = {
    id: `pair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    channel: input.channel,
    senderID: input.senderID,
    displayName: input.displayName,
    messagePreview: input.messagePreview,
    status: "pending",
    requestedAt: nowIso2()
  };
  store.pairs = [next, ...store.pairs].slice(0, 1000);
  writeChannelStore(projectDir, store);
  return next;
}
function resolvePairRequest(projectDir, pairID, status) {
  const store = readChannelStore(projectDir);
  const pair = store.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending")
    return null;
  pair.status = status;
  pair.resolvedAt = nowIso2();
  if (status === "approved") {
    const channel = store.channels[pair.channel];
    const ownerByEnv = new Set(String(process.env.MIYA_OWNER_IDS ?? "").split(",").map((item) => item.trim()).filter(Boolean));
    if (!channel.allowlist.includes(pair.senderID)) {
      channel.allowlist = [...channel.allowlist, pair.senderID].sort();
    }
    const currentTier = channel.contactTiers?.[pair.senderID];
    const resolvedTier = currentTier ?? (ownerByEnv.has(pair.senderID) ? "owner" : "friend");
    channel.contactTiers = {
      ...channel.contactTiers ?? {},
      [pair.senderID]: resolvedTier
    };
    channel.updatedAt = nowIso2();
  }
  writeChannelStore(projectDir, store);
  return pair;
}
function listPairRequests(projectDir, status) {
  const store = readChannelStore(projectDir);
  const pairs = status ? store.pairs.filter((item) => item.status === status) : store.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function isSenderAllowed(projectDir, channel, senderID) {
  const store = readChannelStore(projectDir);
  const allowed = store.channels[channel].allowlist;
  return allowed.includes(senderID);
}
function getContactTier(projectDir, channel, senderID) {
  const store = readChannelStore(projectDir);
  const state = store.channels[channel];
  if (!state.allowlist.includes(senderID))
    return null;
  return state.contactTiers?.[senderID] ?? "friend";
}
function setContactTier(projectDir, channel, senderID, tier) {
  const store = readChannelStore(projectDir);
  const state = store.channels[channel];
  const allowlist = state.allowlist.includes(senderID) ? state.allowlist : [...state.allowlist, senderID].sort();
  const next = {
    ...state,
    allowlist,
    contactTiers: {
      ...state.contactTiers ?? {},
      [senderID]: tier
    },
    updatedAt: nowIso2()
  };
  store.channels[channel] = next;
  writeChannelStore(projectDir, store);
  return next;
}
function listContactTiers(projectDir, channel) {
  const store = readChannelStore(projectDir);
  const channels = channel ? [channel] : [...CHANNEL_NAMES];
  const rows = [];
  for (const name of channels) {
    const state = store.channels[name];
    const mapping = state.contactTiers ?? {};
    for (const senderID of state.allowlist) {
      rows.push({
        channel: name,
        senderID,
        tier: mapping[senderID] ?? "friend"
      });
    }
  }
  return rows.sort((a, b) => `${a.channel}:${a.senderID}`.localeCompare(`${b.channel}:${b.senderID}`));
}
var init_pairing_store = __esm(() => {
  init_workflow();
  init_system_keyring();
  init_types();
});

// src/policy/index.ts
import { createHash as createHash3 } from "node:crypto";
import * as fs11 from "node:fs";
import * as path10 from "node:path";
function nowIso3() {
  return new Date().toISOString();
}
function policyFile(projectDir) {
  return path10.join(getMiyaRuntimeDir(projectDir), "policy.json");
}
function defaultPolicy() {
  return {
    version: 1,
    updatedAt: nowIso3(),
    domains: {
      outbound_send: "running",
      desktop_control: "running",
      shell_exec: "running",
      fs_write: "running",
      memory_read: "running",
      memory_write: "running",
      memory_delete: "running",
      training: "running",
      media_generate: "running",
      read_only_research: "running",
      local_build: "running"
    },
    outbound: {
      allowedChannels: ["qq", "wechat"],
      requireArchAdvisorApproval: true,
      requireAllowlist: true,
      minIntervalMs: 4000,
      burstWindowMs: 60000,
      burstLimit: 3,
      duplicateWindowMs: 60000
    }
  };
}
function readPolicy(projectDir) {
  const file3 = policyFile(projectDir);
  if (!fs11.existsSync(file3)) {
    const base = defaultPolicy();
    fs11.mkdirSync(path10.dirname(file3), { recursive: true });
    fs11.writeFileSync(file3, `${JSON.stringify(base, null, 2)}
`, "utf-8");
    return base;
  }
  try {
    const parsed = JSON.parse(fs11.readFileSync(file3, "utf-8"));
    const base = defaultPolicy();
    const parsedDomains = parsed.domains && typeof parsed.domains === "object" ? parsed.domains : {};
    return {
      ...base,
      ...parsed,
      domains: {
        ...base.domains,
        ...parsedDomains
      },
      outbound: {
        ...base.outbound,
        ...parsed.outbound ?? {}
      }
    };
  } catch {
    return defaultPolicy();
  }
}
function writePolicy(projectDir, patch) {
  const file3 = policyFile(projectDir);
  const current = readPolicy(projectDir);
  const next = {
    ...current,
    ...patch,
    outbound: {
      ...current.outbound,
      ...patch.outbound ?? {}
    },
    updatedAt: nowIso3()
  };
  fs11.mkdirSync(path10.dirname(file3), { recursive: true });
  fs11.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function hashPolicy(policy) {
  return createHash3("sha256").update(JSON.stringify({
    version: policy.version,
    domains: policy.domains,
    outbound: policy.outbound
  })).digest("hex");
}
function currentPolicyHash(projectDir) {
  return hashPolicy(readPolicy(projectDir));
}
function assertPolicyHash(projectDir, providedHash) {
  const hash3 = currentPolicyHash(projectDir);
  if (!providedHash) {
    return { ok: false, hash: hash3, reason: "missing_policy_hash" };
  }
  if (providedHash !== hash3) {
    return { ok: false, hash: hash3, reason: "policy_hash_mismatch" };
  }
  return { ok: true, hash: hash3 };
}
function isDomainRunning(projectDir, domain3) {
  const policy = readPolicy(projectDir);
  return policy.domains[domain3] === "running";
}
function isPolicyDomain(value) {
  return typeof value === "string" && POLICY_DOMAINS.includes(value);
}
var POLICY_DOMAINS;
var init_policy2 = __esm(() => {
  init_workflow();
  POLICY_DOMAINS = [
    "outbound_send",
    "desktop_control",
    "shell_exec",
    "fs_write",
    "memory_read",
    "memory_write",
    "memory_delete",
    "training",
    "media_generate",
    "read_only_research",
    "local_build"
  ];
});

// src/policy/semantic-tags.ts
function isSemanticTag(value) {
  return typeof value === "string" && SEMANTIC_TAGS.includes(value);
}
function normalizeSemanticTags(value) {
  if (!Array.isArray(value))
    return [];
  return value.map((item) => String(item)).filter((item) => isSemanticTag(item));
}
function assertSemanticTags(value) {
  if (!Array.isArray(value))
    return;
  for (const item of value) {
    if (!isSemanticTag(item)) {
      throw new Error(`invalid_semantic_tag:${String(item)}`);
    }
  }
}
var SEMANTIC_TAGS;
var init_semantic_tags = __esm(() => {
  SEMANTIC_TAGS = [
    "window_not_found",
    "window_occluded",
    "recipient_mismatch",
    "input_mutex_timeout",
    "receipt_uncertain",
    "privilege_barrier",
    "ui_style_mismatch"
  ];
});

// src/channels/service.ts
import * as fs12 from "node:fs";
import * as path11 from "node:path";
import { createHash as createHash4, randomUUID as randomUUID3 } from "node:crypto";
function parseEnvList(input) {
  if (!input)
    return [];
  return input.split(",").map((value) => value.trim()).filter(Boolean);
}
function outboundAuditFile(projectDir) {
  return path11.join(getMiyaRuntimeDir(projectDir), "channels-outbound.jsonl");
}
function appendOutboundAudit(projectDir, row) {
  const file3 = outboundAuditFile(projectDir);
  fs12.mkdirSync(path11.dirname(file3), { recursive: true });
  fs12.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
function semanticTagsForOutboundMessage(message) {
  if (message.includes("target_not_in_allowlist"))
    return ["recipient_mismatch"];
  if (message.includes("recipient_text_mismatch"))
    return ["recipient_mismatch"];
  if (message.includes("arch_advisor_denied"))
    return ["privilege_barrier"];
  if (message.includes("input_mutex_timeout"))
    return ["input_mutex_timeout"];
  if (message.includes("receipt_uncertain"))
    return ["receipt_uncertain"];
  if (message.includes("blocked_by_privilege") || message.includes("privilege")) {
    return ["privilege_barrier"];
  }
  if (message.includes("window_not_found"))
    return ["window_not_found"];
  if (message.includes("window_occluded"))
    return ["window_occluded"];
  if (message.includes("ui_style_mismatch"))
    return ["ui_style_mismatch"];
  return [];
}
function parsePositiveIntEnv(name, fallback) {
  const raw = process.env[name];
  if (!raw)
    return fallback;
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0)
    return fallback;
  return Math.floor(parsed);
}
function acquireInputMutex(sessionID, timeoutMs = INPUT_MUTEX_TIMEOUT_MS) {
  return new Promise((resolve, reject) => {
    let released = false;
    const makeLease = () => ({
      release: () => {
        if (released)
          return;
        released = true;
        if (inputMutexOwner === sessionID) {
          inputMutexOwner = null;
        }
        while (inputMutexQueue.length > 0 && !inputMutexOwner) {
          const next = inputMutexQueue.shift();
          if (!next)
            break;
          if (!next.active)
            continue;
          next.grant();
        }
      }
    });
    const pending = {
      sessionID,
      active: true,
      grant: () => {}
    };
    const timer = setTimeout(() => {
      pending.active = false;
      const idx = inputMutexQueue.indexOf(pending);
      if (idx >= 0)
        inputMutexQueue.splice(idx, 1);
      reject(new Error("input_mutex_timeout"));
    }, timeoutMs);
    const grant = () => {
      if (!pending.active)
        return;
      pending.active = false;
      clearTimeout(timer);
      inputMutexOwner = sessionID;
      resolve(makeLease());
    };
    pending.grant = grant;
    if (!inputMutexOwner) {
      grant();
      return;
    }
    inputMutexQueue.push(pending);
  });
}
function buildSemanticSummary(row) {
  if (row.sent) {
    return {
      conclusion: "Outbound send completed with verifiable desktop evidence.",
      keyAssertion: `recipient_check=${row.recipientTextCheck ?? "uncertain"}, send_status=${row.sendStatusCheck ?? "uncertain"}`,
      recovery: "No recovery needed."
    };
  }
  if (row.message.includes("arch_advisor_denied")) {
    return {
      conclusion: "Outbound send blocked by Arch Advisor approval gate.",
      keyAssertion: "Arch Advisor approval flag was false, so outbound flow was denied before desktop execution.",
      recovery: "Re-issue approval ticket via Arch Advisor and retry only after policy checks pass."
    };
  }
  if (row.message.includes("input_mutex_timeout")) {
    return {
      conclusion: "Outbound send blocked by input mutex timeout.",
      keyAssertion: "Desktop control was denied because user input mutex could not be acquired in time.",
      recovery: "Wait for user idle state and retry with renewed approval tickets."
    };
  }
  if (row.message.includes("ui_style_mismatch")) {
    return {
      conclusion: "Outbound send degraded due to unstable UI/OCR style mismatch.",
      keyAssertion: "Visual confirmation confidence was too low after retry, so send was treated as failed.",
      recovery: "Adjust DPI/theme/window state, then retry with refreshed evidence."
    };
  }
  return {
    conclusion: row.sent ? "Outbound send completed." : "Outbound send blocked or uncertain.",
    keyAssertion: `message=${row.message}`,
    recovery: row.sent ? "No recovery needed." : "Review desktop evidence and retry only after policy/approval checks pass."
  };
}
function buildEvidenceBundle(row) {
  if (row.channel !== "qq" && row.channel !== "wechat")
    return;
  const screenshots = [row.preSendScreenshotPath, row.postSendScreenshotPath].filter((item) => typeof item === "string" && item.length > 0);
  const ticketTraceIds = [
    row.ticketSummary?.outboundSendTraceId,
    row.ticketSummary?.desktopControlTraceId
  ].filter((item) => typeof item === "string" && item.length > 0);
  return {
    kind: "desktop_outbound",
    version: "v5",
    destination: row.destination,
    payloadHash: row.payloadHash,
    ticketTraceIds: ticketTraceIds.length > 0 ? ticketTraceIds : undefined,
    screenshots,
    checks: {
      recipientTextCheck: row.recipientTextCheck,
      sendStatusCheck: row.sendStatusCheck,
      receiptStatus: row.receiptStatus
    },
    diagnostics: {
      windowFingerprint: row.windowFingerprint,
      failureStep: row.failureStep,
      ocrSource: row.ocrSource,
      ocrPreview: row.ocrPreview
    },
    meta: {
      captureMethod: row.captureMethod ?? "unknown",
      confidence: Number.isFinite(row.evidenceConfidence) ? Number(row.evidenceConfidence) : 0,
      limitations: row.evidenceLimitations ?? [],
      policyHash: row.policyHash
    },
    simulation: screenshots.length > 0 ? {
      status: "captured",
      clickTargets: []
    } : {
      status: "not_available",
      reason: "desktop_screenshots_missing"
    }
  };
}
function listOutboundAudit(projectDir, limit = 50) {
  const file3 = outboundAuditFile(projectDir);
  if (!fs12.existsSync(file3))
    return [];
  const rows = fs12.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}

class ChannelRuntime {
  projectDir;
  callbacks;
  sendQqDesktopMessageImpl;
  sendWechatDesktopMessageImpl;
  analyzeDesktopOutboundEvidenceImpl;
  telegramPolling = false;
  telegramOffset = 0;
  slackSocketModeRunning = false;
  slackSocket;
  slackReconnectTimer;
  outboundThrottle = new Map;
  outboundPayloadHistory = new Map;
  inputMutexStrike = new Map;
  inputMutexCooldownUntil = new Map;
  sendFingerprintHistory = new Map;
  constructor(projectDir, callbacks, deps = {}) {
    this.projectDir = projectDir;
    this.callbacks = callbacks;
    this.sendQqDesktopMessageImpl = deps.sendQqDesktopMessage ?? sendQqDesktopMessage;
    this.sendWechatDesktopMessageImpl = deps.sendWechatDesktopMessage ?? sendWechatDesktopMessage;
    this.analyzeDesktopOutboundEvidenceImpl = deps.analyzeDesktopOutboundEvidence ?? analyzeDesktopOutboundEvidence;
  }
  listChannels() {
    return listChannelStates(this.projectDir);
  }
  listPairs(status) {
    return listPairRequests(this.projectDir, status);
  }
  approvePair(pairID) {
    return resolvePairRequest(this.projectDir, pairID, "approved");
  }
  rejectPair(pairID) {
    return resolvePairRequest(this.projectDir, pairID, "rejected");
  }
  markChannelEnabled(channel, enabled) {
    upsertChannelState(this.projectDir, channel, { enabled, connected: enabled });
  }
  async start() {
    upsertChannelState(this.projectDir, "webchat", { enabled: true, connected: true });
    await this.startTelegramPolling();
    this.syncPassiveChannelStates();
    await this.startSlackSocketMode();
  }
  syncPassiveChannelStates() {
    upsertChannelState(this.projectDir, "qq", {
      enabled: false,
      connected: false,
      lastError: "QQ outbound requires desktop UI automation runtime"
    });
    upsertChannelState(this.projectDir, "wechat", {
      enabled: false,
      connected: false,
      lastError: "WeChat outbound requires desktop UI automation runtime"
    });
    const hasSlack = !!process.env.MIYA_SLACK_BOT_TOKEN;
    upsertChannelState(this.projectDir, "slack", {
      enabled: hasSlack,
      connected: hasSlack,
      lastError: hasSlack ? undefined : "Missing MIYA_SLACK_BOT_TOKEN"
    });
    const hasDiscord = !!process.env.MIYA_DISCORD_BOT_TOKEN;
    upsertChannelState(this.projectDir, "discord", {
      enabled: hasDiscord,
      connected: hasDiscord,
      lastError: hasDiscord ? undefined : "Missing MIYA_DISCORD_BOT_TOKEN"
    });
    const hasWhatsApp = !!process.env.MIYA_WHATSAPP_TOKEN && !!process.env.MIYA_WHATSAPP_PHONE_NUMBER_ID;
    upsertChannelState(this.projectDir, "whatsapp", {
      enabled: hasWhatsApp,
      connected: hasWhatsApp,
      lastError: hasWhatsApp ? undefined : "Missing MIYA_WHATSAPP_TOKEN or MIYA_WHATSAPP_PHONE_NUMBER_ID"
    });
    const hasGoogleChat = !!process.env.MIYA_GOOGLE_CHAT_WEBHOOK_URL;
    upsertChannelState(this.projectDir, "google_chat", {
      enabled: hasGoogleChat,
      connected: hasGoogleChat,
      lastError: hasGoogleChat ? undefined : "Missing MIYA_GOOGLE_CHAT_WEBHOOK_URL"
    });
    const hasSignal = !!process.env.MIYA_SIGNAL_REST_URL;
    upsertChannelState(this.projectDir, "signal", {
      enabled: hasSignal,
      connected: hasSignal,
      lastError: hasSignal ? undefined : "Missing MIYA_SIGNAL_REST_URL"
    });
    const hasIMessage = !!process.env.MIYA_BLUEBUBBLES_URL;
    upsertChannelState(this.projectDir, "imessage", {
      enabled: hasIMessage,
      connected: hasIMessage,
      lastError: hasIMessage ? undefined : "Missing MIYA_BLUEBUBBLES_URL"
    });
    const hasTeams = !!process.env.MIYA_TEAMS_WEBHOOK_URL;
    upsertChannelState(this.projectDir, "teams", {
      enabled: hasTeams,
      connected: hasTeams,
      lastError: hasTeams ? undefined : "Missing MIYA_TEAMS_WEBHOOK_URL"
    });
  }
  async startSlackSocketMode() {
    const appToken = process.env.MIYA_SLACK_APP_TOKEN;
    const botToken = process.env.MIYA_SLACK_BOT_TOKEN;
    if (!appToken || !botToken || this.slackSocketModeRunning)
      return;
    this.slackSocketModeRunning = true;
    const connect = async () => {
      if (!this.slackSocketModeRunning)
        return;
      try {
        const openRes = await fetch("https://slack.com/api/apps.connections.open", {
          method: "POST",
          headers: {
            authorization: `Bearer ${appToken}`,
            "content-type": "application/json"
          },
          body: "{}"
        });
        const openBody = await openRes.json();
        if (!openBody.ok || !openBody.url) {
          throw new Error(openBody.error ?? "slack_socket_open_failed");
        }
        const socket = new WebSocket(openBody.url);
        this.slackSocket = socket;
        socket.onopen = () => {
          upsertChannelState(this.projectDir, "slack", {
            enabled: true,
            connected: true,
            lastError: undefined
          });
        };
        socket.onmessage = (event) => {
          this.handleSlackSocketMessage(String(event.data));
        };
        socket.onerror = () => {
          upsertChannelState(this.projectDir, "slack", {
            connected: false,
            lastError: "slack_socket_error"
          });
        };
        socket.onclose = () => {
          if (!this.slackSocketModeRunning)
            return;
          upsertChannelState(this.projectDir, "slack", {
            connected: false,
            lastError: "slack_socket_closed"
          });
          this.scheduleSlackReconnect(connect);
        };
      } catch (error92) {
        upsertChannelState(this.projectDir, "slack", {
          connected: false,
          lastError: error92 instanceof Error ? error92.message : String(error92)
        });
        this.scheduleSlackReconnect(connect);
      }
    };
    await connect();
  }
  scheduleSlackReconnect(connect) {
    if (!this.slackSocketModeRunning)
      return;
    if (this.slackReconnectTimer)
      clearTimeout(this.slackReconnectTimer);
    this.slackReconnectTimer = setTimeout(() => {
      connect();
    }, 3000);
  }
  async handleSlackSocketMessage(messageText) {
    if (!messageText.trim())
      return;
    const payload = JSON.parse(messageText);
    if (payload.envelope_id && this.slackSocket?.readyState === WebSocket.OPEN) {
      this.slackSocket.send(JSON.stringify({ envelope_id: payload.envelope_id }));
    }
    if (payload.type !== "events_api")
      return;
    const event = payload.payload?.event;
    if (!event)
      return;
    if (event.type !== "message")
      return;
    if (!event.user || !event.text || !event.channel)
      return;
    if (event.bot_id)
      return;
    await this.handleInbound({
      channel: "slack",
      senderID: event.user,
      displayName: event.user,
      conversationID: event.channel,
      text: event.text,
      raw: payload
    });
  }
  async startTelegramPolling() {
    const token = process.env.MIYA_TELEGRAM_BOT_TOKEN;
    if (!token) {
      upsertChannelState(this.projectDir, "telegram", {
        enabled: false,
        connected: false,
        lastError: "Missing MIYA_TELEGRAM_BOT_TOKEN"
      });
      return;
    }
    if (this.telegramPolling)
      return;
    this.telegramPolling = true;
    upsertChannelState(this.projectDir, "telegram", {
      enabled: true,
      connected: true,
      lastError: undefined
    });
    const poll = async () => {
      if (!this.telegramPolling)
        return;
      try {
        const url3 = `https://api.telegram.org/bot${token}/getUpdates?timeout=20&offset=${this.telegramOffset}`;
        const response = await fetch(url3);
        const body = await response.json();
        if (!body.ok) {
          throw new Error(body.description ?? "telegram_get_updates_failed");
        }
        for (const update of body.result ?? []) {
          this.telegramOffset = Math.max(this.telegramOffset, Number(update.update_id) + 1);
          const message = update.message;
          if (!message?.text || !message.chat?.id || !message.from?.id) {
            continue;
          }
          await this.handleInbound({
            channel: "telegram",
            senderID: String(message.from.id),
            displayName: message.from.username ?? message.from.first_name ?? String(message.from.id),
            conversationID: String(message.chat.id),
            text: message.text,
            raw: update
          });
        }
        upsertChannelState(this.projectDir, "telegram", {
          connected: true,
          lastError: undefined
        });
      } catch (error92) {
        upsertChannelState(this.projectDir, "telegram", {
          connected: false,
          lastError: error92 instanceof Error ? error92.message : String(error92)
        });
      } finally {
        if (this.telegramPolling) {
          setTimeout(() => {
            poll();
          }, 500);
        }
      }
    };
    poll();
  }
  stop() {
    this.telegramPolling = false;
    this.slackSocketModeRunning = false;
    if (this.slackReconnectTimer) {
      clearTimeout(this.slackReconnectTimer);
      this.slackReconnectTimer = undefined;
    }
    if (this.slackSocket) {
      try {
        this.slackSocket.close();
      } catch {}
      this.slackSocket = undefined;
    }
  }
  async handleInbound(message) {
    const allowByEnv = parseEnvList(process.env.MIYA_ALLOWED_SENDERS);
    const isAllowed = allowByEnv.length > 0 ? allowByEnv.includes(message.senderID) : isSenderAllowed(this.projectDir, message.channel, message.senderID);
    if (!isAllowed) {
      const pair = ensurePairRequest(this.projectDir, {
        channel: message.channel,
        senderID: message.senderID,
        displayName: message.displayName,
        messagePreview: message.text.slice(0, 120)
      });
      await this.callbacks.onPairRequested(pair);
      await this.sendPairingMessage(message.channel, message.conversationID);
      return;
    }
    await this.callbacks.onInbound(message);
  }
  recordOutboundAttempt(row) {
    const semanticTags = normalizeSemanticTags(row.semanticTags ?? semanticTagsForOutboundMessage(row.message));
    assertSemanticTags(semanticTags);
    const payload = {
      id: row.id ?? `out_${randomUUID3()}`,
      at: row.at ?? new Date().toISOString(),
      channel: row.channel,
      destination: row.destination,
      textPreview: row.textPreview,
      sent: row.sent,
      message: row.message,
      mediaPath: row.mediaPath,
      reason: row.reason,
      riskLevel: row.riskLevel,
      archAdvisorApproved: row.archAdvisorApproved,
      targetInAllowlist: row.targetInAllowlist,
      contactTier: row.contactTier,
      intent: row.intent,
      containsSensitive: row.containsSensitive,
      policyHash: row.policyHash,
      sendFingerprint: row.sendFingerprint,
      ticketSummary: row.ticketSummary,
      visualPrecheck: row.visualPrecheck,
      visualPostcheck: row.visualPostcheck,
      receiptStatus: row.receiptStatus,
      payloadHash: row.payloadHash,
      windowFingerprint: row.windowFingerprint,
      recipientTextCheck: row.recipientTextCheck,
      sendStatusCheck: row.sendStatusCheck,
      preSendScreenshotPath: row.preSendScreenshotPath,
      postSendScreenshotPath: row.postSendScreenshotPath,
      failureStep: row.failureStep,
      ocrSource: row.ocrSource,
      ocrPreview: row.ocrPreview,
      captureMethod: row.captureMethod,
      evidenceConfidence: row.evidenceConfidence,
      evidenceLimitations: row.evidenceLimitations,
      evidenceBundle: buildEvidenceBundle(row),
      semanticSummary: buildSemanticSummary(row),
      semanticTags
    };
    appendOutboundAudit(this.projectDir, payload);
    return payload;
  }
  checkThrottle(channel, destination) {
    const now = Date.now();
    const key = `${channel}:${destination}`;
    const policy = readPolicy(this.projectDir);
    const windowMs = Math.max(1000, Number(policy.outbound.burstWindowMs || 60000));
    const minIntervalMs = Math.max(500, Number(policy.outbound.minIntervalMs || 4000));
    const burstLimit = Math.max(1, Number(policy.outbound.burstLimit || 3));
    const list = (this.outboundThrottle.get(key) ?? []).filter((ts) => now - ts <= windowMs);
    if (list.length > 0 && now - list[list.length - 1] < minIntervalMs) {
      this.outboundThrottle.set(key, list);
      return `throttled:min_interval_${minIntervalMs}ms`;
    }
    if (list.length >= burstLimit) {
      this.outboundThrottle.set(key, list);
      return `throttled:burst_limit_${burstLimit}_per_${windowMs}ms`;
    }
    list.push(now);
    this.outboundThrottle.set(key, list);
    return null;
  }
  checkDuplicatePayload(channel, destination, text) {
    const now = Date.now();
    const policy = readPolicy(this.projectDir);
    const duplicateWindowMs = Math.max(1000, Number(policy.outbound.duplicateWindowMs || 60000));
    const key = `${channel}:${destination}`;
    const payloadHash = createHash4("sha256").update(text).digest("hex").slice(0, 24);
    const recent = (this.outboundPayloadHistory.get(key) ?? []).filter((item) => now - item.at <= duplicateWindowMs);
    const duplicated = recent.some((item) => item.hash === payloadHash);
    if (!duplicated) {
      recent.push({ at: now, hash: payloadHash });
      this.outboundPayloadHistory.set(key, recent);
      return null;
    }
    this.outboundPayloadHistory.set(key, recent);
    return `duplicate_payload_within_${duplicateWindowMs}ms`;
  }
  isDesktopChannel(channel) {
    return channel === "qq" || channel === "wechat";
  }
  inMutexCooldown(sessionID) {
    const until = this.inputMutexCooldownUntil.get(sessionID) ?? 0;
    return until > Date.now();
  }
  markMutexTimeout(sessionID) {
    const strikes = (this.inputMutexStrike.get(sessionID) ?? 0) + 1;
    this.inputMutexStrike.set(sessionID, strikes);
    if (strikes >= INPUT_MUTEX_STRIKE_LIMIT) {
      this.inputMutexCooldownUntil.set(sessionID, Date.now() + INPUT_MUTEX_COOLDOWN_MS);
      this.inputMutexStrike.set(sessionID, 0);
    }
  }
  clearMutexStrike(sessionID) {
    this.inputMutexStrike.set(sessionID, 0);
  }
  checkSendFingerprint(sendFingerprint) {
    const now = Date.now();
    const windowMs = 60000;
    for (const [fingerprint, ts] of this.sendFingerprintHistory.entries()) {
      if (now - ts > windowMs) {
        this.sendFingerprintHistory.delete(fingerprint);
      }
    }
    if (this.sendFingerprintHistory.has(sendFingerprint)) {
      return "duplicate_send_fingerprint";
    }
    this.sendFingerprintHistory.set(sendFingerprint, now);
    return null;
  }
  normalizeDesktopRuntimeError(error92) {
    const raw = error92 instanceof Error ? error92.message : typeof error92 === "string" ? error92 : "unknown";
    return raw.trim().toLowerCase().replace(/[^a-z0-9:_-]+/g, "_").slice(0, 120) || "unknown";
  }
  recordDesktopRuntimeFailure(input) {
    const detail = this.normalizeDesktopRuntimeError(input.error);
    const audit = this.recordOutboundAttempt({
      channel: input.channel,
      destination: input.destination,
      textPreview: input.textPreview,
      sent: false,
      message: `outbound_degraded:desktop_runtime_exception:${detail}`,
      reason: "desktop_send_failed",
      archAdvisorApproved: input.archAdvisorApproved,
      targetInAllowlist: input.targetInAllowlist,
      contactTier: input.contactTier,
      intent: input.intent,
      containsSensitive: input.containsSensitive,
      riskLevel: input.riskLevel,
      policyHash: input.policyHash,
      sendFingerprint: input.sendFingerprint,
      ticketSummary: input.ticketSummary,
      payloadHash: input.payloadHash,
      failureStep: "desktop.runtime"
    });
    return { sent: false, message: audit.message, auditID: audit.id };
  }
  async sendMessage(input) {
    const text = (input.text ?? "").trim();
    const mediaPath = (input.mediaPath ?? "").trim();
    const payloadHash = (input.payloadHash ?? createHash4("sha256").update(`${text}||${mediaPath}`).digest("hex")).trim();
    if (!text && !mediaPath) {
      return { sent: false, message: "invalid_outbound_payload_empty" };
    }
    try {
      assertChannelCanSend(input.channel);
    } catch (error92) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: error92 instanceof Error ? error92.message : String(error92),
        reason: "channel_blocked",
        payloadHash
      });
      return {
        sent: false,
        message: audit.message,
        auditID: audit.id
      };
    }
    const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
    const riskLevel = input.outboundCheck?.riskLevel ?? "HIGH";
    const intent = input.outboundCheck?.intent ?? "initiate";
    const containsSensitive = Boolean(input.outboundCheck?.containsSensitive);
    const policyHash = input.outboundCheck?.policyHash;
    const sessionID = (input.sessionID ?? "main").trim() || "main";
    const ticketSummary = input.approvalTickets?.outboundSend && input.approvalTickets.desktopControl ? {
      outboundSendTraceId: input.approvalTickets.outboundSend.traceID,
      desktopControlTraceId: input.approvalTickets.desktopControl.traceID,
      expiresAt: Date.parse(input.approvalTickets.outboundSend.expiresAt) < Date.parse(input.approvalTickets.desktopControl.expiresAt) ? input.approvalTickets.outboundSend.expiresAt : input.approvalTickets.desktopControl.expiresAt
    } : undefined;
    if (!archAdvisorApproved) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: "outbound_blocked:arch_advisor_denied",
        reason: "arch_advisor_denied",
        archAdvisorApproved,
        riskLevel,
        intent,
        containsSensitive,
        policyHash,
        payloadHash
      });
      return { sent: false, message: audit.message, auditID: audit.id };
    }
    const targetInAllowlist = input.outboundCheck?.bypassAllowlist === true ? true : isSenderAllowed(this.projectDir, input.channel, input.destination);
    if (!targetInAllowlist) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: `outbound_blocked:target_not_in_allowlist:${input.channel}`,
        reason: "allowlist_denied",
        archAdvisorApproved,
        targetInAllowlist,
        riskLevel,
        intent,
        containsSensitive,
        policyHash,
        payloadHash
      });
      return { sent: false, message: audit.message, auditID: audit.id };
    }
    const tier = input.outboundCheck?.bypassAllowlist === true ? "owner" : getContactTier(this.projectDir, input.channel, input.destination);
    if (tier === "friend") {
      if (intent !== "reply") {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_blocked:friend_tier_can_only_reply",
          reason: "allowlist_denied",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
      if (containsSensitive) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_blocked:friend_tier_sensitive_content_denied",
          reason: "allowlist_denied",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.outboundCheck?.bypassThrottle !== true) {
      const throttle = this.checkThrottle(input.channel, input.destination);
      if (throttle) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${throttle}`,
          reason: "throttled",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.outboundCheck?.bypassDuplicateGuard !== true) {
      const duplicate = this.checkDuplicatePayload(input.channel, input.destination, `${text}||${mediaPath}`);
      if (duplicate) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${duplicate}`,
          reason: "duplicate_payload",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.sendFingerprint) {
      const fingerprintDup = this.checkSendFingerprint(input.sendFingerprint);
      if (fingerprintDup) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${fingerprintDup}`,
          reason: "duplicate_payload",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    let mutexLease = null;
    if (this.isDesktopChannel(input.channel)) {
      if (this.inMutexCooldown(sessionID)) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_degraded:input_mutex_cooldown:draft_only",
          reason: "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
      try {
        mutexLease = await acquireInputMutex(sessionID, INPUT_MUTEX_TIMEOUT_MS);
      } catch {
        this.markMutexTimeout(sessionID);
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_degraded:input_mutex_timeout:draft_only",
          reason: "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.channel === "qq" || input.channel === "wechat") {
      try {
        if (input.channel === "qq") {
          const result2 = await this.sendQqDesktopMessageImpl({
            projectDir: this.projectDir,
            destination: input.destination,
            text,
            mediaPath
          });
          const visionCheck2 = await this.analyzeDesktopOutboundEvidenceImpl({
            destination: input.destination,
            preSendScreenshotPath: result2.preSendScreenshotPath,
            postSendScreenshotPath: result2.postSendScreenshotPath,
            visualPrecheck: result2.visualPrecheck,
            visualPostcheck: result2.visualPostcheck,
            receiptStatus: result2.receiptStatus,
            recipientTextCheck: result2.recipientTextCheck
          });
          if (visionCheck2.recipientMatch === "mismatch") {
            result2.sent = false;
            result2.message = "outbound_blocked:recipient_text_mismatch";
          }
          if (visionCheck2.sendStatusDetected === "failed") {
            result2.sent = false;
            result2.message = "outbound_blocked:receipt_uncertain";
          }
          if (visionCheck2.uiStyleMismatch) {
            result2.sent = false;
            result2.message = "outbound_degraded:ui_style_mismatch:draft_only";
          }
          if (result2.sent && result2.receiptStatus !== "confirmed") {
            result2.sent = false;
            result2.message = "outbound_blocked:receipt_uncertain";
          }
          const audit2 = this.recordOutboundAttempt({
            channel: "qq",
            destination: input.destination,
            textPreview: text.slice(0, 200),
            sent: result2.sent,
            message: result2.message,
            mediaPath: mediaPath || undefined,
            reason: result2.sent ? "sent" : "desktop_send_failed",
            archAdvisorApproved,
            targetInAllowlist,
            contactTier: tier,
            intent,
            containsSensitive,
            riskLevel,
            policyHash,
            sendFingerprint: input.sendFingerprint,
            ticketSummary,
            payloadHash: result2.payloadHash ?? payloadHash,
            windowFingerprint: result2.windowFingerprint,
            recipientTextCheck: visionCheck2.recipientMatch === "matched" || visionCheck2.recipientMatch === "mismatch" ? visionCheck2.recipientMatch : result2.recipientTextCheck,
            sendStatusCheck: visionCheck2.sendStatusDetected,
            preSendScreenshotPath: result2.preSendScreenshotPath,
            postSendScreenshotPath: result2.postSendScreenshotPath,
            failureStep: result2.failureStep,
            ocrSource: visionCheck2.ocrSource,
            ocrPreview: visionCheck2.ocrPreview,
            captureMethod: visionCheck2.capture.method,
            evidenceConfidence: visionCheck2.capture.confidence,
            evidenceLimitations: visionCheck2.capture.limitations,
            visualPrecheck: result2.visualPrecheck,
            visualPostcheck: result2.visualPostcheck,
            receiptStatus: result2.receiptStatus
          });
          if (result2.sent) {
            this.clearMutexStrike(sessionID);
          }
          if (!audit2.evidenceBundle || !audit2.semanticSummary) {
            return {
              sent: false,
              message: "outbound_blocked:missing_evidence_bundle",
              auditID: audit2.id
            };
          }
          return { ...result2, auditID: audit2.id };
        }
        const result = await this.sendWechatDesktopMessageImpl({
          projectDir: this.projectDir,
          destination: input.destination,
          text,
          mediaPath
        });
        const visionCheck = await this.analyzeDesktopOutboundEvidenceImpl({
          destination: input.destination,
          preSendScreenshotPath: result.preSendScreenshotPath,
          postSendScreenshotPath: result.postSendScreenshotPath,
          visualPrecheck: result.visualPrecheck,
          visualPostcheck: result.visualPostcheck,
          receiptStatus: result.receiptStatus,
          recipientTextCheck: result.recipientTextCheck
        });
        if (visionCheck.recipientMatch === "mismatch") {
          result.sent = false;
          result.message = "outbound_blocked:recipient_text_mismatch";
        }
        if (visionCheck.sendStatusDetected === "failed") {
          result.sent = false;
          result.message = "outbound_blocked:receipt_uncertain";
        }
        if (visionCheck.uiStyleMismatch) {
          result.sent = false;
          result.message = "outbound_degraded:ui_style_mismatch:draft_only";
        }
        if (result.sent && result.receiptStatus !== "confirmed") {
          result.sent = false;
          result.message = "outbound_blocked:receipt_uncertain";
        }
        const audit = this.recordOutboundAttempt({
          channel: "wechat",
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: result.sent,
          message: result.message,
          mediaPath: mediaPath || undefined,
          reason: result.sent ? "sent" : "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash: result.payloadHash ?? payloadHash,
          windowFingerprint: result.windowFingerprint,
          recipientTextCheck: visionCheck.recipientMatch === "matched" || visionCheck.recipientMatch === "mismatch" ? visionCheck.recipientMatch : result.recipientTextCheck,
          sendStatusCheck: visionCheck.sendStatusDetected,
          preSendScreenshotPath: result.preSendScreenshotPath,
          postSendScreenshotPath: result.postSendScreenshotPath,
          failureStep: result.failureStep,
          ocrSource: visionCheck.ocrSource,
          ocrPreview: visionCheck.ocrPreview,
          captureMethod: visionCheck.capture.method,
          evidenceConfidence: visionCheck.capture.confidence,
          evidenceLimitations: visionCheck.capture.limitations,
          visualPrecheck: result.visualPrecheck,
          visualPostcheck: result.visualPostcheck,
          receiptStatus: result.receiptStatus
        });
        if (result.sent) {
          this.clearMutexStrike(sessionID);
        }
        if (!audit.evidenceBundle || !audit.semanticSummary) {
          return {
            sent: false,
            message: "outbound_blocked:missing_evidence_bundle",
            auditID: audit.id
          };
        }
        return { ...result, auditID: audit.id };
      } catch (error92) {
        return this.recordDesktopRuntimeFailure({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash,
          error: error92
        });
      } finally {
        mutexLease?.release();
      }
    }
    mutexLease?.release();
    return {
      sent: false,
      message: `channel_send_blocked:${input.channel}:INBOUND_ONLY channels are receive-only`
    };
  }
  async sendPairingMessage(channel, destination) {
    if (channel !== "qq" && channel !== "wechat") {
      return;
    }
    const pairingText = "Miya security: your account is not paired yet. Ask admin to approve pairing in Miya control panel.";
    await this.sendMessage({
      channel,
      destination,
      text: pairingText,
      outboundCheck: {
        archAdvisorApproved: true,
        riskLevel: "LOW",
        bypassAllowlist: true,
        bypassThrottle: true,
        bypassDuplicateGuard: true
      }
    });
  }
}
var INPUT_MUTEX_TIMEOUT_MS, INPUT_MUTEX_STRIKE_LIMIT = 3, INPUT_MUTEX_COOLDOWN_MS, inputMutexOwner = null, inputMutexQueue;
var init_service = __esm(() => {
  init_qq();
  init_wechat();
  init_vision();
  init_policy();
  init_pairing_store();
  init_workflow();
  init_policy2();
  init_semantic_tags();
  INPUT_MUTEX_TIMEOUT_MS = parsePositiveIntEnv("MIYA_INPUT_MUTEX_TIMEOUT_MS", 20000);
  INPUT_MUTEX_COOLDOWN_MS = 15 * 60 * 1000;
  inputMutexQueue = [];
});

// src/channel/router.ts
var init_router = __esm(() => {
  init_policy();
});

// src/channel/types.ts
var init_types2 = __esm(() => {
  init_types();
});
// src/channel/index.ts
var init_channel = __esm(() => {
  init_service();
  init_pairing_store();
  init_qq();
  init_wechat();
  init_router();
  init_types2();
});

// src/safety/tier.ts
function tierAtLeast(current, required3) {
  return SAFETY_RANK[current] >= SAFETY_RANK[required3];
}
var SAFETY_RANK;
var init_tier = __esm(() => {
  SAFETY_RANK = {
    LIGHT: 1,
    STANDARD: 2,
    THOROUGH: 3
  };
});

// src/safety/state-machine.ts
import * as fs13 from "node:fs";
import * as path12 from "node:path";
function nowIso4() {
  return new Date().toISOString();
}
function stateFile(projectDir) {
  return path12.join(getMiyaRuntimeDir(projectDir), "safety-state.json");
}
function auditFile(projectDir) {
  return path12.join(getMiyaRuntimeDir(projectDir), "safety-state-audit.jsonl");
}
function ensureDir5(filePath3) {
  fs13.mkdirSync(path12.dirname(filePath3), { recursive: true });
}
function defaultState() {
  return {
    version: 1,
    updatedAt: nowIso4(),
    globalState: "running",
    domains: Object.fromEntries(POLICY_DOMAINS.map((domain3) => [domain3, "running"]))
  };
}
function writeState(projectDir, state) {
  const file3 = stateFile(projectDir);
  const next = {
    ...state,
    updatedAt: nowIso4()
  };
  ensureDir5(file3);
  fs13.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function readSafetyState(projectDir) {
  const file3 = stateFile(projectDir);
  if (!fs13.existsSync(file3)) {
    const created = defaultState();
    return writeState(projectDir, created);
  }
  try {
    const parsed = JSON.parse(fs13.readFileSync(file3, "utf-8"));
    const base = defaultState();
    const domains = {
      ...base.domains,
      ...parsed.domains ?? {}
    };
    return {
      ...base,
      ...parsed,
      domains
    };
  } catch {
    return defaultState();
  }
}
function appendAudit(projectDir, row) {
  const file3 = auditFile(projectDir);
  ensureDir5(file3);
  fs13.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
function syncPolicyDomain(projectDir, domain3, state) {
  const policy = readPolicy(projectDir);
  const mapped = state === "running" ? "running" : "paused";
  if (policy.domains[domain3] === mapped)
    return;
  writePolicy(projectDir, {
    domains: {
      ...policy.domains,
      [domain3]: mapped
    }
  });
}
function transitionSafetyState(projectDir, input) {
  const current = readSafetyState(projectDir);
  const next = {
    ...current,
    globalState: input.globalState ?? current.globalState,
    reason: input.reason,
    traceID: input.traceID ?? current.traceID,
    domains: {
      ...current.domains,
      ...input.domains ?? {}
    }
  };
  const written = writeState(projectDir, next);
  for (const domain3 of POLICY_DOMAINS) {
    syncPolicyDomain(projectDir, domain3, written.domains[domain3]);
  }
  appendAudit(projectDir, {
    id: `safety_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    at: nowIso4(),
    source: input.source,
    reason: input.reason,
    traceID: input.traceID,
    policyHash: input.policyHash,
    globalState: written.globalState,
    domains: input.domains ?? {}
  });
  return written;
}
function isDomainExecutionAllowed(projectDir, domain3) {
  const state = readSafetyState(projectDir);
  if (state.globalState === "killed")
    return false;
  return state.domains[domain3] === "running";
}
var init_state_machine = __esm(() => {
  init_policy2();
  init_workflow();
});

// src/safety/store.ts
import * as fs14 from "node:fs";
import * as path13 from "node:path";
function runtimeFile2(projectDir, name) {
  return path13.join(getMiyaRuntimeDir(projectDir), name);
}
function ensureDir6(file3) {
  fs14.mkdirSync(path13.dirname(file3), { recursive: true });
}
function readJson(file3, fallback) {
  if (!fs14.existsSync(file3))
    return fallback;
  try {
    return JSON.parse(fs14.readFileSync(file3, "utf-8"));
  } catch {
    return fallback;
  }
}
function writeJson2(file3, value) {
  ensureDir6(file3);
  fs14.writeFileSync(file3, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function nowIso5() {
  return new Date().toISOString();
}
function syncGatewayStatus(projectDir, status) {
  const file3 = runtimeFile2(projectDir, "gateway.json");
  if (!fs14.existsSync(file3))
    return;
  const current = readJson(file3, {});
  if (!current || typeof current !== "object")
    return;
  writeJson2(file3, { ...current, status });
}
function listRecentSelfApprovalRecords(projectDir, limit = 10) {
  const file3 = runtimeFile2(projectDir, "self-approval.json");
  const current = readJson(file3, { records: [] });
  return current.records.slice(0, Math.max(1, limit));
}
function readTokenStore(projectDir) {
  const file3 = runtimeFile2(projectDir, "approval-tokens.json");
  const store = readJson(file3, { tokens: {} });
  const decoded = { tokens: {} };
  for (const [sessionID, tokens] of Object.entries(store.tokens ?? {})) {
    const plainSession = decryptSensitiveValue(projectDir, sessionID);
    decoded.tokens[plainSession] = {};
    for (const [hash3, token] of Object.entries(tokens ?? {})) {
      const plainHash = decryptSensitiveValue(projectDir, hash3);
      decoded.tokens[plainSession][plainHash] = {
        ...token,
        request_hash: decryptSensitiveValue(projectDir, token.request_hash),
        action: decryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  return decoded;
}
function writeTokenStore(projectDir, store) {
  const file3 = runtimeFile2(projectDir, "approval-tokens.json");
  const encoded = { tokens: {} };
  for (const [sessionID, tokens] of Object.entries(store.tokens ?? {})) {
    const safeSession = encryptSensitiveValue(projectDir, sessionID);
    encoded.tokens[safeSession] = {};
    for (const [hash3, token] of Object.entries(tokens ?? {})) {
      const safeHash = encryptSensitiveValue(projectDir, hash3);
      encoded.tokens[safeSession][safeHash] = {
        ...token,
        request_hash: encryptSensitiveValue(projectDir, token.request_hash),
        action: encryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  writeJson2(file3, encoded);
}
function saveApprovalToken(projectDir, sessionID, token, ttlMs = TOKEN_TTL_MS) {
  const store = readTokenStore(projectDir);
  const created = new Date;
  const expires = new Date(created.getTime() + ttlMs);
  const next = {
    ...token,
    created_at: created.toISOString(),
    expires_at: expires.toISOString()
  };
  const sessionTokens = store.tokens[sessionID] ?? {};
  sessionTokens[token.request_hash] = next;
  const normalized = Object.values(sessionTokens).sort((a, b) => Date.parse(b.created_at) - Date.parse(a.created_at)).slice(0, TOKEN_LIMIT_PER_SESSION);
  store.tokens[sessionID] = Object.fromEntries(normalized.map((entry2) => [entry2.request_hash, entry2]));
  writeTokenStore(projectDir, store);
  return next;
}
function findApprovalToken(projectDir, sessionID, requestHashes, requiredTier) {
  const store = readTokenStore(projectDir);
  const sessionTokens = store.tokens[sessionID] ?? {};
  const now = Date.now();
  for (const hash3 of requestHashes) {
    const token = sessionTokens[hash3];
    if (!token)
      continue;
    const expiresAt = Date.parse(token.expires_at);
    if (!Number.isFinite(expiresAt) || expiresAt < now)
      continue;
    if (!tierAtLeast(token.tier, requiredTier))
      continue;
    return token;
  }
  return null;
}
function readKillSwitch(projectDir) {
  return readJson(runtimeFile2(projectDir, "kill-switch.json"), {
    active: false
  });
}
function activateKillSwitch(projectDir, reason, traceID) {
  const next = {
    active: true,
    reason,
    trace_id: traceID,
    activated_at: nowIso5()
  };
  writeJson2(runtimeFile2(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_activate",
    reason,
    traceID,
    globalState: "killed",
    domains: {}
  });
  syncGatewayStatus(projectDir, "killswitch");
  return next;
}
function releaseKillSwitch(projectDir) {
  const next = { active: false };
  writeJson2(runtimeFile2(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_release",
    reason: "manual_release",
    globalState: "running",
    domains: {}
  });
  syncGatewayStatus(projectDir, "running");
  return next;
}
var TOKEN_TTL_MS = 120000, TOKEN_LIMIT_PER_SESSION = 200;
var init_store3 = __esm(() => {
  init_workflow();
  init_tier();
  init_state_machine();
  init_system_keyring();
});

// src/safety/risk.ts
import { createHash as createHash5 } from "node:crypto";
function normalizePattern(pattern) {
  return pattern.trim().replaceAll("\\", "/");
}
function hasIrreversiblePattern(patterns) {
  return patterns.some((pattern) => IRREVERSIBLE_BASH_PATTERNS.some((rule) => rule.test(pattern)));
}
function hasSensitivePath(patterns) {
  return patterns.some((pattern) => SENSITIVE_PATH_PATTERNS.some((rule) => rule.test(pattern)));
}
function hasIrreversibleEditPattern(patterns) {
  return patterns.some((pattern) => /\b(delete|remove|overwrite|truncate|destroy|wipe)\b/i.test(pattern) || pattern.endsWith(".env") || pattern.includes("/.env"));
}
function requiredTierForRequest(request) {
  const patterns = request.patterns.map(normalizePattern);
  if (request.permission === "external_directory")
    return "THOROUGH";
  if (request.permission === "external_message")
    return "THOROUGH";
  if (request.permission === "desktop_control")
    return "THOROUGH";
  if (request.permission === "node_invoke") {
    const patterns2 = request.patterns.map(normalizePattern).join(" ");
    if (/\b(system\.run|camera\.capture|canvas\.open|canvas\.render|voice\.)\b/i.test(patterns2)) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  if (request.permission === "skills_install")
    return "THOROUGH";
  if (request.permission === "webhook_outbound")
    return "THOROUGH";
  if (request.permission === "bash") {
    return hasIrreversiblePattern(patterns) ? "THOROUGH" : "STANDARD";
  }
  if (request.permission === "edit") {
    if (hasSensitivePath(patterns) || hasIrreversibleEditPattern(patterns)) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  return "STANDARD";
}
function buildRequestHash(request, includeMessageContext = true) {
  const payload = {
    permission: request.permission,
    patterns: [...request.patterns].map(normalizePattern).sort(),
    toolCallID: includeMessageContext ? request.toolCallID ?? "" : "",
    messageID: includeMessageContext ? request.messageID ?? "" : ""
  };
  return createHash5("sha256").update(JSON.stringify(payload)).digest("hex");
}
var IRREVERSIBLE_BASH_PATTERNS, SENSITIVE_PATH_PATTERNS;
var init_risk = __esm(() => {
  IRREVERSIBLE_BASH_PATTERNS = [
    /\bgit\s+push\b/i,
    /\bgit\s+remote\s+set-url\b/i,
    /\bgit\s+reset\s+--hard\b/i,
    /\bgit\s+clean\b[^\n]*\b-f\b/i,
    /\bgit\s+branch\b[^\n]*\b-D\b/i,
    /\brm\s+-[^\n]*\br\b/i,
    /\brm\s+-[^\n]*\bf\b/i,
    /\brm\s+(-rf|-fr)\b/i,
    /\bdel\s+\/[sfpq]/i,
    /\berase\s+\/[sfpq]/i,
    /\bRemove-Item\b[^\n]*\b(-Recurse|-Force)\b/i,
    /\btruncate\b/i,
    /\bcp\b[^\n]*\b-f\b/i,
    />\s*\.env(\.|$)/i,
    /\b(overwrite|truncate)\b/i
  ];
  SENSITIVE_PATH_PATTERNS = [
    /\.env(\.|$)/i,
    /\.pem$/i,
    /\.key$/i,
    /cookie/i,
    /credential/i,
    /secret/i,
    /token/i
  ];
});

// src/policy/decision-fusion.ts
function normalizeConfidence(value) {
  if (!Number.isFinite(value))
    return 0;
  if (value < 0)
    return 0;
  if (value > 1)
    return 1;
  return value;
}
function normalizeTrustScore(value) {
  if (!Number.isFinite(value))
    return 50;
  if (value < 0)
    return 0;
  if (value > 100)
    return 100;
  return Math.round(value);
}
function normalizeTrustMode(input) {
  let silentMin = Math.max(0, Math.min(100, Math.round(input?.silentMin ?? 90)));
  let modalMax = Math.max(0, Math.min(100, Math.round(input?.modalMax ?? 50)));
  if (silentMin <= modalMax) {
    const pivot = Math.round((silentMin + modalMax) / 2);
    silentMin = Math.min(100, pivot + 1);
    modalMax = Math.max(0, pivot - 1);
  }
  if (silentMin - modalMax < 2) {
    if (silentMin < 100)
      silentMin += 1;
    else if (modalMax > 0)
      modalMax -= 1;
  }
  if (silentMin <= modalMax) {
    return { silentMin: 90, modalMax: 50 };
  }
  return { silentMin, modalMax };
}
function resolveApprovalMode(input) {
  if (input.action !== "allow")
    return "modal_approval";
  const thresholds = normalizeTrustMode(input.trustMode);
  const silentMin = thresholds.silentMin;
  const modalMax = thresholds.modalMax;
  if (input.trustScore >= silentMin)
    return "silent_audit";
  if (input.trustScore <= modalMax)
    return "modal_approval";
  return "toast_gate";
}
function evaluateOutboundDecisionFusion(input) {
  const conf = normalizeConfidence(input.confidenceIntent);
  const evidenceConf = normalizeConfidence(input.evidenceConfidence ?? input.confidenceIntent);
  const trustScore = normalizeTrustScore(input.trustMinScore);
  const expressionMatched = input.factorTextSensitive && !input.factorRecipientIsMe || input.factorTextSensitive && input.factorIntentSuspicious;
  if (evidenceConf < 0.35) {
    const action2 = expressionMatched ? conf < 0.5 ? "hard_fuse" : "soft_fuse" : "allow";
    return {
      expressionMatched,
      zone: action2 === "hard_fuse" ? "danger" : "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: action2 === "hard_fuse" ? "decision_fusion_danger_low_evidence" : action2 === "soft_fuse" ? "decision_fusion_gray_low_evidence" : "decision_fusion_low_evidence_confirmation_required"
    };
  }
  if (!expressionMatched) {
    const action2 = "allow";
    return {
      expressionMatched: false,
      zone: "safe",
      action: action2,
      approvalMode: resolveApprovalMode({
        action: action2,
        trustScore,
        trustMode: input.trustMode
      }),
      reason: "decision_fusion_clear"
    };
  }
  if (conf < 0.5) {
    const action2 = "hard_fuse";
    return {
      expressionMatched: true,
      zone: "danger",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_danger"
    };
  }
  if (conf <= 0.85) {
    const action2 = "soft_fuse";
    return {
      expressionMatched: true,
      zone: "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_gray"
    };
  }
  const action = "allow";
  return {
    expressionMatched: true,
    zone: "safe",
    action,
    approvalMode: resolveApprovalMode({
      action,
      trustScore,
      trustMode: input.trustMode
    }),
    reason: "decision_fusion_safe_by_confidence"
  };
}

// src/policy/incident.ts
import * as fs15 from "node:fs";
import * as path14 from "node:path";
import { randomUUID as randomUUID4 } from "node:crypto";
function incidentFile(projectDir) {
  return path14.join(getMiyaRuntimeDir(projectDir), "policy-incidents.jsonl");
}
function appendPolicyIncident(projectDir, incident) {
  assertSemanticTags(incident.semanticTags);
  const semanticTags = normalizeSemanticTags(incident.semanticTags);
  const payload = {
    id: incident.id ?? `incident_${randomUUID4()}`,
    at: incident.at ?? new Date().toISOString(),
    type: incident.type,
    reason: incident.reason,
    channel: incident.channel,
    destination: incident.destination,
    auditID: incident.auditID,
    policyHash: incident.policyHash,
    pausedDomains: incident.pausedDomains,
    statusByDomain: incident.statusByDomain,
    semanticSummary: incident.semanticSummary,
    semanticTags,
    details: incident.details
  };
  const file3 = incidentFile(projectDir);
  fs15.mkdirSync(path14.dirname(file3), { recursive: true });
  fs15.appendFileSync(file3, `${JSON.stringify(payload)}
`, "utf-8");
  return payload;
}
function listPolicyIncidents(projectDir, limit = 50) {
  const file3 = incidentFile(projectDir);
  if (!fs15.existsSync(file3))
    return [];
  const rows = fs15.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}
var init_incident = __esm(() => {
  init_workflow();
  init_semantic_tags();
});

// src/nodes/index.ts
import * as fs16 from "node:fs";
import * as path15 from "node:path";
import { createHash as createHash6, randomBytes as randomBytes2, randomUUID as randomUUID5, timingSafeEqual } from "node:crypto";
function nowIso6() {
  return new Date().toISOString();
}
function hashToken(token) {
  return createHash6("sha256").update(token).digest("hex");
}
function defaultNodePermissions() {
  return {
    screenRecording: false,
    accessibility: false,
    filesystem: "none",
    network: false
  };
}
function inferPermissionsFromCapabilities(capabilities, base) {
  const inferred = defaultNodePermissions();
  for (const capability of capabilities) {
    if (capability === "perm.screenRecording")
      inferred.screenRecording = true;
    if (capability === "perm.accessibility")
      inferred.accessibility = true;
    if (capability === "perm.network")
      inferred.network = true;
    if (capability.startsWith("perm.filesystem.")) {
      const suffix = capability.slice("perm.filesystem.".length);
      if (suffix === "none" || suffix === "read" || suffix === "full") {
        inferred.filesystem = suffix;
      }
    }
  }
  return {
    ...inferred,
    ...base ?? {}
  };
}
function normalizeNodeRecord(partial3) {
  const capabilityList = Array.isArray(partial3.capabilities) ? partial3.capabilities.map((item) => String(item)).filter(Boolean).sort() : [];
  const fallbackHeartbeat = String(partial3.lastSeenAt ?? nowIso6());
  const permissions = inferPermissionsFromCapabilities(capabilityList, partial3.permissions);
  const status = partial3.connected ? "online" : "offline";
  return {
    nodeID: String(partial3.nodeID ?? ""),
    deviceID: String(partial3.deviceID ?? ""),
    type: partial3.type === "cli" || partial3.type === "desktop" || partial3.type === "mobile" || partial3.type === "browser" ? partial3.type : "cli",
    role: "node",
    platform: String(partial3.platform ?? process.platform),
    permissions,
    capabilities: capabilityList,
    connected: Boolean(partial3.connected),
    paired: Boolean(partial3.paired),
    status: partial3.status === "online" || partial3.status === "offline" || partial3.status === "error" ? partial3.status : status,
    tokenHash: typeof partial3.tokenHash === "string" ? partial3.tokenHash : undefined,
    tokenIssuedAt: typeof partial3.tokenIssuedAt === "string" ? partial3.tokenIssuedAt : undefined,
    tokenLastUsedAt: typeof partial3.tokenLastUsedAt === "string" ? partial3.tokenLastUsedAt : undefined,
    lastHeartbeatAt: typeof partial3.lastHeartbeatAt === "string" ? partial3.lastHeartbeatAt : fallbackHeartbeat,
    lastSeenAt: String(partial3.lastSeenAt ?? fallbackHeartbeat),
    createdAt: String(partial3.createdAt ?? nowIso6()),
    updatedAt: String(partial3.updatedAt ?? nowIso6())
  };
}
function applyHeartbeatHealth(store) {
  const now = Date.now();
  let changed = false;
  for (const node of Object.values(store.nodes)) {
    const heartbeatAt = Date.parse(node.lastHeartbeatAt || node.lastSeenAt);
    if (Number.isNaN(heartbeatAt))
      continue;
    const stale = now - heartbeatAt > HEARTBEAT_STALE_MS;
    if (stale && (node.connected || node.status === "online")) {
      node.connected = false;
      node.status = "offline";
      node.updatedAt = nowIso6();
      changed = true;
    }
  }
  return changed;
}
function filePath3(projectDir) {
  return path15.join(getMiyaRuntimeDir(projectDir), "nodes.json");
}
function ensureDir7(file3) {
  fs16.mkdirSync(path15.dirname(file3), { recursive: true });
}
function readStore2(projectDir) {
  const file3 = filePath3(projectDir);
  if (!fs16.existsSync(file3)) {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
  try {
    const parsed = JSON.parse(fs16.readFileSync(file3, "utf-8"));
    const rawNodes = parsed.nodes ?? {};
    const nodes = {};
    for (const [nodeID, node] of Object.entries(rawNodes)) {
      const normalized = normalizeNodeRecord({
        ...node,
        nodeID: nodeID || node?.nodeID
      });
      if (!normalized.nodeID)
        continue;
      nodes[normalized.nodeID] = normalized;
    }
    return {
      nodes,
      devices: parsed.devices ?? {},
      pairs: Array.isArray(parsed.pairs) ? parsed.pairs : [],
      invokes: parsed.invokes ?? {}
    };
  } catch {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
}
function writeStore2(projectDir, store) {
  const file3 = filePath3(projectDir);
  ensureDir7(file3);
  fs16.writeFileSync(file3, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function readStoreWithHealth(projectDir) {
  const store = readStore2(projectDir);
  if (applyHeartbeatHealth(store)) {
    writeStore2(projectDir, store);
  }
  return store;
}
function verifyNodeToken(node, token) {
  if (!node.tokenHash)
    return true;
  if (!token)
    return false;
  const expected = Buffer.from(node.tokenHash, "hex");
  const actual = Buffer.from(hashToken(token), "hex");
  if (expected.length !== actual.length)
    return false;
  return timingSafeEqual(expected, actual);
}
function registerNode(projectDir, input) {
  const store = readStoreWithHealth(projectDir);
  const existing = store.nodes[input.nodeID];
  if (existing && !verifyNodeToken(existing, input.token)) {
    throw new Error("node_token_invalid");
  }
  const nextCapabilities = [...new Set(input.capabilities)].sort();
  const now = nowIso6();
  const createdAt = store.nodes[input.nodeID]?.createdAt ?? nowIso6();
  const lastHeartbeatAt = now;
  const tokenLastUsedAt = existing?.tokenHash ? now : existing?.tokenLastUsedAt;
  const node = {
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    type: input.type ?? existing?.type ?? "cli",
    role: "node",
    platform: input.platform,
    permissions: inferPermissionsFromCapabilities(nextCapabilities, {
      ...existing?.permissions,
      ...input.permissions ?? {}
    }),
    capabilities: nextCapabilities,
    connected: true,
    paired: existing?.paired ?? false,
    status: "online",
    tokenHash: existing?.tokenHash,
    tokenIssuedAt: existing?.tokenIssuedAt,
    tokenLastUsedAt,
    lastHeartbeatAt,
    lastSeenAt: now,
    createdAt,
    updatedAt: now
  };
  store.nodes[input.nodeID] = node;
  const device = {
    deviceID: input.deviceID,
    label: store.devices[input.deviceID]?.label,
    approved: store.devices[input.deviceID]?.approved ?? false,
    createdAt: store.devices[input.deviceID]?.createdAt ?? now,
    updatedAt: now
  };
  store.devices[input.deviceID] = device;
  writeStore2(projectDir, store);
  return node;
}
function touchNodeHeartbeat(projectDir, nodeID) {
  const store = readStore2(projectDir);
  const node = store.nodes[nodeID];
  if (!node)
    return null;
  const now = nowIso6();
  node.connected = true;
  node.status = "online";
  node.lastHeartbeatAt = now;
  node.lastSeenAt = now;
  node.updatedAt = now;
  writeStore2(projectDir, store);
  return node;
}
function markNodeDisconnected(projectDir, nodeID) {
  const store = readStore2(projectDir);
  const node = store.nodes[nodeID];
  if (!node)
    return;
  node.connected = false;
  node.status = "offline";
  node.updatedAt = nowIso6();
  writeStore2(projectDir, store);
}
function listNodes(projectDir) {
  const store = readStoreWithHealth(projectDir);
  return Object.values(store.nodes).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function listDevices(projectDir) {
  const store = readStoreWithHealth(projectDir);
  return Object.values(store.devices).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function describeNode(projectDir, nodeID) {
  const store = readStoreWithHealth(projectDir);
  return store.nodes[nodeID] ?? null;
}
function issueNodeToken(projectDir, nodeID) {
  const store = readStoreWithHealth(projectDir);
  const node = store.nodes[nodeID];
  if (!node)
    return null;
  const token = `nkt_${randomBytes2(24).toString("hex")}`;
  const issuedAt = nowIso6();
  node.tokenHash = hashToken(token);
  node.tokenIssuedAt = issuedAt;
  node.tokenLastUsedAt = issuedAt;
  node.updatedAt = issuedAt;
  store.nodes[nodeID] = node;
  writeStore2(projectDir, store);
  return { nodeID, token, issuedAt };
}
function createNodePairRequest(projectDir, input) {
  const store = readStore2(projectDir);
  const pending = store.pairs.find((item) => item.nodeID === input.nodeID && item.status === "pending");
  if (pending)
    return pending;
  const pair = {
    id: `npair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    status: "pending",
    requestedAt: nowIso6()
  };
  store.pairs = [pair, ...store.pairs].slice(0, 1000);
  writeStore2(projectDir, store);
  return pair;
}
function listNodePairs(projectDir, status) {
  const store = readStore2(projectDir);
  const pairs = status ? store.pairs.filter((item) => item.status === status) : store.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function resolveNodePair(projectDir, pairID, status) {
  const store = readStore2(projectDir);
  const pair = store.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending")
    return null;
  pair.status = status;
  pair.resolvedAt = nowIso6();
  if (status === "approved") {
    const node = store.nodes[pair.nodeID];
    if (node) {
      node.paired = true;
      node.updatedAt = nowIso6();
    }
    const device = store.devices[pair.deviceID];
    if (device) {
      device.approved = true;
      device.updatedAt = nowIso6();
    }
  }
  writeStore2(projectDir, store);
  return pair;
}
function createInvokeRequest(projectDir, input) {
  const store = readStore2(projectDir);
  const invoke = {
    id: `invoke_${randomUUID5()}`,
    nodeID: input.nodeID,
    capability: input.capability,
    args: input.args,
    status: "pending",
    createdAt: nowIso6(),
    updatedAt: nowIso6()
  };
  store.invokes[invoke.id] = invoke;
  writeStore2(projectDir, store);
  return invoke;
}
function markInvokeSent(projectDir, invokeID) {
  const store = readStore2(projectDir);
  const invoke = store.invokes[invokeID];
  if (!invoke)
    return null;
  invoke.status = "sent";
  invoke.updatedAt = nowIso6();
  writeStore2(projectDir, store);
  return invoke;
}
function resolveInvokeResult(projectDir, invokeID, input) {
  const store = readStore2(projectDir);
  const invoke = store.invokes[invokeID];
  if (!invoke)
    return null;
  invoke.status = input.ok ? "completed" : "failed";
  invoke.result = input.result;
  invoke.error = input.error;
  invoke.updatedAt = nowIso6();
  writeStore2(projectDir, store);
  return invoke;
}
function listInvokeRequests(projectDir, limit = 50) {
  const store = readStore2(projectDir);
  return Object.values(store.invokes).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, limit));
}
var HEARTBEAT_STALE_MS;
var init_nodes = __esm(() => {
  init_workflow();
  HEARTBEAT_STALE_MS = 2 * 60 * 1000;
});

// src/security/owner-identity.ts
import { createHash as createHash7, randomUUID as randomUUID6 } from "node:crypto";
import * as fs17 from "node:fs";
import * as path16 from "node:path";
function nowIso7() {
  return new Date().toISOString();
}
function filePath4(projectDir) {
  return path16.join(getMiyaRuntimeDir(projectDir), "security", "owner-identity.json");
}
function guestAuditPath(projectDir) {
  return path16.join(getMiyaRuntimeDir(projectDir), "security", "guest-conversations.jsonl");
}
function clamp(input, min, max) {
  if (!Number.isFinite(input))
    return min;
  return Math.min(max, Math.max(min, input));
}
function defaultVoiceprintThresholds() {
  return {
    ownerMinScore: 0.78,
    guestMaxScore: 0.62,
    ownerMinLiveness: 0.65,
    guestMaxLiveness: 0.55,
    ownerMinDiarizationRatio: 0.7,
    minSampleDurationSec: 2,
    farTarget: 0.01,
    frrTarget: 0.03
  };
}
function normalizeVoiceprintThresholds(input) {
  const base = defaultVoiceprintThresholds();
  const normalized = {
    ownerMinScore: typeof input?.ownerMinScore === "number" ? clamp(input.ownerMinScore, 0.5, 0.99) : base.ownerMinScore,
    guestMaxScore: typeof input?.guestMaxScore === "number" ? clamp(input.guestMaxScore, 0.01, 0.9) : base.guestMaxScore,
    ownerMinLiveness: typeof input?.ownerMinLiveness === "number" ? clamp(input.ownerMinLiveness, 0.1, 0.99) : base.ownerMinLiveness,
    guestMaxLiveness: typeof input?.guestMaxLiveness === "number" ? clamp(input.guestMaxLiveness, 0.01, 0.9) : base.guestMaxLiveness,
    ownerMinDiarizationRatio: typeof input?.ownerMinDiarizationRatio === "number" ? clamp(input.ownerMinDiarizationRatio, 0.1, 1) : base.ownerMinDiarizationRatio,
    minSampleDurationSec: typeof input?.minSampleDurationSec === "number" ? clamp(input.minSampleDurationSec, 0.5, 20) : base.minSampleDurationSec,
    farTarget: typeof input?.farTarget === "number" ? clamp(input.farTarget, 0.0001, 0.5) : base.farTarget,
    frrTarget: typeof input?.frrTarget === "number" ? clamp(input.frrTarget, 0.0001, 0.5) : base.frrTarget
  };
  if (normalized.guestMaxScore >= normalized.ownerMinScore) {
    normalized.guestMaxScore = Math.max(0.01, normalized.ownerMinScore - 0.05);
  }
  return normalized;
}
function defaultState2() {
  return {
    initialized: false,
    mode: "unknown",
    voiceprintModelPath: "",
    voiceprintSampleDir: "",
    voiceprintThresholds: defaultVoiceprintThresholds(),
    updatedAt: nowIso7()
  };
}
function hashSecret(input) {
  return createHash7("sha256").update(input).digest("hex");
}
function defaultVoiceprintModelPath(projectDir) {
  return process.env.MIYA_VOICEPRINT_MODEL_PATH || getMiyaVoiceprintModelDir(projectDir);
}
function defaultVoiceprintSampleDir(projectDir) {
  return process.env.MIYA_VOICEPRINT_SAMPLE_DIR || getMiyaVoiceprintSampleDir(projectDir);
}
function readOwnerIdentityState(projectDir) {
  const file3 = filePath4(projectDir);
  if (!fs17.existsSync(file3)) {
    return {
      ...defaultState2(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
  try {
    const parsed = JSON.parse(fs17.readFileSync(file3, "utf-8"));
    return {
      ...defaultState2(),
      ...parsed,
      voiceprintModelPath: typeof parsed.voiceprintModelPath === "string" ? parsed.voiceprintModelPath : defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: typeof parsed.voiceprintSampleDir === "string" ? parsed.voiceprintSampleDir : defaultVoiceprintSampleDir(projectDir),
      voiceprintThresholds: normalizeVoiceprintThresholds(parsed.voiceprintThresholds),
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso7()
    };
  } catch {
    return {
      ...defaultState2(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
}
function writeOwnerIdentityState(projectDir, state) {
  const file3 = filePath4(projectDir);
  fs17.mkdirSync(path16.dirname(file3), { recursive: true });
  const next = {
    ...state,
    voiceprintThresholds: normalizeVoiceprintThresholds(state.voiceprintThresholds),
    updatedAt: nowIso7()
  };
  fs17.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function initOwnerIdentity(projectDir, input) {
  const current = readOwnerIdentityState(projectDir);
  const next = {
    ...current,
    initialized: true,
    passwordHash: hashSecret(input.password),
    passphraseHash: hashSecret(input.passphrase),
    voiceprintEmbeddingID: input.voiceprintEmbeddingID || current.voiceprintEmbeddingID || `owner_${randomUUID6()}`,
    voiceprintModelPath: input.voiceprintModelPath || current.voiceprintModelPath || defaultVoiceprintModelPath(projectDir),
    voiceprintSampleDir: input.voiceprintSampleDir || current.voiceprintSampleDir || defaultVoiceprintSampleDir(projectDir),
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...input.voiceprintThresholds ?? {}
    }),
    mode: "owner",
    lastSpeakerAt: nowIso7(),
    updatedAt: nowIso7()
  };
  return writeOwnerIdentityState(projectDir, next);
}
function verifyOwnerSecrets(projectDir, input) {
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized || !state.passwordHash || !state.passphraseHash)
    return false;
  const passOk = typeof input.password === "string" && hashSecret(input.password) === state.passwordHash;
  const phraseOk = typeof input.passphrase === "string" && hashSecret(input.passphrase) === state.passphraseHash;
  return passOk || phraseOk;
}
function verifyOwnerPasswordOnly(projectDir, password) {
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized || !state.passwordHash)
    return false;
  if (typeof password !== "string" || !password)
    return false;
  return hashSecret(password) === state.passwordHash;
}
function rotateOwnerSecrets(projectDir, input) {
  if (!verifyOwnerSecrets(projectDir, {
    password: input.currentPassword,
    passphrase: input.currentPassphrase
  })) {
    throw new Error("owner_secret_verification_failed");
  }
  const state = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...state,
    initialized: true,
    passwordHash: hashSecret(input.newPassword),
    passphraseHash: hashSecret(input.newPassphrase),
    mode: "owner",
    lastSpeakerAt: nowIso7(),
    updatedAt: nowIso7()
  });
}
function updateVoiceprintThresholds(projectDir, patch) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...patch
    }),
    updatedAt: nowIso7()
  });
}
function resolveInteractionMode(projectDir, input) {
  const hint = (input.speakerHint || "").trim().toLowerCase();
  if (hint === "owner" || hint === "guest" || hint === "unknown") {
    return hint;
  }
  const state = readOwnerIdentityState(projectDir);
  if (!state.initialized)
    return "unknown";
  if (typeof input.speakerScore === "number") {
    if (input.speakerScore >= state.voiceprintThresholds.ownerMinScore)
      return "owner";
    if (input.speakerScore < state.voiceprintThresholds.guestMaxScore)
      return "guest";
  }
  return state.mode === "owner" ? "owner" : "unknown";
}
function setInteractionMode(projectDir, mode) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    mode,
    lastSpeakerAt: nowIso7(),
    updatedAt: nowIso7()
  });
}
function appendGuestConversation(projectDir, input) {
  const file3 = guestAuditPath(projectDir);
  fs17.mkdirSync(path16.dirname(file3), { recursive: true });
  const row = {
    id: `guest_${randomUUID6()}`,
    at: nowIso7(),
    source: input.source,
    sessionID: input.sessionID,
    text: input.text
  };
  fs17.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
var init_owner_identity = __esm(() => {
  init_paths();
  init_workflow();
});

// src/security/owner-sync.ts
import { randomUUID as randomUUID7 } from "node:crypto";
import * as fs18 from "node:fs";
import * as path17 from "node:path";
function nowIso8() {
  return new Date().toISOString();
}
function storeFile(projectDir) {
  return path17.join(getMiyaRuntimeDir(projectDir), "security", "owner-sync.json");
}
function readStore3(projectDir) {
  const file3 = storeFile(projectDir);
  if (!fs18.existsSync(file3))
    return { tokens: [] };
  try {
    const parsed = JSON.parse(fs18.readFileSync(file3, "utf-8"));
    return Array.isArray(parsed.tokens) ? parsed : { tokens: [] };
  } catch {
    return { tokens: [] };
  }
}
function writeStore3(projectDir, store) {
  const file3 = storeFile(projectDir);
  fs18.mkdirSync(path17.dirname(file3), { recursive: true });
  fs18.writeFileSync(file3, `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function purgeExpired(tokens) {
  const now = Date.now();
  return tokens.filter((item) => {
    const expiresAt = Date.parse(item.expiresAt);
    if (!Number.isFinite(expiresAt))
      return false;
    if (expiresAt < now && item.status === "pending")
      return false;
    return true;
  });
}
function normalizeToken(input) {
  return input.trim().toUpperCase();
}
function createToken() {
  return `OS${randomUUID7().replaceAll("-", "").slice(0, 10).toUpperCase()}`;
}
function issueOwnerSyncToken(projectDir, input) {
  const ttlMs = Math.max(60000, Number(input.ttlMs ?? 10 * 60000));
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const now = Date.now();
  const existing = store.tokens.find((item) => item.status === "pending" && item.action === input.action && item.payloadHash === input.payloadHash && Date.parse(item.expiresAt) > now);
  if (existing) {
    writeStore3(projectDir, store);
    return existing;
  }
  const createdAt = nowIso8();
  const record3 = {
    token: createToken(),
    action: input.action,
    payloadHash: input.payloadHash,
    status: "pending",
    createdAt,
    expiresAt: new Date(now + ttlMs).toISOString()
  };
  store.tokens.unshift(record3);
  store.tokens = store.tokens.slice(0, 500);
  writeStore3(projectDir, store);
  return record3;
}
function approveOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token)
    return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "pending") {
    writeStore3(projectDir, store);
    return { ok: false, reason: `owner_sync_token_not_pending:${found.status}` };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  found.status = "approved";
  found.approvedAt = nowIso8();
  found.approvedBy = { channel: input.channel, senderID: input.senderID };
  writeStore3(projectDir, store);
  return { ok: true, record: found };
}
function verifyOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token)
    return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore3(projectDir, store);
    return { ok: false, reason: `owner_sync_token_not_approved:${found.status}` };
  }
  if (found.action !== input.action) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_action_mismatch" };
  }
  if (found.payloadHash !== input.payloadHash) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_payload_mismatch" };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  writeStore3(projectDir, store);
  return { ok: true, record: found };
}
function consumeOwnerSyncToken(projectDir, tokenInput) {
  const token = normalizeToken(tokenInput);
  if (!token)
    return { ok: false, reason: "owner_sync_token_empty" };
  const store = readStore3(projectDir);
  store.tokens = purgeExpired(store.tokens);
  const found = store.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore3(projectDir, store);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore3(projectDir, store);
    return { ok: false, reason: `owner_sync_token_not_approved:${found.status}` };
  }
  found.status = "consumed";
  found.consumedAt = nowIso8();
  writeStore3(projectDir, store);
  return { ok: true };
}
function detectOwnerSyncTokenFromText(text) {
  const normalized = text.trim();
  if (!normalized)
    return null;
  const matched = /(?:同意|确认|approve|confirm|ok)\s*[:：#]?\s*([a-z0-9_-]{6,64})/i.exec(normalized) ?? /(?:\/miya\s+confirm)\s+([a-z0-9_-]{6,64})/i.exec(normalized);
  if (!matched?.[1])
    return null;
  return normalizeToken(matched[1]);
}
var init_owner_sync = __esm(() => {
  init_workflow();
});

// src/voice/state.ts
import * as fs19 from "node:fs";
import * as path18 from "node:path";
import { randomUUID as randomUUID8 } from "node:crypto";
function nowIso9() {
  return new Date().toISOString();
}
function filePath5(projectDir) {
  return path18.join(getMiyaRuntimeDir(projectDir), "voice.json");
}
function ensureDir8(file3) {
  fs19.mkdirSync(path18.dirname(file3), { recursive: true });
}
function defaultState3() {
  return {
    enabled: false,
    wakeWordEnabled: false,
    talkMode: false,
    routeSessionID: "main",
    sttProvider: "local",
    ttsProvider: "local",
    history: []
  };
}
function readVoiceState(projectDir) {
  const file3 = filePath5(projectDir);
  if (!fs19.existsSync(file3))
    return defaultState3();
  try {
    const parsed = JSON.parse(fs19.readFileSync(file3, "utf-8"));
    return {
      ...defaultState3(),
      ...parsed,
      history: Array.isArray(parsed.history) ? parsed.history : []
    };
  } catch {
    return defaultState3();
  }
}
function writeVoiceState(projectDir, state) {
  const file3 = filePath5(projectDir);
  ensureDir8(file3);
  fs19.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
  return state;
}
function patchVoiceState(projectDir, patch) {
  const current = readVoiceState(projectDir);
  const next = {
    ...current,
    ...patch
  };
  return writeVoiceState(projectDir, next);
}
function appendVoiceHistory(projectDir, input) {
  const state = readVoiceState(projectDir);
  const item = {
    id: `voice_${randomUUID8()}`,
    text: input.text,
    source: input.source,
    language: input.language,
    mediaID: input.mediaID,
    createdAt: nowIso9()
  };
  const next = {
    ...state,
    lastInputAt: item.createdAt,
    lastTranscript: item.text,
    history: [item, ...state.history].slice(0, 200)
  };
  writeVoiceState(projectDir, next);
  return item;
}
function clearVoiceHistory(projectDir) {
  const state = readVoiceState(projectDir);
  return writeVoiceState(projectDir, {
    ...state,
    history: [],
    lastInputAt: undefined,
    lastTranscript: undefined
  });
}
var init_state2 = __esm(() => {
  init_workflow();
});

// src/config/provider-override-audit.ts
import * as fs20 from "node:fs";
import * as path19 from "node:path";
function providerOverrideAuditFile(projectDir) {
  return path19.join(getMiyaRuntimeDir(projectDir), "audit", "provider-overrides.jsonl");
}
function listProviderOverrideAudits(projectDir, limit = 50) {
  const file3 = providerOverrideAuditFile(projectDir);
  if (!fs20.existsSync(file3))
    return [];
  const safeLimit = Math.max(1, Math.min(500, Math.floor(limit)));
  const lines = fs20.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean);
  return lines.slice(-safeLimit).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => item !== null).reverse();
}
var init_provider_override_audit = __esm(() => {
  init_workflow();
});

// src/gateway/agent-model-api.ts
class AgentModelRuntimeApi {
  projectDir;
  constructor(projectDir) {
    this.projectDir = projectDir;
  }
  list() {
    const runtime = readPersistedAgentRuntime(this.projectDir);
    const agents = [];
    for (const agentName of ALL_AGENT_NAMES) {
      const entry2 = runtime.agents[agentName];
      const model = entry2?.model ?? DEFAULT_MODELS[agentName];
      const source = entry2?.model ? "runtime" : "default";
      agents.push({
        agentName,
        model,
        providerID: entry2?.providerID,
        variant: entry2?.variant,
        updatedAt: entry2?.updatedAt ?? "",
        source,
        active: runtime.activeAgentId === agentName,
        healthStatus: this.resolveHealthStatus(model)
      });
    }
    return {
      activeAgentId: runtime.activeAgentId,
      revision: runtime.revision,
      agents
    };
  }
  set(input) {
    const agentName = normalizeAgentName(input.agentName);
    if (!agentName) {
      throw new Error("invalid_agent_name");
    }
    if (!normalizeModelRef(input.model)) {
      throw new Error("invalid_model_ref");
    }
    const changed = persistAgentRuntimeSelection(this.projectDir, {
      agentName,
      model: input.model,
      variant: input.variant,
      providerID: input.providerID,
      options: input.options,
      apiKey: input.apiKey,
      baseURL: input.baseURL,
      activeAgentId: input.activate === false ? undefined : agentName
    });
    return { changed };
  }
  reset(input) {
    const changed = removePersistedAgentRuntimeSelection(this.projectDir, input.agentName, {
      clearActive: input.clearActive ?? true,
      activeAgentId: input.activeAgentId
    });
    return { changed };
  }
  resolveHealthStatus(model) {
    if (!model)
      return "unavailable";
    return isModelLikelyAvailable(model) ? "healthy" : "degraded";
  }
}
var init_agent_model_api = __esm(() => {
  init_constants();
  init_model_health();
  init_agent_model_persistence();
});

// src/canvas/state.ts
import { randomUUID as randomUUID9 } from "node:crypto";
import * as fs21 from "node:fs";
import * as path20 from "node:path";
function nowIso10() {
  return new Date().toISOString();
}
function filePath6(projectDir) {
  return path20.join(getMiyaRuntimeDir(projectDir), "canvas.json");
}
function ensureDir9(file3) {
  fs21.mkdirSync(path20.dirname(file3), { recursive: true });
}
function defaultState4() {
  return {
    activeDocID: undefined,
    docs: {},
    events: []
  };
}
function readCanvasState(projectDir) {
  const file3 = filePath6(projectDir);
  if (!fs21.existsSync(file3))
    return defaultState4();
  try {
    const parsed = JSON.parse(fs21.readFileSync(file3, "utf-8"));
    return {
      activeDocID: parsed.activeDocID,
      docs: parsed.docs ?? {},
      events: Array.isArray(parsed.events) ? parsed.events : []
    };
  } catch {
    return defaultState4();
  }
}
function writeCanvasState(projectDir, state) {
  const file3 = filePath6(projectDir);
  ensureDir9(file3);
  fs21.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
  return state;
}
function pushEvent(state, input) {
  state.events = [
    {
      id: `canvas_evt_${randomUUID9()}`,
      kind: input.kind,
      docID: input.docID,
      at: nowIso10(),
      actor: input.actor
    },
    ...state.events
  ].slice(0, 400);
}
function openCanvasDoc(projectDir, input) {
  const state = readCanvasState(projectDir);
  const id = `canvas_${randomUUID9()}`;
  const now = nowIso10();
  const doc3 = {
    id,
    title: input.title,
    type: input.type ?? "markdown",
    content: input.content ?? "",
    createdAt: now,
    updatedAt: now
  };
  state.docs[id] = doc3;
  state.activeDocID = id;
  pushEvent(state, { kind: "open", docID: id, actor: input.actor ?? "gateway" });
  writeCanvasState(projectDir, state);
  return doc3;
}
function renderCanvasDoc(projectDir, input) {
  const state = readCanvasState(projectDir);
  const doc3 = state.docs[input.docID];
  if (!doc3)
    return null;
  doc3.content = input.merge ? `${doc3.content}
${input.content}` : input.content;
  doc3.updatedAt = nowIso10();
  state.activeDocID = doc3.id;
  pushEvent(state, { kind: "render", docID: doc3.id, actor: input.actor ?? "gateway" });
  writeCanvasState(projectDir, state);
  return doc3;
}
function closeCanvasDoc(projectDir, docID, actor = "gateway") {
  const state = readCanvasState(projectDir);
  const doc3 = state.docs[docID];
  if (!doc3)
    return null;
  if (state.activeDocID === docID) {
    state.activeDocID = undefined;
  }
  pushEvent(state, { kind: "close", docID, actor });
  writeCanvasState(projectDir, state);
  return doc3;
}
function listCanvasDocs(projectDir) {
  const state = readCanvasState(projectDir);
  return Object.values(state.docs).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function getCanvasDoc(projectDir, docID) {
  const state = readCanvasState(projectDir);
  return state.docs[docID] ?? null;
}
var init_state3 = __esm(() => {
  init_workflow();
});

// src/companion/memory-sqlite.ts
import * as fs22 from "node:fs";
import { createRequire as createRequire2 } from "node:module";
import * as path21 from "node:path";
function createSqlDatabase(file3) {
  try {
    const bunSqlite = require2("bun:sqlite");
    return new bunSqlite.Database(file3);
  } catch {}
  try {
    const nodeSqlite = require2("node:sqlite");
    const nodeDb = new nodeSqlite.DatabaseSync(file3);
    const tx = (fn) => (...args) => {
      nodeDb.exec("BEGIN");
      try {
        const result = fn(...args);
        nodeDb.exec("COMMIT");
        return result;
      } catch (error92) {
        try {
          nodeDb.exec("ROLLBACK");
        } catch {}
        throw error92;
      }
    };
    return {
      exec: (sql) => nodeDb.exec(sql),
      query: (sql) => {
        const stmt = nodeDb.prepare(sql);
        return {
          run: (...params) => stmt.run(...params),
          get: (...params) => stmt.get(...params),
          all: (...params) => stmt.all(...params)
        };
      },
      transaction: tx,
      close: () => nodeDb.close()
    };
  } catch {}
  throw new Error("sqlite_runtime_unavailable");
}
function memoryDir(projectDir) {
  return path21.join(getMiyaRuntimeDir(projectDir), "memory");
}
function sqlitePath(projectDir) {
  return path21.join(memoryDir(projectDir), "memories.sqlite");
}
function openDatabase(projectDir) {
  fs22.mkdirSync(memoryDir(projectDir), { recursive: true });
  const db = createSqlDatabase(sqlitePath(projectDir));
  db.exec(`
    CREATE TABLE IF NOT EXISTS memories (
      id TEXT PRIMARY KEY,
      subject TEXT NOT NULL,
      predicate TEXT NOT NULL,
      object TEXT NOT NULL,
      memory_kind TEXT DEFAULT 'Fact',
      confidence REAL DEFAULT 0.5,
      source_message_id TEXT,
      conflict_flag INTEGER DEFAULT 0,
      is_archived INTEGER DEFAULT 0,
      access_count INTEGER DEFAULT 0,
      created_at TEXT NOT NULL,
      last_accessed_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memories_vss (
      memory_id TEXT PRIMARY KEY,
      object_embedding TEXT NOT NULL,
      FOREIGN KEY(memory_id) REFERENCES memories(id) ON DELETE CASCADE
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS long_term_graph (
      memory_id TEXT PRIMARY KEY,
      subject TEXT NOT NULL,
      predicate TEXT NOT NULL,
      object TEXT NOT NULL,
      memory_kind TEXT NOT NULL,
      confidence REAL DEFAULT 0.5,
      source_message_id TEXT,
      updated_at TEXT NOT NULL,
      FOREIGN KEY(memory_id) REFERENCES memories(id) ON DELETE CASCADE
    );
  `);
  try {
    db.exec(`ALTER TABLE memories ADD COLUMN memory_kind TEXT DEFAULT 'Fact'`);
  } catch {}
  return db;
}
function parseTriplet(text) {
  const parts = text.trim().split(/\s+/);
  if (parts.length >= 3) {
    return {
      subject: parts[0] ?? "User",
      predicate: parts[1] ?? "knows",
      object: parts.slice(2).join(" ")
    };
  }
  return {
    subject: "User",
    predicate: "fact",
    object: text.trim()
  };
}
function syncCompanionMemoriesToSqlite(projectDir, items) {
  let db = null;
  try {
    db = openDatabase(projectDir);
    const upsertMemory = db.query(`
      INSERT INTO memories (
        id, subject, predicate, object, memory_kind, confidence, source_message_id,
        conflict_flag, is_archived, access_count, created_at, last_accessed_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(id) DO UPDATE SET
        subject=excluded.subject,
        predicate=excluded.predicate,
        object=excluded.object,
        memory_kind=excluded.memory_kind,
        confidence=excluded.confidence,
        source_message_id=excluded.source_message_id,
        conflict_flag=excluded.conflict_flag,
        is_archived=excluded.is_archived,
        access_count=excluded.access_count,
        created_at=excluded.created_at,
        last_accessed_at=excluded.last_accessed_at
    `);
    const upsertVss = db.query(`
      INSERT INTO memories_vss (memory_id, object_embedding)
      VALUES (?, ?)
      ON CONFLICT(memory_id) DO UPDATE SET
        object_embedding=excluded.object_embedding
    `);
    const upsertLongTermGraph = db.query(`
      INSERT INTO long_term_graph (
        memory_id, subject, predicate, object, memory_kind, confidence, source_message_id, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(memory_id) DO UPDATE SET
        subject=excluded.subject,
        predicate=excluded.predicate,
        object=excluded.object,
        memory_kind=excluded.memory_kind,
        confidence=excluded.confidence,
        source_message_id=excluded.source_message_id,
        updated_at=excluded.updated_at
    `);
    const tx = db.transaction(() => {
      for (const item of items) {
        const triplet = parseTriplet(item.text);
        upsertMemory.run(item.id, triplet.subject, triplet.predicate, triplet.object, item.memoryKind ?? "Fact", item.confidence, item.sourceMessageID ?? null, item.conflictWizardID ? 1 : 0, item.isArchived ? 1 : 0, item.accessCount, item.createdAt, item.lastAccessedAt);
        upsertVss.run(item.id, JSON.stringify(item.embedding));
        upsertLongTermGraph.run(item.id, triplet.subject, triplet.predicate, triplet.object, item.memoryKind ?? "Fact", item.confidence, item.sourceMessageID ?? null, item.updatedAt);
      }
    });
    tx();
  } catch {} finally {
    try {
      db?.close();
    } catch {}
  }
}
function getCompanionMemorySqliteStats(projectDir) {
  let db = null;
  const dbPath = sqlitePath(projectDir);
  try {
    db = openDatabase(projectDir);
    const memoryCount = Number(db.query("SELECT COUNT(1) AS c FROM memories").get()?.c ?? 0);
    const vectorCount = Number(db.query("SELECT COUNT(1) AS c FROM memories_vss").get()?.c ?? 0);
    const graphCount = Number(db.query("SELECT COUNT(1) AS c FROM long_term_graph").get()?.c ?? 0);
    return {
      sqlitePath: dbPath,
      memoryCount,
      vectorCount,
      graphCount
    };
  } finally {
    try {
      db?.close();
    } catch {}
  }
}
var require2;
var init_memory_sqlite = __esm(() => {
  init_workflow();
  require2 = createRequire2(import.meta.url);
});

// src/companion/memory-vector.ts
import { createHash as createHash8, randomUUID as randomUUID10 } from "node:crypto";
import * as fs23 from "node:fs";
import * as path22 from "node:path";
function nowIso11() {
  return new Date().toISOString();
}
function filePath7(projectDir) {
  return path22.join(getMiyaRuntimeDir(projectDir), "companion-memory-vectors.json");
}
function correctionFilePath(projectDir) {
  return path22.join(getMiyaRuntimeDir(projectDir), "companion-memory-corrections.json");
}
function ensureDir10(projectDir) {
  fs23.mkdirSync(path22.dirname(filePath7(projectDir)), { recursive: true });
}
function readStore4(projectDir) {
  const file3 = filePath7(projectDir);
  if (!fs23.existsSync(file3))
    return { version: 1, items: [] };
  try {
    const parsed = JSON.parse(fs23.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      items: Array.isArray(parsed.items) ? parsed.items.map((item) => ({
        ...item,
        confidence: typeof item.confidence === "number" && Number.isFinite(item.confidence) ? Math.max(0, Math.min(1, item.confidence)) : 0.7,
        tier: item.tier === "L1" || item.tier === "L2" || item.tier === "L3" ? item.tier : "L2",
        sourceMessageID: typeof item.sourceMessageID === "string" && item.sourceMessageID.trim() ? item.sourceMessageID : undefined,
        sourceType: item.sourceType === "manual" || item.sourceType === "conversation" || item.sourceType === "reflect" || item.sourceType === "direct_correction" ? item.sourceType : "manual",
        memoryKind: item.memoryKind === "Fact" || item.memoryKind === "Insight" || item.memoryKind === "UserPreference" ? item.memoryKind : undefined,
        status: item.status === "active" || item.status === "pending" || item.status === "superseded" ? item.status : "active",
        accessCount: typeof item.accessCount === "number" && Number.isFinite(item.accessCount) ? Math.max(0, Math.floor(item.accessCount)) : 0,
        isArchived: typeof item.isArchived === "boolean" ? item.isArchived : false
      })) : []
    };
  } catch {
    return { version: 1, items: [] };
  }
}
function readCorrectionStore(projectDir) {
  const file3 = correctionFilePath(projectDir);
  if (!fs23.existsSync(file3))
    return { version: 1, items: [] };
  try {
    const parsed = JSON.parse(fs23.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      items: Array.isArray(parsed.items) ? parsed.items : []
    };
  } catch {
    return { version: 1, items: [] };
  }
}
function writeCorrectionStore(projectDir, store) {
  ensureDir10(projectDir);
  fs23.writeFileSync(correctionFilePath(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
  return store;
}
function writeStore4(projectDir, store) {
  ensureDir10(projectDir);
  fs23.writeFileSync(filePath7(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
  syncCompanionMemoriesToSqlite(projectDir, store.items);
  return store;
}
function normalizeText(text) {
  return text.trim().replace(/\s+/g, " ");
}
function textToEmbedding(text, dims = 64) {
  const vec = new Array(dims).fill(0);
  const parts = normalizeText(text).toLowerCase().split(/[^\p{L}\p{N}]+/u).filter(Boolean);
  if (parts.length === 0)
    return vec;
  for (const part of parts) {
    const hash3 = createHash8("sha256").update(part).digest();
    for (let i = 0;i < 8; i += 1) {
      const idx = hash3[i] % dims;
      vec[idx] += 1 + hash3[i + 8] % 3;
    }
  }
  const norm = Math.sqrt(vec.reduce((sum, value) => sum + value * value, 0));
  if (norm <= 0)
    return vec;
  return vec.map((value) => value / norm);
}
function cosine(a, b) {
  if (a.length !== b.length || a.length === 0)
    return 0;
  let sum = 0;
  for (let i = 0;i < a.length; i += 1)
    sum += a[i] * b[i];
  return sum;
}
function extractConflictKey(text) {
  const negative = text.match(/(?:不喜欢|讨厌|不想|不要)\s*([^，。!！?？]+)/);
  if (negative?.[1])
    return { key: normalizeText(negative[1]), polarity: "negative" };
  const positive = text.match(/(?:喜欢|爱|偏好|想要)\s*([^，。!！?？]+)/);
  if (positive?.[1])
    return { key: normalizeText(positive[1]), polarity: "positive" };
  return { polarity: "neutral" };
}
function decayCompanionMemoryVectors(projectDir, halfLifeDays = 30) {
  const store = readStore4(projectDir);
  const safeHalfLife = Math.max(1, halfLifeDays);
  const lambda = Math.log(2) / safeHalfLife;
  const nowMs = Date.now();
  let updated = 0;
  for (const item of store.items) {
    if (item.status !== "active")
      continue;
    const ageDays = Math.max(0, (nowMs - Date.parse(item.updatedAt)) / (24 * 3600 * 1000));
    const nextScore = Math.max(0.05, item.score * Math.exp(-lambda * ageDays));
    if (Math.abs(nextScore - item.score) > 0.0001) {
      item.score = Number(nextScore.toFixed(4));
      if (item.score < 0.08) {
        item.isArchived = true;
      }
      item.updatedAt = nowIso11();
      updated += 1;
    }
  }
  writeStore4(projectDir, store);
  return { updated, items: store.items };
}
function upsertCompanionMemoryVector(projectDir, input) {
  const text = normalizeText(input.text);
  if (!text)
    throw new Error("invalid_memory_text");
  decayCompanionMemoryVectors(projectDir);
  const store = readStore4(projectDir);
  const embedding = textToEmbedding(text);
  const now = nowIso11();
  const near = store.items.filter((item) => item.status === "active").map((item) => ({
    item,
    sim: cosine(item.embedding, embedding)
  })).sort((a, b) => b.sim - a.sim)[0];
  if (near && near.sim >= 0.95) {
    near.item.score = Math.min(1.5, near.item.score + 0.15);
    near.item.accessCount += 1;
    near.item.isArchived = false;
    near.item.lastAccessedAt = now;
    near.item.updatedAt = now;
    writeStore4(projectDir, store);
    return near.item;
  }
  const preference = extractConflictKey(text);
  const confidenceInput = typeof input.confidence === "number" && Number.isFinite(input.confidence) ? input.confidence : input.tier === "L1" ? 1 : input.tier === "L3" ? 0.4 : 0.7;
  const confidence = Math.max(0, Math.min(1, confidenceInput));
  const created = {
    id: `mem_${randomUUID10()}`,
    text,
    source: input.source?.trim() || "manual",
    embedding,
    score: 1,
    confidence,
    tier: input.tier ?? (confidence >= 0.95 ? "L1" : confidence >= 0.6 ? "L2" : "L3"),
    sourceMessageID: input.sourceMessageID,
    sourceType: input.sourceType ?? "manual",
    memoryKind: input.memoryKind,
    status: input.activate ? "active" : "pending",
    conflictKey: preference.key,
    accessCount: 0,
    isArchived: false,
    createdAt: now,
    updatedAt: now,
    lastAccessedAt: now
  };
  if (preference.key && preference.polarity !== "neutral") {
    const conflicting = [];
    for (const item of store.items) {
      if (item.status === "superseded")
        continue;
      const other = extractConflictKey(item.text);
      if (!other.key || other.key !== preference.key || other.polarity === "neutral")
        continue;
      if (other.polarity !== preference.polarity) {
        conflicting.push(item);
      }
    }
    if (conflicting.length > 0) {
      const lambda = Math.log(2) / 30;
      const newScore = created.confidence;
      const scored = conflicting.map((item) => {
        const ageDays = Math.max(0, (Date.now() - Date.parse(item.lastAccessedAt)) / (24 * 3600 * 1000));
        const score = item.confidence * Math.exp(-lambda * ageDays);
        return { item, score };
      });
      const strongestOld = scored.sort((a, b) => b.score - a.score)[0];
      const threshold = 0.1;
      const forceOverride = created.sourceType === "direct_correction";
      const shouldOverwrite = forceOverride || (strongestOld ? newScore > strongestOld.score + threshold : false);
      if (shouldOverwrite) {
        created.status = "active";
        for (const other of conflicting) {
          other.status = "superseded";
          other.supersededBy = created.id;
          other.updatedAt = now;
        }
      } else {
        const correctionStore = readCorrectionStore(projectDir);
        const wizard = {
          id: `mcw_${randomUUID10()}`,
          conflictKey: preference.key,
          candidateMemoryID: created.id,
          existingMemoryIDs: conflicting.map((item) => item.id),
          status: "pending",
          createdAt: now,
          updatedAt: now
        };
        correctionStore.items = [wizard, ...correctionStore.items].slice(0, 1000);
        writeCorrectionStore(projectDir, correctionStore);
        created.conflictWizardID = wizard.id;
        created.status = "pending";
      }
    }
  }
  store.items = [created, ...store.items].slice(0, 1000);
  writeStore4(projectDir, store);
  return created;
}
function searchCompanionMemoryVectors(projectDir, query, limit = 5, options) {
  const q = normalizeText(query);
  if (!q)
    return [];
  const qEmb = textToEmbedding(q);
  const store = readStore4(projectDir);
  const nowMs = Date.now();
  const recencyHalfLifeDays = Math.max(1, options?.recencyHalfLifeDays ?? 30);
  const alpha = options?.alpha ?? 0.6;
  const beta = options?.beta ?? 0.2;
  const gamma = options?.gamma ?? 0.2;
  const threshold = Math.max(0, options?.threshold ?? 0.15);
  const importanceFromTier = (tier) => tier === "L1" ? 1 : tier === "L2" ? 0.7 : 0.4;
  const recency = (at) => {
    const deltaDays = Math.max(0, (nowMs - Date.parse(at)) / (24 * 3600 * 1000));
    const lambda = Math.log(2) / recencyHalfLifeDays;
    return Math.exp(-lambda * deltaDays);
  };
  const results = store.items.filter((item) => item.status === "active" && !item.isArchived).map((item) => {
    const similarity = cosine(item.embedding, qEmb);
    const importance = importanceFromTier(item.tier) * item.score * item.confidence;
    const rankScore = alpha * similarity + beta * recency(item.lastAccessedAt) + gamma * importance;
    return { ...item, similarity, rankScore };
  }).filter((item) => item.rankScore >= threshold).sort((a, b) => b.rankScore - a.rankScore).slice(0, Math.max(1, limit));
  for (const item of results) {
    const target = store.items.find((existing) => existing.id === item.id);
    if (!target)
      continue;
    target.accessCount += 1;
    target.lastAccessedAt = nowIso11();
  }
  writeStore4(projectDir, store);
  return results;
}
function listCompanionMemoryVectors(projectDir) {
  return readStore4(projectDir).items;
}
function listPendingCompanionMemoryVectors(projectDir) {
  return readStore4(projectDir).items.filter((item) => item.status === "pending");
}
function listCompanionMemoryCorrections(projectDir) {
  return readCorrectionStore(projectDir).items;
}
function updateCompanionMemoryVector(projectDir, input) {
  const store = readStore4(projectDir);
  const target = store.items.find((item) => item.id === input.memoryID);
  if (!target)
    return null;
  const nextText = typeof input.text === "string" && input.text.trim() ? normalizeText(input.text) : target.text;
  const confidenceInput = typeof input.confidence === "number" && Number.isFinite(input.confidence) ? Math.max(0, Math.min(1, Number(input.confidence))) : target.confidence;
  target.text = nextText;
  target.embedding = textToEmbedding(nextText);
  target.conflictKey = extractConflictKey(nextText).key;
  target.confidence = confidenceInput;
  target.tier = input.tier ?? (confidenceInput >= 0.95 ? "L1" : confidenceInput >= 0.6 ? "L2" : "L3");
  target.memoryKind = input.memoryKind === "Fact" || input.memoryKind === "Insight" || input.memoryKind === "UserPreference" ? input.memoryKind : target.memoryKind;
  if (input.status === "pending" || input.status === "active" || input.status === "superseded") {
    target.status = input.status;
  }
  target.updatedAt = nowIso11();
  if (target.status === "active") {
    target.lastAccessedAt = target.updatedAt;
  }
  writeStore4(projectDir, store);
  return target;
}
function archiveCompanionMemoryVector(projectDir, input) {
  const store = readStore4(projectDir);
  const target = store.items.find((item) => item.id === input.memoryID);
  if (!target)
    return null;
  target.isArchived = Boolean(input.archived);
  target.updatedAt = nowIso11();
  writeStore4(projectDir, store);
  return target;
}
function confirmCompanionMemoryVector(projectDir, input) {
  const store = readStore4(projectDir);
  const target = store.items.find((item) => item.id === input.memoryID);
  if (!target)
    return null;
  const now = nowIso11();
  if (!input.confirm) {
    target.status = "superseded";
    target.updatedAt = now;
  } else {
    target.status = "active";
    target.updatedAt = now;
    target.lastAccessedAt = now;
    if (input.supersedeConflicts && target.conflictKey) {
      for (const item of store.items) {
        if (item.id === target.id || item.status === "superseded")
          continue;
        if (item.conflictKey === target.conflictKey) {
          const sourcePolarity = extractConflictKey(target.text).polarity;
          const itemPolarity = extractConflictKey(item.text).polarity;
          if (sourcePolarity !== "neutral" && itemPolarity !== "neutral" && sourcePolarity !== itemPolarity) {
            item.status = "superseded";
            item.supersededBy = target.id;
            item.updatedAt = now;
          }
        }
      }
    }
  }
  writeStore4(projectDir, store);
  if (target.conflictWizardID) {
    const corrections = readCorrectionStore(projectDir);
    corrections.items = corrections.items.map((item) => item.id === target.conflictWizardID ? {
      ...item,
      status: input.confirm ? "resolved" : "rejected",
      updatedAt: now
    } : item);
    writeCorrectionStore(projectDir, corrections);
  }
  return target;
}
var init_memory_vector = __esm(() => {
  init_workflow();
  init_memory_sqlite();
});

// src/companion/store.ts
import { randomUUID as randomUUID11 } from "node:crypto";
import * as fs24 from "node:fs";
import * as path23 from "node:path";
function nowIso12() {
  return new Date().toISOString();
}
function filePath8(projectDir) {
  return path23.join(getMiyaRuntimeDir(projectDir), "companion.json");
}
function ensureDir11(file3) {
  fs24.mkdirSync(path23.dirname(file3), { recursive: true });
}
function defaultProfile() {
  return {
    enabled: false,
    onboardingCompleted: false,
    name: "Miya",
    persona: "calm, supportive, and proactive",
    relationship: "companion",
    style: "warm and concise",
    memoryFacts: [],
    assets: [],
    updatedAt: nowIso12()
  };
}
function readCompanionProfile(projectDir) {
  const file3 = filePath8(projectDir);
  if (!fs24.existsSync(file3))
    return defaultProfile();
  try {
    const parsed = JSON.parse(fs24.readFileSync(file3, "utf-8"));
    return {
      ...defaultProfile(),
      ...parsed,
      memoryFacts: Array.isArray(parsed.memoryFacts) ? parsed.memoryFacts : [],
      assets: Array.isArray(parsed.assets) ? parsed.assets : [],
      updatedAt: parsed.updatedAt ?? nowIso12()
    };
  } catch {
    return defaultProfile();
  }
}
function writeCompanionProfile(projectDir, profile) {
  const file3 = filePath8(projectDir);
  ensureDir11(file3);
  const next = {
    ...profile,
    updatedAt: nowIso12()
  };
  fs24.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function patchCompanionProfile(projectDir, patch) {
  const current = readCompanionProfile(projectDir);
  return writeCompanionProfile(projectDir, {
    ...current,
    ...patch
  });
}
function addCompanionAsset(projectDir, input) {
  const current = readCompanionProfile(projectDir);
  const asset = {
    id: `asset_${randomUUID11()}`,
    type: input.type,
    pathOrUrl: input.pathOrUrl,
    label: input.label,
    createdAt: nowIso12()
  };
  return writeCompanionProfile(projectDir, {
    ...current,
    assets: [asset, ...current.assets].slice(0, 200)
  });
}
function resetCompanionProfile(projectDir) {
  return writeCompanionProfile(projectDir, defaultProfile());
}
function syncCompanionProfileMemoryFacts(projectDir) {
  const current = readCompanionProfile(projectDir);
  const memoryFacts = listCompanionMemoryVectors(projectDir).filter((item) => item.status === "active").map((item) => item.text).slice(0, 300);
  return writeCompanionProfile(projectDir, {
    ...current,
    memoryFacts
  });
}
var init_store4 = __esm(() => {
  init_workflow();
  init_memory_vector();
});

// src/learning/skill-drafts.ts
import { createHash as createHash9, randomUUID as randomUUID12 } from "node:crypto";
import * as fs25 from "node:fs";
import * as path24 from "node:path";
function nowIso13() {
  return new Date().toISOString();
}
function filePath9(projectDir) {
  return path24.join(getMiyaRuntimeDir(projectDir), "learning-skill-drafts.json");
}
function normalizeText2(text) {
  return String(text ?? "").replace(/\s+/g, " ").trim();
}
function tokenize(text) {
  return Array.from(new Set(normalizeText2(text).toLowerCase().split(/[^a-z0-9_\-\u4e00-\u9fff]+/i).map((item) => item.trim()).filter((item) => item.length >= 2)));
}
function hashText(text) {
  return createHash9("sha256").update(text).digest("hex").slice(0, 16);
}
function ensureDir12(projectDir) {
  fs25.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp2(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeDraft(raw) {
  const now = nowIso13();
  return {
    id: String(raw.id ?? `draft_${randomUUID12()}`),
    source: raw.source === "reflect" ? "reflect" : "ralph",
    status: raw.status === "accepted" || raw.status === "rejected" || raw.status === "recommended" || raw.status === "draft" ? raw.status : "draft",
    title: normalizeText2(String(raw.title ?? "")),
    problemPattern: normalizeText2(String(raw.problemPattern ?? "")),
    solutionPattern: normalizeText2(String(raw.solutionPattern ?? "")),
    commands: Array.isArray(raw.commands) ? raw.commands.map(String).map(normalizeText2).filter(Boolean) : [],
    tags: Array.isArray(raw.tags) ? raw.tags.map(String).map((item) => item.trim().toLowerCase()).filter(Boolean) : [],
    confidence: clamp2(Number(raw.confidence ?? 0.5), 0.1, 0.99),
    uses: clamp2(Number(raw.uses ?? 0), 0, 1e6),
    hits: clamp2(Number(raw.hits ?? 0), 0, 1e6),
    misses: clamp2(Number(raw.misses ?? 0), 0, 1e6),
    createdAt: raw.createdAt ? String(raw.createdAt) : now,
    updatedAt: raw.updatedAt ? String(raw.updatedAt) : now
  };
}
function readStore5(projectDir) {
  const file3 = filePath9(projectDir);
  if (!fs25.existsSync(file3))
    return { drafts: [] };
  try {
    const parsed = JSON.parse(fs25.readFileSync(file3, "utf-8"));
    const drafts = Array.isArray(parsed?.drafts) ? parsed.drafts.map((item) => normalizeDraft(item)) : [];
    return { drafts };
  } catch {
    return { drafts: [] };
  }
}
function writeStore5(projectDir, store) {
  ensureDir12(projectDir);
  fs25.writeFileSync(filePath9(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function findSimilarDraftIndex(drafts, candidate) {
  const signature = hashText(`${candidate.source}|${candidate.problemPattern}|${candidate.solutionPattern}|${candidate.commands.join("|")}`);
  return drafts.findIndex((item) => {
    const current = hashText(`${item.source}|${item.problemPattern}|${item.solutionPattern}|${item.commands.join("|")}`);
    return current === signature;
  });
}
function upsertDraft(projectDir, draft) {
  const store = readStore5(projectDir);
  const index = findSimilarDraftIndex(store.drafts, draft);
  if (index >= 0) {
    const current = store.drafts[index];
    const merged = normalizeDraft({
      ...current,
      ...draft,
      id: current.id,
      createdAt: current.createdAt,
      confidence: current.confidence * 0.7 + draft.confidence * 0.3,
      status: current.status === "accepted" || current.status === "rejected" ? current.status : draft.status,
      tags: Array.from(new Set([...current.tags, ...draft.tags])).slice(0, 12),
      updatedAt: nowIso13()
    });
    store.drafts[index] = merged;
    writeStore5(projectDir, store);
    return merged;
  }
  const next = normalizeDraft(draft);
  store.drafts = [next, ...store.drafts].slice(0, 500);
  writeStore5(projectDir, store);
  return next;
}
function draftScoreForQuery(draft, query) {
  const queryTokens = tokenize(query);
  if (queryTokens.length === 0)
    return 0;
  const targetTokens = new Set(tokenize(`${draft.title} ${draft.problemPattern} ${draft.solutionPattern} ${draft.tags.join(" ")}`));
  let overlap = 0;
  for (const token of queryTokens) {
    if (targetTokens.has(token))
      overlap += 1;
  }
  const overlapScore = overlap / queryTokens.length;
  const quality = draft.confidence;
  const statusBoost = draft.status === "accepted" ? 0.12 : draft.status === "recommended" ? 0.06 : 0;
  return clamp2(overlapScore * 0.75 + quality * 0.25 + statusBoost, 0, 1);
}
function matchDrafts(projectDir, query, threshold, limit) {
  const store = readStore5(projectDir);
  return store.drafts.filter((draft) => draft.status !== "rejected").map((draft) => ({ draft, score: draftScoreForQuery(draft, query) })).filter((item) => item.score >= threshold).sort((a, b) => b.score - a.score).slice(0, Math.max(1, limit));
}
function listSkillDrafts(projectDir, input) {
  const limit = Math.max(1, Math.min(200, Math.floor(Number(input?.limit ?? 50))));
  const store = readStore5(projectDir);
  return store.drafts.filter((draft) => input?.status ? draft.status === input.status : true).slice(0, limit);
}
function setSkillDraftStatus(projectDir, draftID, status, usage) {
  const store = readStore5(projectDir);
  const index = store.drafts.findIndex((item) => item.id === draftID);
  if (index < 0)
    return null;
  const current = store.drafts[index];
  const next = normalizeDraft({
    ...current,
    status: status ?? current.status,
    uses: usage ? current.uses + 1 : current.uses,
    hits: usage ? current.hits + (usage.hit ? 1 : 0) : current.hits,
    misses: usage ? current.misses + (usage.hit ? 0 : 1) : current.misses,
    updatedAt: nowIso13()
  });
  store.drafts[index] = next;
  writeStore5(projectDir, store);
  return next;
}
function getLearningStats(projectDir) {
  const drafts = readStore5(projectDir).drafts;
  const byStatus = {
    draft: 0,
    recommended: 0,
    accepted: 0,
    rejected: 0
  };
  let totalUses = 0;
  let totalHits = 0;
  for (const draft of drafts) {
    byStatus[draft.status] += 1;
    totalUses += draft.uses;
    totalHits += draft.hits;
  }
  return {
    total: drafts.length,
    byStatus,
    totalUses,
    hitRate: totalUses > 0 ? Number((totalHits / totalUses).toFixed(4)) : 0
  };
}
function buildLearningInjection(projectDir, query, input) {
  const threshold = clamp2(Number(input?.threshold ?? 0.64), 0.3, 0.98);
  const limit = Math.max(1, Math.min(3, Math.floor(Number(input?.limit ?? 2))));
  const matches = matchDrafts(projectDir, query, threshold, limit);
  if (matches.length === 0)
    return { snippet: undefined, matchedDraftIDs: [] };
  const lines = [
    "[MIYA_LEARNING_DRAFT_REUSE]",
    "Matched historical patterns (use as guidance, then verify):"
  ];
  for (const item of matches) {
    lines.push(`- draft=${item.draft.id} score=${item.score.toFixed(2)} title=${item.draft.title}`);
    lines.push(`  pattern=${item.draft.problemPattern}`);
    lines.push(`  fix=${item.draft.solutionPattern}`);
    if (item.draft.commands.length > 0) {
      lines.push(`  commands=${item.draft.commands.join(" ; ")}`);
    }
  }
  return {
    snippet: lines.join(`
`),
    matchedDraftIDs: matches.map((item) => item.draft.id)
  };
}
function createSkillDraftsFromReflect(projectDir, input) {
  const memories = Array.isArray(input.createdMemories) ? input.createdMemories : [];
  if (memories.length === 0)
    return [];
  const preferenceMemories = memories.filter((item) => item.memoryKind === "UserPreference").slice(0, 6);
  if (preferenceMemories.length === 0)
    return [];
  const pattern = preferenceMemories.map((item) => item.text).join(" | ");
  const draft = upsertDraft(projectDir, {
    id: `draft_${randomUUID12()}`,
    source: "reflect",
    status: "draft",
    title: "Reflect 偏好执行草案",
    problemPattern: "任务执行涉及用户习惯或偏好判断",
    solutionPattern: `优先遵循近期偏好记忆：${pattern}`,
    commands: [],
    tags: ["reflect", "preference"],
    confidence: 0.62,
    uses: 0,
    hits: 0,
    misses: 0,
    createdAt: nowIso13(),
    updatedAt: nowIso13()
  });
  return [draft];
}
var init_skill_drafts = __esm(() => {
  init_workflow();
});

// src/learning/index.ts
var init_learning = __esm(() => {
  init_skill_drafts();
});

// src/companion/memory-reflect.ts
import { createHash as createHash10, randomUUID as randomUUID13 } from "node:crypto";
import * as fs26 from "node:fs";
import * as path25 from "node:path";
function nowIso14() {
  return new Date().toISOString();
}
function memoryDir2(projectDir) {
  return path25.join(getMiyaRuntimeDir(projectDir), "memory");
}
function shortTermLogPath(projectDir) {
  return path25.join(memoryDir2(projectDir), "short-term-history.jsonl");
}
function archiveLogPath(projectDir) {
  return path25.join(memoryDir2(projectDir), "archived-history.jsonl");
}
function reflectJobPath(projectDir) {
  return path25.join(memoryDir2(projectDir), "reflect-jobs.jsonl");
}
function reflectStatePath(projectDir) {
  return path25.join(memoryDir2(projectDir), "reflect-state.json");
}
function ensureDir13(projectDir) {
  fs26.mkdirSync(memoryDir2(projectDir), { recursive: true });
}
function normalizeText3(input) {
  return input.trim().replace(/\s+/g, " ");
}
function hashMessage(input) {
  return createHash10("sha256").update(`${input.sender}
${input.at}
${normalizeText3(input.text)}`).digest("hex");
}
function parseJsonlRows(file3) {
  if (!fs26.existsSync(file3))
    return [];
  const rows = [];
  const raw = fs26.readFileSync(file3, "utf-8");
  for (const line of raw.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed)
      continue;
    try {
      rows.push(JSON.parse(trimmed));
    } catch {}
  }
  return rows;
}
function writeJsonlRows(file3, rows) {
  const body = rows.map((row) => JSON.stringify(row)).join(`
`);
  fs26.writeFileSync(file3, body ? `${body}
` : "", "utf-8");
}
function readReflectState(projectDir) {
  const file3 = reflectStatePath(projectDir);
  if (!fs26.existsSync(file3))
    return {};
  try {
    const parsed = JSON.parse(fs26.readFileSync(file3, "utf-8"));
    return parsed ?? {};
  } catch {
    return {};
  }
}
function writeReflectState(projectDir, patch) {
  ensureDir13(projectDir);
  const file3 = reflectStatePath(projectDir);
  const next = {
    ...readReflectState(projectDir),
    ...patch
  };
  fs26.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function extractTriplets(log) {
  if (log.sender === "system")
    return [];
  const text = normalizeText3(log.text);
  if (!text)
    return [];
  const triplets = [];
  const add = (kind, subject, predicate, object3, confidence, tier) => {
    const value = normalizeText3(object3);
    if (!value)
      return;
    triplets.push({
      kind,
      subject,
      predicate,
      object: value,
      confidence,
      tier,
      sourceLogID: log.id
    });
  };
  const likes = text.match(/我(?:特别)?喜欢([^，。！？!?.]+)/);
  if (likes?.[1])
    add("UserPreference", "User", "likes", likes[1], 0.86, "L2");
  const dislikes = text.match(/我(?:很|真的)?不喜欢([^，。！？!?.]+)/);
  if (dislikes?.[1])
    add("UserPreference", "User", "dislikes", dislikes[1], 0.86, "L2");
  const prefers = text.match(/(?:以后|之后|从现在开始)?(?:只要|只喝|只用|优先)\s*([^，。！？!?.]+)/);
  if (prefers?.[1])
    add("UserPreference", "User", "prefers", prefers[1], 0.9, "L2");
  const avoids = text.match(/(?:不要|别|避免)\s*([^，。！？!?.]+)/);
  if (avoids?.[1])
    add("UserPreference", "User", "avoids", avoids[1], 0.88, "L2");
  const needs = text.match(/我(?:需要|想要|要)([^，。！？!?.]+)/);
  if (needs?.[1])
    add("Fact", "User", "requires", needs[1], 0.7, "L2");
  const blocks = text.match(/(?:卡在|被|遇到)([^，。！？!?.]+)(?:问题|错误|异常|报错)/);
  if (blocks?.[1])
    add("Insight", "User", "is_blocking", `${blocks[1]}问题`, 0.75, "L2");
  const anxiety = text.match(/(?:焦虑|着急|担心|压力很大|怕来不及)([^，。！？!?.]*)/);
  if (anxiety)
    add("Insight", "User", "emotion_signal", `进度压力 ${anxiety[0]}`.trim(), 0.72, "L3");
  const project = text.match(/(?:项目|仓库|repo|分支)\s*[:：]?\s*([^，。！？!?.]+)/i);
  if (project?.[1])
    add("Fact", "User", "project", project[1], 0.68, "L2");
  const apiRef = text.match(/(?:API|文档|doc|docs?)\s*[:：]?\s*([^，。！？!?.]+)/i);
  if (apiRef?.[1])
    add("Fact", "User", "api_reference", apiRef[1], 0.64, "L3");
  if (triplets.length === 0 && text.length <= 120) {
    add("Fact", log.sender === "assistant" ? "Miya" : "User", "stated", text, 0.55, "L3");
  }
  return triplets;
}
function tripletText(triplet) {
  return `${triplet.subject} ${triplet.predicate} ${triplet.object}`;
}
function appendShortTermMemoryLog(projectDir, input) {
  const text = normalizeText3(input.text);
  if (!text)
    return null;
  const at = input.at ?? nowIso14();
  const messageHash = input.messageID || hashMessage({ text, sender: input.sender, at });
  ensureDir13(projectDir);
  const file3 = shortTermLogPath(projectDir);
  const rows = parseJsonlRows(file3);
  if (rows.some((row2) => row2.messageHash === messageHash))
    return null;
  const row = {
    id: `st_${randomUUID13()}`,
    sessionID: input.sessionID?.trim() || "main",
    sender: input.sender,
    text,
    at,
    messageHash
  };
  rows.push(row);
  writeJsonlRows(file3, rows);
  writeReflectState(projectDir, { lastLogAt: at });
  return row;
}
function getMemoryReflectStatus(projectDir) {
  const rows = parseJsonlRows(shortTermLogPath(projectDir));
  const pendingLogs = rows.filter((row) => !row.processedAt).length;
  const state = readReflectState(projectDir);
  return {
    pendingLogs,
    lastLogAt: state.lastLogAt,
    lastReflectAt: state.lastReflectAt
  };
}
function reflectCompanionMemory(projectDir, input) {
  ensureDir13(projectDir);
  const state = readReflectState(projectDir);
  const now = nowIso14();
  if (input?.idempotencyKey && state.lastReflectIdempotencyKey === input.idempotencyKey) {
    if (state.lastReflectResult)
      return state.lastReflectResult;
  }
  const cooldownMinutes = Math.max(0, input?.cooldownMinutes ?? 0);
  if (cooldownMinutes > 0 && state.lastReflectAt) {
    const deltaMs = Date.now() - Date.parse(state.lastReflectAt);
    if (Number.isFinite(deltaMs) && deltaMs < cooldownMinutes * 60 * 1000) {
      const blocked = {
        jobID: `reflect_${randomUUID13()}`,
        processedLogs: 0,
        generatedTriplets: 0,
        generatedFacts: 0,
        generatedInsights: 0,
        generatedPreferences: 0,
        createdMemories: [],
        archivedLogs: 0
      };
      writeReflectState(projectDir, {
        lastReflectReason: `cooldown_blocked_${cooldownMinutes}m`
      });
      return blocked;
    }
  }
  const rows = parseJsonlRows(shortTermLogPath(projectDir));
  const pending = rows.filter((row) => !row.processedAt);
  const minLogs = Math.max(1, input?.minLogs ?? 1);
  if (!input?.force && pending.length < minLogs) {
    return {
      jobID: `reflect_${randomUUID13()}`,
      processedLogs: 0,
      generatedTriplets: 0,
      generatedFacts: 0,
      generatedInsights: 0,
      generatedPreferences: 0,
      createdMemories: [],
      archivedLogs: 0
    };
  }
  const maxLogs = Math.max(1, input?.maxLogs ?? 50);
  const picked = pending.slice(0, maxLogs);
  const triplets = picked.flatMap((row) => extractTriplets(row));
  const generatedFacts = triplets.filter((item) => item.kind === "Fact").length;
  const generatedInsights = triplets.filter((item) => item.kind === "Insight").length;
  const generatedPreferences = triplets.filter((item) => item.kind === "UserPreference").length;
  const createdMemories = triplets.map((triplet) => upsertCompanionMemoryVector(projectDir, {
    text: tripletText(triplet),
    source: "reflect",
    activate: false,
    confidence: triplet.confidence,
    tier: triplet.tier,
    sourceMessageID: triplet.sourceLogID,
    sourceType: "reflect",
    memoryKind: triplet.kind
  }));
  const processedAt = nowIso14();
  const pickedIdSet = new Set(picked.map((row) => row.id));
  const nextRows = rows.filter((row) => !pickedIdSet.has(row.id));
  writeJsonlRows(shortTermLogPath(projectDir), nextRows);
  const archived = parseJsonlRows(archiveLogPath(projectDir));
  const moved = picked.map((row) => ({ ...row, processedAt }));
  writeJsonlRows(archiveLogPath(projectDir), [...archived, ...moved]);
  const result = {
    jobID: `reflect_${randomUUID13()}`,
    processedLogs: picked.length,
    generatedTriplets: triplets.length,
    generatedFacts,
    generatedInsights,
    generatedPreferences,
    createdMemories,
    archivedLogs: moved.length
  };
  createSkillDraftsFromReflect(projectDir, {
    createdMemories
  });
  fs26.appendFileSync(reflectJobPath(projectDir), `${JSON.stringify({ ...result, at: processedAt })}
`, "utf-8");
  writeReflectState(projectDir, {
    lastReflectAt: now,
    lastReflectIdempotencyKey: input?.idempotencyKey,
    lastReflectResult: result,
    lastReflectReason: "ok"
  });
  return result;
}
function maybeAutoReflectCompanionMemory(projectDir, input) {
  const idleMinutes = Math.max(1, input?.idleMinutes ?? 5);
  const minPendingLogs = Math.max(1, input?.minPendingLogs ?? 1);
  const cooldownMinutes = Math.max(1, input?.cooldownMinutes ?? 3);
  const status = getMemoryReflectStatus(projectDir);
  if (status.pendingLogs < minPendingLogs)
    return null;
  if (!status.lastLogAt)
    return null;
  const nowMs = Date.now();
  const idleMs = nowMs - Date.parse(status.lastLogAt);
  if (!Number.isFinite(idleMs) || idleMs < idleMinutes * 60 * 1000)
    return null;
  if (status.lastReflectAt) {
    const cooldownMs = nowMs - Date.parse(status.lastReflectAt);
    if (Number.isFinite(cooldownMs) && cooldownMs < cooldownMinutes * 60 * 1000)
      return null;
  }
  return reflectCompanionMemory(projectDir, {
    force: true,
    minLogs: minPendingLogs,
    maxLogs: input?.maxLogs ?? 50
  });
}
function maybeReflectOnSessionEnd(projectDir, input) {
  const minPendingLogs = Math.max(1, input?.minPendingLogs ?? 50);
  const status = getMemoryReflectStatus(projectDir);
  if (status.pendingLogs < minPendingLogs)
    return null;
  return reflectCompanionMemory(projectDir, {
    force: true,
    minLogs: minPendingLogs,
    maxLogs: input?.maxLogs ?? 100
  });
}
var init_memory_reflect = __esm(() => {
  init_workflow();
  init_learning();
  init_memory_vector();
});

// src/companion/wizard.ts
import { createHash as createHash11, randomUUID as randomUUID14 } from "node:crypto";
import * as fs27 from "node:fs";
import * as path26 from "node:path";
function nowIso15() {
  return new Date().toISOString();
}
function normalizeSessionId(sessionId) {
  const normalized = sessionId.trim().replace(/[^a-zA-Z0-9_-]+/g, "_");
  return normalized || "main";
}
function profilesRoot(projectDir) {
  return path26.join(getMiyaRuntimeDir(projectDir), "profiles", "companion");
}
function sessionRoot(projectDir, sessionId) {
  return path26.join(profilesRoot(projectDir), "sessions", normalizeSessionId(sessionId));
}
function currentProfileDir(projectDir, sessionId) {
  return path26.join(sessionRoot(projectDir, sessionId), "current");
}
function wizardFilePath(projectDir, sessionId) {
  return path26.join(currentProfileDir(projectDir, sessionId), "wizard-state.json");
}
function metadataPath(projectDir, sessionId) {
  return path26.join(currentProfileDir(projectDir, sessionId), "metadata.json");
}
function ensureProfileLayout(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  fs27.mkdirSync(path26.join(current, "photos"), { recursive: true });
  fs27.mkdirSync(path26.join(current, "embeddings"), { recursive: true });
  fs27.mkdirSync(path26.join(current, "lora"), { recursive: true });
  fs27.mkdirSync(path26.join(current, "voice"), { recursive: true });
  fs27.mkdirSync(path26.join(sessionRoot(projectDir, sessionId), "history"), { recursive: true });
}
function safeReadJson(filePath10) {
  if (!fs27.existsSync(filePath10))
    return null;
  try {
    return JSON.parse(fs27.readFileSync(filePath10, "utf-8"));
  } catch {
    return null;
  }
}
function safeWriteJson(filePath10, value) {
  fs27.mkdirSync(path26.dirname(filePath10), { recursive: true });
  fs27.writeFileSync(filePath10, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function checksumFile(filePath10) {
  try {
    const data = fs27.readFileSync(filePath10);
    return `sha256:${createHash11("sha256").update(data).digest("hex")}`;
  } catch {
    return "sha256:unknown";
  }
}
function extensionForMime(mimeType, fallback = ".bin") {
  if (mimeType.includes("png"))
    return ".png";
  if (mimeType.includes("jpeg") || mimeType.includes("jpg"))
    return ".jpg";
  if (mimeType.includes("webp"))
    return ".webp";
  if (mimeType.includes("wav"))
    return ".wav";
  if (mimeType.includes("mpeg") || mimeType.includes("mp3"))
    return ".mp3";
  if (mimeType.includes("ogg"))
    return ".ogg";
  return fallback;
}
function defaultMetadata(sessionId) {
  const now = nowIso15();
  return {
    profileId: `companion-${now.replace(/[:.]/g, "-")}`,
    createdAt: now,
    updatedAt: now,
    version: "v1",
    assets: {
      photos: {
        count: 0,
        paths: [],
        checksums: []
      },
      voice: {
        hasSample: false,
        duration: 0,
        modelType: "gpt_sovits_v2"
      },
      persona: {
        sourceText: "",
        generatedPrompt: ""
      }
    },
    trainingStatus: {
      image: "pending",
      voice: "pending"
    },
    sessionBinding: {
      opencodeSessionId: sessionId,
      daemonSessionId: `daemon-${sessionId}`
    }
  };
}
function defaultState5(sessionId) {
  const now = nowIso15();
  return {
    sessionId: `wizard:companion:${normalizeSessionId(sessionId)}`,
    boundSessionId: sessionId || "main",
    state: "idle",
    startedAt: now,
    updatedAt: now,
    assets: {
      photos: [],
      voiceSample: "",
      personalityText: ""
    },
    trainingJobs: {},
    jobs: []
  };
}
function writeMetadata(projectDir, sessionId, metadata) {
  const next = { ...metadata, updatedAt: nowIso15() };
  safeWriteJson(metadataPath(projectDir, sessionId), next);
  return next;
}
function readMetadata(projectDir, sessionId) {
  ensureProfileLayout(projectDir, sessionId);
  const existing = safeReadJson(metadataPath(projectDir, sessionId));
  if (existing)
    return existing;
  const created = defaultMetadata(sessionId);
  writeMetadata(projectDir, sessionId, created);
  return created;
}
function writeState2(projectDir, sessionId, state) {
  ensureProfileLayout(projectDir, sessionId);
  const next = { ...state, updatedAt: nowIso15() };
  safeWriteJson(wizardFilePath(projectDir, sessionId), next);
  return next;
}
function moveCurrentToHistory(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  if (!fs27.existsSync(current))
    return;
  const historyDir = path26.join(sessionRoot(projectDir, sessionId), "history", new Date().toISOString().replace(/[:.]/g, "-"));
  fs27.mkdirSync(path26.dirname(historyDir), { recursive: true });
  fs27.cpSync(current, historyDir, { recursive: true });
  fs27.rmSync(current, { recursive: true, force: true });
}
function listSessionDirs(projectDir) {
  const root = path26.join(profilesRoot(projectDir), "sessions");
  if (!fs27.existsSync(root))
    return [];
  return fs27.readdirSync(root, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => entry2.name);
}
function sessionHasWizardFile(projectDir, sessionDirName) {
  const file3 = path26.join(profilesRoot(projectDir), "sessions", sessionDirName, "current", "wizard-state.json");
  return fs27.existsSync(file3);
}
function stateHasAssets(state) {
  return state.assets.photos.length > 0 || Boolean(state.assets.voiceSample) || Boolean(state.assets.personalityText);
}
function findSessionByJobId(projectDir, jobID) {
  for (const sid of listCompanionWizardSessions(projectDir)) {
    const state = readCompanionWizardState(projectDir, sid);
    if (state.jobs.some((job) => job.id === jobID))
      return sid;
  }
  return null;
}
function resolveSessionForWrite(projectDir, requestedSessionId) {
  if (requestedSessionId?.trim()) {
    return normalizeSessionId(requestedSessionId);
  }
  const sessions = listCompanionWizardSessions(projectDir);
  if (sessions.length === 0)
    return "main";
  const active = sessions.filter((sid) => {
    const state = readCompanionWizardState(projectDir, sid);
    return state.state !== "idle" || stateHasAssets(state) || state.jobs.length > 0;
  });
  if (active.length === 1)
    return active[0];
  if (active.includes("main"))
    return "main";
  return active[0] ?? sessions[0] ?? "main";
}
function listCompanionWizardSessions(projectDir) {
  return listSessionDirs(projectDir).filter((name) => sessionHasWizardFile(projectDir, name)).map((name) => name || "main");
}
function readCompanionWizardState(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  const existing = safeReadJson(wizardFilePath(projectDir, effectiveSessionId));
  if (existing)
    return existing;
  const created = defaultState5(effectiveSessionId);
  return writeState2(projectDir, effectiveSessionId, created);
}
function isCompanionWizardEmpty(projectDir, sessionId = "main") {
  const state = readCompanionWizardState(projectDir, sessionId);
  if (stateHasAssets(state))
    return false;
  if (state.jobs.length > 0)
    return false;
  return state.state === "idle";
}
function startCompanionWizard(projectDir, input) {
  const sessionId = normalizeSessionId(input?.sessionId ?? "main");
  ensureProfileLayout(projectDir, sessionId);
  if (input?.forceReset) {
    moveCurrentToHistory(projectDir, sessionId);
    ensureProfileLayout(projectDir, sessionId);
  }
  const existing = readCompanionWizardState(projectDir, sessionId);
  if (!input?.forceReset && (stateHasAssets(existing) || existing.state !== "idle")) {
    return existing;
  }
  const state = writeState2(projectDir, sessionId, {
    ...defaultState5(sessionId),
    state: "awaiting_photos",
    startedAt: nowIso15()
  });
  writeMetadata(projectDir, sessionId, defaultMetadata(sessionId));
  return state;
}
function resetCompanionWizard(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  moveCurrentToHistory(projectDir, effectiveSessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  writeMetadata(projectDir, effectiveSessionId, defaultMetadata(effectiveSessionId));
  return writeState2(projectDir, effectiveSessionId, {
    ...defaultState5(effectiveSessionId),
    state: "idle"
  });
}
function copyMediaToProfile(projectDir, mediaIDs, targetDir) {
  const output = [];
  fs27.mkdirSync(targetDir, { recursive: true });
  for (const mediaID of mediaIDs) {
    const item = getMediaItem(projectDir, mediaID);
    if (!item?.localPath || !fs27.existsSync(item.localPath)) {
      throw new Error(`media_asset_not_found:${mediaID}`);
    }
    const ext = path26.extname(item.fileName) || extensionForMime(item.mimeType);
    const fileName = `${String(output.length + 1).padStart(2, "0")}_original${ext}`;
    const filePath10 = path26.join(targetDir, fileName);
    fs27.copyFileSync(item.localPath, filePath10);
    output.push(filePath10);
  }
  return output;
}
function enqueueJob(state, input) {
  const job = {
    id: `wjob_${randomUUID14()}`,
    type: input.type,
    status: "queued",
    progress: 0,
    estimatedTime: input.estimatedTime,
    fallbackStrategy: input.fallbackStrategy,
    createdAt: nowIso15(),
    updatedAt: nowIso15(),
    attempts: 0
  };
  return {
    ...state,
    jobs: [...state.jobs, job],
    trainingJobs: {
      ...state.trainingJobs,
      imageJobId: input.type === "training.image" ? job.id : state.trainingJobs.imageJobId,
      voiceJobId: input.type === "training.voice" ? job.id : state.trainingJobs.voiceJobId
    }
  };
}
function submitWizardPhotos(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_photos") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  if (input.mediaIDs.length < 1 || input.mediaIDs.length > 5) {
    throw new Error("wizard_photo_count_invalid:must_be_1_to_5");
  }
  const photosDir = path26.join(currentProfileDir(projectDir, sessionId), "photos");
  fs27.rmSync(photosDir, { recursive: true, force: true });
  const copied = copyMediaToProfile(projectDir, input.mediaIDs, photosDir);
  if (copied.length < 1 || copied.length > 5 || copied.length !== input.mediaIDs.length) {
    throw new Error("wizard_photo_copy_invalid:must_be_1_to_5");
  }
  const withJob = enqueueJob({
    ...current,
    state: "training_image",
    assets: {
      ...current.assets,
      photos: copied
    }
  }, {
    type: "training.image",
    estimatedTime: "约5-10分钟",
    fallbackStrategy: "若显存不足将自动降级到embedding方案"
  });
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      photos: {
        count: copied.length,
        paths: copied.map((item) => path26.relative(currentProfileDir(projectDir, sessionId), item)),
        checksums: copied.map((item) => checksumFile(item))
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      image: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.imageJobId);
  if (!job)
    throw new Error("image_job_not_created");
  return { state: written, job };
}
function submitWizardVoice(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_voice") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const voiceDir = path26.join(currentProfileDir(projectDir, sessionId), "voice");
  fs27.mkdirSync(voiceDir, { recursive: true });
  const copied = copyMediaToProfile(projectDir, [input.mediaID], voiceDir);
  if (copied.length !== 1)
    throw new Error("voice_asset_not_found");
  const voicePath = path26.join(voiceDir, "original_sample.wav");
  fs27.copyFileSync(copied[0], voicePath);
  const withJob = enqueueJob({
    ...current,
    state: "training_voice",
    assets: {
      ...current.assets,
      voiceSample: voicePath
    }
  }, {
    type: "training.voice",
    estimatedTime: "约3-8分钟",
    fallbackStrategy: "若显存不足将自动降级到embedding方案"
  });
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      voice: {
        hasSample: true,
        duration: 0,
        modelType: "gpt_sovits_v2"
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      voice: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.voiceJobId);
  if (!job)
    throw new Error("voice_job_not_created");
  return { state: written, job };
}
function submitWizardPersonality(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_personality") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const text = input.personalityText.trim();
  if (!text)
    throw new Error("invalid_personality_text");
  const personaPath = path26.join(currentProfileDir(projectDir, sessionId), "persona.json");
  const persona = {
    sourceText: text,
    generatedPrompt: `system: ${text}`,
    updatedAt: nowIso15()
  };
  safeWriteJson(personaPath, persona);
  const next = writeState2(projectDir, sessionId, {
    ...current,
    state: "completed",
    assets: {
      ...current.assets,
      personalityText: text
    }
  });
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      persona: {
        sourceText: text,
        generatedPrompt: persona.generatedPrompt
      }
    }
  });
  return next;
}
function pickQueuedTrainingJob(projectDir, sessionId) {
  const targetSessions = sessionId ? [normalizeSessionId(sessionId)] : listCompanionWizardSessions(projectDir);
  for (const sid of targetSessions) {
    const state = readCompanionWizardState(projectDir, sid);
    if (state.jobs.some((item) => item.status === "training"))
      continue;
    const queued = state.jobs.find((item) => item.status === "queued");
    if (queued)
      return { sessionId: sid, job: queued };
  }
  return null;
}
function markTrainingJobRunning(projectDir, jobID, sessionId = "main") {
  const sid = normalizeSessionId(sessionId);
  const resolvedSession = sessionId === "main" ? findSessionByJobId(projectDir, jobID) ?? sid : sid;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    jobs: current.jobs.map((job2) => job2.id === jobID ? {
      ...job2,
      status: "training",
      progress: Math.max(5, job2.progress),
      attempts: job2.attempts + 1,
      updatedAt: nowIso15()
    } : job2)
  });
  const job = updated.jobs.find((item) => item.id === jobID);
  if (!job)
    return updated;
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, image: "training" }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, voice: "training" }
    });
  }
  return updated;
}
function requeueTrainingJob(projectDir, input) {
  const sid = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sid);
  return writeState2(projectDir, sid, {
    ...current,
    jobs: current.jobs.map((job) => job.id === input.jobID ? {
      ...job,
      status: "queued",
      progress: Math.max(10, job.progress),
      checkpointPath: input.checkpointPath,
      message: input.message,
      updatedAt: nowIso15()
    } : job)
  });
}
function markTrainingJobFinished(projectDir, input) {
  const sid = normalizeSessionId(input.sessionId ?? "main");
  const resolvedSession = input.sessionId == null ? findSessionByJobId(projectDir, input.jobID) ?? sid : sid;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const job = current.jobs.find((item) => item.id === input.jobID);
  if (!job)
    return current;
  const nextState = job.type === "training.image" ? input.status === "failed" || input.status === "canceled" ? "training_image" : "awaiting_voice" : input.status === "failed" || input.status === "canceled" ? "training_voice" : "awaiting_personality";
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    state: nextState,
    jobs: current.jobs.map((item) => item.id === input.jobID ? {
      ...item,
      status: input.status,
      message: input.message,
      progress: input.status === "failed" ? item.progress : 100,
      currentTier: input.tier,
      checkpointPath: input.checkpointPath ?? item.checkpointPath,
      updatedAt: nowIso15()
    } : item)
  });
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        image: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        voice: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  }
  return updated;
}
function cancelCompanionWizardTraining(projectDir, sessionId = "main") {
  const sid = resolveSessionForWrite(projectDir, sessionId);
  const current = readCompanionWizardState(projectDir, sid);
  let hasCanceled = false;
  const nextJobs = current.jobs.map((job) => {
    if (job.status !== "queued" && job.status !== "training")
      return job;
    hasCanceled = true;
    return {
      ...job,
      status: "canceled",
      message: "训练已取消/可重试",
      updatedAt: nowIso15()
    };
  });
  if (!hasCanceled)
    return current;
  const nextState = current.assets.voiceSample ? "awaiting_personality" : current.assets.photos.length > 0 ? "awaiting_voice" : "awaiting_photos";
  return writeState2(projectDir, sid, {
    ...current,
    state: nextState,
    jobs: nextJobs
  });
}
function getCompanionProfileCurrentDir(projectDir, sessionId = "main") {
  const sid = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, sid);
  return currentProfileDir(projectDir, sid);
}
function getWizardJobById(projectDir, jobID) {
  for (const sid of listCompanionWizardSessions(projectDir)) {
    const state = readCompanionWizardState(projectDir, sid);
    const match = state.jobs.find((job) => job.id === jobID);
    if (match)
      return { ...match, sessionId: sid };
  }
  return null;
}
function wizardChecklist(state) {
  return [
    state.assets.photos.length > 0 ? "visual:done" : "visual:pending",
    state.assets.voiceSample ? "voice:done" : "voice:pending",
    state.assets.personalityText ? "persona:done" : "persona:pending"
  ];
}
var init_wizard = __esm(() => {
  init_store2();
  init_workflow();
});

// src/multimodal/image.ts
import * as fs28 from "node:fs";
import * as path27 from "node:path";
function sanitizePrompt(prompt) {
  return prompt.trim().slice(0, 2000);
}
function toBase64FromFile(filePath10) {
  try {
    if (!fs28.existsSync(filePath10))
      return null;
    return fs28.readFileSync(filePath10).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:"))
    return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode(projectDir) {
  if (process.env.MIYA_MULTIMODAL_TEST_MODE === "1")
    return true;
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime;
  const multimodal = runtime?.multimodal;
  return multimodal?.test_mode === true;
}
async function generateImage(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const prompt = sanitizePrompt(input.prompt);
  if (!prompt)
    throw new Error("invalid_prompt");
  const model = input.model?.trim() || DEFAULT_IMAGE_MODEL;
  const size = input.size?.trim() || DEFAULT_IMAGE_SIZE;
  const referenceMediaIDs = (input.referenceMediaIDs ?? []).filter(Boolean);
  const references = referenceMediaIDs.map((id) => getMediaItem(projectDir, id)).filter((item) => Boolean(item)).map((item) => ({
    id: item.id,
    fileName: item.fileName,
    mimeType: item.mimeType,
    localPath: item.localPath
  }));
  const outputDir = getMiyaImageTempDir(projectDir);
  const outputPath = path27.join(outputDir, `flux-${Date.now()}.png`);
  const profileDir = path27.join(getMiyaRuntimeDir(projectDir), "profiles", "companion", "current");
  let inference;
  if (useMultimodalTestMode(projectDir)) {
    inference = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      inference = await daemon.runFluxImageGenerate({
        prompt,
        outputPath,
        profileDir,
        references: references.map((item) => item.localPath).filter((item) => Boolean(item)),
        size
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number")
            pending = String(plan.pending);
        } catch {}
        throw new Error(`model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`);
      }
      if (!isRuntimeNotReadyError(error92))
        throw error92;
      inference = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const payloadBase64 = toBase64FromFile(inference.outputPath) ?? BLANK_PNG_BASE64;
  const media = ingestMedia(projectDir, {
    source: "multimodal.image.generate",
    kind: "image",
    mimeType: "image/png",
    fileName: `generated-${Date.now()}.png`,
    contentBase64: payloadBase64,
    sizeBytes: Math.floor(payloadBase64.length * 3 / 4),
    metadata: {
      status: inference.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      prompt,
      model,
      size,
      tier: inference.tier,
      degraded: inference.degraded,
      engineMessage: inference.message,
      runtimeError: inference.message.startsWith("python_runtime_not_ready:") ? inference.message : undefined,
      references,
      createdBy: "miya_generate_image"
    }
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "image",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `generated:${model}`
    });
  }
  return {
    media,
    model,
    size,
    prompt
  };
}
var DEFAULT_IMAGE_MODEL = "local:flux.1-schnell", DEFAULT_IMAGE_SIZE = "1024x1024", BLANK_PNG_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO6sYz0AAAAASUVORK5CYII=";
var init_image = __esm(() => {
  init_store4();
  init_daemon();
  init_store2();
  init_paths();
  init_settings();
  init_workflow();
});

// src/multimodal/vision-regression.ts
import * as path28 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
var FIXTURE_FILE;
var init_vision_regression = __esm(() => {
  init_vision();
  FIXTURE_FILE = path28.join(path28.dirname(fileURLToPath2(import.meta.url)), "fixtures", "desktop-outbound-ocr-regression.json");
});

// src/multimodal/voice.ts
import * as fs29 from "node:fs";
import * as path29 from "node:path";
function normalizeFormat(format) {
  if (format === "mp3" || format === "ogg")
    return format;
  return "wav";
}
function buildSilentWavBase64(durationMs) {
  const sampleRate = 16000;
  const channels = 1;
  const bitsPerSample = 16;
  const bytesPerSample = bitsPerSample / 8;
  const frameCount = Math.max(1, Math.floor(sampleRate * durationMs / 1000));
  const dataSize = frameCount * channels * bytesPerSample;
  const buffer = Buffer.alloc(44 + dataSize);
  buffer.write("RIFF", 0);
  buffer.writeUInt32LE(36 + dataSize, 4);
  buffer.write("WAVE", 8);
  buffer.write("fmt ", 12);
  buffer.writeUInt32LE(16, 16);
  buffer.writeUInt16LE(1, 20);
  buffer.writeUInt16LE(channels, 22);
  buffer.writeUInt32LE(sampleRate, 24);
  buffer.writeUInt32LE(sampleRate * channels * bytesPerSample, 28);
  buffer.writeUInt16LE(channels * bytesPerSample, 32);
  buffer.writeUInt16LE(bitsPerSample, 34);
  buffer.write("data", 36);
  buffer.writeUInt32LE(dataSize, 40);
  return buffer.toString("base64");
}
function toBase64FromFile2(filePath10) {
  try {
    if (!fs29.existsSync(filePath10))
      return null;
    return fs29.readFileSync(filePath10).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:"))
    return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode2(projectDir) {
  if (process.env.MIYA_MULTIMODAL_TEST_MODE === "1")
    return true;
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime;
  const multimodal = runtime?.multimodal;
  return multimodal?.test_mode === true;
}
async function synthesizeVoiceOutput(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const text = input.text.trim();
  if (!text)
    throw new Error("invalid_tts_text");
  const voice = input.voice?.trim() || DEFAULT_VOICE;
  const model = input.model?.trim() || DEFAULT_TTS_MODEL;
  const format = normalizeFormat(input.format);
  const mimeType = format === "mp3" ? "audio/mpeg" : format === "ogg" ? "audio/ogg" : "audio/wav";
  const estDurationMs = Math.max(600, Math.min(7000, text.length * 55));
  const outputDir = getMiyaVoiceTempDir(projectDir);
  const outputPath = path29.join(outputDir, `tts-${Date.now()}.${format}`);
  const profileDir = path29.join(getMiyaRuntimeDir(projectDir), "profiles", "companion", "current");
  let tts;
  if (useMultimodalTestMode2(projectDir)) {
    tts = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      tts = await daemon.runSovitsTts({
        text,
        outputPath,
        profileDir,
        voice,
        format
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget2(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number")
            pending = String(plan.pending);
        } catch {}
        throw new Error(`model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`);
      }
      if (!isRuntimeNotReadyError2(error92))
        throw error92;
      tts = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const wavBase64 = toBase64FromFile2(tts.outputPath) ?? buildSilentWavBase64(estDurationMs);
  const media = ingestMedia(projectDir, {
    source: "multimodal.voice.output",
    kind: "audio",
    mimeType,
    fileName: `tts-${Date.now()}.${format}`,
    contentBase64: wavBase64,
    sizeBytes: Math.floor(wavBase64.length * 3 / 4),
    metadata: {
      status: tts.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      text,
      voice,
      model,
      format,
      tier: tts.tier,
      degraded: tts.degraded,
      engineMessage: tts.message,
      payloadCodec: "pcm_s16le",
      estimatedDurationMs: estDurationMs,
      runtimeError: tts.message.startsWith("python_runtime_not_ready:") ? tts.message : undefined,
      createdBy: "miya_voice_output"
    }
  });
  appendVoiceHistory(projectDir, {
    text,
    source: "talk",
    mediaID: media.id
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "audio",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `voice:${voice}`
    });
  }
  return {
    media,
    voice,
    model,
    format
  };
}
var DEFAULT_VOICE = "default", DEFAULT_TTS_MODEL = "local:gpt-sovits-v2pro";
var init_voice = __esm(() => {
  init_store4();
  init_daemon();
  init_store2();
  init_paths();
  init_settings();
  init_state2();
  init_workflow();
});

// src/multimodal/intent.ts
function extractFriend(text) {
  const bracket = text.match(/给\s*\[([^\]]+)\]/);
  if (bracket?.[1])
    return bracket[1].trim();
  const plain = text.match(/给\s*([^\s，。!?！？]+)/);
  if (plain?.[1])
    return plain[1].trim();
  return "";
}
function detectMultimodalIntent(text) {
  const normalized = text.trim();
  if (!normalized)
    return { type: "unknown" };
  if (/(发张自拍|来张自拍|自拍一下|自拍照)/.test(normalized)) {
    return {
      type: "selfie",
      prompt: "a natural selfie portrait, indoor soft light, realistic phone camera shot"
    };
  }
  if (/(用你的声音发一条语音给|发语音给|语音发给)/.test(normalized)) {
    const friend = extractFriend(normalized);
    return {
      type: "voice_to_friend",
      text: normalized,
      friend
    };
  }
  return { type: "unknown" };
}

// src/multimodal/index.ts
var init_multimodal = __esm(() => {
  init_image();
  init_vision();
  init_vision_regression();
  init_voice();
});

// src/resource-scheduler/store.ts
import * as fs30 from "node:fs";
import * as path30 from "node:path";
function schedulerDir(projectDir) {
  return path30.join(getMiyaRuntimeDir(projectDir), "resource-scheduler");
}
function snapshotPath(projectDir) {
  return path30.join(schedulerDir(projectDir), "state.json");
}
function eventsPath(projectDir) {
  return path30.join(schedulerDir(projectDir), "events.jsonl");
}
function ensureDir14(projectDir) {
  fs30.mkdirSync(schedulerDir(projectDir), { recursive: true });
}
function writeSchedulerSnapshot(projectDir, snapshot) {
  ensureDir14(projectDir);
  fs30.writeFileSync(snapshotPath(projectDir), `${JSON.stringify(snapshot, null, 2)}
`, "utf-8");
}
function appendSchedulerEvent(projectDir, event) {
  ensureDir14(projectDir);
  fs30.appendFileSync(eventsPath(projectDir), `${JSON.stringify(event)}
`, "utf-8");
}
var init_store5 = __esm(() => {
  init_workflow();
});

// src/resource-scheduler/vram.ts
function clampNonNegative(value) {
  if (!Number.isFinite(value) || value <= 0)
    return 0;
  return Math.floor(value);
}
function calculateVramBudget(input) {
  const availableMB = Math.max(0, clampNonNegative(input.snapshot.totalVramMB) - clampNonNegative(input.snapshot.safetyMarginMB) - clampNonNegative(input.snapshot.usedVramMB));
  const loaded = new Map(input.snapshot.loadedModels.map((model) => [model.modelID, clampNonNegative(model.vramMB)]));
  const keepLoaded = new Set;
  let modelsNeedLoadMB = 0;
  for (const model of input.models) {
    if (!model.required)
      continue;
    const need = clampNonNegative(model.vramMB);
    const loadedMB = loaded.get(model.modelID) ?? 0;
    if (loadedMB >= need) {
      keepLoaded.add(model.modelID);
      continue;
    }
    modelsNeedLoadMB += need;
  }
  const requiredMB = clampNonNegative(input.task.taskVramMB) + modelsNeedLoadMB;
  const overflowMB = Math.max(0, requiredMB - availableMB);
  const fit = overflowMB <= 0;
  const suggestedTaskVramMB = fit ? clampNonNegative(input.task.taskVramMB) : Math.max(256, clampNonNegative(input.task.taskVramMB) - overflowMB);
  const unloadFirst = input.snapshot.loadedModels.filter((model) => model.pins <= 0 && !keepLoaded.has(model.modelID)).sort((a, b) => Date.parse(a.lastUsedAt) - Date.parse(b.lastUsedAt)).map((model) => model.modelID);
  return {
    fit,
    availableMB,
    requiredMB,
    overflowMB,
    suggestedTaskVramMB,
    canUseReferenceOnly: suggestedTaskVramMB < 512,
    modelPlan: {
      keepLoaded: [...keepLoaded],
      unloadFirst
    }
  };
}
function decideModelSwapAction(input) {
  const current = (input.currentModelID ?? "").trim();
  const target = (input.targetModelID ?? "").trim();
  if (!target)
    return "reuse";
  if (current && current === target)
    return "reuse";
  if (input.budget.fit)
    return current ? "hot_load" : "reuse";
  if (input.budget.modelPlan.unloadFirst.length > 0)
    return "evict_then_load";
  return "degraded_reference";
}

// src/resource-scheduler/scheduler.ts
import { randomUUID as randomUUID15 } from "node:crypto";
function nowIso16() {
  return new Date().toISOString();
}
function toNumber(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0)
    return fallback;
  return Math.floor(parsed);
}
function toStringList(value) {
  if (!value)
    return [];
  return value.split(",").map((item) => item.trim()).filter(Boolean);
}

class ResourceScheduler {
  projectDir;
  totalVramMB;
  safetyMarginMB;
  maxConcurrentTasks;
  hotsetModelIDs = new Set;
  warmPool = new Map;
  warmPoolLimit;
  isolateTrainingLane;
  queue = [];
  active = new Map;
  loadedModels = new Map;
  currentModelByKind = new Map;
  usedVramMB = 0;
  draining = false;
  constructor(projectDir, options = {}) {
    this.projectDir = projectDir;
    this.totalVramMB = Math.min(8192, options.totalVramMB ?? toNumber(process.env.MIYA_RESOURCE_TOTAL_VRAM_MB, 8192));
    this.safetyMarginMB = options.safetyMarginMB ?? toNumber(process.env.MIYA_RESOURCE_SAFETY_MARGIN_MB, 768);
    this.maxConcurrentTasks = options.maxConcurrentTasks ?? toNumber(process.env.MIYA_RESOURCE_MAX_CONCURRENT, 2);
    this.warmPoolLimit = options.warmPoolLimit ?? toNumber(process.env.MIYA_RESOURCE_WARM_POOL_LIMIT, 8);
    this.isolateTrainingLane = options.isolateTrainingLane ?? process.env.MIYA_RESOURCE_ISOLATE_TRAINING_LANE !== "0";
    const hotset = new Set([
      ...Array.isArray(options.hotsetModelIDs) ? options.hotsetModelIDs : [],
      ...toStringList(process.env.MIYA_RESOURCE_HOTSET_MODELS)
    ]);
    for (const modelID of hotset) {
      if (modelID)
        this.hotsetModelIDs.add(modelID);
    }
    this.recordSnapshot();
  }
  async acquire(request) {
    const pendingID = `lease_${randomUUID15()}`;
    return new Promise((resolve, reject) => {
      const timeoutMs = typeof request.timeoutMs === "number" && request.timeoutMs > 0 ? request.timeoutMs : undefined;
      const timeoutAtMs = timeoutMs ? Date.now() + timeoutMs : undefined;
      const pending = {
        id: pendingID,
        request,
        createdAtMs: Date.now(),
        timeoutAtMs,
        resolve,
        reject
      };
      this.queue.push(pending);
      this.queue.sort((a, b) => {
        const priorityA = a.request.priority ?? 0;
        const priorityB = b.request.priority ?? 0;
        if (priorityA !== priorityB)
          return priorityB - priorityA;
        return a.createdAtMs - b.createdAtMs;
      });
      appendSchedulerEvent(this.projectDir, {
        at: nowIso16(),
        type: "queued",
        leaseID: pendingID,
        kind: request.kind,
        priority: request.priority ?? 0,
        requestedVramMB: request.vramMB ?? 0,
        modelID: request.modelID
      });
      this.recordSnapshot();
      this.scheduleDrain();
    });
  }
  async withLease(request, run) {
    const lease = await this.acquire(request);
    try {
      return await run();
    } finally {
      lease.release();
    }
  }
  snapshot() {
    return {
      timestamp: nowIso16(),
      totalVramMB: this.totalVramMB,
      safetyMarginMB: this.safetyMarginMB,
      usedVramMB: this.usedVramMB,
      activeTasks: this.active.size,
      queueDepth: this.queue.length,
      loadedModels: [...this.loadedModels.values()].sort((a, b) => b.lastUsedAtMs - a.lastUsedAtMs).map((model) => ({
        modelID: model.modelID,
        vramMB: model.vramMB,
        pins: model.pins,
        lastUsedAt: new Date(model.lastUsedAtMs).toISOString()
      })),
      hotsetModelIDs: [...this.hotsetModelIDs.values()],
      warmPoolModels: [...this.warmPool.values()].sort((a, b) => b.cachedAtMs - a.cachedAtMs).map((model) => ({
        modelID: model.modelID,
        cachedAt: new Date(model.cachedAtMs).toISOString()
      }))
    };
  }
  planVramBudget(request) {
    return calculateVramBudget({
      snapshot: this.snapshot(),
      task: {
        taskID: request.kind,
        taskVramMB: Math.max(0, Math.floor(request.vramMB ?? 0)),
        priority: request.priority
      },
      models: request.modelID ? [
        {
          modelID: request.modelID,
          vramMB: Math.max(0, Math.floor(request.modelVramMB ?? request.vramMB ?? 0)),
          required: true
        }
      ] : []
    });
  }
  scheduleDrain() {
    if (this.draining)
      return;
    this.draining = true;
    queueMicrotask(() => {
      this.draining = false;
      this.drainQueue();
    });
  }
  drainQueue() {
    let progressed = true;
    while (progressed) {
      progressed = false;
      this.removeExpiredPending();
      if (this.active.size >= this.maxConcurrentTasks)
        return;
      const pending = this.queue[0];
      if (!pending)
        return;
      if (!this.canGrant(pending.request))
        return;
      this.queue.shift();
      const grantedAt = nowIso16();
      const requestVramMB = Math.max(0, Math.floor(pending.request.vramMB ?? 0));
      const lease = {
        id: pending.id,
        kind: pending.request.kind,
        grantedAt,
        requestVramMB,
        modelID: pending.request.modelID
      };
      this.active.set(lease.id, lease);
      if (requestVramMB > 0)
        this.usedVramMB += requestVramMB;
      if (pending.request.modelID) {
        const modelVramMB = Math.max(0, Math.floor(pending.request.modelVramMB ?? requestVramMB));
        const swapAction = this.selectModelSwapAction(pending.request.kind, pending.request.modelID, pending.request);
        if (swapAction === "evict_then_load") {
          this.evictModelsIfNeeded(modelVramMB);
        }
        this.ensureModelLoaded(pending.request.modelID, modelVramMB);
        this.pinModel(pending.request.modelID);
        this.currentModelByKind.set(pending.request.kind, pending.request.modelID);
        appendSchedulerEvent(this.projectDir, {
          at: nowIso16(),
          type: "model_swap",
          kind: pending.request.kind,
          action: swapAction,
          modelID: pending.request.modelID,
          vramMB: modelVramMB
        });
      }
      appendSchedulerEvent(this.projectDir, {
        at: grantedAt,
        type: "granted",
        leaseID: lease.id,
        kind: lease.kind,
        requestedVramMB: requestVramMB,
        modelID: lease.modelID
      });
      this.recordSnapshot();
      pending.resolve({
        id: lease.id,
        kind: lease.kind,
        grantedAt,
        vramMB: requestVramMB,
        release: () => this.release(lease.id)
      });
      progressed = true;
    }
  }
  release(leaseID) {
    const lease = this.active.get(leaseID);
    if (!lease)
      return;
    this.active.delete(leaseID);
    if (lease.requestVramMB > 0) {
      this.usedVramMB = Math.max(0, this.usedVramMB - lease.requestVramMB);
    }
    if (lease.modelID) {
      this.unpinModel(lease.modelID);
      this.touchModel(lease.modelID);
    }
    appendSchedulerEvent(this.projectDir, {
      at: nowIso16(),
      type: "released",
      leaseID,
      kind: lease.kind,
      releasedVramMB: lease.requestVramMB,
      modelID: lease.modelID
    });
    this.recordSnapshot();
    this.scheduleDrain();
  }
  canGrant(request) {
    if (this.active.size >= this.maxConcurrentTasks)
      return false;
    if (this.isolateTrainingLane) {
      if (this.isTrainingKind(request.kind) && this.hasActiveInferenceTask())
        return false;
      if (!this.isTrainingKind(request.kind) && this.hasActiveTrainingTask())
        return false;
    }
    const neededVramMB = Math.max(0, Math.floor(request.vramMB ?? 0));
    if (neededVramMB === 0)
      return true;
    const modelVramMB = request.modelID ? Math.max(0, Math.floor(request.modelVramMB ?? request.vramMB ?? 0)) : 0;
    this.evictModelsIfNeeded(neededVramMB + modelVramMB);
    return this.availableVramMB() >= neededVramMB + modelVramMB;
  }
  selectModelSwapAction(kind, targetModelID, request) {
    const budget = this.planVramBudget(request);
    return decideModelSwapAction({
      currentModelID: this.currentModelByKind.get(kind),
      targetModelID,
      budget
    });
  }
  availableVramMB() {
    return Math.max(0, this.totalVramMB - this.safetyMarginMB - this.usedVramMB - this.loadedModelsVramMB());
  }
  loadedModelsVramMB() {
    let sum = 0;
    for (const model of this.loadedModels.values())
      sum += model.vramMB;
    return sum;
  }
  removeExpiredPending() {
    const now = Date.now();
    const keep = [];
    for (const pending of this.queue) {
      if (pending.timeoutAtMs && pending.timeoutAtMs <= now) {
        appendSchedulerEvent(this.projectDir, {
          at: nowIso16(),
          type: "timeout",
          leaseID: pending.id,
          kind: pending.request.kind
        });
        pending.reject(new Error("resource_acquire_timeout"));
      } else {
        keep.push(pending);
      }
    }
    if (keep.length !== this.queue.length) {
      this.queue.length = 0;
      this.queue.push(...keep);
      this.recordSnapshot();
    }
  }
  ensureModelLoaded(modelID, vramMB) {
    if (!modelID || vramMB <= 0)
      return;
    const existing = this.loadedModels.get(modelID);
    if (existing) {
      existing.lastUsedAtMs = Date.now();
      return;
    }
    const warmEntry = this.warmPool.get(modelID);
    if (warmEntry) {
      this.warmPool.delete(modelID);
      appendSchedulerEvent(this.projectDir, {
        at: nowIso16(),
        type: "model_restored_from_warm_pool",
        modelID
      });
    }
    this.evictModelsIfNeeded(vramMB);
    this.loadedModels.set(modelID, {
      modelID,
      vramMB,
      pins: 0,
      lastUsedAtMs: Date.now()
    });
    appendSchedulerEvent(this.projectDir, {
      at: nowIso16(),
      type: "model_loaded",
      modelID,
      vramMB
    });
  }
  evictModelsIfNeeded(requiredVramMB) {
    if (requiredVramMB <= 0)
      return;
    if (this.availableVramMB() >= requiredVramMB)
      return;
    const candidates = [...this.loadedModels.values()].filter((item) => item.pins <= 0).sort((a, b) => {
      const hotA = this.hotsetModelIDs.has(a.modelID) ? 1 : 0;
      const hotB = this.hotsetModelIDs.has(b.modelID) ? 1 : 0;
      if (hotA !== hotB)
        return hotA - hotB;
      return a.lastUsedAtMs - b.lastUsedAtMs;
    });
    for (const candidate of candidates) {
      this.loadedModels.delete(candidate.modelID);
      this.addToWarmPool(candidate.modelID);
      appendSchedulerEvent(this.projectDir, {
        at: nowIso16(),
        type: "model_unloaded",
        modelID: candidate.modelID,
        vramMB: candidate.vramMB,
        reason: "lru_evict"
      });
      if (this.availableVramMB() >= requiredVramMB)
        break;
    }
  }
  pinModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model)
      return;
    model.pins += 1;
    model.lastUsedAtMs = Date.now();
  }
  unpinModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model)
      return;
    model.pins = Math.max(0, model.pins - 1);
    model.lastUsedAtMs = Date.now();
  }
  touchModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model)
      return;
    model.lastUsedAtMs = Date.now();
  }
  isTrainingKind(kind) {
    return kind === "training.image" || kind === "training.voice";
  }
  hasActiveTrainingTask() {
    for (const lease of this.active.values()) {
      if (this.isTrainingKind(lease.kind))
        return true;
    }
    return false;
  }
  hasActiveInferenceTask() {
    for (const lease of this.active.values()) {
      if (!this.isTrainingKind(lease.kind))
        return true;
    }
    return false;
  }
  addToWarmPool(modelID) {
    if (!modelID || this.hotsetModelIDs.has(modelID) || this.warmPoolLimit <= 0)
      return;
    this.warmPool.set(modelID, {
      modelID,
      cachedAtMs: Date.now()
    });
    this.pruneWarmPool();
  }
  pruneWarmPool() {
    if (this.warmPool.size <= this.warmPoolLimit)
      return;
    const entries = [...this.warmPool.values()].sort((a, b) => a.cachedAtMs - b.cachedAtMs);
    while (this.warmPool.size > this.warmPoolLimit) {
      const candidate = entries.shift();
      if (!candidate)
        break;
      this.warmPool.delete(candidate.modelID);
    }
  }
  recordSnapshot() {
    writeSchedulerSnapshot(this.projectDir, this.snapshot());
  }
}
var init_scheduler = __esm(() => {
  init_store5();
});

// src/resource-scheduler/index.ts
function getResourceScheduler(projectDir, options) {
  const existing = schedulers.get(projectDir);
  if (existing)
    return existing;
  const created = new ResourceScheduler(projectDir, options);
  schedulers.set(projectDir, created);
  return created;
}
var schedulers;
var init_resource_scheduler = __esm(() => {
  init_scheduler();
  schedulers = new Map;
});

// src/sessions/index.ts
import * as fs31 from "node:fs";
import * as path31 from "node:path";
function nowIso17() {
  return new Date().toISOString();
}
function filePath10(projectDir) {
  return path31.join(getMiyaRuntimeDir(projectDir), "sessions.json");
}
function ensureDir15(file3) {
  fs31.mkdirSync(path31.dirname(file3), { recursive: true });
}
function readStore6(projectDir) {
  const file3 = filePath10(projectDir);
  if (!fs31.existsSync(file3)) {
    return { sessions: {} };
  }
  try {
    const parsed = JSON.parse(fs31.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const normalized = { sessions: {} };
    for (const [id, session] of Object.entries(parsed.sessions ?? {})) {
      normalized.sessions[id] = {
        ...session,
        groupId: decryptSensitiveValue(projectDir, String(session.groupId ?? "")),
        title: typeof session.title === "string" ? decryptSensitiveValue(projectDir, session.title) : session.title,
        routing: {
          ...session.routing ?? { opencodeSessionID: "main", agent: "1-task-manager" },
          opencodeSessionID: decryptSensitiveValue(projectDir, String(session.routing?.opencodeSessionID ?? "main"))
        },
        queue: Array.isArray(session.queue) ? session.queue.map((item) => ({
          ...item,
          text: decryptSensitiveValue(projectDir, String(item.text ?? "")),
          source: decryptSensitiveValue(projectDir, String(item.source ?? ""))
        })) : []
      };
    }
    return normalized;
  } catch {
    return { sessions: {} };
  }
}
function writeStore6(projectDir, store) {
  const file3 = filePath10(projectDir);
  ensureDir15(file3);
  const encrypted = { sessions: {} };
  for (const [id, session] of Object.entries(store.sessions)) {
    encrypted.sessions[id] = {
      ...session,
      groupId: encryptSensitiveValue(projectDir, session.groupId),
      title: session.title ? encryptSensitiveValue(projectDir, session.title) : session.title,
      routing: {
        ...session.routing,
        opencodeSessionID: encryptSensitiveValue(projectDir, session.routing.opencodeSessionID)
      },
      queue: session.queue.map((item) => ({
        ...item,
        text: encryptSensitiveValue(projectDir, item.text),
        source: encryptSensitiveValue(projectDir, item.source)
      }))
    };
  }
  fs31.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function sanitizeSession(value) {
  return {
    ...value,
    policy: {
      activation: value.policy?.activation ?? DEFAULT_POLICY.activation,
      reply: value.policy?.reply ?? DEFAULT_POLICY.reply,
      queueStrategy: value.policy?.queueStrategy ?? DEFAULT_POLICY.queueStrategy
    },
    routing: {
      opencodeSessionID: value.routing?.opencodeSessionID ?? "main",
      agent: value.routing?.agent ?? "1-task-manager"
    },
    queue: Array.isArray(value.queue) ? value.queue : []
  };
}
function listSessions(projectDir) {
  const store = readStore6(projectDir);
  return Object.values(store.sessions).map(sanitizeSession).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function getSession(projectDir, sessionID) {
  const store = readStore6(projectDir);
  const session = store.sessions[sessionID];
  return session ? sanitizeSession(session) : null;
}
function upsertSession(projectDir, input) {
  const store = readStore6(projectDir);
  const existing = store.sessions[input.id];
  const createdAt = existing?.createdAt ?? nowIso17();
  const session = sanitizeSession({
    id: input.id,
    kind: input.kind ?? existing?.kind ?? "channel",
    groupId: input.groupId ?? existing?.groupId ?? input.id,
    title: input.title ?? existing?.title,
    policy: existing?.policy ?? DEFAULT_POLICY,
    routing: {
      opencodeSessionID: input.routingSessionID ?? existing?.routing?.opencodeSessionID ?? "main",
      agent: input.agent ?? existing?.routing?.agent ?? "1-task-manager"
    },
    queue: existing?.queue ?? [],
    createdAt,
    updatedAt: nowIso17()
  });
  store.sessions[input.id] = session;
  writeStore6(projectDir, store);
  return session;
}
function setSessionPolicy(projectDir, sessionID, patch) {
  const store = readStore6(projectDir);
  const existing = store.sessions[sessionID];
  if (!existing)
    return null;
  const next = sanitizeSession({
    ...existing,
    policy: {
      ...existing.policy,
      ...patch
    },
    updatedAt: nowIso17()
  });
  store.sessions[sessionID] = next;
  writeStore6(projectDir, store);
  return next;
}
function enqueueSessionMessage(projectDir, sessionID, input) {
  const store = readStore6(projectDir);
  const existing = sanitizeSession(store.sessions[sessionID] ?? upsertSession(projectDir, {
    id: sessionID
  }));
  const message = {
    id: `queue_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    text: input.text,
    source: input.source,
    createdAt: nowIso17()
  };
  const nextQueue = [...existing.queue, message];
  const next = {
    ...existing,
    queue: nextQueue,
    updatedAt: nowIso17()
  };
  store.sessions[sessionID] = next;
  writeStore6(projectDir, store);
  return message;
}
function dequeueSessionMessage(projectDir, sessionID) {
  const store = readStore6(projectDir);
  const existing = store.sessions[sessionID];
  if (!existing || existing.queue.length === 0) {
    return null;
  }
  const [first, ...rest] = existing.queue;
  store.sessions[sessionID] = {
    ...existing,
    queue: rest,
    updatedAt: nowIso17()
  };
  writeStore6(projectDir, store);
  return first;
}
var DEFAULT_POLICY;
var init_sessions = __esm(() => {
  init_workflow();
  init_system_keyring();
  DEFAULT_POLICY = {
    activation: "active",
    reply: "auto",
    queueStrategy: "fifo"
  };
});

// src/router/classifier.ts
function classifyIntent(text) {
  const lower = text.toLowerCase();
  if (/(报错|修复|bug|错误|test fail|failing|compile)/i.test(lower)) {
    return "code_fix";
  }
  if (/(查找|定位|where|find|grep|search)/i.test(lower)) {
    return "code_search";
  }
  if (/(文档|api|docs|reference|手册)/i.test(lower)) {
    return "docs_research";
  }
  if (/(架构|设计方案|tradeoff|risk|风控)/i.test(lower)) {
    return "architecture";
  }
  if (/(ui|样式|页面|交互|设计|视觉)/i.test(lower)) {
    return "ui_design";
  }
  return "general";
}
function recommendedAgent(intent) {
  if (intent === "code_fix")
    return "5-code-fixer";
  if (intent === "code_search")
    return "2-code-search";
  if (intent === "docs_research")
    return "3-docs-helper";
  if (intent === "architecture")
    return "4-architecture-advisor";
  if (intent === "ui_design")
    return "6-ui-designer";
  return "1-task-manager";
}

// src/router/fallback.ts
function resolveFallbackAgent(intent, availableAgents) {
  const primary = recommendedAgent(intent);
  if (availableAgents.includes(primary))
    return primary;
  if (availableAgents.includes("1-task-manager"))
    return "1-task-manager";
  return availableAgents[0] ?? primary;
}
function resolveAgentWithFeedback(intent, availableAgents, ranked) {
  const base = resolveFallbackAgent(intent, availableAgents);
  if (ranked.length === 0)
    return base;
  const preferred = ranked.find((item) => availableAgents.includes(item.agent) && item.score >= 0.55);
  return preferred?.agent ?? base;
}
var init_fallback = () => {};

// src/router/learner.ts
import * as fs32 from "node:fs";
import * as path32 from "node:path";
function filePath11(projectDir) {
  return path32.join(getMiyaRuntimeDir(projectDir), "router-history.json");
}
function readStore7(projectDir) {
  const file3 = filePath11(projectDir);
  if (!fs32.existsSync(file3))
    return { records: [] };
  try {
    const parsed = JSON.parse(fs32.readFileSync(file3, "utf-8"));
    return { records: Array.isArray(parsed.records) ? parsed.records : [] };
  } catch {
    return { records: [] };
  }
}
function rankAgentsByFeedback(projectDir, intent, availableAgents) {
  const records = readStore7(projectDir).records.filter((item) => item.intent === intent).slice(0, 300);
  const scored = availableAgents.map((agent) => {
    const matched = records.filter((item) => item.suggestedAgent === agent);
    const accepted = matched.filter((item) => item.accepted).length;
    const samples = matched.length;
    const acceptRate = samples > 0 ? accepted / samples : 0;
    const score = Number((acceptRate * 0.8 + Math.min(0.2, samples / 50)).toFixed(4));
    return {
      agent,
      score,
      samples,
      acceptRate: Number(acceptRate.toFixed(4))
    };
  });
  return scored.sort((a, b) => b.score - a.score);
}
var init_learner = __esm(() => {
  init_workflow();
});

// src/router/runtime.ts
import * as fs33 from "node:fs";
import * as path33 from "node:path";
function getComplexityProfile(complexity) {
  if (complexity === "low") {
    return { maxAgents: 1, contextStrategy: "minimal", enableEarlyExit: true };
  }
  if (complexity === "medium") {
    return { maxAgents: 3, contextStrategy: "summary", enableEarlyExit: true };
  }
  return { maxAgents: 7, contextStrategy: "full", enableEarlyExit: false };
}
function primaryAgentForIntent(intent) {
  if (intent === "code_fix")
    return "5-code-fixer";
  if (intent === "code_search")
    return "2-code-search";
  if (intent === "docs_research")
    return "3-docs-helper";
  if (intent === "architecture")
    return "4-architecture-advisor";
  if (intent === "ui_design")
    return "6-ui-designer";
  return "1-task-manager";
}
function buildAgentPlan(input) {
  const profile = getComplexityProfile(input.complexity);
  const include = (target, list) => {
    if (!target || !input.availableAgents.includes(target) || list.includes(target))
      return list;
    return [...list, target];
  };
  if (input.pinnedAgent) {
    return {
      plannedAgents: [input.selectedAgent],
      maxAgents: 1,
      contextStrategy: "minimal",
      requiresMultipleSteps: false,
      enableEarlyExit: true
    };
  }
  if (input.complexity === "low") {
    return {
      plannedAgents: [input.selectedAgent],
      maxAgents: profile.maxAgents,
      contextStrategy: profile.contextStrategy,
      requiresMultipleSteps: false,
      enableEarlyExit: profile.enableEarlyExit
    };
  }
  if (input.complexity === "medium") {
    let plan = [];
    plan = include("1-task-manager", plan);
    plan = include(input.selectedAgent, plan);
    plan = include(primaryAgentForIntent(input.intent), plan);
    plan = include("5-code-fixer", plan);
    return {
      plannedAgents: plan.slice(0, profile.maxAgents),
      maxAgents: profile.maxAgents,
      contextStrategy: profile.contextStrategy,
      requiresMultipleSteps: true,
      enableEarlyExit: profile.enableEarlyExit
    };
  }
  const highPlan = [
    "1-task-manager",
    input.selectedAgent,
    primaryAgentForIntent(input.intent),
    ...ORCHESTRATION_ORDER
  ].filter((agent, index, arr) => arr.indexOf(agent) === index).filter((agent) => input.availableAgents.includes(agent)).slice(0, profile.maxAgents);
  return {
    plannedAgents: highPlan,
    maxAgents: profile.maxAgents,
    contextStrategy: profile.contextStrategy,
    requiresMultipleSteps: true,
    enableEarlyExit: profile.enableEarlyExit
  };
}
function modeFile(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "router-mode.json");
}
function costFile(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "router-cost.jsonl");
}
function sessionStateFile(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "router-session-state.json");
}
function ensureDir16(projectDir) {
  fs33.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp3(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function nowIso18() {
  return new Date().toISOString();
}
function parseMode(raw) {
  const input = raw && typeof raw === "object" ? raw : {};
  const forcedStage = input.forcedStage === "low" || input.forcedStage === "medium" || input.forcedStage === "high" ? input.forcedStage : undefined;
  const stageTokenMultiplierInput = input.stageTokenMultiplier && typeof input.stageTokenMultiplier === "object" ? input.stageTokenMultiplier : {};
  const stageCostInput = input.stageCostUsdPer1k && typeof input.stageCostUsdPer1k === "object" ? input.stageCostUsdPer1k : {};
  return {
    ecoMode: input.ecoMode !== false,
    forcedStage,
    stageTokenMultiplier: {
      low: clamp3(Number(stageTokenMultiplierInput.low ?? DEFAULT_MODE.stageTokenMultiplier.low), 0.2, 2.5),
      medium: clamp3(Number(stageTokenMultiplierInput.medium ?? DEFAULT_MODE.stageTokenMultiplier.medium), 0.3, 3),
      high: clamp3(Number(stageTokenMultiplierInput.high ?? DEFAULT_MODE.stageTokenMultiplier.high), 0.4, 4)
    },
    stageCostUsdPer1k: {
      low: clamp3(Number(stageCostInput.low ?? DEFAULT_MODE.stageCostUsdPer1k.low), 0.0001, 0.1),
      medium: clamp3(Number(stageCostInput.medium ?? DEFAULT_MODE.stageCostUsdPer1k.medium), 0.0001, 0.2),
      high: clamp3(Number(stageCostInput.high ?? DEFAULT_MODE.stageCostUsdPer1k.high), 0.0001, 0.3)
    }
  };
}
function readRouterModeConfig(projectDir) {
  const file3 = modeFile(projectDir);
  if (!fs33.existsSync(file3))
    return DEFAULT_MODE;
  try {
    const parsed = JSON.parse(fs33.readFileSync(file3, "utf-8"));
    return parseMode(parsed);
  } catch {
    return DEFAULT_MODE;
  }
}
function readSessionStore(projectDir) {
  const file3 = sessionStateFile(projectDir);
  if (!fs33.existsSync(file3))
    return { sessions: {} };
  try {
    const parsed = JSON.parse(fs33.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions)
      return { sessions: {} };
    return {
      sessions: Object.fromEntries(Object.entries(parsed.sessions).map(([sessionID, state]) => [
        sessionID,
        {
          sessionID,
          consecutiveFailures: clamp3(Number(state?.consecutiveFailures ?? 0), 0, 10),
          lastStage: state?.lastStage === "low" || state?.lastStage === "medium" || state?.lastStage === "high" ? state.lastStage : "medium",
          updatedAt: String(state?.updatedAt ?? nowIso18())
        }
      ]))
    };
  } catch {
    return { sessions: {} };
  }
}
function writeSessionStore(projectDir, store) {
  ensureDir16(projectDir);
  fs33.writeFileSync(sessionStateFile(projectDir), `${JSON.stringify(store, null, 2)}
`, "utf-8");
}
function getSessionState2(projectDir, sessionID) {
  const store = readSessionStore(projectDir);
  return store.sessions[sessionID] ?? {
    sessionID,
    consecutiveFailures: 0,
    lastStage: "medium",
    updatedAt: nowIso18()
  };
}
function stageLevel(stage) {
  if (stage === "low")
    return 0;
  if (stage === "medium")
    return 1;
  return 2;
}
function levelToStage(level) {
  if (level <= 0)
    return "low";
  if (level === 1)
    return "medium";
  return "high";
}
function readCostRows(projectDir, limit = 500) {
  const file3 = costFile(projectDir);
  if (!fs33.existsSync(file3))
    return [];
  const rows = fs33.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => Boolean(item));
  return rows.slice(-Math.max(1, limit));
}
function appendCostRow(projectDir, row) {
  ensureDir16(projectDir);
  fs33.appendFileSync(costFile(projectDir), `${JSON.stringify(row)}
`, "utf-8");
}
function analyzeRouteComplexity(text) {
  const normalized = String(text ?? "").trim();
  const reasons = [];
  let score = 0;
  if (normalized.length > 1600) {
    score += 2;
    reasons.push("long_request");
  } else if (normalized.length > 700) {
    score += 1;
    reasons.push("medium_length");
  }
  if (/```[\s\S]*```/.test(normalized)) {
    score += 2;
    reasons.push("contains_code_block");
  }
  if (/(架构|tradeoff|风险|risk|migration|重构|performance|性能|security|安全)/i.test(normalized)) {
    score += 1;
    reasons.push("architecture_or_risk");
  }
  if (/(并行|多步骤|pipeline|workflow|验证|verify|修复|fix|loop)/i.test(normalized)) {
    score += 1;
    reasons.push("multi_step_execution");
  }
  if (/(今天|马上|紧急|critical|p0|severe)/i.test(normalized)) {
    score += 1;
    reasons.push("urgency_signal");
  }
  const complexity = score >= 4 ? "high" : score >= 2 ? "medium" : "low";
  return { complexity, score, reasons };
}
function stageFromComplexity(complexity) {
  if (complexity === "high")
    return "high";
  if (complexity === "medium")
    return "medium";
  return "low";
}
function compressTextByStage(text, stage) {
  const normalized = String(text ?? "").trim();
  if (!normalized)
    return { text: "", compressed: false };
  if (stage === "high")
    return { text: normalized, compressed: false };
  if (stage === "medium" && normalized.length <= 4200)
    return { text: normalized, compressed: false };
  if (stage === "low" && normalized.length <= 1600)
    return { text: normalized, compressed: false };
  if (stage === "medium") {
    const head2 = normalized.slice(0, 2600);
    const tail2 = normalized.slice(-1200);
    return {
      text: `${head2}

[MIYA_ROUTER_COMPRESSION stage=medium]
...
${tail2}`,
      compressed: true
    };
  }
  const head = normalized.slice(0, 900);
  const bulletLines = normalized.split(/\r?\n/).map((line) => line.trim()).filter((line) => /^[-*0-9.]/.test(line)).slice(0, 8).join(`
`);
  const tail = normalized.slice(-480);
  const merged = [head, bulletLines, tail].filter(Boolean).join(`
`);
  return {
    text: `${merged}

[MIYA_ROUTER_COMPRESSION stage=low reason=eco_mode]`,
    compressed: true
  };
}
function estimateInputTokens(text) {
  const length = String(text ?? "").length;
  return Math.max(20, Math.ceil(length / 3.6));
}
function estimateOutputTokens(inputTokens, stage) {
  if (stage === "low")
    return Math.max(60, Math.ceil(inputTokens * 0.35));
  if (stage === "medium")
    return Math.max(100, Math.ceil(inputTokens * 0.55));
  return Math.max(140, Math.ceil(inputTokens * 0.9));
}
function buildRouteExecutionPlan(input) {
  const intent = classifyIntent(input.text);
  const complexity = analyzeRouteComplexity(input.text);
  const mode = readRouterModeConfig(input.projectDir);
  const session = getSessionState2(input.projectDir, input.sessionID);
  const ranked = rankAgentsByFeedback(input.projectDir, intent, input.availableAgents);
  const preferredAgent = resolveFallbackAgent(intent, input.availableAgents);
  const fallbackAgent = resolveFallbackAgent(intent, input.availableAgents);
  const selectedByFeedback = resolveAgentWithFeedback(intent, input.availableAgents, ranked);
  const pinnedAgent = input.pinnedAgent?.trim();
  const selectedAgent = pinnedAgent && input.availableAgents.includes(pinnedAgent) ? pinnedAgent : selectedByFeedback;
  const feedbackScore = ranked.find((item) => item.agent === selectedAgent)?.score ?? 0;
  const feedbackSamples = ranked.find((item) => item.agent === selectedAgent)?.samples ?? 0;
  let stage = stageFromComplexity(complexity.complexity);
  const reasons = [...complexity.reasons];
  if (mode.forcedStage) {
    stage = mode.forcedStage;
    reasons.push("forced_stage");
  } else {
    if (mode.ecoMode) {
      stage = levelToStage(stageLevel(stage) - 1);
      reasons.push("eco_mode_downshift");
    }
    if (session.consecutiveFailures >= 1) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_1");
    }
    if (session.consecutiveFailures >= 2) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_2");
    }
  }
  const agentPlan = buildAgentPlan({
    complexity: complexity.complexity,
    intent,
    selectedAgent,
    availableAgents: input.availableAgents,
    pinnedAgent: pinnedAgent && input.availableAgents.includes(pinnedAgent) ? pinnedAgent : undefined
  });
  if (agentPlan.plannedAgents.length > 1) {
    reasons.push("multi_agent_plan");
  }
  if (pinnedAgent && input.availableAgents.includes(pinnedAgent)) {
    reasons.push("pinned_agent_lock");
  }
  return {
    intent,
    complexity: complexity.complexity,
    complexityScore: complexity.score,
    stage,
    agent: selectedAgent,
    plannedAgents: agentPlan.plannedAgents,
    maxAgents: agentPlan.maxAgents,
    contextStrategy: agentPlan.contextStrategy,
    requiresMultipleSteps: agentPlan.requiresMultipleSteps,
    enableEarlyExit: agentPlan.enableEarlyExit,
    preferredAgent,
    fallbackAgent,
    feedbackScore,
    feedbackSamples,
    ecoMode: mode.ecoMode,
    reasons
  };
}
function prepareRoutePayload(projectDir, input) {
  const mode = readRouterModeConfig(projectDir);
  const compressed = compressTextByStage(input.text, input.stage);
  const inputTokens = estimateInputTokens(compressed.text);
  const outputTokensEstimate = estimateOutputTokens(inputTokens, input.stage);
  const totalTokensEstimate = Math.ceil((inputTokens + outputTokensEstimate) * mode.stageTokenMultiplier[input.stage]);
  const baselineHighTokensEstimate = Math.ceil((inputTokens + estimateOutputTokens(inputTokens, "high")) * mode.stageTokenMultiplier.high);
  const costUsdEstimate = Number((totalTokensEstimate / 1000 * mode.stageCostUsdPer1k[input.stage]).toFixed(6));
  return {
    text: compressed.text,
    compressed: compressed.compressed,
    inputTokens,
    outputTokensEstimate,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    costUsdEstimate
  };
}
function recordRouteExecutionOutcome(input) {
  const row = {
    at: nowIso18(),
    sessionID: input.sessionID,
    intent: input.intent,
    complexity: input.complexity,
    stage: input.stage,
    agent: input.agent,
    success: input.success,
    inputTokens: input.inputTokens,
    outputTokensEstimate: input.outputTokensEstimate,
    totalTokensEstimate: input.totalTokensEstimate,
    baselineHighTokensEstimate: input.baselineHighTokensEstimate,
    costUsdEstimate: input.costUsdEstimate
  };
  appendCostRow(input.projectDir, row);
  const store = readSessionStore(input.projectDir);
  const current = store.sessions[input.sessionID] ?? {
    sessionID: input.sessionID,
    consecutiveFailures: 0,
    lastStage: input.stage,
    updatedAt: nowIso18()
  };
  const next = {
    sessionID: input.sessionID,
    consecutiveFailures: input.success ? 0 : clamp3(current.consecutiveFailures + 1, 0, 10),
    lastStage: input.stage,
    updatedAt: nowIso18()
  };
  store.sessions[input.sessionID] = next;
  writeSessionStore(input.projectDir, store);
  return row;
}
function getRouteCostSummary(projectDir, limit = 300) {
  const rows = readCostRows(projectDir, limit);
  const byStage = {
    low: { records: 0, tokens: 0, costUsd: 0 },
    medium: { records: 0, tokens: 0, costUsd: 0 },
    high: { records: 0, tokens: 0, costUsd: 0 }
  };
  let totalTokensEstimate = 0;
  let baselineHighTokensEstimate = 0;
  let totalCostUsdEstimate = 0;
  for (const row of rows) {
    byStage[row.stage].records += 1;
    byStage[row.stage].tokens += row.totalTokensEstimate;
    byStage[row.stage].costUsd += row.costUsdEstimate;
    totalTokensEstimate += row.totalTokensEstimate;
    baselineHighTokensEstimate += row.baselineHighTokensEstimate;
    totalCostUsdEstimate += row.costUsdEstimate;
  }
  const savingsTokensEstimate = Math.max(0, baselineHighTokensEstimate - totalTokensEstimate);
  const savingsPercentEstimate = baselineHighTokensEstimate > 0 ? Number((savingsTokensEstimate / baselineHighTokensEstimate * 100).toFixed(2)) : 0;
  return {
    totalRecords: rows.length,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    savingsTokensEstimate,
    savingsPercentEstimate,
    totalCostUsdEstimate: Number(totalCostUsdEstimate.toFixed(6)),
    byStage: {
      low: {
        ...byStage.low,
        costUsd: Number(byStage.low.costUsd.toFixed(6))
      },
      medium: {
        ...byStage.medium,
        costUsd: Number(byStage.medium.costUsd.toFixed(6))
      },
      high: {
        ...byStage.high,
        costUsd: Number(byStage.high.costUsd.toFixed(6))
      }
    }
  };
}
function listRouteCostRecords(projectDir, limit = 40) {
  return readCostRows(projectDir, limit);
}
var DEFAULT_MODE, ORCHESTRATION_ORDER;
var init_runtime = __esm(() => {
  init_workflow();
  init_fallback();
  init_learner();
  DEFAULT_MODE = {
    ecoMode: true,
    stageTokenMultiplier: {
      low: 0.62,
      medium: 1,
      high: 1.45
    },
    stageCostUsdPer1k: {
      low: 0.0009,
      medium: 0.0018,
      high: 0.0032
    }
  };
  ORCHESTRATION_ORDER = [
    "1-task-manager",
    "2-code-search",
    "3-docs-helper",
    "4-architecture-advisor",
    "5-code-fixer",
    "6-ui-designer",
    "7-code-simplicity-reviewer"
  ];
});

// src/router/index.ts
var init_router2 = __esm(() => {
  init_fallback();
  init_learner();
  init_runtime();
});

// src/skills/frontmatter.ts
function normalizeScalar(value) {
  const trimmed = value.trim();
  if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
    return trimmed.slice(1, -1).trim();
  }
  return trimmed;
}
function normalizeList(value) {
  const trimmed = value.trim();
  if (!trimmed)
    return [];
  const body = trimmed.startsWith("[") && trimmed.endsWith("]") ? trimmed.slice(1, -1) : trimmed;
  return body.split(",").map((item) => normalizeScalar(item)).filter(Boolean);
}
function parseSkillFrontmatter(markdown) {
  const trimmed = markdown.trimStart();
  if (!trimmed.startsWith("---")) {
    return {};
  }
  const lines = trimmed.split(/\r?\n/);
  if (lines.length < 3 || lines[0].trim() !== "---") {
    return {};
  }
  const endIndex = lines.findIndex((line, index) => index > 0 && line.trim() === "---");
  if (endIndex === -1) {
    return {};
  }
  const result = {};
  let activeListKey;
  for (const rawLine of lines.slice(1, endIndex)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#"))
      continue;
    if (activeListKey && line.startsWith("- ")) {
      const value2 = normalizeScalar(line.slice(2));
      if (value2) {
        const existing = result[activeListKey] ?? [];
        result[activeListKey] = [...existing, value2];
      }
      continue;
    }
    activeListKey = undefined;
    const colon = line.indexOf(":");
    if (colon <= 0)
      continue;
    const key = line.slice(0, colon).trim();
    const value = line.slice(colon + 1).trim();
    if (key === "name")
      result.name = value;
    else if (key === "version")
      result.version = value;
    else if (key === "description")
      result.description = value;
    else if (LIST_KEYS.has(key)) {
      const listKey = key;
      const parsed = normalizeList(value);
      if (parsed.length > 0) {
        result[listKey] = parsed;
      } else {
        result[listKey] = [];
        activeListKey = listKey;
      }
    }
  }
  return result;
}
var LIST_KEYS;
var init_frontmatter = __esm(() => {
  LIST_KEYS = new Set(["bins", "env", "platforms", "permissions"]);
});

// src/skills/gating.ts
import { spawnSync as spawnSync3 } from "node:child_process";
function hasBinary(bin) {
  const checker = process.platform === "win32" ? "where" : "which";
  const result = spawnSync3(checker, [bin], { stdio: "ignore" });
  return result.status === 0;
}
function evaluateSkillGate(frontmatter) {
  const reasons = [];
  if (Array.isArray(frontmatter.platforms) && frontmatter.platforms.length > 0) {
    if (!frontmatter.platforms.includes(process.platform)) {
      reasons.push(`platform_not_supported:${process.platform}`);
    }
  }
  for (const envName of frontmatter.env ?? []) {
    if (!process.env[envName]) {
      reasons.push(`missing_env:${envName}`);
    }
  }
  for (const bin of frontmatter.bins ?? []) {
    if (!hasBinary(bin)) {
      reasons.push(`missing_bin:${bin}`);
    }
  }
  return {
    loadable: reasons.length === 0,
    reasons
  };
}
var init_gating = () => {};

// src/skills/loader.ts
import * as fs34 from "node:fs";
import * as os2 from "node:os";
import * as path34 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";
function isSkillDir(dir) {
  const skillFile = path34.join(dir, "SKILL.md");
  return fs34.existsSync(skillFile);
}
function listSkillDirs(rootDir) {
  if (!fs34.existsSync(rootDir))
    return [];
  const entries = fs34.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path34.join(rootDir, entry2.name));
  return entries.filter(isSkillDir);
}
function builtinSkillRoots(projectDir) {
  const roots = new Set;
  const localBuiltinRoot = path34.dirname(fileURLToPath3(import.meta.url));
  roots.add(path34.join(projectDir, "miya-src", "src", "skills"));
  roots.add(localBuiltinRoot);
  return [...roots];
}
function enforcePermissionMetadataGate(source, frontmatter, gate) {
  if (source === "builtin")
    return gate;
  if ((frontmatter.permissions?.length ?? 0) > 0)
    return gate;
  const reasons = [...gate.reasons, "missing_permission_metadata"];
  return {
    loadable: false,
    reasons: [...new Set(reasons)]
  };
}
function discoverSkills(projectDir, extraDirs = []) {
  const workspaceRoot = path34.join(projectDir, "skills");
  const globalRoot = path34.join(os2.homedir(), ".config", "opencode", "miya", "skills");
  const scopedDirs = [
    { source: "workspace", dirs: listSkillDirs(workspaceRoot) },
    { source: "global", dirs: listSkillDirs(globalRoot) },
    {
      source: "builtin",
      dirs: builtinSkillRoots(projectDir).flatMap((root) => listSkillDirs(root))
    },
    {
      source: "extra",
      dirs: extraDirs.flatMap((root) => listSkillDirs(path34.resolve(projectDir, root)))
    }
  ];
  const precedence = {
    workspace: 4,
    global: 3,
    extra: 2,
    builtin: 1
  };
  const byName = new Map;
  for (const scope of scopedDirs) {
    for (const dir of scope.dirs) {
      const skillFile = path34.join(dir, "SKILL.md");
      let content = "";
      try {
        content = fs34.readFileSync(skillFile, "utf-8");
      } catch {
        continue;
      }
      const frontmatter = parseSkillFrontmatter(content);
      const name = frontmatter.name ?? path34.basename(dir);
      const gate = enforcePermissionMetadataGate(scope.source, frontmatter, evaluateSkillGate(frontmatter));
      const descriptor = {
        id: name,
        name,
        source: scope.source,
        dir,
        skillFile,
        frontmatter,
        gate
      };
      const existing = byName.get(name);
      if (!existing || precedence[scope.source] >= precedence[existing.source]) {
        byName.set(name, descriptor);
      }
    }
  }
  return [...byName.values()].sort((a, b) => a.name.localeCompare(b.name));
}
var init_loader = __esm(() => {
  init_frontmatter();
  init_gating();
});

// src/skills/state.ts
import * as fs35 from "node:fs";
import * as path35 from "node:path";
function nowIso19() {
  return new Date().toISOString();
}
function filePath12(projectDir) {
  return path35.join(getMiyaRuntimeDir(projectDir), "skills.json");
}
function ensureDir17(file3) {
  fs35.mkdirSync(path35.dirname(file3), { recursive: true });
}
function readState(projectDir) {
  const file3 = filePath12(projectDir);
  if (!fs35.existsSync(file3)) {
    return { enabled: [], updatedAt: nowIso19() };
  }
  try {
    const parsed = JSON.parse(fs35.readFileSync(file3, "utf-8"));
    return {
      enabled: Array.isArray(parsed.enabled) ? parsed.enabled.map(String) : [],
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso19()
    };
  } catch {
    return { enabled: [], updatedAt: nowIso19() };
  }
}
function writeState3(projectDir, state) {
  const file3 = filePath12(projectDir);
  ensureDir17(file3);
  fs35.writeFileSync(file3, `${JSON.stringify(state, null, 2)}
`, "utf-8");
}
function listEnabledSkills(projectDir) {
  return readState(projectDir).enabled;
}
function setSkillEnabled(projectDir, skillID, enabled) {
  const state = readState(projectDir);
  const normalized = new Set(state.enabled);
  if (enabled)
    normalized.add(skillID);
  else
    normalized.delete(skillID);
  const next = {
    enabled: [...normalized].sort(),
    updatedAt: nowIso19()
  };
  writeState3(projectDir, next);
  return next.enabled;
}
var init_state4 = __esm(() => {
  init_workflow();
});

// src/skills/sync.ts
import { createHash as createHash12 } from "node:crypto";
import * as fs36 from "node:fs";
import * as os3 from "node:os";
import * as path36 from "node:path";
function nowIso20(options) {
  return options?.now?.() ?? new Date().toISOString();
}
function stateFile2(projectDir) {
  return path36.join(getMiyaRuntimeDir(projectDir), "ecosystem-bridge.json");
}
function readState2(projectDir) {
  const file3 = stateFile2(projectDir);
  if (!fs36.existsSync(file3))
    return { ...DEFAULT_STATE2 };
  try {
    const parsed = JSON.parse(fs36.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date(0).toISOString(),
      sourcePacks: parsed.sourcePacks && typeof parsed.sourcePacks === "object" ? parsed.sourcePacks : {},
      importPlans: parsed.importPlans && typeof parsed.importPlans === "object" ? parsed.importPlans : {},
      pinnedReleases: parsed.pinnedReleases && typeof parsed.pinnedReleases === "object" ? parsed.pinnedReleases : {}
    };
  } catch {
    return { ...DEFAULT_STATE2 };
  }
}
function writeState4(projectDir, state, options) {
  const file3 = stateFile2(projectDir);
  fs36.mkdirSync(path36.dirname(file3), { recursive: true });
  const next = {
    ...state,
    version: 1,
    updatedAt: nowIso20(options)
  };
  fs36.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
}
function runGit(args, cwd) {
  const proc = Bun.spawnSync(["git", ...args], {
    cwd,
    stdout: "pipe",
    stderr: "pipe"
  });
  return {
    exitCode: proc.exitCode,
    stdout: Buffer.from(proc.stdout).toString("utf-8").trim(),
    stderr: Buffer.from(proc.stderr).toString("utf-8").trim()
  };
}
function git(options, args, cwd) {
  return (options?.gitRunner ?? runGit)(args, cwd);
}
function normalizeText4(value) {
  const trimmed = value?.trim();
  if (!trimmed)
    return;
  return trimmed;
}
function defaultSourceRoots(projectDir) {
  return [
    path36.join(projectDir, "skills"),
    path36.join(os3.homedir(), ".config", "opencode", "miya", "skills")
  ];
}
function listSkillReposFromRoot(rootDir) {
  if (!fs36.existsSync(rootDir))
    return [];
  return fs36.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path36.join(rootDir, entry2.name)).filter((dir) => {
    return fs36.existsSync(path36.join(dir, "SKILL.md")) && fs36.existsSync(path36.join(dir, ".git"));
  });
}
function sanitizeIdSegment(input) {
  return input.replace(/[^a-zA-Z0-9_-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
}
function buildSourcePackID(repo, localDir) {
  const base = sanitizeIdSegment(path36.basename(localDir) || "source-pack") || "source-pack";
  const fingerprint = createHash12("sha256").update(`${repo ?? ""}|${path36.resolve(localDir)}`).digest("hex").slice(0, 12);
  return `${base}-${fingerprint}`;
}
function trustLevelForRepo(repo) {
  if (!repo)
    return "unknown";
  return TRUSTED_SOURCE_ALLOWLIST.some((rule) => rule.test(repo)) ? "allowlisted" : "untrusted";
}
function resolveSkillName(localDir) {
  const manifest = path36.join(localDir, "SKILL.md");
  if (!fs36.existsSync(manifest))
    return path36.basename(localDir);
  try {
    const raw = fs36.readFileSync(manifest, "utf-8");
    const heading = /^#\s+(.+)$/m.exec(raw)?.[1]?.trim();
    if (heading)
      return heading;
  } catch {}
  return path36.basename(localDir);
}
function readGitValue(options, cwd, args) {
  const result = git(options, args, cwd);
  if (result.exitCode !== 0)
    return;
  return normalizeText4(result.stdout);
}
function resolveUpstreamRef(localDir, branch, options) {
  const upstream = readGitValue(options, localDir, [
    "rev-parse",
    "--abbrev-ref",
    "--symbolic-full-name",
    "@{upstream}"
  ]);
  if (upstream)
    return upstream;
  if (branch && branch !== "HEAD")
    return `origin/${branch}`;
  return "origin/HEAD";
}
function resolveRevision(localDir, ref, options) {
  const resolved = readGitValue(options, localDir, ["rev-parse", `${ref}^{commit}`]);
  if (!resolved) {
    throw new Error(`source_pack_revision_unresolved:${ref}`);
  }
  return resolved;
}
function requireCleanWorkingTree(localDir, options) {
  const status = git(options, ["status", "--porcelain"], localDir);
  if (status.exitCode !== 0) {
    throw new Error(status.stderr || "source_pack_status_failed");
  }
  if (status.stdout.trim()) {
    throw new Error("source_pack_dirty_worktree");
  }
}
function discoverSourcePacks(projectDir, state, options) {
  const roots = options?.sourceRoots?.length ? options.sourceRoots : defaultSourceRoots(projectDir);
  const dirs = new Set;
  for (const root of roots) {
    for (const repoDir of listSkillReposFromRoot(root)) {
      dirs.add(path36.resolve(repoDir));
    }
  }
  const packs = [];
  for (const localDir of [...dirs]) {
    const headRevision = readGitValue(options, localDir, ["rev-parse", "HEAD"]);
    if (!headRevision)
      continue;
    const repo = readGitValue(options, localDir, ["config", "--get", "remote.origin.url"]);
    const branch = readGitValue(options, localDir, ["rev-parse", "--abbrev-ref", "HEAD"]) ?? "HEAD";
    const sourcePackID = buildSourcePackID(repo, localDir);
    const sourceState = state.sourcePacks[sourcePackID];
    const importPlan = state.importPlans[sourcePackID];
    const pinnedRelease = state.pinnedReleases[sourcePackID];
    packs.push({
      sourcePackID,
      name: path36.basename(localDir),
      skillName: resolveSkillName(localDir),
      repo,
      localDir,
      branch,
      headRevision,
      latestRevision: sourceState?.latestRevision,
      lastPulledAt: sourceState?.lastPulledAt,
      trustLevel: trustLevelForRepo(repo),
      importPlan,
      pinnedRelease
    });
  }
  return packs.sort((a, b) => {
    const byName = a.name.localeCompare(b.name);
    if (byName !== 0)
      return byName;
    return a.sourcePackID.localeCompare(b.sourcePackID);
  });
}
function requireSourcePack(projectDir, sourcePackID, options) {
  const state = readState2(projectDir);
  const packs = discoverSourcePacks(projectDir, state, options);
  const sourcePack = packs.find((item) => item.sourcePackID === sourcePackID);
  if (!sourcePack)
    throw new Error(`unknown_source_pack:${sourcePackID}`);
  return { state, sourcePack };
}
function ensureImportPlan(state, sourcePack, options) {
  const existing = state.importPlans[sourcePack.sourcePackID];
  if (existing) {
    const refreshed = {
      ...existing,
      sourcePackID: sourcePack.sourcePackID,
      localDir: sourcePack.localDir,
      updatedAt: nowIso20(options)
    };
    state.importPlans[sourcePack.sourcePackID] = refreshed;
    return refreshed;
  }
  const created = {
    sourcePackID: sourcePack.sourcePackID,
    localDir: sourcePack.localDir,
    importMode: "skills_only",
    permissionMode: "sandbox_read_only",
    createdAt: nowIso20(options),
    updatedAt: nowIso20(options)
  };
  state.importPlans[sourcePack.sourcePackID] = created;
  return created;
}
function updateSourcePackState(state, sourcePack, patch) {
  const current = state.sourcePacks[sourcePack.sourcePackID];
  state.sourcePacks[sourcePack.sourcePackID] = {
    sourcePackID: sourcePack.sourcePackID,
    repo: sourcePack.repo,
    localDir: sourcePack.localDir,
    latestRevision: current?.latestRevision,
    lastPulledAt: current?.lastPulledAt,
    lastError: current?.lastError,
    ...patch
  };
}
function listEcosystemBridge(projectDir, options) {
  const state = readState2(projectDir);
  const sourcePacks = discoverSourcePacks(projectDir, state, options);
  const bySkillName = new Map;
  for (const pack of sourcePacks) {
    const key = pack.skillName.toLowerCase();
    const list = bySkillName.get(key) ?? [];
    list.push(pack);
    bySkillName.set(key, list);
  }
  const conflicts = [];
  for (const [, list] of bySkillName.entries()) {
    if (list.length <= 1)
      continue;
    conflicts.push({
      type: "skill_name_collision",
      skillName: list[0].skillName,
      sourcePackIDs: list.map((item) => item.sourcePackID).sort()
    });
  }
  const importPlans = Object.values(state.importPlans).sort((a, b) => a.sourcePackID.localeCompare(b.sourcePackID));
  const pinnedReleases = Object.values(state.pinnedReleases).sort((a, b) => a.sourcePackID.localeCompare(b.sourcePackID));
  return {
    sourcePacks,
    importPlans,
    pinnedReleases,
    conflicts: conflicts.sort((a, b) => a.skillName.localeCompare(b.skillName))
  };
}
function pullSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pull = git(options, ["fetch", "--prune", "origin"], resolved.sourcePack.localDir);
  if (pull.exitCode !== 0) {
    updateSourcePackState(resolved.state, resolved.sourcePack, {
      lastError: pull.stderr || "source_pack_fetch_failed"
    });
    writeState4(projectDir, resolved.state, options);
    throw new Error(pull.stderr || "source_pack_fetch_failed");
  }
  const compareRef = resolveUpstreamRef(resolved.sourcePack.localDir, resolved.sourcePack.branch, options);
  const latestRevision = resolveRevision(resolved.sourcePack.localDir, compareRef, options);
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision,
    lastPulledAt: nowIso20(options),
    lastError: undefined
  });
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    latestRevision,
    compareRef,
    pulledAt: nowIso20(options)
  };
}
function diffSourcePack(projectDir, sourcePackID, options) {
  const { state, sourcePack } = requireSourcePack(projectDir, sourcePackID, options);
  const compareRef = state.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(sourcePack.localDir, sourcePack.branch, options);
  const compareRevision = resolveRevision(sourcePack.localDir, compareRef, options);
  const count = git(options, ["rev-list", "--left-right", "--count", `HEAD...${compareRevision}`], sourcePack.localDir);
  if (count.exitCode !== 0) {
    throw new Error(count.stderr || "source_pack_diff_failed");
  }
  const [aheadRaw, behindRaw] = count.stdout.split(/\s+/);
  const ahead = Number.parseInt(aheadRaw ?? "0", 10) || 0;
  const behind = Number.parseInt(behindRaw ?? "0", 10) || 0;
  const logResult = git(options, ["log", "--oneline", "--max-count", "20", `HEAD..${compareRevision}`], sourcePack.localDir);
  const pendingCommits = logResult.exitCode === 0 && logResult.stdout ? logResult.stdout.split(`
`).map((line) => line.trim()).filter(Boolean) : [];
  return {
    sourcePackID,
    localDir: sourcePack.localDir,
    headRevision: sourcePack.headRevision,
    compareRevision,
    compareRef,
    ahead,
    behind,
    pendingCommits,
    pinnedRelease: state.pinnedReleases[sourcePackID]
  };
}
function applySourcePack(projectDir, sourcePackID, input = {}, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const targetRef = normalizeText4(input.revision) ?? resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(resolved.sourcePack.localDir, resolved.sourcePack.branch, options);
  const targetRevision = resolveRevision(resolved.sourcePack.localDir, targetRef, options);
  const previousRevision = resolved.sourcePack.headRevision;
  if (previousRevision !== targetRevision) {
    const checkout = git(options, ["checkout", "--detach", targetRevision], resolved.sourcePack.localDir);
    if (checkout.exitCode !== 0) {
      throw new Error(checkout.stderr || "source_pack_apply_failed");
    }
  }
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision: resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? targetRevision,
    lastError: undefined
  });
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : resolved.state.pinnedReleases[sourcePackID]?.previousRevision,
    appliedAt: nowIso20(options)
  };
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    appliedRevision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : undefined,
    detachedHead: true
  };
}
function rollbackSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pinned = resolved.state.pinnedReleases[sourcePackID];
  if (!pinned?.previousRevision) {
    throw new Error(`source_pack_rollback_unavailable:${sourcePackID}`);
  }
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const previousRevision = resolved.sourcePack.headRevision;
  const rollbackRevision = resolveRevision(resolved.sourcePack.localDir, pinned.previousRevision, options);
  const checkout = git(options, ["checkout", "--detach", rollbackRevision], resolved.sourcePack.localDir);
  if (checkout.exitCode !== 0) {
    throw new Error(checkout.stderr || "source_pack_rollback_failed");
  }
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: rollbackRevision,
    previousRevision,
    appliedAt: nowIso20(options)
  };
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    rolledBackTo: rollbackRevision,
    previousRevision,
    detachedHead: true
  };
}
var DEFAULT_STATE2, TRUSTED_SOURCE_ALLOWLIST;
var init_sync = __esm(() => {
  init_workflow();
  DEFAULT_STATE2 = {
    version: 1,
    updatedAt: new Date(0).toISOString(),
    sourcePacks: {},
    importPlans: {},
    pinnedReleases: {}
  };
  TRUSTED_SOURCE_ALLOWLIST = [
    /^https?:\/\/github\.com\/(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i,
    /^git@github\.com:(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i
  ];
});

// src/mcp/context7.ts
var context7;
var init_context7 = __esm(() => {
  context7 = {
    type: "remote",
    url: "https://mcp.context7.com/mcp",
    headers: process.env.CONTEXT7_API_KEY ? { CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY } : undefined,
    oauth: false,
    capabilities: {
      sampling: false,
      mcpUi: false
    }
  };
});

// src/mcp/grep-app.ts
var grep_app;
var init_grep_app = __esm(() => {
  grep_app = {
    type: "remote",
    url: "https://mcp.grep.app",
    oauth: false,
    capabilities: {
      sampling: false,
      mcpUi: false
    }
  };
});

// src/mcp/websearch.ts
var websearch;
var init_websearch = __esm(() => {
  websearch = {
    type: "remote",
    url: "https://mcp.exa.ai/mcp?tools=web_search_exa",
    headers: process.env.EXA_API_KEY ? { "x-api-key": process.env.EXA_API_KEY } : undefined,
    oauth: false,
    capabilities: {
      sampling: false,
      mcpUi: false
    }
  };
});

// src/mcp/index.ts
function createBuiltinMcps(disabledMcps = []) {
  return Object.fromEntries(Object.entries(allBuiltinMcps).filter(([name]) => !disabledMcps.includes(name)));
}
function buildMcpServiceManifest(disabledMcps = []) {
  const builtins = createBuiltinMcps(disabledMcps);
  const mcps = Object.entries(builtins).map(([name, config3]) => {
    const caps = "capabilities" in config3 ? config3.capabilities : undefined;
    return {
      name,
      type: config3.type,
      sampling: Boolean(caps?.sampling),
      mcpUi: Boolean(caps?.mcpUi),
      serviceExpose: Boolean(caps?.serviceExpose)
    };
  });
  return {
    service: "miya-control-plane",
    version: 2,
    generatedAt: new Date().toISOString(),
    mcps,
    controlPlaneEndpoints: [
      "gateway.status.get",
      "gateway.backpressure.stats",
      "daemon.backpressure.stats",
      "provider.override.audit.list",
      "mcp.capabilities.list",
      "mcp.service.expose"
    ]
  };
}
var allBuiltinMcps;
var init_mcp = __esm(() => {
  init_context7();
  init_grep_app();
  init_websearch();
  allBuiltinMcps = {
    websearch,
    context7,
    grep_app
  };
});

// src/utils/logger.ts
import * as fs37 from "node:fs";
import * as os4 from "node:os";
import * as path37 from "node:path";
function sanitizeLogValue(value) {
  if (value instanceof Error) {
    return {
      name: value.name,
      message: value.message,
      stack: value.stack
    };
  }
  if (typeof value === "bigint")
    return value.toString();
  if (typeof value === "symbol")
    return String(value);
  return value;
}
function stringifyLogData(data) {
  if (typeof data === "undefined")
    return "";
  const seen = new WeakSet;
  try {
    return JSON.stringify(data, (_key, value) => {
      const sanitized = sanitizeLogValue(value);
      if (sanitized && typeof sanitized === "object") {
        if (seen.has(sanitized))
          return "[circular]";
        seen.add(sanitized);
      }
      return sanitized;
    });
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    return JSON.stringify({
      logger_error: "log_serialize_failed",
      message
    });
  }
}
function log(message, data) {
  try {
    const timestamp = new Date().toISOString();
    const payload = stringifyLogData(data);
    const logEntry = `[${timestamp}] ${message}${payload ? ` ${payload}` : ""}
`;
    fs37.appendFileSync(logFile, logEntry);
  } catch {}
}
var logFile;
var init_logger = __esm(() => {
  logFile = path37.join(os4.tmpdir(), "miya.log");
});

// src/autoflow/state.ts
import * as fs38 from "node:fs";
import * as path38 from "node:path";
function nowIso21() {
  return new Date().toISOString();
}
function stateFilePath(projectDir) {
  return path38.join(getMiyaRuntimeDir(projectDir), "autoflow-state.json");
}
function normalizeFixRounds(value) {
  if (!Number.isFinite(value))
    return DEFAULT_MAX_FIX_ROUNDS;
  return Math.max(1, Math.min(10, Math.floor(Number(value))));
}
function normalizeState(sessionID, raw) {
  const createdAt = raw?.createdAt ?? nowIso21();
  const history = Array.isArray(raw?.history) ? raw?.history.slice(-MAX_HISTORY).map((item) => ({
    at: String(item.at ?? createdAt),
    phase: item.phase ?? "planning",
    event: String(item.event ?? "unknown"),
    summary: String(item.summary ?? "")
  })) : [];
  const fixCommands = Array.isArray(raw?.fixCommands) ? raw.fixCommands.map(String).map((item) => item.trim()).filter(Boolean) : [];
  const recentVerificationHashes = Array.isArray(raw?.recentVerificationHashes) ? raw.recentVerificationHashes.map(String).slice(-3) : [];
  const planTasks = Array.isArray(raw?.planTasks) ? raw.planTasks : [];
  return {
    sessionID,
    goal: String(raw?.goal ?? "").trim(),
    phase: raw?.phase ?? "planning",
    createdAt,
    updatedAt: raw?.updatedAt ?? createdAt,
    maxFixRounds: normalizeFixRounds(raw?.maxFixRounds),
    fixRound: Number.isFinite(raw?.fixRound) ? Math.max(0, Math.floor(Number(raw?.fixRound))) : 0,
    verificationCommand: raw?.verificationCommand ? String(raw.verificationCommand) : undefined,
    fixCommands,
    planTasks,
    recentVerificationHashes,
    lastError: raw?.lastError ? String(raw.lastError) : undefined,
    lastDag: raw?.lastDag && Number.isFinite(raw.lastDag.total) ? {
      total: Math.max(0, Math.floor(Number(raw.lastDag.total))),
      completed: Math.max(0, Math.floor(Number(raw.lastDag.completed))),
      failed: Math.max(0, Math.floor(Number(raw.lastDag.failed))),
      blocked: Math.max(0, Math.floor(Number(raw.lastDag.blocked)))
    } : undefined,
    history
  };
}
function readStore8(projectDir) {
  const file3 = stateFilePath(projectDir);
  if (!fs38.existsSync(file3))
    return { sessions: {} };
  try {
    const parsed = JSON.parse(fs38.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const sessions = {};
    for (const [sessionID, state] of Object.entries(parsed.sessions)) {
      sessions[sessionID] = normalizeState(sessionID, state);
    }
    return { sessions };
  } catch {
    return { sessions: {} };
  }
}
function listAutoflowSessions(projectDir, limit = 50) {
  const store = readStore8(projectDir);
  return Object.values(store.sessions).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, Math.min(200, limit)));
}
var DEFAULT_MAX_FIX_ROUNDS = 3, MAX_HISTORY = 120;
var init_state5 = __esm(() => {
  init_workflow();
});
// src/autoflow/engine.ts
var init_engine = __esm(() => {
  init_state5();
});

// src/autoflow/persistent.ts
import * as fs39 from "node:fs";
import * as path39 from "node:path";
function storeFile2(projectDir) {
  return path39.join(getMiyaRuntimeDir(projectDir), "autoflow-persistent.json");
}
function clamp4(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeConfig(raw) {
  return {
    enabled: raw?.enabled !== false,
    resumeCooldownMs: clamp4(Number(raw?.resumeCooldownMs ?? DEFAULT_CONFIG.resumeCooldownMs), 500, 120000),
    maxAutoResumes: clamp4(Number(raw?.maxAutoResumes ?? DEFAULT_CONFIG.maxAutoResumes), 1, 50),
    maxConsecutiveResumeFailures: clamp4(Number(raw?.maxConsecutiveResumeFailures ?? DEFAULT_CONFIG.maxConsecutiveResumeFailures), 1, 20),
    resumeTimeoutMs: clamp4(Number(raw?.resumeTimeoutMs ?? DEFAULT_CONFIG.resumeTimeoutMs), 3000, 10 * 60000)
  };
}
function normalizeRuntime(sessionID, raw) {
  return {
    sessionID,
    resumeAttempts: clamp4(Number(raw?.resumeAttempts ?? 0), 0, 1000),
    resumeFailures: clamp4(Number(raw?.resumeFailures ?? 0), 0, 1000),
    userStopped: Boolean(raw?.userStopped),
    lastStopAt: raw?.lastStopAt ? String(raw.lastStopAt) : undefined,
    lastStopType: raw?.lastStopType ? String(raw.lastStopType) : undefined,
    lastStopReason: raw?.lastStopReason ? String(raw.lastStopReason) : undefined,
    lastResumeAt: raw?.lastResumeAt ? String(raw.lastResumeAt) : undefined,
    lastOutcomePhase: raw?.lastOutcomePhase ? String(raw.lastOutcomePhase) : undefined,
    lastOutcomeSummary: raw?.lastOutcomeSummary ? String(raw.lastOutcomeSummary) : undefined
  };
}
function readStore9(projectDir) {
  const file3 = storeFile2(projectDir);
  if (!fs39.existsSync(file3))
    return { config: DEFAULT_CONFIG, sessions: {} };
  try {
    const parsed = JSON.parse(fs39.readFileSync(file3, "utf-8"));
    const sessionsRaw = parsed.sessions && typeof parsed.sessions === "object" ? parsed.sessions : {};
    const sessions = Object.fromEntries(Object.entries(sessionsRaw).map(([sessionID, runtime]) => [
      sessionID,
      normalizeRuntime(sessionID, runtime)
    ]));
    return {
      config: normalizeConfig(parsed.config),
      sessions
    };
  } catch {
    return { config: DEFAULT_CONFIG, sessions: {} };
  }
}
function readAutoflowPersistentConfig(projectDir) {
  return readStore9(projectDir).config;
}
function getAutoflowPersistentRuntimeSnapshot(projectDir, limit = 50) {
  const store = readStore9(projectDir);
  return Object.values(store.sessions).sort((a, b) => Date.parse(b.lastStopAt ?? b.lastResumeAt ?? "") - Date.parse(a.lastStopAt ?? a.lastResumeAt ?? "")).slice(0, Math.max(1, Math.min(200, limit)));
}
var DEFAULT_CONFIG;
var init_persistent = __esm(() => {
  init_workflow();
  init_engine();
  init_state5();
  DEFAULT_CONFIG = {
    enabled: true,
    resumeCooldownMs: 2500,
    maxAutoResumes: 8,
    maxConsecutiveResumeFailures: 3,
    resumeTimeoutMs: 90000
  };
});

// src/autoflow/index.ts
var init_autoflow = __esm(() => {
  init_state5();
  init_engine();
  init_persistent();
});

// src/gateway/control-ui-shared.ts
function normalizeControlUiBasePath(basePath) {
  if (!basePath)
    return "";
  let normalized = basePath.trim();
  if (!normalized)
    return "";
  if (!normalized.startsWith("/"))
    normalized = `/${normalized}`;
  if (normalized === "/")
    return "";
  if (normalized.endsWith("/"))
    normalized = normalized.slice(0, -1);
  return normalized;
}

// src/gateway/control-ui.ts
import fs40 from "node:fs";
import path40 from "node:path";
function contentTypeForExt(ext) {
  switch (ext) {
    case ".html":
      return "text/html; charset=utf-8";
    case ".js":
      return "application/javascript; charset=utf-8";
    case ".css":
      return "text/css; charset=utf-8";
    case ".json":
    case ".map":
      return "application/json; charset=utf-8";
    case ".svg":
      return "image/svg+xml";
    case ".png":
      return "image/png";
    case ".jpg":
    case ".jpeg":
      return "image/jpeg";
    case ".gif":
      return "image/gif";
    case ".webp":
      return "image/webp";
    case ".ico":
      return "image/x-icon";
    case ".txt":
      return "text/plain; charset=utf-8";
    default:
      return "application/octet-stream";
  }
}
function securityHeaders(contentType) {
  const headers = {
    "cache-control": "no-cache",
    "x-frame-options": "DENY",
    "content-security-policy": "frame-ancestors 'none'",
    "x-content-type-options": "nosniff"
  };
  if (contentType)
    headers["content-type"] = contentType;
  return headers;
}
function textResponse(status, body) {
  return new Response(body, {
    status,
    headers: securityHeaders("text/plain; charset=utf-8")
  });
}
function isSafeRelativePath(relPath) {
  if (!relPath)
    return false;
  const normalized = path40.posix.normalize(relPath);
  if (normalized.startsWith("../") || normalized === "..")
    return false;
  if (normalized.includes("\x00"))
    return false;
  return true;
}
function resolveRequestedFile(pathname, basePath) {
  if (basePath) {
    if (pathname === basePath)
      return "index.html";
    if (!pathname.startsWith(`${basePath}/`))
      return null;
    pathname = pathname.slice(basePath.length);
  }
  if (!pathname.startsWith("/"))
    return null;
  if (pathname === "/" || pathname === "")
    return "index.html";
  const assetsIndex = pathname.indexOf("/assets/");
  const rel = assetsIndex >= 0 ? pathname.slice(assetsIndex + 1) : pathname.slice(1);
  const requested = rel && !rel.endsWith("/") ? rel : `${rel}index.html`;
  return requested || "index.html";
}
function resolveRootState(projectDir) {
  const envRoot = process.env.MIYA_GATEWAY_UI_ROOT?.trim();
  const candidates = envRoot ? [envRoot] : [
    path40.join(projectDir, "miya-src", "gateway-ui", "dist"),
    path40.join(projectDir, "gateway-ui", "dist"),
    path40.join(projectDir, ".opencode", "miya", "gateway-ui", "dist"),
    path40.join(projectDir, ".opencode", "miya", "gateway-ui")
  ];
  for (const candidate of candidates) {
    const indexPath = path40.join(candidate, "index.html");
    if (fs40.existsSync(indexPath) && fs40.statSync(indexPath).isFile()) {
      return { kind: "resolved", path: candidate };
    }
  }
  if (envRoot)
    return { kind: "invalid", path: envRoot };
  return { kind: "missing" };
}
function createControlUiRequestOptions(projectDir) {
  return {
    basePath: normalizeControlUiBasePath(process.env.MIYA_GATEWAY_UI_BASE_PATH),
    root: resolveRootState(projectDir)
  };
}
function handleControlUiHttpRequest(request, opts) {
  if (request.method !== "GET" && request.method !== "HEAD")
    return null;
  const url3 = new URL(request.url);
  const pathname = url3.pathname;
  const basePath = normalizeControlUiBasePath(opts?.basePath);
  const requestedFile = resolveRequestedFile(pathname, basePath);
  if (!requestedFile)
    return null;
  if (!isSafeRelativePath(requestedFile)) {
    return textResponse(404, "Not Found");
  }
  const root = opts?.root;
  if (root?.kind === "invalid") {
    return textResponse(503, `Control UI assets not found at ${root.path}. Set MIYA_GATEWAY_UI_ROOT to a built UI directory.`);
  }
  if (root?.kind === "missing") {
    return textResponse(503, "Control UI assets not found. Set MIYA_GATEWAY_UI_ROOT to a built UI directory.");
  }
  if (!root || root.kind !== "resolved")
    return null;
  const filePath13 = path40.join(root.path, requestedFile);
  if (!filePath13.startsWith(root.path)) {
    return textResponse(404, "Not Found");
  }
  const indexPath = path40.join(root.path, "index.html");
  const resolvedPath = fs40.existsSync(filePath13) && fs40.statSync(filePath13).isFile() ? filePath13 : indexPath;
  if (!fs40.existsSync(resolvedPath) || !fs40.statSync(resolvedPath).isFile()) {
    return textResponse(404, "Not Found");
  }
  const headers = securityHeaders(contentTypeForExt(path40.extname(resolvedPath).toLowerCase()));
  if (request.method === "HEAD") {
    return new Response(null, { status: 200, headers });
  }
  const body = fs40.readFileSync(resolvedPath);
  return new Response(body, {
    status: 200,
    headers
  });
}
var init_control_ui = () => {};

// src/gateway/negotiation-budget.ts
function nowIso22() {
  return new Date().toISOString();
}
function sanitizeBudget(input) {
  const autoRetry = Number.isFinite(input.autoRetry) ? Math.max(0, Math.floor(input.autoRetry)) : 0;
  const humanEdit = Number.isFinite(input.humanEdit) ? Math.max(0, Math.floor(input.humanEdit)) : 0;
  return { autoRetry, humanEdit };
}
function applyNegotiationBudget(store, input) {
  const budget = sanitizeBudget(input.budget);
  const fixability = input.fixability;
  const existing = store.get(input.key);
  const state = existing ? {
    ...existing,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    updatedAt: nowIso22()
  } : {
    key: input.key,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    autoUsed: 0,
    humanUsed: 0,
    updatedAt: nowIso22()
  };
  if (!input.attemptType) {
    store.set(input.key, state);
    return { allowed: true, state };
  }
  if (state.fixability === "impossible") {
    store.set(input.key, state);
    return { allowed: false, reason: "fixability_impossible", state };
  }
  if (input.attemptType === "auto") {
    if (state.autoUsed >= state.budget.autoRetry) {
      store.set(input.key, state);
      return { allowed: false, reason: "auto_retry_exhausted", state };
    }
    state.autoUsed += 1;
  } else {
    if (state.humanUsed >= state.budget.humanEdit) {
      store.set(input.key, state);
      return { allowed: false, reason: "human_edit_exhausted", state };
    }
    state.humanUsed += 1;
  }
  state.updatedAt = nowIso22();
  store.set(input.key, state);
  return { allowed: true, state };
}

// src/gateway/sanitizer.ts
function normalizeWhitespace(text) {
  return text.replace(/\r\n/g, `
`).trim();
}
function inferContextMode(text) {
  const trimmed = normalizeWhitespace(text);
  if (!trimmed)
    return "work";
  let workScore = 0;
  let chatScore = 0;
  for (const pattern of WORK_HINTS) {
    if (pattern.test(trimmed))
      workScore += 1;
  }
  for (const pattern of CHAT_HINTS) {
    if (pattern.test(trimmed))
      chatScore += 1;
  }
  return workScore >= chatScore ? "work" : "chat";
}
function sanitizeWorkContext(text) {
  const removed = [];
  let body = normalizeWhitespace(text);
  if (WORK_BLOCKED_WORDS.test(body)) {
    removed.push("persona_words");
    body = body.replace(WORK_BLOCKED_WORDS, "");
  }
  body = body.replace(/[ \t]{2,}/g, " ").replace(/\n{3,}/g, `

`).trim();
  return {
    text: ["[Context Mode: WORK]", WORK_INSTRUCTION, body].filter(Boolean).join(`
`),
    removed
  };
}
function sanitizeChatContext(text) {
  const removed = [];
  const lines = normalizeWhitespace(text).split(`
`);
  const kept = [];
  for (const line of lines) {
    if (CODE_CONTEXT_LINE.test(line)) {
      removed.push("code_context_line");
      continue;
    }
    kept.push(line);
  }
  const body = kept.join(`
`).replace(/\n{3,}/g, `

`).trim();
  return {
    text: ["[Context Mode: CHAT]", CHAT_INSTRUCTION, body].filter(Boolean).join(`
`),
    removed
  };
}
function sanitizeGatewayContext(input) {
  const mode = input.modeHint ?? inferContextMode(input.text);
  if (mode === "chat") {
    const sanitized2 = sanitizeChatContext(input.text);
    return {
      mode,
      payload: sanitized2.text,
      removedSignals: sanitized2.removed
    };
  }
  const sanitized = sanitizeWorkContext(input.text);
  return {
    mode,
    payload: sanitized.text,
    removedSignals: sanitized.removed
  };
}
var WORK_INSTRUCTION = "You are a technical coding assistant. No small talk.", CHAT_INSTRUCTION = "You are Miya, a girlfriend assistant. Be gentle and cute.", WORK_HINTS, CHAT_HINTS, WORK_BLOCKED_WORDS, CODE_CONTEXT_LINE;
var init_sanitizer = __esm(() => {
  WORK_HINTS = [
    /```/,
    /\b(stack trace|traceback|exception|TypeError|ReferenceError)\b/i,
    /\b(function|class|import|npm|pnpm|bun|pip|pytest|docker|sql|api)\b/i,
    /\b(\.ts|\.tsx|\.js|\.py|\.md|package\.json|tsconfig)\b/i,
    /(修复|报错|编译|代码|脚本|函数|接口|性能|测试|部署)/
  ];
  CHAT_HINTS = [
    /(亲爱|宝贝|老公|老婆|撒娇|抱抱|晚安|想你|陪我|聊天|温柔)/,
    /\b(love|dear|sweet|cute|hug)\b/i
  ];
  WORK_BLOCKED_WORDS = /(亲爱的|宝贝|老公|老婆|撒娇|语气|情绪|可爱|温柔)/g;
  CODE_CONTEXT_LINE = new RegExp([
    "^\\s*```",
    "^\\s*(src|apps?|packages?)[/\\\\]",
    "^\\s*[A-Za-z]:[/\\\\]",
    "^\\s*at\\s+\\S+\\s*\\(",
    '^\\s*File\\s+".*",\\s+line\\s+\\d+',
    "\\.(ts|tsx|js|jsx|py|java|go|rs|cpp|c|h|json|yaml|yml|toml|md)\\b",
    "\\b(package\\.json|tsconfig|requirements\\.txt|pnpm-lock|bun\\.lock)\\b"
  ].join("|"), "i");
});

// src/gateway/protocol.ts
class GatewayMethodRegistry {
  handlers = new Map;
  inFlight = 0;
  queue = [];
  rejectedOverloaded = 0;
  rejectedTimeout = 0;
  queueWaitSamplesMs = [];
  maxInFlight;
  maxQueued;
  queueTimeoutMs;
  constructor(options = {}) {
    this.maxInFlight = Math.max(1, Math.floor(options.maxInFlight ?? Number(process.env.MIYA_GATEWAY_MAX_IN_FLIGHT ?? 8)));
    this.maxQueued = Math.max(1, Math.floor(options.maxQueued ?? Number(process.env.MIYA_GATEWAY_MAX_QUEUED ?? 64)));
    this.queueTimeoutMs = Math.max(100, Math.floor(options.queueTimeoutMs ?? Number(process.env.MIYA_GATEWAY_QUEUE_TIMEOUT_MS ?? 15000)));
  }
  register(method, handler) {
    this.handlers.set(method, handler);
  }
  async invoke(method, params, context) {
    if (this.inFlight < this.maxInFlight) {
      return this.executeNow(method, params, context);
    }
    if (this.queue.length >= this.maxQueued) {
      this.rejectedOverloaded += 1;
      throw new Error(`gateway_backpressure_overloaded:in_flight=${this.inFlight}:queued=${this.queue.length}`);
    }
    return await new Promise((resolve3, reject) => {
      const queued = {
        method,
        params,
        context,
        enqueuedAtMs: Date.now(),
        resolve: resolve3,
        reject,
        timeout: setTimeout(() => {
          const index = this.queue.indexOf(queued);
          if (index >= 0)
            this.queue.splice(index, 1);
          this.rejectedTimeout += 1;
          reject(new Error("gateway_backpressure_timeout"));
        }, this.queueTimeoutMs)
      };
      this.queue.push(queued);
    });
  }
  list() {
    return [...this.handlers.keys()].sort();
  }
  stats() {
    const rejectedOverloaded = this.rejectedOverloaded;
    const rejectedTimeout = this.rejectedTimeout;
    const queueWaitMsP95 = this.queueWaitMsP95();
    return {
      inFlight: this.inFlight,
      queued: this.queue.length,
      maxInFlight: this.maxInFlight,
      maxQueued: this.maxQueued,
      rejected_overloaded: rejectedOverloaded,
      rejected_timeout: rejectedTimeout,
      queue_wait_ms_p95: queueWaitMsP95,
      rejectedOverloaded,
      rejectedTimeout,
      queueWaitMsP95
    };
  }
  async executeNow(method, params, context) {
    const handler = this.handlers.get(method);
    if (!handler)
      throw new Error(`unknown_method:${method}`);
    this.inFlight += 1;
    try {
      return await handler(params, context);
    } finally {
      this.inFlight = Math.max(0, this.inFlight - 1);
      this.drainQueue();
    }
  }
  drainQueue() {
    if (this.inFlight >= this.maxInFlight)
      return;
    const next = this.queue.shift();
    if (!next)
      return;
    clearTimeout(next.timeout);
    this.recordQueueWait(Date.now() - next.enqueuedAtMs);
    this.executeNow(next.method, next.params, next.context).then((value) => next.resolve(value)).catch((error92) => next.reject(error92)).finally(() => {
      if (this.inFlight < this.maxInFlight && this.queue.length > 0) {
        this.drainQueue();
      }
    });
  }
  recordQueueWait(waitMs) {
    if (!Number.isFinite(waitMs) || waitMs < 0)
      return;
    this.queueWaitSamplesMs.push(waitMs);
    if (this.queueWaitSamplesMs.length > 256) {
      this.queueWaitSamplesMs.splice(0, this.queueWaitSamplesMs.length - 256);
    }
  }
  queueWaitMsP95() {
    if (this.queueWaitSamplesMs.length === 0)
      return 0;
    const sorted = [...this.queueWaitSamplesMs].sort((a, b) => a - b);
    const index = Math.max(0, Math.min(sorted.length - 1, Math.floor(sorted.length * 0.95)));
    return Math.floor(sorted[index] ?? 0);
  }
}
function parseIncomingFrame(message) {
  let payload = message;
  if (typeof message === "string") {
    const raw = message.trim();
    if (!raw)
      return { error: "empty_message" };
    if (raw === "status") {
      payload = { type: "request", id: "legacy-status", method: "gateway.status.get", params: {} };
    } else {
      try {
        payload = JSON.parse(raw);
      } catch {
        return { error: "invalid_json" };
      }
    }
  }
  try {
    const frame = GatewayIncomingFrameSchema.parse(payload);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}
function toResponseFrame(input) {
  const result = toJsonCompatible(input.result);
  const errorDetails = toJsonCompatible(input.errorDetails);
  if (input.ok) {
    return ResponseFrameSchema.parse({
      type: "response",
      id: input.id,
      ok: true,
      result
    });
  }
  return ResponseFrameSchema.parse({
    type: "response",
    id: input.id,
    ok: false,
    error: {
      code: input.errorCode ?? "internal_error",
      message: input.errorMessage ?? "Internal error",
      details: errorDetails
    }
  });
}
function toEventFrame(input) {
  const payload = toJsonCompatible(input.payload);
  return EventFrameSchema.parse({
    type: "event",
    event: input.event,
    payload,
    stateVersion: input.stateVersion
  });
}
function toPongFrame(ts) {
  return PongFrameSchema.parse({
    type: "pong",
    ts
  });
}
function toJsonCompatible(input) {
  if (input === undefined)
    return null;
  if (input === null)
    return null;
  if (typeof input === "string" || typeof input === "number" || typeof input === "boolean") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map((item) => toJsonCompatible(item));
  }
  if (typeof input === "object") {
    const source = input;
    const next = {};
    for (const [key, value] of Object.entries(source)) {
      if (value === undefined)
        continue;
      next[key] = toJsonCompatible(value);
    }
    return next;
  }
  return String(input);
}
var JsonValue, JsonObject, HelloFrameSchema, RequestFrameSchema, PingFrameSchema, PongFrameSchema, ResponseFrameSchema, EventFrameSchema, GatewayIncomingFrameSchema, GatewayOutgoingFrameSchema;
var init_protocol = __esm(() => {
  init_zod();
  JsonValue = exports_external.lazy(() => exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean(), exports_external.null(), exports_external.array(JsonValue), exports_external.record(exports_external.string(), JsonValue)]));
  JsonObject = exports_external.record(exports_external.string(), JsonValue);
  HelloFrameSchema = exports_external.object({
    type: exports_external.literal("hello"),
    role: exports_external.enum(["ui", "admin", "node", "channel", "unknown"]).default("unknown"),
    clientID: exports_external.string().optional(),
    protocolVersion: exports_external.string().optional(),
    auth: exports_external.object({
      token: exports_external.string().optional()
    }).optional(),
    capabilities: exports_external.array(exports_external.string()).optional()
  });
  RequestFrameSchema = exports_external.object({
    type: exports_external.literal("request"),
    id: exports_external.string().min(1),
    method: exports_external.string().min(1),
    params: JsonObject.default({})
  });
  PingFrameSchema = exports_external.object({
    type: exports_external.literal("ping"),
    ts: exports_external.number().int().nonnegative()
  });
  PongFrameSchema = exports_external.object({
    type: exports_external.literal("pong"),
    ts: exports_external.number().int().nonnegative()
  });
  ResponseFrameSchema = exports_external.object({
    type: exports_external.literal("response"),
    id: exports_external.string(),
    ok: exports_external.boolean(),
    result: JsonValue.optional(),
    error: exports_external.object({
      code: exports_external.string(),
      message: exports_external.string(),
      details: JsonValue.optional()
    }).optional()
  });
  EventFrameSchema = exports_external.object({
    type: exports_external.literal("event"),
    event: exports_external.string().min(1),
    payload: JsonValue,
    stateVersion: exports_external.record(exports_external.string(), exports_external.number()).optional()
  });
  GatewayIncomingFrameSchema = exports_external.union([HelloFrameSchema, RequestFrameSchema, PingFrameSchema]);
  GatewayOutgoingFrameSchema = exports_external.union([ResponseFrameSchema, EventFrameSchema, PongFrameSchema]);
});

// src/gateway/index.ts
var exports_gateway = {};
__export(exports_gateway, {
  stopGateway: () => stopGateway,
  startGatewayWithLog: () => startGatewayWithLog,
  registerGatewayDependencies: () => registerGatewayDependencies,
  probeGatewayAlive: () => probeGatewayAlive,
  isGatewayOwner: () => isGatewayOwner,
  ensureGatewayRunning: () => ensureGatewayRunning,
  createGatewayTools: () => createGatewayTools
});
import { spawnSync as spawnSync4 } from "node:child_process";
import { createHash as createHash13, randomUUID as randomUUID16 } from "node:crypto";
import * as fs41 from "node:fs";
import { createServer } from "node:http";
import * as os5 from "node:os";
import * as path41 from "node:path";
function nowIso23() {
  return new Date().toISOString();
}
function resolveKillSwitchMode(projectDir, kill) {
  if (kill.active)
    return "all_stop";
  const outbound = isDomainExecutionAllowed(projectDir, "outbound_send");
  const desktop = isDomainExecutionAllowed(projectDir, "desktop_control");
  if (!outbound && !desktop)
    return "all_stop";
  if (!outbound)
    return "outbound_only";
  if (!desktop)
    return "desktop_only";
  return "off";
}
function resolvePsycheApprovalMode(input) {
  if (input.decision !== "allow")
    return "modal_approval";
  if (input.urgency === "high" || input.urgency === "critical")
    return "modal_approval";
  if (input.trust.minScore >= input.mode.silentMin)
    return "silent_audit";
  if (input.trust.minScore <= input.mode.modalMax)
    return "modal_approval";
  return "toast_gate";
}
function appendNexusInsight(runtime, input) {
  const trimmed = input.text.trim();
  if (!trimmed)
    return;
  runtime.nexus.insights.push({
    at: input.at ?? nowIso23(),
    text: trimmed,
    auditID: input.auditID
  });
  if (runtime.nexus.insights.length > 30) {
    runtime.nexus.insights.splice(0, runtime.nexus.insights.length - 30);
  }
}
function shouldEmitThrottledLog(cache, key, windowMs) {
  const now = Date.now();
  const last = cache.get(key) ?? 0;
  if (now - last < windowMs)
    return false;
  cache.set(key, now);
  return true;
}
function depsOf(projectDir) {
  return dependencies.get(projectDir) ?? {};
}
function registerGatewayDependencies(projectDir, deps) {
  const current = dependencies.get(projectDir) ?? {};
  dependencies.set(projectDir, { ...current, ...deps });
}
function gatewayFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "gateway.json");
}
function trustModeFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "gateway-trust-mode.json");
}
function psycheModeFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "gateway-psyche-mode.json");
}
function learningGateFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "gateway-learning-gate.json");
}
function normalizeTrustMode2(input) {
  const silentMinRaw = Number(input?.silentMin ?? DEFAULT_TRUST_MODE.silentMin);
  const modalMaxRaw = Number(input?.modalMax ?? DEFAULT_TRUST_MODE.modalMax);
  const silentMin = Math.max(0, Math.min(100, Number.isFinite(silentMinRaw) ? silentMinRaw : DEFAULT_TRUST_MODE.silentMin));
  const modalMax = Math.max(0, Math.min(100, Number.isFinite(modalMaxRaw) ? modalMaxRaw : DEFAULT_TRUST_MODE.modalMax));
  const correctedSilentMin = Math.max(Math.ceil(modalMax), Math.round(silentMin));
  return {
    silentMin: correctedSilentMin,
    modalMax: Math.round(modalMax)
  };
}
function readTrustModeConfig(projectDir) {
  const raw = safeReadJsonObject(trustModeFile(projectDir));
  if (!raw)
    return DEFAULT_TRUST_MODE;
  return normalizeTrustMode2({
    silentMin: typeof raw.silentMin === "number" ? raw.silentMin : undefined,
    modalMax: typeof raw.modalMax === "number" ? raw.modalMax : undefined
  });
}
function writeTrustModeConfig(projectDir, config3) {
  const normalized = normalizeTrustMode2(config3);
  writeJsonAtomic(trustModeFile(projectDir), normalized);
  return normalized;
}
function normalizePsycheMode(input) {
  return {
    resonanceEnabled: typeof input?.resonanceEnabled === "boolean" ? input.resonanceEnabled : DEFAULT_PSYCHE_MODE.resonanceEnabled,
    captureProbeEnabled: typeof input?.captureProbeEnabled === "boolean" ? input.captureProbeEnabled : DEFAULT_PSYCHE_MODE.captureProbeEnabled
  };
}
function readPsycheModeConfig(projectDir) {
  const raw = safeReadJsonObject(psycheModeFile(projectDir));
  if (!raw)
    return DEFAULT_PSYCHE_MODE;
  return normalizePsycheMode({
    resonanceEnabled: typeof raw.resonanceEnabled === "boolean" ? raw.resonanceEnabled : undefined,
    captureProbeEnabled: typeof raw.captureProbeEnabled === "boolean" ? raw.captureProbeEnabled : undefined
  });
}
function writePsycheModeConfig(projectDir, config3) {
  const current = readPsycheModeConfig(projectDir);
  const normalized = normalizePsycheMode({
    ...current,
    ...config3
  });
  writeJsonAtomic(psycheModeFile(projectDir), normalized);
  return normalized;
}
function normalizeLearningGate(input) {
  return {
    candidateMode: input?.candidateMode === "silent_audit" ? "silent_audit" : "toast_gate",
    persistentRequiresApproval: typeof input?.persistentRequiresApproval === "boolean" ? input.persistentRequiresApproval : DEFAULT_LEARNING_GATE.persistentRequiresApproval
  };
}
function readLearningGateConfig(projectDir) {
  const raw = safeReadJsonObject(learningGateFile(projectDir));
  if (!raw)
    return DEFAULT_LEARNING_GATE;
  return normalizeLearningGate({
    candidateMode: raw.candidateMode === "silent_audit" || raw.candidateMode === "toast_gate" ? raw.candidateMode : undefined,
    persistentRequiresApproval: typeof raw.persistentRequiresApproval === "boolean" ? raw.persistentRequiresApproval : undefined
  });
}
function writeLearningGateConfig(projectDir, config3) {
  const current = readLearningGateConfig(projectDir);
  const normalized = normalizeLearningGate({
    ...current,
    ...config3
  });
  writeJsonAtomic(learningGateFile(projectDir), normalized);
  return normalized;
}
function resolvePsycheConsultEnabled(projectDir, mode) {
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "1")
    return true;
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "0")
    return false;
  const config3 = readConfig(projectDir);
  const configured = config3.automation?.psycheConsultEnabled;
  if (typeof configured === "boolean")
    return configured;
  return mode.resonanceEnabled;
}
function gatewayOwnerLockFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "gateway-owner.json");
}
function ensureDir18(file3) {
  fs41.mkdirSync(path41.dirname(file3), { recursive: true });
}
function writeJsonAtomic(file3, payload) {
  ensureDir18(file3);
  const tmp = `${file3}.tmp.${process.pid}.${Date.now()}`;
  fs41.writeFileSync(tmp, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
  fs41.renameSync(tmp, file3);
}
function safeReadJsonObject(file3) {
  if (!fs41.existsSync(file3))
    return null;
  try {
    const parsed = JSON.parse(fs41.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed))
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function readGatewayOwnerLock(projectDir) {
  const raw = safeReadJsonObject(gatewayOwnerLockFile(projectDir));
  if (!raw)
    return null;
  const pid = Number(raw.pid);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  const startedAt = String(raw.startedAt ?? "");
  if (!Number.isFinite(pid) || !token || !updatedAt || !startedAt)
    return null;
  return { pid, token, updatedAt, startedAt };
}
function describeOwnerLock(lock) {
  if (!lock)
    return { exists: false };
  return {
    exists: true,
    pid: lock.pid,
    updatedAt: lock.updatedAt,
    startedAt: lock.startedAt,
    fresh: isOwnerLockFresh(lock),
    alive: isProcessAlive(lock.pid)
  };
}
function isProcessAlive(pid) {
  if (!Number.isFinite(pid) || pid <= 0)
    return false;
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function isOwnerLockFresh(lock) {
  const ts = Date.parse(lock.updatedAt);
  if (!Number.isFinite(ts))
    return false;
  return Date.now() - ts <= 15000;
}
function ownerSummary(projectDir) {
  const lock = readGatewayOwnerLock(projectDir);
  if (!lock) {
    return {
      isOwner: false,
      ownerFresh: false
    };
  }
  const token = ownerTokens.get(projectDir);
  return {
    isOwner: Boolean(token) && lock.pid === process.pid && lock.token === token,
    ownerPID: lock.pid,
    ownerFresh: isOwnerLockFresh(lock)
  };
}
function writeOwnerLock(projectDir, token) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const existing = readGatewayOwnerLock(projectDir);
  const lock = {
    pid: process.pid,
    token,
    updatedAt: nowIso23(),
    startedAt: existing?.pid === process.pid && existing.token === token ? existing.startedAt : nowIso23()
  };
  writeJsonAtomic(file3, lock);
  return lock;
}
function touchOwnerLock(projectDir) {
  const token = ownerTokens.get(projectDir);
  if (!token)
    return;
  writeOwnerLock(projectDir, token);
}
function removeOwnerLock(projectDir) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  const token = ownerTokens.get(projectDir);
  if (!lock || !token)
    return;
  if (lock.pid === process.pid && lock.token === token) {
    try {
      fs41.unlinkSync(file3);
    } catch {}
  }
}
function acquireGatewayOwner(projectDir) {
  const existingToken = ownerTokens.get(projectDir) ?? randomUUID16();
  ownerTokens.set(projectDir, existingToken);
  const lockFile = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  if (lock && lock.pid === process.pid && lock.token === existingToken && isOwnerLockFresh(lock)) {
    const refreshed = {
      ...lock,
      updatedAt: nowIso23()
    };
    writeJsonAtomic(lockFile, refreshed);
    return { owned: true, owner: refreshed };
  }
  if (lock && isProcessAlive(lock.pid) && isOwnerLockFresh(lock)) {
    return { owned: false, owner: lock };
  }
  const created = writeOwnerLock(projectDir, existingToken);
  return { owned: true, owner: created };
}
function readGatewayStateFile(projectDir) {
  const raw = safeReadJsonObject(gatewayFile(projectDir));
  if (!raw)
    return null;
  const url3 = String(raw.url ?? "").trim();
  const port = Number(raw.port);
  const pid = Number(raw.pid);
  const startedAt = String(raw.startedAt ?? "");
  const status = String(raw.status ?? "running");
  if (!url3 || !Number.isFinite(port) || !Number.isFinite(pid) || !startedAt) {
    return null;
  }
  return {
    url: url3,
    port,
    pid,
    startedAt,
    status: status === "killswitch" ? "killswitch" : "running"
  };
}
function describeGatewayState(state) {
  if (!state)
    return { exists: false };
  return {
    exists: true,
    url: state.url,
    port: state.port,
    pid: state.pid,
    startedAt: state.startedAt,
    status: state.status,
    pidAlive: isProcessAlive(state.pid)
  };
}
function clearGatewayStateFile(projectDir) {
  try {
    fs41.unlinkSync(gatewayFile(projectDir));
  } catch {}
}
function isGatewayOwner(projectDir) {
  const token = ownerTokens.get(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  if (!token || !lock)
    return false;
  return lock.pid === process.pid && lock.token === token && isOwnerLockFresh(lock);
}
async function probeGatewayAlive(url3, timeoutMs = 800) {
  const controller = new AbortController;
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const response = await fetch(`${url3.replace(/\/+$/, "")}/api/status`, {
      method: "GET",
      signal: controller.signal
    });
    return response.ok;
  } catch {
    return false;
  } finally {
    clearTimeout(timer);
  }
}
function killAwareStatus(projectDir) {
  return readKillSwitch(projectDir).active ? "killswitch" : "running";
}
function gatewayPort(runtime) {
  return Number(runtime.server.port ?? 0);
}
function resolveGatewayListenOptions(projectDir) {
  const config3 = readConfig(projectDir);
  const gateway = config3.gateway ?? {};
  const rawHost = String(gateway.bindHost ?? "").trim();
  const rawPort = Number(gateway.port);
  const hostname5 = rawHost || "127.0.0.1";
  const port = Number.isFinite(rawPort) && rawPort > 0 && rawPort <= 65535 ? Math.floor(rawPort) : 0;
  return { hostname: hostname5, port };
}
function logControlUiFallback(projectDir, pathname, controlUi, responseStatus) {
  const logKey = `${projectDir}:control-ui-fallback`;
  if (!shouldEmitThrottledLog(controlUiFallbackLoggedAtByDir, logKey, 1e4))
    return;
  log("[gateway] control-ui fallback to built-in console", {
    projectDir,
    pathname,
    responseStatus,
    uiRootKind: controlUi.root?.kind ?? "unknown",
    uiRootPath: controlUi.root && "path" in controlUi.root ? String(controlUi.root.path) : undefined,
    uiBasePath: controlUi.basePath ?? "",
    envUiRoot: process.env.MIYA_GATEWAY_UI_ROOT ?? "",
    envUiBasePath: process.env.MIYA_GATEWAY_UI_BASE_PATH ?? ""
  });
}
function toGatewayState(projectDir, runtime) {
  const host = String(runtime.server.hostname || "127.0.0.1") || "127.0.0.1";
  return {
    url: `http://${host}:${gatewayPort(runtime)}`,
    port: gatewayPort(runtime),
    pid: process.pid,
    startedAt: runtime.startedAt,
    status: killAwareStatus(projectDir)
  };
}
function writeGatewayState(projectDir, state) {
  const file3 = gatewayFile(projectDir);
  writeJsonAtomic(file3, state);
}
function syncGatewayState(projectDir, runtime) {
  const state = toGatewayState(projectDir, runtime);
  writeGatewayState(projectDir, state);
  return state;
}
function stopGateway(projectDir) {
  const runtime = runtimes.get(projectDir);
  if (!runtime)
    return { stopped: false };
  maybeReflectOnSessionEnd(projectDir, {
    minPendingLogs: 50,
    maxLogs: 200
  });
  const previous = toGatewayState(projectDir, runtime);
  if (runtime.wizardTickTimer) {
    clearInterval(runtime.wizardTickTimer);
    runtime.wizardTickTimer = undefined;
  }
  if (runtime.ownerBeatTimer) {
    clearInterval(runtime.ownerBeatTimer);
    runtime.ownerBeatTimer = undefined;
  }
  if (runtime.memoryReflectTimer) {
    clearInterval(runtime.memoryReflectTimer);
    runtime.memoryReflectTimer = undefined;
  }
  if (runtime.daemonLauncherUnsubscribe) {
    runtime.daemonLauncherUnsubscribe();
    runtime.daemonLauncherUnsubscribe = undefined;
  }
  try {
    runtime.channelRuntime.stop();
  } catch {}
  try {
    for (const ws of runtime.wsClients) {
      try {
        ws.close();
      } catch {}
    }
    runtime.server.wsServer.close();
    runtime.server.httpServer.close();
  } catch {}
  runtimes.delete(projectDir);
  clearGatewayStateFile(projectDir);
  removeOwnerLock(projectDir);
  return { stopped: true, previous };
}
function hashText2(input) {
  return createHash13("sha256").update(input).digest("hex");
}
function parseText(value) {
  return typeof value === "string" ? value : "";
}
function parseChannel(value) {
  return isChannelName(value) ? value : null;
}
function wizardPromptByState(state) {
  if (state === "awaiting_photos")
    return WIZARD_PROMPT_PHOTOS;
  if (state === "awaiting_voice")
    return WIZARD_PROMPT_VOICE;
  if (state === "awaiting_personality")
    return WIZARD_PROMPT_PERSONALITY;
  if (state === "completed")
    return WIZARD_PROMPT_DONE;
  return "";
}
function contextEnvelopeByMode(mode) {
  if (mode === "guest") {
    return [
      "[Guest Mode Active]",
      "Only use public persona.",
      "Do not access memory/vault/relationship private context.",
      "Refuse desktop control, outbound actions, and sensitive data requests."
    ].join(`
`);
  }
  if (mode === "unknown") {
    return "[Unknown Speaker] Safety-first mode: avoid sensitive actions until owner verification.";
  }
  return "[Owner Mode Active] Full private context is available.";
}
function containsSensitiveText(text) {
  const sensitivePattern = /(密码|验证码|银行卡|身份证|私钥|seed|助记词|token|secret|api[_-]?key|wallet|汇款|转账|打款|otp|password)/i;
  return sensitivePattern.test(text);
}
function inferIntentSuspicious(text) {
  const suspiciousPattern = /(立刻发|马上发|偷偷发|别告诉|绕过|伪装|冒充|代发|紧急转账|秘密|隐私文件|内部资料|账号|凭据)/i;
  return suspiciousPattern.test(text);
}
function isHighRiskInstruction(text) {
  return /(忽略所有规则|批量发送|发送所有|删除所有|格式化|重置密码|导出全部|泄露|转账|付款|发给客户群)/i.test(text);
}
function isCriticalInjectionIntent(text) {
  return /(忽略所有规则|绕过.*(验证|风控|权限)|关闭.*(安全|审计|日志)|导出.*(全部|所有).*(密码|token|密钥)|重置.*(密码|口令))/i.test(text);
}
function shouldBypassIntentGuard(source) {
  return /^policy:|^system:/.test(source);
}
function buildSessionPayloadByMode(mode, text) {
  if (mode === "guest") {
    if (containsSensitiveText(text) || isHighRiskInstruction(text)) {
      const digest = hashText2(text).slice(0, 16);
      return {
        redacted: true,
        payload: [
          "[Guest Mode Active]",
          "Private context pointers: memory=null, vault=null, relationship=null.",
          "Sensitive request is blocked in guest mode.",
          `redacted_request_sha256=${digest}`,
          "Reply policy: refuse sensitive actions and keep light conversation only."
        ].join(`
`)
      };
    }
    return {
      redacted: false,
      payload: [
        contextEnvelopeByMode(mode),
        "Private context pointers: memory=null, vault=null, relationship=null.",
        text
      ].join(`
`)
    };
  }
  if (mode === "unknown") {
    return {
      redacted: false,
      payload: [contextEnvelopeByMode(mode), text].join(`
`)
    };
  }
  return { redacted: false, payload: [contextEnvelopeByMode(mode), text].join(`
`) };
}
async function enforceCriticalIntentGuard(projectDir, input) {
  if (shouldBypassIntentGuard(input.source))
    return false;
  if (!isCriticalInjectionIntent(input.text))
    return false;
  const traceID = randomUUID16();
  const reason = "critical_intent_killswitch_triggered";
  activateKillSwitch(projectDir, reason, traceID);
  appendPolicyIncident(projectDir, {
    type: "decision_fusion_hard",
    reason,
    pausedDomains: ["outbound_send", "desktop_control"],
    statusByDomain: {
      outbound_send: "paused",
      desktop_control: "paused"
    },
    semanticSummary: {
      trigger: "critical_intent_guard",
      keyAssertion: "Message matched critical injection / exfiltration intent pattern.",
      recovery: "Use OpenCode local password to unlock and manually resume domains."
    },
    semanticTags: ["recipient_mismatch"],
    details: {
      source: input.source,
      sessionID: input.sessionID,
      textDigest: hashText2(input.text).slice(0, 24)
    }
  });
  await notifySafetyReport(projectDir, input.sessionID, [
    "Miya 红色警报：已触发异常检测熔断（Kill-Switch）",
    `原因: ${reason}`,
    "检测到高危注入/越权意图，已暂停高危能力域。",
    "恢复：请在 OpenCode 完成本地验证后手动恢复。"
  ]);
  return true;
}
function collectStringValues(input, maxItems = 40) {
  const out = [];
  const stack = [input];
  while (stack.length > 0 && out.length < maxItems) {
    const current = stack.pop();
    if (typeof current === "string") {
      const text = current.trim();
      if (text.length > 0)
        out.push(text);
      continue;
    }
    if (!current || typeof current !== "object")
      continue;
    if (Array.isArray(current)) {
      for (const item of current)
        stack.push(item);
      continue;
    }
    for (const value of Object.values(current)) {
      stack.push(value);
    }
  }
  return out;
}
function shouldGuardMethod(method) {
  if (method.startsWith("policy.") || method.startsWith("gateway.") || method.startsWith("doctor.")) {
    return false;
  }
  return true;
}
function assertConsoleMethodAllowed(method, context) {
  if (context.role !== "ui")
    return;
  if (UI_ALLOWED_METHODS.has(method))
    return;
  throw new Error(`console_method_forbidden:${method}`);
}
function interventionAuditFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "audit", "intervention.jsonl");
}
function appendInterventionAudit(projectDir, input) {
  const id = `intervention_${randomUUID16()}`;
  const file3 = interventionAuditFile(projectDir);
  fs41.mkdirSync(path41.dirname(file3), { recursive: true });
  fs41.appendFileSync(file3, `${JSON.stringify({
    id,
    at: nowIso23(),
    ...input
  })}
`, "utf-8");
  return id;
}
function normalizeApprovalTier(input) {
  if (input === "high" || input === "thorough")
    return "THOROUGH";
  if (input === "low" || input === "light")
    return "LIGHT";
  return "STANDARD";
}
async function invokeGatewayMethod(projectDir, runtime, method, params, context) {
  assertConsoleMethodAllowed(method, context);
  if (shouldGuardMethod(method)) {
    const texts = collectStringValues(params);
    for (const text of texts) {
      if (await enforceCriticalIntentGuard(projectDir, {
        sessionID: parseText(params.sessionID) || "main",
        text,
        source: `method:${method}`
      })) {
        throw new Error("kill_switch_triggered_by_critical_intent");
      }
    }
  }
  return runtime.methods.invoke(method, params, context);
}
function parseExecSpec(raw) {
  const input = raw.trim();
  if (!input)
    return null;
  const tokens = [];
  let current = "";
  let quote = null;
  for (let i = 0;i < input.length; i += 1) {
    const ch = input[i] ?? "";
    if ((ch === '"' || ch === "'") && (!quote || quote === ch)) {
      quote = quote ? null : ch;
      continue;
    }
    if (!quote && /\s/.test(ch)) {
      if (current)
        tokens.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current)
    tokens.push(current);
  if (tokens.length === 0)
    return null;
  return {
    command: tokens[0],
    args: tokens.slice(1)
  };
}
async function verifyVoiceprintWithLocalModel(projectDir, input) {
  const config3 = readConfig(projectDir);
  const strictFromConfig = config3.security?.voiceprint?.strict !== false;
  const strict = process.env.MIYA_VOICEPRINT_STRICT !== undefined ? process.env.MIYA_VOICEPRINT_STRICT !== "0" : strictFromConfig;
  const hintMode = resolveInteractionMode(projectDir, {
    speakerHint: input.speakerHint,
    speakerScore: input.speakerScore
  });
  const audioPath = (input.mediaPath ?? "").trim();
  const cmdRaw = String(process.env.MIYA_VOICEPRINT_VERIFY_CMD ?? "").trim();
  if (!audioPath || !fs41.existsSync(audioPath)) {
    return { mode: strict ? "unknown" : hintMode, score: input.speakerScore, source: "no_audio" };
  }
  if (!cmdRaw) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : undefined,
      source: "strict_no_cmd"
    };
  }
  const spec = parseExecSpec(cmdRaw);
  if (!spec) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : undefined,
      source: "strict_invalid_cmd"
    };
  }
  const state = readOwnerIdentityState(projectDir);
  if (!state.voiceprintModelPath || !fs41.existsSync(state.voiceprintModelPath)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_model_missing"
    };
  }
  if (!state.voiceprintSampleDir || !fs41.existsSync(state.voiceprintSampleDir)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_samples_missing"
    };
  }
  const daemon = getMiyaClient(projectDir);
  const args = spec.args.map((item) => item.replaceAll("{audio}", audioPath).replaceAll("{model}", state.voiceprintModelPath).replaceAll("{samples}", state.voiceprintSampleDir || "").replaceAll("{embedding}", state.voiceprintEmbeddingID ?? ""));
  try {
    const result = await daemon.runIsolatedProcess({
      kind: "voice.asr",
      command: spec.command,
      args,
      timeoutMs: 45000,
      resource: { priority: 90, vramMB: 256, modelID: "local:eres2net", modelVramMB: 512 },
      metadata: { stage: "security.voiceprint.verify", audioPath }
    });
    if (result.exitCode !== 0) {
      return {
        mode: strict ? "unknown" : hintMode,
        score: input.speakerScore,
        source: "strict_cmd_failed"
      };
    }
    const stdout = result.stdout.trim();
    const parsed = JSON.parse(stdout);
    const score = typeof parsed.speaker_score === "number" ? Number(parsed.speaker_score) : input.speakerScore;
    const liveness = typeof parsed.liveness_score === "number" ? Number(parsed.liveness_score) : undefined;
    const sampleDuration = typeof parsed.sample_duration_sec === "number" ? Number(parsed.sample_duration_sec) : undefined;
    const diarization = Array.isArray(parsed.diarization) ? parsed.diarization : [];
    const ownerSegments = diarization.filter((seg) => String(seg.speaker ?? "").toLowerCase() === "owner").length;
    const thresholds = state.voiceprintThresholds;
    const diarizationLooksOwner = diarization.length === 0 ? true : ownerSegments / diarization.length >= thresholds.ownerMinDiarizationRatio;
    const sampleDurationOk = typeof sampleDuration !== "number" || sampleDuration >= thresholds.minSampleDurationSec;
    const mode = parsed.mode && ["owner", "guest", "unknown"].includes(parsed.mode) ? parsed.mode : !sampleDurationOk ? "unknown" : typeof score === "number" ? score >= thresholds.ownerMinScore && (liveness ?? 1) >= thresholds.ownerMinLiveness && diarizationLooksOwner ? "owner" : score < thresholds.guestMaxScore || typeof liveness === "number" && liveness < thresholds.guestMaxLiveness ? "guest" : "unknown" : "unknown";
    return { mode, score, source: "voiceprint_cmd" };
  } catch {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_cmd_error"
    };
  }
}
function normalizeRuntimeDependencyRecommendations(status) {
  const fromPlan = Array.isArray(status.repairPlan?.recommendations) ? status.repairPlan?.recommendations ?? [] : [];
  if (fromPlan.length > 0)
    return fromPlan;
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const fallback = [];
  if (issues.some((issue3) => issue3.startsWith("torch_not_installed"))) {
    fallback.push({
      package: "torch",
      recommendedVersion: ">=2.2.0",
      reason: "PyTorch runtime is required by FLUX/GPT-SoVITS tasks.",
      command: 'pip install "torch>=2.2.0" "torchvision>=0.17.0" "torchaudio>=2.2.0"'
    });
  }
  if (issues.some((issue3) => issue3.startsWith("ffmpeg_missing"))) {
    fallback.push({
      package: "ffmpeg",
      recommendedVersion: "system_latest",
      reason: "Audio conversion requires ffmpeg binary in PATH.",
      command: "winget install --id Gyan.FFmpeg -e"
    });
  }
  if (fallback.length === 0 && issues.length > 0) {
    fallback.push({
      package: "python-deps",
      recommendedVersion: "requirements.txt",
      reason: "Environment check reported dependency issues.",
      command: "python -m pip install --upgrade pip setuptools wheel && python -m pip install --disable-pip-version-check -r miya-src/python/requirements.txt"
    });
  }
  return fallback;
}
function buildDependencyAssistPrompt(status) {
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const recommendations = normalizeRuntimeDependencyRecommendations(status);
  const recommendationLines = recommendations.map((item) => `- ${item.package} ${item.recommendedVersion}
  reason: ${item.reason}
  cmd: ${item.command}`).join(`
`);
  return [
    "Miya dependency fault detected in local Python runtime.",
    `python: ${status.pythonPath ?? "unknown"}`,
    `issues: ${issues.join(", ") || "none"}`,
    "Please produce a short repair guide with exact commands and conflict explanation.",
    "Use and refine these baseline recommendations:",
    recommendationLines || "- reinstall requirements and inspect pip stderr"
  ].join(`
`);
}
async function maybeTriggerDependencyAssist(projectDir, runtime, status) {
  const issueType = status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok";
  if (issueType !== "dependency_fault")
    return { triggered: false };
  const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
  const digest = hashText2(prompt);
  if (runtime.dependencyAssistHashes.has(digest)) {
    return { triggered: false };
  }
  runtime.dependencyAssistHashes.add(digest);
  const routed = await routeSessionMessage(projectDir, {
    sessionID: "main",
    source: "daemon.python.env.dependency_fault",
    text: prompt
  });
  return { triggered: true, routed };
}
function deriveRiskLevel(input) {
  if (input.containsSensitive && (input.factorIntentSuspicious || !input.factorRecipientIsMe)) {
    return "HIGH";
  }
  if (input.containsSensitive || input.factorIntentSuspicious) {
    return "MEDIUM";
  }
  return "LOW";
}
function requirePolicyHash(projectDir, providedHash) {
  const policyGuard = assertPolicyHash(projectDir, providedHash);
  if (!policyGuard.ok) {
    throw new Error(`${policyGuard.reason}:expected=${policyGuard.hash}`);
  }
  return policyGuard.hash;
}
function requireDomainRunning(projectDir, domain3) {
  if (!isDomainRunning(projectDir, domain3) || !isDomainExecutionAllowed(projectDir, domain3)) {
    throw new Error(`domain_paused:${domain3}`);
  }
}
function requireOwnerMode(projectDir) {
  const state = readOwnerIdentityState(projectDir);
  if (state.mode !== "owner") {
    throw new Error(`owner_mode_required:current=${state.mode}`);
  }
}
function resolveNegotiationID(input) {
  const explicit = (input.explicitID ?? "").trim();
  if (explicit)
    return explicit;
  const consultAuditID = (input.consultAuditID ?? "").trim();
  if (consultAuditID)
    return consultAuditID;
  return `neg_${hashText2(`${input.sessionID}|${input.channel}|${input.destination}|${input.payloadHash}`).slice(0, 24)}`;
}
function consumeNegotiationBudget(input) {
  const applied = applyNegotiationBudget(input.runtime.negotiationBudgets, {
    key: input.negotiationID,
    fixability: input.fixability,
    budget: input.budget,
    attemptType: input.attemptType
  });
  if (applied.allowed)
    return { ok: true, state: applied.state };
  return {
    ok: false,
    state: applied.state,
    reason: applied.reason
  };
}
async function sendChannelMessageGuarded(projectDir, runtime, input) {
  const resolvedPolicyHash = requirePolicyHash(projectDir, input.policyHash);
  requireDomainRunning(projectDir, "outbound_send");
  requireDomainRunning(projectDir, "desktop_control");
  const identity = readOwnerIdentityState(projectDir);
  const localPhysicalConfirmed = Boolean(input.confirmation?.physicalConfirmed);
  const localPasswordVerified = verifyOwnerPasswordOnly(projectDir, input.confirmation?.password);
  const localGuestOverride = (identity.mode === "guest" || identity.mode === "unknown") && localPhysicalConfirmed && localPasswordVerified;
  if ((identity.mode === "guest" || identity.mode === "unknown") && !localGuestOverride) {
    return {
      sent: false,
      message: "outbound_blocked:guest_mode",
      policyHash: currentPolicyHash(projectDir)
    };
  }
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = hashText2(`${input.text}||${mediaPath}`);
  const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
  const intent = input.outboundCheck?.intent ?? "initiate";
  const factorRecipientIsMeInput = input.outboundCheck?.factorRecipientIsMe;
  const factorRecipientIsMe = typeof factorRecipientIsMeInput === "boolean" ? factorRecipientIsMeInput : getContactTier(projectDir, input.channel, input.destination) === "owner";
  const containsSensitive = containsSensitiveText(input.text);
  const factorIntentSuspicious = inferIntentSuspicious(input.text);
  const confidenceIntentRaw = factorIntentSuspicious ? 0.35 : containsSensitive ? 0.75 : 0.95;
  const riskLevel = deriveRiskLevel({
    containsSensitive,
    factorIntentSuspicious,
    factorRecipientIsMe
  });
  const captureLimitations = Array.isArray(input.outboundCheck?.captureLimitations) ? input.outboundCheck.captureLimitations : [];
  let evidenceConfidence = typeof input.outboundCheck?.evidenceConfidence === "number" && Number.isFinite(input.outboundCheck.evidenceConfidence) ? Number(input.outboundCheck.evidenceConfidence) : confidenceIntentRaw;
  evidenceConfidence = Math.max(0, Math.min(1, evidenceConfidence));
  if (captureLimitations.some((item) => item === "no_desktop_screenshot" || item === "pixel_evidence_unavailable" || item.startsWith("capture_tree_exhausted") || item === "capture_method_unspecified")) {
    evidenceConfidence = Math.min(evidenceConfidence, 0.34);
  }
  const userInitiated = input.outboundCheck?.userInitiated !== false;
  if (isHighRiskInstruction(input.text)) {
    const physicalConfirmed = localPhysicalConfirmed;
    const secretVerified = verifyOwnerSecrets(projectDir, {
      password: input.confirmation?.password,
      passphrase: input.confirmation?.passphrase
    });
    if (!physicalConfirmed || !secretVerified) {
      return {
        sent: false,
        message: "outbound_blocked:high_risk_confirmation_required",
        requiresConfirmation: true,
        policyHash: currentPolicyHash(projectDir)
      };
    }
    const ownerSyncRequired = process.env.MIYA_OWNER_SYNC_REQUIRED !== "0";
    if (ownerSyncRequired && !localGuestOverride) {
      const providedOwnerSyncToken = String(input.confirmation?.ownerSyncToken ?? "").trim();
      if (!providedOwnerSyncToken) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: "outbound_blocked:owner_sync_confirmation_required",
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: `请用本人档在 QQ/微信 回复: 同意 ${pending.token}（10分钟内有效）`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      const ownerSync = verifyOwnerSyncToken(projectDir, {
        token: providedOwnerSyncToken,
        action: "outbound.high_risk.send",
        payloadHash
      });
      if (!ownerSync.ok) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: `outbound_blocked:owner_sync_confirmation_required:${ownerSync.reason ?? "invalid_token"}`,
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: `请用本人档在 QQ/微信 回复: 同意 ${pending.token}（10分钟内有效）`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      consumeOwnerSyncToken(projectDir, providedOwnerSyncToken);
    }
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    const cached3 = runtime.outboundSendDedupe.get(key);
    if (cached3) {
      return {
        ...cached3.result,
        cached: true
      };
    }
  }
  const fusion = evaluateOutboundDecisionFusion({
    factorTextSensitive: containsSensitive,
    factorRecipientIsMe,
    factorIntentSuspicious,
    confidenceIntent: confidenceIntentRaw,
    trustMinScore: runtime.nexus.trust?.minScore,
    trustMode: runtime.nexus.trustMode,
    evidenceConfidence
  });
  if (fusion.action === "hard_fuse") {
    const safetyState = transitionSafetyState(projectDir, {
      source: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: "decision_fusion_hard",
        keyAssertion: "A=contains_sensitive and decision fusion matched in danger zone (confidence < 0.5).",
        recovery: "Review outbound intent in OpenCode and manually resume paused domains after confirmation."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya安全报告：已触发硬熔断并暂停能力域",
      `触发原因: ${incident.reason}`,
      `能力域状态: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `关键断言: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      "恢复条件: 请在确认外发意图后手动恢复域开关"
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_hard",
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (fusion.action === "soft_fuse") {
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_soft",
      reason: "outbound_blocked:decision_fusion_soft_confirmation_required",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      semanticSummary: {
        trigger: "decision_fusion_soft",
        keyAssertion: "Decision fusion matched in gray zone (0.5 <= confidence <= 0.85), manual confirmation required.",
        recovery: "Confirm outbound intent in OpenCode, then retry with explicit approval."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya安全提示：当前外发进入灰区柔性熔断",
      `触发原因: ${incident.reason}`,
      `关键断言: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      "建议确认: 亲爱的，这句话听起来有点敏感，你是认真的吗？"
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_soft_confirmation_required",
      requiresConfirmation: true,
      policyHash: resolvedPolicyHash,
      incident
    };
  }
  const psycheMode = runtime.nexus.psycheMode;
  const psycheConsultEnabled = resolvePsycheConsultEnabled(projectDir, psycheMode);
  if (!psycheMode.resonanceEnabled && !userInitiated) {
    runtime.nexus.guardianSafeHoldReason = "resonance_disabled";
    appendNexusInsight(runtime, {
      text: "共鸣层已关闭：自动触达进入静默等待。"
    });
    const negotiationID2 = resolveNegotiationID({
      explicitID: input.outboundCheck?.negotiationID,
      sessionID: input.sessionID,
      channel: input.channel,
      destination: input.destination,
      payloadHash
    });
    const budgetState = consumeNegotiationBudget({
      runtime,
      negotiationID: negotiationID2,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      attemptType: input.outboundCheck?.retryAttemptType
    });
    if (!budgetState.ok) {
      return {
        sent: false,
        message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
        policyHash: resolvedPolicyHash,
        retryAfterSec: 120,
        fixability: "retry_later",
        budget: { autoRetry: 1, humanEdit: 1 },
        approvalMode: "modal_approval",
        negotiationID: negotiationID2
      };
    }
    return {
      sent: false,
      message: "outbound_blocked:resonance_disabled_safe_hold",
      policyHash: resolvedPolicyHash,
      retryAfterSec: 120,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      approvalMode: "toast_gate",
      negotiationID: negotiationID2,
      psyche: {
        decision: "defer",
        reason: "resonance_disabled_safe_hold",
        state: "UNKNOWN"
      }
    };
  }
  runtime.nexus.guardianSafeHoldReason = undefined;
  let psycheConsult = null;
  if (psycheConsultEnabled) {
    try {
      const daemon = getMiyaClient(projectDir);
      const consult = await daemon.psycheConsult({
        intent: `outbound.send.${input.channel}`,
        urgency: riskLevel === "HIGH" ? "high" : riskLevel === "MEDIUM" ? "medium" : "low",
        channel: input.channel,
        userInitiated,
        allowScreenProbe: psycheMode.captureProbeEnabled,
        signals: input.outboundCheck?.psycheSignals,
        captureLimitations: input.outboundCheck?.captureLimitations,
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence
        }
      });
      psycheConsult = {
        auditID: consult.auditID,
        intent: consult.intent,
        urgency: consult.urgency,
        channel: consult.channel,
        userInitiated: consult.userInitiated,
        state: consult.state
      };
      const approvalMode = resolvePsycheApprovalMode({
        decision: consult.decision,
        urgency: consult.urgency,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      runtime.nexus.trust = consult.trust;
      runtime.nexus.sessionId = input.sessionID;
      runtime.nexus.permission = "external_message";
      appendNexusInsight(runtime, {
        text: consult.insightText,
        auditID: consult.auditID,
        at: consult.at
      });
      publishGatewayEvent(runtime, "insight.append", {
        at: consult.at,
        text: consult.insightText,
        auditID: consult.auditID
      });
      publishGatewayEvent(runtime, "trust.update", {
        at: consult.at,
        auditID: consult.auditID,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      if (consult.decision !== "allow") {
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          consultAuditID: consult.auditID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: consult.fixability,
          budget: consult.budget,
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            psyche: consult,
            retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
            fixability: consult.fixability,
            budget: consult.budget,
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        try {
          await daemon.psycheOutcome({
            consultAuditID: consult.auditID,
            intent: consult.intent,
            urgency: consult.urgency,
            channel: consult.channel,
            userInitiated: consult.userInitiated,
            state: consult.state,
            delivered: false,
            blockedReason: consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred",
            trust: {
              target: `${input.channel}:${input.destination}`,
              source: `session:${input.sessionID}`,
              action: `outbound.send.${input.channel}`,
              evidenceConfidence,
              highRiskRollback: riskLevel === "HIGH" && consult.decision === "deny"
            }
          });
        } catch {}
        return {
          sent: false,
          message: consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred",
          policyHash: resolvedPolicyHash,
          psyche: consult,
          retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
          fixability: consult.fixability,
          budget: consult.budget,
          approvalMode,
          negotiationID: negotiationID2
        };
      }
    } catch (error92) {
      if (!userInitiated) {
        runtime.nexus.guardianSafeHoldReason = "psyche_consult_unavailable";
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            retryAfterSec: 30,
            fixability: "retry_later",
            budget: { autoRetry: 1, humanEdit: 1 },
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        return {
          sent: false,
          message: "outbound_blocked:psyche_deferred",
          policyHash: resolvedPolicyHash,
          retryAfterSec: 30,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          approvalMode: "modal_approval",
          negotiationID: negotiationID2,
          psyche: {
            decision: "defer",
            reason: "psyche_consult_unavailable",
            state: "UNKNOWN",
            error: error92 instanceof Error ? error92.message : String(error92)
          }
        };
      }
    }
  }
  const outboundTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "external_message",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!outboundTicket.ok)
    throw new Error(`approval_required:${outboundTicket.reason}`);
  const desktopTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "desktop_control",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!desktopTicket.ok)
    throw new Error(`approval_required:${desktopTicket.reason}`);
  const sendFingerprint = hashText2(`${input.channel}|${input.destination}|${payloadHash}|${Math.floor(Date.now() / 60000)}`).slice(0, 40);
  const outboundRuntime = runtime.channelRuntime;
  const result = await outboundRuntime.sendMessage({
    channel: input.channel,
    destination: input.destination,
    text: input.text,
    mediaPath: mediaPath || undefined,
    sessionID: input.sessionID,
    sendFingerprint,
    payloadHash,
    approvalTickets: {
      outboundSend: outboundTicket.ticket,
      desktopControl: desktopTicket.ticket
    },
    outboundCheck: {
      archAdvisorApproved,
      riskLevel,
      intent: intent === "reply" ? "reply" : "initiate",
      containsSensitive,
      policyHash: resolvedPolicyHash
    }
  });
  runtime.nexus.guardianSafeHoldReason = undefined;
  const negotiationID = (input.outboundCheck?.negotiationID ?? "").trim();
  if (Boolean(result.sent) && negotiationID) {
    runtime.negotiationBudgets.delete(negotiationID);
  }
  if (psycheConsultEnabled && psycheConsult) {
    try {
      const daemon = getMiyaClient(projectDir);
      await daemon.psycheOutcome({
        consultAuditID: psycheConsult.auditID,
        intent: psycheConsult.intent,
        urgency: psycheConsult.urgency,
        channel: psycheConsult.channel,
        userInitiated: psycheConsult.userInitiated,
        state: psycheConsult.state,
        delivered: Boolean(result.sent),
        blockedReason: result.sent ? undefined : String(result.message ?? ""),
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence,
          highRiskRollback: riskLevel === "HIGH" && !result.sent
        }
      });
    } catch {}
  }
  const violationType = result.message === "outbound_blocked:friend_tier_sensitive_content_denied" ? "friend_tier_sensitive_violation" : result.message === "outbound_blocked:friend_tier_can_only_reply" ? "friend_tier_initiate_violation" : null;
  if (violationType) {
    const safetyState = transitionSafetyState(projectDir, {
      source: "friend_tier_violation",
      reason: result.message,
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: violationType,
      reason: result.message,
      channel: input.channel,
      destination: input.destination,
      auditID: result.auditID,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: violationType,
        keyAssertion: `Outbound to friend tier violated policy (${result.message}).`,
        recovery: "Review recipient tier and outbound payload, then manually resume paused domains."
      },
      semanticTags: ["recipient_mismatch"]
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya安全报告：朋友档外发违规，已暂停能力域",
      `触发原因: ${result.message}`,
      `能力域状态: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `收件通道: ${input.channel}, 收件目标: ${input.destination}`,
      "恢复条件: 调整联系人档位/内容后手动恢复域开关"
    ]);
    return {
      ...result,
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    runtime.outboundSendDedupe.set(key, { ts: Date.now(), result });
    const cutoff = Date.now() - 10 * 60 * 1000;
    for (const [dedupeKey, value] of runtime.outboundSendDedupe.entries()) {
      if (value.ts < cutoff)
        runtime.outboundSendDedupe.delete(dedupeKey);
    }
  }
  return {
    ...result,
    policyHash: resolvedPolicyHash,
    sendFingerprint
  };
}
async function notifySafetyReport(projectDir, sessionID, lines) {
  try {
    await routeSessionMessage(projectDir, {
      sessionID: sessionID || "main",
      text: lines.join(`
`),
      source: "policy:incident"
    });
  } catch {}
}
function enforceInteractionModeIsolation(projectDir, mode) {
  if (mode === "owner")
    return;
  transitionSafetyState(projectDir, {
    source: "interaction_mode_isolation",
    reason: `interaction_mode_${mode}`,
    domains: {
      outbound_send: "paused",
      desktop_control: "paused",
      memory_read: "paused",
      memory_write: "paused",
      memory_delete: "paused"
    }
  });
}
function listBackground(projectDir) {
  const manager = depsOf(projectDir).backgroundManager;
  if (!manager) {
    return { total: 0, running: 0, tasks: [] };
  }
  const tasks = manager.listTasks(100);
  return {
    total: tasks.length,
    running: tasks.filter((item) => item.status === "running").length,
    tasks: tasks.map((item) => ({
      id: item.id,
      description: item.description,
      agent: item.agent,
      status: item.status,
      startedAt: item.startedAt.toISOString(),
      completedAt: item.completedAt?.toISOString()
    }))
  };
}
function collectDoctorIssues(projectDir, runtime, base) {
  const issues = [];
  const host = String(runtime.server.hostname || "127.0.0.1");
  if (host !== "127.0.0.1" && host !== "localhost") {
    issues.push({
      code: "gateway_bind_non_loopback",
      severity: "warn",
      message: `Gateway bind host is ${host}.`,
      fix: "Use loopback bind by default, or add strict external auth."
    });
  }
  if (base.killSwitch.active) {
    issues.push({
      code: "kill_switch_active",
      severity: "error",
      message: `Kill switch active: ${base.killSwitch.reason ?? "unknown"}.`,
      fix: "Resolve cause and run miya_kill_release."
    });
  }
  const channelStore = readChannelStore(projectDir);
  for (const channel of Object.values(channelStore.channels)) {
    if (channel.enabled && channel.name !== "webchat" && channel.allowlist.length === 0) {
      issues.push({
        code: `channel_allowlist_empty_${channel.name}`,
        severity: "warn",
        message: `${channel.name} enabled without allowlist.`,
        fix: "Approve at least one pair request before auto handling."
      });
    }
  }
  for (const node of base.nodes.list) {
    if (node.connected && !node.paired) {
      issues.push({
        code: `node_unpaired_${node.nodeID}`,
        severity: "warn",
        message: `Node ${node.nodeID} connected but not paired.`,
        fix: "Approve node pairing."
      });
    }
  }
  if (base.skills.discovered.some((item) => !item.gate.loadable)) {
    issues.push({
      code: "skills_gate_failures",
      severity: "info",
      message: "Some skills are gated by missing requirements.",
      fix: "Inspect skills.status and satisfy gate requirements."
    });
  }
  if (base.voice.enabled && base.voice.wakeWordEnabled && !base.voice.talkMode) {
    issues.push({
      code: "voice_wake_without_talk_mode",
      severity: "info",
      message: "Voice wake word is enabled while talk mode is disabled.",
      fix: "Enable talk mode if you expect always-on voice behavior."
    });
  }
  if (base.companion.enabled && !base.companion.onboardingCompleted) {
    issues.push({
      code: "companion_onboarding_incomplete",
      severity: "warn",
      message: "Companion mode enabled before onboarding completion.",
      fix: "Run companion.wizard.start and finish profile setup."
    });
  }
  return issues;
}
function buildSnapshot(projectDir, runtime) {
  const deps = depsOf(projectDir);
  const kill = readKillSwitch(projectDir);
  const jobs = deps.automationService?.listJobs() ?? [];
  const approvals = deps.automationService?.listApprovals() ?? [];
  const recentRuns = deps.automationService?.listHistory(20) ?? [];
  const sessions = listSessions(projectDir);
  const channels = runtime.channelRuntime.listChannels();
  const pendingPairs = runtime.channelRuntime.listPairs("pending");
  const recentOutbound = listOutboundAudit(projectDir, 30);
  const nodes = listNodes(projectDir);
  const devices = listDevices(projectDir);
  const invokes = listInvokeRequests(projectDir, 40);
  const enabledSkills = listEnabledSkills(projectDir);
  const discoveredSkills = discoverSkills(projectDir, deps.extraSkillDirs ?? []);
  const mediaRecent = listMediaItems(projectDir, 20);
  const voice = readVoiceState(projectDir);
  const canvas = readCanvasState(projectDir);
  const companion = readCompanionProfile(projectDir);
  const ownerIdentity = readOwnerIdentityState(projectDir);
  const persistedRuntime = readPersistedAgentRuntime(projectDir);
  const owner = ownerSummary(projectDir);
  if (owner.isOwner) {
    ensureMiyaLauncher(projectDir);
  }
  const autoflowSessions = listAutoflowSessions(projectDir, 30);
  const autoflowPersistentConfig = readAutoflowPersistentConfig(projectDir);
  const autoflowPersistentSessions = getAutoflowPersistentRuntimeSnapshot(projectDir, 30);
  const routingMode = readRouterModeConfig(projectDir);
  const routingCost = getRouteCostSummary(projectDir, 500);
  const routingRecent = listRouteCostRecords(projectDir, 20);
  const learningStats = getLearningStats(projectDir);
  const learningTopDrafts = listSkillDrafts(projectDir, { limit: 8 }).map((item) => ({
    id: item.id,
    status: item.status,
    source: item.source,
    confidence: item.confidence,
    uses: item.uses,
    hitRate: item.uses > 0 ? Number((item.hits / item.uses).toFixed(3)) : 0,
    title: item.title
  }));
  runtime.nexus.pendingTickets = approvals.filter((item) => item.status === "pending").length;
  runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, kill);
  const base = {
    updatedAt: nowIso23(),
    lifecycle: {
      gateway: "standalone_background",
      ui: "opencode_bound"
    },
    gateway: syncGatewayState(projectDir, runtime),
    runtime: {
      isOwner: owner.isOwner,
      ownerPID: owner.ownerPID,
      ownerFresh: owner.ownerFresh,
      activeAgentId: persistedRuntime.activeAgentId,
      storageRevision: persistedRuntime.revision
    },
    daemon: getLauncherDaemonSnapshot(projectDir),
    policyHash: currentPolicyHash(projectDir),
    configCenter: readConfig(projectDir),
    killSwitch: kill,
    nexus: {
      sessionId: runtime.nexus.sessionId,
      activeTool: runtime.nexus.activeTool,
      permission: runtime.nexus.permission,
      pendingTickets: runtime.nexus.pendingTickets,
      killSwitchMode: resolveKillSwitchMode(projectDir, kill),
      insights: runtime.nexus.insights.slice(-10),
      trust: runtime.nexus.trust,
      trustMode: runtime.nexus.trustMode,
      psycheMode: runtime.nexus.psycheMode,
      learningGate: runtime.nexus.learningGate,
      guardianSafeHoldReason: runtime.nexus.guardianSafeHoldReason
    },
    safety: {
      recentSelfApproval: listRecentSelfApprovalRecords(projectDir, 15)
    },
    jobs: {
      total: jobs.length,
      enabled: jobs.filter((item) => item.enabled).length,
      pendingApprovals: approvals.filter((item) => item.status === "pending").length,
      recentRuns
    },
    loop: getSessionState(projectDir, "main"),
    autoflow: {
      active: autoflowSessions.filter((item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing").length,
      sessions: autoflowSessions.map((item) => {
        const phaseProgress = item.phase === "planning" ? 10 : item.phase === "execution" ? 45 : item.phase === "verification" ? 70 : item.phase === "fixing" ? 80 : item.phase === "completed" ? 100 : item.phase === "failed" ? 100 : 0;
        const fixProgress = item.maxFixRounds > 0 ? Math.min(20, Math.floor(item.fixRound / item.maxFixRounds * 20)) : 0;
        const retryReason = [...item.history].reverse().find((row) => row.event === "verification_failed" || row.event === "execution_failed")?.summary;
        return {
          sessionID: item.sessionID,
          phase: item.phase,
          goal: item.goal,
          fixRound: item.fixRound,
          maxFixRounds: item.maxFixRounds,
          updatedAt: item.updatedAt,
          progressPct: Math.min(100, phaseProgress + fixProgress),
          retryReason,
          lastError: item.lastError,
          lastDag: item.lastDag
        };
      }),
      persistent: {
        enabled: autoflowPersistentConfig.enabled,
        resumeCooldownMs: autoflowPersistentConfig.resumeCooldownMs,
        maxAutoResumes: autoflowPersistentConfig.maxAutoResumes,
        maxConsecutiveResumeFailures: autoflowPersistentConfig.maxConsecutiveResumeFailures,
        resumeTimeoutMs: autoflowPersistentConfig.resumeTimeoutMs,
        sessions: autoflowPersistentSessions.map((item) => ({
          sessionID: item.sessionID,
          resumeAttempts: item.resumeAttempts,
          resumeFailures: item.resumeFailures,
          userStopped: item.userStopped,
          lastOutcomePhase: item.lastOutcomePhase,
          lastOutcomeSummary: item.lastOutcomeSummary
        }))
      }
    },
    routing: {
      ecoMode: routingMode.ecoMode,
      forcedStage: routingMode.forcedStage,
      cost: routingCost,
      recent: routingRecent
    },
    learning: {
      stats: learningStats,
      topDrafts: learningTopDrafts
    },
    background: listBackground(projectDir),
    sessions: {
      total: sessions.length,
      active: sessions.filter((item) => item.policy.activation === "active").length,
      queued: sessions.filter((item) => item.policy.activation === "queued").length,
      muted: sessions.filter((item) => item.policy.activation === "muted").length,
      items: sessions.slice(0, 100)
    },
    channels: {
      states: channels,
      pendingPairs,
      recentOutbound
    },
    nodes: {
      total: nodes.length,
      connected: nodes.filter((item) => item.connected).length,
      pendingPairs: listNodePairs(projectDir, "pending").length,
      list: nodes,
      devices,
      invokes
    },
    skills: {
      enabled: enabledSkills,
      discovered: discoveredSkills
    },
    media: {
      total: mediaRecent.length,
      recent: mediaRecent
    },
    voice,
    canvas: {
      activeDocID: canvas.activeDocID,
      docs: listCanvasDocs(projectDir),
      events: canvas.events.slice(0, 100)
    },
    companion,
    security: {
      ownerIdentity: {
        ...ownerIdentity,
        passwordHash: ownerIdentity.passwordHash ? "***" : undefined,
        passphraseHash: ownerIdentity.passphraseHash ? "***" : undefined
      }
    }
  };
  return {
    ...base,
    doctor: {
      issues: collectDoctorIssues(projectDir, runtime, base)
    }
  };
}
function daemonProgressAuditFile(projectDir) {
  return path41.join(getMiyaRuntimeDir(projectDir), "audit", "daemon-job-progress.jsonl");
}
function appendDaemonProgressAudit(projectDir, input) {
  const file3 = daemonProgressAuditFile(projectDir);
  fs41.mkdirSync(path41.dirname(file3), { recursive: true });
  fs41.appendFileSync(file3, `${JSON.stringify({ id: `dprogress_${randomUUID16()}`, ...input })}
`, "utf-8");
}
async function routeSessionMessage(projectDir, input) {
  const availableAgents = [
    "1-task-manager",
    "2-code-search",
    "3-docs-helper",
    "4-architecture-advisor",
    "5-code-fixer",
    "6-ui-designer"
  ];
  const deps = depsOf(projectDir);
  if (await enforceCriticalIntentGuard(projectDir, input)) {
    return {
      delivered: false,
      queued: false,
      reason: "kill_switch_triggered_by_critical_intent"
    };
  }
  const interactionMode = readOwnerIdentityState(projectDir).mode;
  enforceInteractionModeIsolation(projectDir, interactionMode);
  const payload = buildSessionPayloadByMode(interactionMode, input.text);
  const sanitized = sanitizeGatewayContext({
    text: payload.payload
  });
  const safeText = sanitized.payload;
  appendShortTermMemoryLog(projectDir, {
    sessionID: input.sessionID,
    sender: "user",
    text: safeText
  });
  if (interactionMode === "guest") {
    appendGuestConversation(projectDir, {
      text: payload.redacted ? "[redacted_sensitive_guest_request]" : input.text,
      source: input.source,
      sessionID: input.sessionID
    });
  }
  const session = getSession(projectDir, input.sessionID) ?? upsertSession(projectDir, {
    id: input.sessionID,
    kind: input.sessionID.startsWith("opencode:") ? "opencode" : "channel",
    groupId: input.sessionID,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  if (session.policy.activation !== "active" || session.policy.reply !== "auto") {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: `policy_${session.policy.activation}_${session.policy.reply}`
    };
  }
  const client = deps.client;
  if (!client) {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: "client_unavailable"
    };
  }
  const pinnedAgent = session.routing.agent && session.routing.agent !== "1-task-manager" ? session.routing.agent : undefined;
  const plan = buildRouteExecutionPlan({
    projectDir,
    sessionID: input.sessionID,
    text: safeText,
    availableAgents,
    pinnedAgent
  });
  const learning = buildLearningInjection(projectDir, safeText, {
    threshold: 0.66,
    limit: 2
  });
  const enrichedText = learning.snippet ? `${learning.snippet}

---

${safeText}` : safeText;
  const payloadPlan = prepareRoutePayload(projectDir, {
    text: enrichedText,
    stage: plan.stage
  });
  const routedAgents = buildRoutedAgentSequence(plan, availableAgents, safeText);
  let lastAttemptedAgent = routedAgents[0] ?? plan.agent;
  try {
    for (let index = 0;index < routedAgents.length; index++) {
      const agent = routedAgents[index];
      if (!agent)
        continue;
      lastAttemptedAgent = agent;
      const routedText = buildRoutedAgentPayload({
        originalText: safeText,
        payloadText: payloadPlan.text,
        agent,
        index,
        total: routedAgents.length,
        contextStrategy: plan.contextStrategy
      });
      await client.session.prompt({
        path: { id: session.routing.opencodeSessionID },
        body: {
          agent,
          parts: [{ type: "text", text: routedText }]
        },
        query: { directory: projectDir }
      });
    }
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: plan.stage,
      agent: lastAttemptedAgent,
      success: true,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, undefined, { hit: true });
      }
    }
    dequeueSessionMessage(projectDir, input.sessionID);
    return { delivered: true, queued: false };
  } catch (error92) {
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: plan.stage,
      agent: lastAttemptedAgent,
      success: false,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, undefined, { hit: false });
      }
    }
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: error92 instanceof Error ? error92.message : String(error92)
    };
  }
}
function buildRoutedAgentSequence(plan, availableAgents, originalText) {
  const source = plan.plannedAgents.length > 0 ? plan.plannedAgents : [plan.agent];
  const filtered = source.filter((agent) => availableAgents.includes(agent));
  const unique = filtered.filter((agent, index, arr) => arr.indexOf(agent) === index);
  const base = unique.length > 0 ? unique : [plan.agent];
  if (plan.complexity === "low") {
    return base.slice(0, 1);
  }
  if (plan.complexity === "medium") {
    if (plan.enableEarlyExit && shouldEarlyExitForMediumTask(originalText)) {
      return base.slice(0, 1);
    }
    const mediumLimit = Math.max(2, Math.min(3, plan.maxAgents ?? 3));
    return base.slice(0, mediumLimit);
  }
  const highLimit = Math.max(1, plan.maxAgents ?? base.length);
  return base.slice(0, highLimit);
}
function shouldEarlyExitForMediumTask(text) {
  const normalized = text.trim().toLowerCase();
  if (!normalized)
    return false;
  const quickFixSignals = [
    "type error",
    "ts",
    "typescript",
    "lint",
    "修复",
    "报错",
    "错误",
    "hotfix",
    "bugfix"
  ];
  const multiStepSignals = [
    "重构",
    "架构",
    "并行",
    "完整流程",
    "端到端",
    "multi-step",
    "workflow",
    "新增页面",
    "登录页面"
  ];
  const hasQuickFixSignal = quickFixSignals.some((token) => normalized.includes(token));
  const hasMultiStepSignal = multiStepSignals.some((token) => normalized.includes(token));
  return hasQuickFixSignal && !hasMultiStepSignal;
}
function buildRoutedAgentPayload(input) {
  if (input.total <= 1)
    return input.payloadText;
  const header = `[MIYA_ROUTER_PIPELINE step=${input.index + 1}/${input.total} ` + `agent=${input.agent} context=${input.contextStrategy}]`;
  if (input.contextStrategy === "full") {
    return `${header}
${input.payloadText}`;
  }
  if (input.contextStrategy === "summary") {
    const summary = input.originalText.trim().slice(0, 1500);
    return `${header}
Task summary:
${summary}

Execution hint: focus on this step and avoid repeating prior output.`;
  }
  const minimal = input.originalText.trim().slice(0, 700);
  return `${header}
${minimal}`;
}
function resolveApprovalTicket(input) {
  const kill = readKillSwitch(input.projectDir);
  if (kill.active) {
    return { ok: false, reason: "kill_switch_active" };
  }
  const request = {
    sessionID: input.sessionID,
    permission: input.permission,
    patterns: input.patterns
  };
  const tier = requiredTierForRequest(request);
  const requestHash = buildRequestHash({
    permission: input.permission,
    patterns: input.patterns,
    toolCallID: "",
    messageID: ""
  }, false);
  const token = findApprovalToken(input.projectDir, input.sessionID, [requestHash], tier);
  if (token) {
    return {
      ok: true,
      ticket: {
        permission: input.permission,
        requestHash,
        traceID: token.trace_id,
        createdAt: token.created_at,
        expiresAt: token.expires_at,
        tier: token.tier
      }
    };
  }
  activateKillSwitch(input.projectDir, "missing_evidence", randomUUID16());
  return { ok: false, reason: "missing_evidence" };
}
function enforceToken(input) {
  const resolved = resolveApprovalTicket(input);
  return resolved.ok ? { ok: true } : resolved;
}
function renderConsoleHtml(snapshot) {
  const payload = JSON.stringify(snapshot).replace(/</g, "\\u003c");
  return `<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya Gateway React</title>
  <style>
    body { margin: 0; font-family: "Segoe UI", "Microsoft YaHei", sans-serif; background: #0f172a; color: #e2e8f0; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .row { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); margin-bottom: 12px; }
    .card { background: #111827; border: 1px solid #1f2937; border-radius: 10px; padding: 12px; }
    .title { color: #93c5fd; font-size: 12px; text-transform: uppercase; }
    .value { font-size: 20px; font-weight: 700; margin-top: 6px; }
    .ok { color: #4ade80; }
    .bad { color: #f87171; }
    textarea { width: 100%; min-height: 220px; resize: vertical; background: #020617; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; padding: 8px; font-family: Consolas, monospace; }
    button { background: #2563eb; color: #fff; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .line { margin: 6px 0; color: #cbd5e1; font-size: 13px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Miya Gateway</h2>
    <div id="daemonStatus" class="line">loading...</div>
    <div class="row">
      <div class="card">
        <div class="title">Daemon CPU/VRAM/Uptime</div>
        <div id="daemonStats" class="value">--</div>
        <div id="daemonJob" class="line">Active Job: --</div>
      </div>
      <div class="card">
        <div class="title">Sessions</div>
        <div id="sessionsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Jobs</div>
        <div id="jobsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Autoflow</div>
        <div id="autoflowValue" class="value">0 active</div>
        <div id="autoflowPhase" class="line">phase: --</div>
      </div>
      <div class="card">
        <div class="title">Routing Cost</div>
        <div id="routingValue" class="value">--</div>
        <div id="routingStage" class="line">stage: --</div>
      </div>
      <div class="card">
        <div class="title">Learning HitRate</div>
        <div id="learningValue" class="value">--</div>
        <div id="learningDrafts" class="line">drafts: --</div>
      </div>
      <div class="card">
        <div class="title">Policy Hash</div>
        <div id="policyHash" class="line">--</div>
      </div>
    </div>
    <div class="card">
      <div class="title">Configuration Center (read/write .opencode/miya/config.json)</div>
      <div class="line">Patch JSON format: { set: {"ui.language":"zh-CN"}, unset: [] }</div>
      <textarea id="patchText">{"set":{},"unset":[]}</textarea>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <button id="saveButton">保存配置</button>
        <span id="saveState" class="line">idle</span>
      </div>
      <pre id="configJson" class="line" style="white-space:pre-wrap;max-height:220px;overflow:auto"></pre>
    </div>
  </div>
  <script>window.__MIYA_SNAPSHOT__ = ${payload};</script>
  <script>
    (function () {
      let state = window.__MIYA_SNAPSHOT__ || {};
      const patchInput = document.getElementById('patchText');
      const saveButton = document.getElementById('saveButton');
      const saveState = document.getElementById('saveState');
      const daemonStatus = document.getElementById('daemonStatus');
      const daemonStats = document.getElementById('daemonStats');
      const daemonJob = document.getElementById('daemonJob');
      const sessionsValue = document.getElementById('sessionsValue');
      const jobsValue = document.getElementById('jobsValue');
      const autoflowValue = document.getElementById('autoflowValue');
      const autoflowPhase = document.getElementById('autoflowPhase');
      const routingValue = document.getElementById('routingValue');
      const routingStage = document.getElementById('routingStage');
      const learningValue = document.getElementById('learningValue');
      const learningDrafts = document.getElementById('learningDrafts');
      const policyHash = document.getElementById('policyHash');
      const configJson = document.getElementById('configJson');

      let ws = null;
      let reqID = 1;
      const pending = new Map();

      function updateSave(value) {
        saveState.textContent = value;
        saveButton.disabled = value === 'saving';
      }

      function render(next) {
        state = next || {};
        const daemonOk = Boolean(state.daemon && state.daemon.connected);
        const label = daemonOk
          ? 'Miya Daemon Connected'
          : ((state.daemon && state.daemon.statusText) || 'Miya Daemon Disconnected');
        daemonStatus.textContent = label;
        daemonStatus.className = 'line ' + (daemonOk ? 'ok' : 'bad');

        const cpu =
          state.daemon && typeof state.daemon.cpuPercent === 'number'
            ? state.daemon.cpuPercent.toFixed(1) + '%'
            : '--';
        const vramUsed =
          state.daemon && typeof state.daemon.vramUsedMB === 'number' ? state.daemon.vramUsedMB : '--';
        const vramTotal =
          state.daemon && typeof state.daemon.vramTotalMB === 'number' ? state.daemon.vramTotalMB : '--';
        const uptime =
          state.daemon && typeof state.daemon.uptimeSec === 'number' ? state.daemon.uptimeSec + 's' : '--';
        daemonStats.textContent = cpu + ' | ' + vramUsed + '/' + vramTotal + ' MB | ' + uptime;

        const jobID = state.daemon && state.daemon.activeJobID ? state.daemon.activeJobID : '--';
        const jobProgress =
          state.daemon && typeof state.daemon.activeJobProgress === 'number'
            ? state.daemon.activeJobProgress + '%'
            : '--';
        daemonJob.textContent = 'Active Job: ' + jobID + ' | ' + jobProgress;

        sessionsValue.textContent =
          String((state.sessions && state.sessions.active) || 0) +
          '/' +
          String((state.sessions && state.sessions.total) || 0);
        jobsValue.textContent =
          String((state.jobs && state.jobs.enabled) || 0) +
          '/' +
          String((state.jobs && state.jobs.total) || 0);
        const activeAutoflow = (state.autoflow && state.autoflow.active) || 0;
        autoflowValue.textContent = String(activeAutoflow) + ' active';
        const firstAutoflow = state.autoflow && state.autoflow.sessions && state.autoflow.sessions[0];
        autoflowPhase.textContent =
          'phase: ' + (firstAutoflow && firstAutoflow.phase ? firstAutoflow.phase : '--');
        const routingCost =
          state.routing && state.routing.cost ? state.routing.cost : null;
        if (routingCost) {
          routingValue.textContent =
            String(routingCost.totalTokensEstimate || 0) +
            ' tk | save ' +
            String(routingCost.savingsPercentEstimate || 0) +
            '%';
        } else {
          routingValue.textContent = '--';
        }
        routingStage.textContent =
          'stage: ' + ((state.routing && state.routing.forcedStage) || (state.routing && state.routing.ecoMode ? 'eco' : 'auto') || '--');
        const learningStats =
          state.learning && state.learning.stats ? state.learning.stats : null;
        if (learningStats) {
          learningValue.textContent =
            (Number(learningStats.hitRate || 0) * 100).toFixed(1) + '%';
          learningDrafts.textContent =
            'drafts: ' + String(learningStats.total || 0) + ' | uses: ' + String(learningStats.totalUses || 0);
        } else {
          learningValue.textContent = '--';
          learningDrafts.textContent = 'drafts: --';
        }
        policyHash.textContent = state.policyHash || '--';
        configJson.textContent = JSON.stringify(state.configCenter || {}, null, 2);
      }

      function sendReq(method, params) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          return Promise.reject(new Error('ws_not_open'));
        }
        const id = 'r-' + reqID++;
        ws.send(JSON.stringify({ type: 'request', id, method, params }));
        return new Promise((resolve, reject) => {
          const timer = setTimeout(() => {
            pending.delete(id);
            reject(new Error('request_timeout'));
          }, 8000);
          pending.set(id, { resolve, reject, timer });
        });
      }

      async function loadStatus() {
        try {
          const res = await fetch('/api/status', { cache: 'no-store' });
          const data = await res.json();
          render(data);
        } catch {}
      }

      function openWs() {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        const token =
          new URLSearchParams(location.search).get('token') ||
          localStorage.getItem('miya_gateway_token') ||
          '';
        if (token) localStorage.setItem('miya_gateway_token', token);

        ws = new WebSocket(proto + '://' + location.host + '/ws');
        ws.onopen = function () {
          ws.send(
            JSON.stringify({
              type: 'hello',
              role: 'ui',
              protocolVersion: '1.0',
              auth: token ? { token } : undefined,
            }),
          );
          ws.send(
            JSON.stringify({
              type: 'request',
              id: 'sub',
              method: 'gateway.subscribe',
              params: { events: ['*'] },
            }),
          );
        };
        ws.onmessage = function (evt) {
          try {
            const frame = JSON.parse(evt.data);
            if (frame.type === 'event' && frame.event === 'gateway.snapshot') {
              render(frame.payload);
              return;
            }
            if (frame.type === 'response') {
              const entry = pending.get(frame.id);
              if (!entry) return;
              pending.delete(frame.id);
              clearTimeout(entry.timer);
              if (frame.ok) entry.resolve(frame.result);
              else entry.reject(new Error((frame.error && frame.error.message) || 'request_failed'));
            }
          } catch {}
        };
        ws.onclose = function () {
          for (const entry of pending.values()) {
            clearTimeout(entry.timer);
            entry.reject(new Error('ws_closed'));
          }
          pending.clear();
        };
      }

      saveButton.addEventListener('click', async function () {
        updateSave('saving');
        try {
          const patch = JSON.parse(patchInput.value || '{}');
          await sendReq('config.center.patch', { patch, policyHash: state ? state.policyHash : undefined });
          updateSave('ok');
        } catch (err) {
          updateSave('error:' + String((err && err.message) || err));
        }
      });

      render(state);
      loadStatus();
      setInterval(loadStatus, 3000);
      openWs();
    })();
  </script>
</body>
</html>`;
}
function renderWebChatHtml() {
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya WebChat</title>
  <style>
    body{margin:0;font-family:Segoe UI,sans-serif;background:#0b1117;color:#e6edf7}
    main{max-width:900px;margin:0 auto;padding:14px;display:grid;gap:10px}
    #log{min-height:360px;border:1px solid #253047;border-radius:8px;background:#111827;padding:10px;white-space:pre-wrap}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px}
    input{border:1px solid #253047;border-radius:8px;background:#111827;color:#e6edf7;padding:8px}
    button{border:1px solid #253047;border-radius:8px;background:#1f6feb;color:#fff;padding:8px 12px;cursor:pointer}
  </style>
</head>
<body>
<main>
  <h2 style="margin:0">Miya WebChat</h2>
  <div id="log"></div>
  <div class="row"><input id="msg" placeholder="Type message"><button id="send">Send</button></div>
</main>
<script>
  const logEl=document.getElementById('log'); const msgEl=document.getElementById('msg'); const sendBtn=document.getElementById('send');
  const p=location.protocol==='https:'?'wss':'ws'; const ws=new WebSocket(p+'://'+location.host+'/ws');
  const log=(t)=>{logEl.textContent+=t+'\\n'; logEl.scrollTop=logEl.scrollHeight;};
  const send=()=>{const text=msgEl.value.trim(); if(!text)return; ws.send(JSON.stringify({type:'request',id:'send-'+Date.now(),method:'sessions.send',params:{sessionID:'webchat:main',text,source:'webchat'}})); log('[you] '+text); msgEl.value='';};
  sendBtn.onclick=send; msgEl.addEventListener('keydown',(e)=>{if(e.key==='Enter')send();});
  ws.onopen=()=>{const qs=new URLSearchParams(location.search);const token=qs.get('token')||localStorage.getItem('miya_gateway_token')||'';if(token)localStorage.setItem('miya_gateway_token',token);ws.send(JSON.stringify({type:'hello',role:'ui',auth:token?{token}:undefined})); ws.send(JSON.stringify({type:'request',id:'sub',method:'gateway.subscribe',params:{events:['*']}})); log('[system] connected');};
  ws.onmessage=(event)=>{try{const frame=JSON.parse(event.data); if(frame.type==='response'&&!frame.ok)log('[error] '+(frame.error?.message||'request_failed'));}catch{}};
</script>
</body>
</html>`;
}
function formatGatewayStateWithRuntime(state, ownerPID, isOwner, activeAgentId, storageRevision) {
  return [
    `url=${state.url}`,
    `port=${state.port}`,
    `pid=${state.pid}`,
    `owner_pid=${ownerPID ?? 0}`,
    `is_owner=${Boolean(isOwner)}`,
    `started_at=${state.startedAt}`,
    `status=${state.status}`,
    `active_agent=${activeAgentId ?? ""}`,
    `storage_revision=${storageRevision ?? 0}`
  ].join(`
`);
}
function maybeBroadcast(projectDir, runtime) {
  if (!hasEventSubscribers(runtime, "gateway.snapshot")) {
    return;
  }
  runtime.stateVersion += 1;
  const frame = toEventFrame({
    event: "gateway.snapshot",
    payload: buildSnapshot(projectDir, runtime),
    stateVersion: { gateway: runtime.stateVersion }
  });
  publishFrame(runtime, frame.event, frame);
}
function publishGatewayEvent(runtime, event, payload) {
  runtime.stateVersion += 1;
  publishFrame(runtime, event, toEventFrame({
    event,
    payload,
    stateVersion: { gateway: runtime.stateVersion }
  }));
}
function isEventSubscribed(wsData, event) {
  return wsData.subscriptions.has("*") || wsData.subscriptions.has(event);
}
function hasEventSubscribers(runtime, event) {
  for (const ws of runtime.wsClients) {
    if (ws.readyState !== wrapper_default.OPEN)
      continue;
    const wsData = ensureWsData(runtime, ws);
    if (!wsData.authenticated || !isEventSubscribed(wsData, event))
      continue;
    return true;
  }
  return false;
}
function publishFrame(runtime, event, frame) {
  let encoded = null;
  for (const ws of runtime.wsClients) {
    if (ws.readyState !== wrapper_default.OPEN)
      continue;
    const wsData = ensureWsData(runtime, ws);
    if (!wsData.authenticated || !isEventSubscribed(wsData, event))
      continue;
    try {
      if (encoded === null) {
        encoded = JSON.stringify(frame);
      }
      ws.send(encoded);
    } catch {}
  }
}
function emitWizardProgress(runtime, payload) {
  publishGatewayEvent(runtime, "companion.wizard.progress", payload);
}
function emitWizardRequeueProgress(runtime, input) {
  emitWizardProgress(runtime, {
    sessionId: input.sessionId,
    jobID: input.jobID,
    type: input.type,
    status: "pending",
    progress: Math.max(10, input.progress),
    message: WIZARD_REQUEUE_MESSAGE,
    step: input.step
  });
}
function emitWizardDoneProgress(runtime, input) {
  const finalStatus = input.status === "failed" ? "failed" : input.status;
  emitWizardProgress(runtime, {
    sessionId: input.sessionId,
    jobID: input.jobID,
    type: input.type,
    status: finalStatus,
    progress: finalStatus === "failed" || finalStatus === "canceled" ? 50 : 100,
    currentTier: input.tier,
    message: input.message,
    step: input.step,
    nextPrompt: wizardPromptByState(input.step)
  });
}
async function runWizardTrainingWorker(projectDir, runtime) {
  if (runtime.wizardRunnerBusy)
    return;
  const queued = pickQueuedTrainingJob(projectDir);
  if (!queued)
    return;
  runtime.wizardRunnerBusy = true;
  try {
    const runningState = markTrainingJobRunning(projectDir, queued.job.id, queued.sessionId);
    emitWizardProgress(runtime, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: "training",
      progress: 5,
      step: runningState.state
    });
    const daemon = getMiyaClient(projectDir);
    const profileDir = getCompanionProfileCurrentDir(projectDir, queued.sessionId);
    if (queued.job.type === "training.image") {
      const photosDir = path41.join(profileDir, "photos");
      const result2 = await daemon.runFluxTraining({
        profileDir,
        photosDir,
        jobID: queued.job.id,
        checkpointPath: queued.job.checkpointPath
      });
      if (result2.status === "failed" && result2.checkpointPath && queued.job.attempts < 3) {
        const requeued = requeueTrainingJob(projectDir, {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          checkpointPath: result2.checkpointPath,
          message: WIZARD_REQUEUE_MESSAGE
        });
        emitWizardRequeueProgress(runtime, {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          type: queued.job.type,
          progress: queued.job.progress,
          step: requeued.state
        });
        return;
      }
      const done2 = markTrainingJobFinished(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        status: result2.status === "failed" ? "failed" : result2.status,
        message: result2.message,
        tier: result2.tier,
        checkpointPath: result2.checkpointPath
      });
      emitWizardDoneProgress(runtime, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        status: result2.status,
        tier: result2.tier,
        message: result2.message,
        step: done2.state
      });
      return;
    }
    const voiceSamplePath = path41.join(profileDir, "voice", "original_sample.wav");
    const result = await daemon.runSovitsTraining({
      profileDir,
      voiceSamplePath,
      jobID: queued.job.id,
      checkpointPath: queued.job.checkpointPath
    });
    if (result.status === "failed" && result.checkpointPath && queued.job.attempts < 3) {
      const requeued = requeueTrainingJob(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        checkpointPath: result.checkpointPath,
        message: WIZARD_REQUEUE_MESSAGE
      });
      emitWizardRequeueProgress(runtime, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        progress: queued.job.progress,
        step: requeued.state
      });
      return;
    }
    const done = markTrainingJobFinished(projectDir, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      status: result.status === "failed" ? "failed" : result.status,
      message: result.message,
      tier: result.tier,
      checkpointPath: result.checkpointPath
    });
    emitWizardDoneProgress(runtime, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: result.status,
      tier: result.tier,
      message: result.message,
      step: done.state
    });
  } finally {
    runtime.wizardRunnerBusy = false;
  }
}
function ensureWsData(runtime, ws) {
  const existing = runtime.wsMeta.get(ws);
  if (existing) {
    return existing;
  }
  const fallback = {
    clientID: `ws_${randomUUID16()}`,
    role: "unknown",
    subscriptions: new Set(["*"]),
    authenticated: !process.env.MIYA_GATEWAY_TOKEN
  };
  runtime.wsMeta.set(ws, fallback);
  return fallback;
}
async function onInboundMessage(projectDir, runtime, message) {
  if (message.channel === "qq" || message.channel === "wechat") {
    const tier = getContactTier(projectDir, message.channel, message.senderID);
    if (tier === "owner") {
      const token = detectOwnerSyncTokenFromText(message.text);
      if (token) {
        const approval = approveOwnerSyncToken(projectDir, {
          token,
          channel: message.channel,
          senderID: message.senderID
        });
        await notifySafetyReport(projectDir, "main", [
          approval.ok ? `Miya 安全确认：已收到本人档同步确认 token=${token}` : `Miya 安全确认失败：token=${token} reason=${approval.reason ?? "unknown"}`
        ]);
        maybeBroadcast(projectDir, runtime);
        return;
      }
    }
  }
  const sessionID = `${message.channel}:${message.conversationID}`;
  upsertSession(projectDir, {
    id: sessionID,
    kind: "channel",
    groupId: sessionID,
    title: message.displayName,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  await routeSessionMessage(projectDir, {
    sessionID,
    text: message.text,
    source: message.channel
  });
  maybeBroadcast(projectDir, runtime);
}
function createMethods(projectDir, runtime) {
  const config3 = readConfig(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const maxInFlight = typeof backpressure?.max_in_flight === "number" ? Number(backpressure.max_in_flight) : undefined;
  const maxQueued = typeof backpressure?.max_queued === "number" ? Number(backpressure.max_queued) : undefined;
  const queueTimeoutMs = typeof backpressure?.queue_timeout_ms === "number" ? Number(backpressure.queue_timeout_ms) : undefined;
  const methods = new GatewayMethodRegistry({
    maxInFlight,
    maxQueued,
    queueTimeoutMs
  });
  const agentRuntimeApi = new AgentModelRuntimeApi(projectDir);
  methods.register("gateway.status.get", async () => buildSnapshot(projectDir, runtime));
  methods.register("autoflow.status.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const sessions = listAutoflowSessions(projectDir, Math.max(1, Math.min(200, limit)));
    const persistentConfig = readAutoflowPersistentConfig(projectDir);
    const persistentSessions = getAutoflowPersistentRuntimeSnapshot(projectDir, Math.max(1, Math.min(200, limit)));
    return {
      active: sessions.filter((item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing").length,
      sessions,
      persistent: {
        ...persistentConfig,
        sessions: persistentSessions
      }
    };
  });
  methods.register("routing.stats.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 200;
    const mode = readRouterModeConfig(projectDir);
    return {
      mode,
      cost: getRouteCostSummary(projectDir, Math.max(1, Math.min(1000, limit))),
      recent: listRouteCostRecords(projectDir, Math.max(1, Math.min(100, limit)))
    };
  });
  methods.register("learning.drafts.stats", async () => ({
    stats: getLearningStats(projectDir)
  }));
  methods.register("learning.drafts.list", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const statusRaw = parseText(params.status);
    const status = statusRaw === "draft" || statusRaw === "recommended" || statusRaw === "accepted" || statusRaw === "rejected" ? statusRaw : undefined;
    return {
      drafts: listSkillDrafts(projectDir, {
        limit: Math.max(1, Math.min(200, limit)),
        status
      })
    };
  });
  methods.register("learning.drafts.recommend", async (params) => {
    const query = parseText(params.query);
    if (!query)
      throw new Error("query_required");
    const threshold = typeof params.threshold === "number" ? Number(params.threshold) : undefined;
    const limit = typeof params.limit === "number" ? Number(params.limit) : undefined;
    return buildLearningInjection(projectDir, query, {
      threshold,
      limit
    });
  });
  methods.register("gateway.shutdown", async () => {
    const state = syncGatewayState(projectDir, runtime);
    setTimeout(() => {
      stopGateway(projectDir);
    }, 20);
    return { ok: true, state };
  });
  methods.register("doctor.run", async () => buildSnapshot(projectDir, runtime).doctor);
  methods.register("gateway.backpressure.stats", async () => ({
    ...runtime.methods.stats(),
    updatedAt: nowIso23()
  }));
  methods.register("daemon.backpressure.stats", async () => ({
    ...getLauncherBackpressureStats(projectDir),
    updatedAt: nowIso23()
  }));
  methods.register("gateway.pressure.run", async (params) => {
    const concurrencyRaw = typeof params.concurrency === "number" ? Number(params.concurrency) : 10;
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 1;
    const timeoutMs = typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : 20000;
    const concurrency = Math.max(1, Math.min(100, Math.floor(concurrencyRaw)));
    const rounds = Math.max(1, Math.min(20, Math.floor(roundsRaw)));
    const daemon = getMiyaClient(projectDir);
    const startedAtMs = Date.now();
    let success3 = 0;
    let failed = 0;
    const errors5 = [];
    for (let round = 0;round < rounds; round += 1) {
      const tasks = Array.from({ length: concurrency }, async (_, index) => {
        try {
          await daemon.runIsolatedProcess({
            kind: "generic",
            command: process.platform === "win32" ? "cmd" : "sh",
            args: process.platform === "win32" ? ["/c", "echo", `miya-pressure-${round}-${index}`] : ["-lc", `echo miya-pressure-${round}-${index}`],
            timeoutMs: Math.max(1000, timeoutMs)
          });
          success3 += 1;
        } catch (error92) {
          failed += 1;
          errors5.push(error92 instanceof Error ? error92.message : String(error92));
        }
      });
      await Promise.all(tasks);
    }
    return {
      success: success3,
      failed,
      elapsedMs: Date.now() - startedAtMs,
      gateway: runtime.methods.stats(),
      daemon: getLauncherBackpressureStats(projectDir),
      errors: errors5.slice(0, 20)
    };
  });
  methods.register("gateway.startup.probe.run", async (params) => {
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 20;
    const rounds = Math.max(1, Math.min(100, Math.floor(roundsRaw)));
    const waitMsRaw = typeof params.waitMs === "number" ? Number(params.waitMs) : 250;
    const waitMs = Math.max(50, Math.min(5000, Math.floor(waitMsRaw)));
    const state = ensureGatewayRunning(projectDir);
    let healthy = 0;
    let daemonReady = 0;
    const samples = [];
    for (let index = 0;index < rounds; index += 1) {
      const gatewayAlive = await probeGatewayAlive(state.url, 1200);
      const daemonSnapshot = getLauncherDaemonSnapshot(projectDir);
      const daemonConnected = Boolean(daemonSnapshot.connected);
      if (gatewayAlive)
        healthy += 1;
      if (daemonConnected)
        daemonReady += 1;
      samples.push({
        index: index + 1,
        gatewayAlive,
        daemonConnected,
        daemonStatus: daemonSnapshot.statusText
      });
      if (index < rounds - 1) {
        await new Promise((resolve4) => setTimeout(resolve4, waitMs));
      }
    }
    return {
      rounds,
      gatewayHealthy: healthy,
      daemonConnected: daemonReady,
      gatewaySuccessRate: Number((healthy / rounds * 100).toFixed(2)),
      daemonSuccessRate: Number((daemonReady / rounds * 100).toFixed(2)),
      samples
    };
  });
  methods.register("config.center.get", async () => readConfig(projectDir));
  methods.register("provider.override.audit.list", async (params) => {
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 50;
    const limit = Math.max(1, Math.min(500, Math.floor(limitRaw)));
    return listProviderOverrideAudits(projectDir, limit);
  });
  methods.register("agent.runtime.list", async () => agentRuntimeApi.list());
  methods.register("agent.runtime.set", async (params) => {
    const agentName = parseText(params.agentName || params.agent);
    const model = params.model;
    const activate = typeof params.activate === "boolean" ? params.activate : true;
    if (!agentName)
      throw new Error("invalid_agent_name");
    if (typeof model !== "string" || model.trim().length === 0) {
      throw new Error("invalid_model_ref");
    }
    const result = agentRuntimeApi.set({
      agentName,
      model,
      variant: params.variant,
      providerID: params.providerID,
      options: params.options,
      apiKey: params.apiKey,
      baseURL: params.baseURL,
      activate
    });
    return {
      ...result,
      state: agentRuntimeApi.list()
    };
  });
  methods.register("agent.runtime.reset", async (params) => {
    const agentName = parseText(params.agentName || params.agent);
    if (!agentName)
      throw new Error("invalid_agent_name");
    const clearActive = typeof params.clearActive === "boolean" ? params.clearActive : true;
    const activeAgentId = parseText(params.activeAgentId) || undefined;
    const result = agentRuntimeApi.reset({
      agentName,
      clearActive,
      activeAgentId
    });
    return {
      ...result,
      state: agentRuntimeApi.list()
    };
  });
  methods.register("config.center.patch", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    const validation = validateConfigPatch(projectDir, params.patch);
    if (!validation.ok) {
      throw new Error(`config_validation_failed:${validation.errors.join("|")}`);
    }
    const applied = applyConfigPatch(projectDir, validation);
    return {
      updatedConfig: applied.updatedConfig,
      changedKeys: applied.applied.map((item) => item.key)
    };
  });
  methods.register("sessions.list", async () => listSessions(projectDir));
  methods.register("sessions.get", async (params) => {
    const sessionID = parseText(params.sessionID);
    if (!sessionID)
      throw new Error("invalid_session_id");
    return getSession(projectDir, sessionID);
  });
  methods.register("sessions.policy.set", async (params) => {
    const sessionID = parseText(params.sessionID);
    const policyHash = parseText(params.policyHash) || undefined;
    if (!sessionID)
      throw new Error("invalid_session_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const patch = {};
    if (params.activation === "active" || params.activation === "queued" || params.activation === "muted") {
      patch.activation = params.activation;
    }
    if (params.reply === "auto" || params.reply === "manual" || params.reply === "summary_only") {
      patch.reply = params.reply;
    }
    if (params.queueStrategy === "fifo" || params.queueStrategy === "priority" || params.queueStrategy === "cooldown") {
      patch.queueStrategy = params.queueStrategy;
    }
    const updated = setSessionPolicy(projectDir, sessionID, patch);
    if (!updated)
      throw new Error("session_not_found");
    return updated;
  });
  methods.register("sessions.send", async (params) => {
    const sessionID = parseText(params.sessionID);
    const text = parseText(params.text);
    if (!sessionID || !text)
      throw new Error("invalid_sessions_send_args");
    if (text.trim() === "/start") {
      const wizard = isCompanionWizardEmpty(projectDir, sessionID) ? startCompanionWizard(projectDir, { sessionId: sessionID }) : readCompanionWizardState(projectDir, sessionID);
      return {
        sessionID: wizard.sessionId,
        wizard,
        checklist: wizardChecklist(wizard),
        message: wizard.state === "awaiting_photos" ? WIZARD_PROMPT_PHOTOS : `检测到已有向导进度，已恢复继续。${wizardPromptByState(wizard.state)}`,
        instruction: "将照片拖拽到聊天中"
      };
    }
    if (text.trim() === "/reset_personality") {
      const wizard = resetCompanionWizard(projectDir, sessionID);
      return {
        sessionID: wizard.sessionId,
        wizard,
        message: "已重置人格资产，请重新开始 /start"
      };
    }
    upsertSession(projectDir, {
      id: sessionID,
      kind: sessionID.startsWith("opencode:") ? "opencode" : "channel",
      groupId: sessionID,
      routingSessionID: parseText(params.routingSessionID) || "main",
      agent: parseText(params.agent) || "1-task-manager"
    });
    return routeSessionMessage(projectDir, {
      sessionID,
      text,
      source: parseText(params.source) || "gateway"
    });
  });
  methods.register("cron.list", async () => depsOf(projectDir).automationService?.listJobs() ?? []);
  methods.register("cron.runs.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(200, Number(params.limit)) : 50;
    return depsOf(projectDir).automationService?.listHistory(limit) ?? [];
  });
  methods.register("cron.add", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || undefined;
    const name = parseText(params.name);
    const time5 = parseText(params.time);
    const command = parseText(params.command);
    if (!name || !time5 || !command)
      throw new Error("invalid_cron_add_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.scheduleDailyCommand({
      name,
      time: time5,
      command,
      cwd: parseText(params.cwd) || undefined,
      timeoutMs: typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : undefined,
      requireApproval: typeof params.requireApproval === "boolean" ? params.requireApproval : false
    });
  });
  methods.register("cron.remove", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || undefined;
    const jobID = parseText(params.jobID);
    if (!jobID)
      throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return { removed: service.deleteJob(jobID) };
  });
  methods.register("cron.update", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || undefined;
    const jobID = parseText(params.jobID);
    if (!jobID || typeof params.enabled !== "boolean")
      throw new Error("invalid_cron_update_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.setJobEnabled(jobID, params.enabled);
  });
  methods.register("cron.run.now", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || undefined;
    const jobID = parseText(params.jobID);
    if (!jobID)
      throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.runJobNow(jobID);
  });
  methods.register("cron.approvals.list", async () => depsOf(projectDir).automationService?.listApprovals() ?? []);
  methods.register("cron.approvals.approve", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || undefined;
    const approvalID = parseText(params.approvalID);
    if (!approvalID)
      throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.approveAndRun(approvalID);
  });
  methods.register("cron.approvals.reject", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service)
      throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || undefined;
    const approvalID = parseText(params.approvalID);
    if (!approvalID)
      throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.rejectApproval(approvalID);
  });
  methods.register("channels.list", async () => runtime.channelRuntime.listChannels());
  methods.register("channels.status", async () => ({
    channels: runtime.channelRuntime.listChannels(),
    pendingPairs: runtime.channelRuntime.listPairs("pending")
  }));
  methods.register("channels.pair.list", async (params) => {
    if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
      return runtime.channelRuntime.listPairs(params.status);
    }
    return runtime.channelRuntime.listPairs();
  });
  methods.register("channels.pair.approve", async (params) => {
    const pairID = parseText(params.pairID);
    if (!pairID)
      throw new Error("invalid_pair_id");
    return runtime.channelRuntime.approvePair(pairID);
  });
  methods.register("channels.pair.reject", async (params) => {
    const pairID = parseText(params.pairID);
    if (!pairID)
      throw new Error("invalid_pair_id");
    return runtime.channelRuntime.rejectPair(pairID);
  });
  methods.register("channels.contact.tier.set", async (params) => {
    const channel = parseChannel(params.channel);
    const senderID = parseText(params.senderID);
    const tier = parseText(params.tier);
    if (!channel || !senderID)
      throw new Error("invalid_channels_contact_tier_args");
    if (tier !== "owner" && tier !== "friend") {
      throw new Error("invalid_channels_contact_tier");
    }
    return setContactTier(projectDir, channel, senderID, tier);
  });
  methods.register("channels.contact.tier.get", async (params) => {
    const channel = parseChannel(params.channel);
    const senderID = parseText(params.senderID);
    if (!channel || !senderID)
      throw new Error("invalid_channels_contact_tier_args");
    return {
      channel,
      senderID,
      tier: getContactTier(projectDir, channel, senderID)
    };
  });
  methods.register("channels.contact.tier.list", async (params) => {
    const channel = parseChannel(params.channel);
    return {
      contacts: listContactTiers(projectDir, channel ?? undefined)
    };
  });
  methods.register("channels.message.send", async (params) => {
    const channel = parseChannel(params.channel);
    const destination = parseText(params.destination);
    const text = parseText(params.text);
    const mediaID = parseText(params.mediaID);
    const mediaPathInput = parseText(params.mediaPath);
    const idempotencyKey = parseText(params.idempotencyKey);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || undefined;
    const mediaFromStore = mediaID ? getMediaItem(projectDir, mediaID) : null;
    const mediaPath = mediaPathInput || mediaFromStore?.localPath || "";
    if (!channel || !destination || !text && !mediaPath) {
      throw new Error("invalid_channels_send_args");
    }
    const outboundCheckRaw = params.outboundCheck && typeof params.outboundCheck === "object" ? params.outboundCheck : null;
    const outboundCheck = {
      archAdvisorApproved: outboundCheckRaw && typeof outboundCheckRaw.archAdvisorApproved === "boolean" ? Boolean(outboundCheckRaw.archAdvisorApproved) : undefined,
      intent: outboundCheckRaw && typeof outboundCheckRaw.intent === "string" ? String(outboundCheckRaw.intent) : undefined,
      factorRecipientIsMe: outboundCheckRaw && typeof outboundCheckRaw.factorRecipientIsMe === "boolean" ? Boolean(outboundCheckRaw.factorRecipientIsMe) : undefined,
      userInitiated: outboundCheckRaw && typeof outboundCheckRaw.userInitiated === "boolean" ? Boolean(outboundCheckRaw.userInitiated) : undefined,
      negotiationID: outboundCheckRaw && typeof outboundCheckRaw.negotiationID === "string" ? String(outboundCheckRaw.negotiationID) : undefined,
      retryAttemptType: outboundCheckRaw && (outboundCheckRaw.retryAttemptType === "auto" || outboundCheckRaw.retryAttemptType === "human") ? outboundCheckRaw.retryAttemptType : undefined,
      evidenceConfidence: outboundCheckRaw && typeof outboundCheckRaw.evidenceConfidence === "number" && Number.isFinite(outboundCheckRaw.evidenceConfidence) ? Number(outboundCheckRaw.evidenceConfidence) : undefined,
      captureLimitations: outboundCheckRaw && Array.isArray(outboundCheckRaw.captureLimitations) ? outboundCheckRaw.captureLimitations.filter((item) => typeof item === "string").map((item) => item.trim()).filter((item) => item.length > 0).slice(0, 32) : undefined,
      psycheSignals: outboundCheckRaw?.psycheSignals && typeof outboundCheckRaw.psycheSignals === "object" && !Array.isArray(outboundCheckRaw.psycheSignals) ? outboundCheckRaw.psycheSignals : undefined
    };
    const confirmationRaw = params.confirmation && typeof params.confirmation === "object" ? params.confirmation : null;
    return sendChannelMessageGuarded(projectDir, runtime, {
      channel,
      destination,
      text,
      mediaPath,
      idempotencyKey,
      sessionID,
      policyHash,
      outboundCheck,
      confirmation: {
        physicalConfirmed: confirmationRaw && typeof confirmationRaw.physicalConfirmed === "boolean" ? Boolean(confirmationRaw.physicalConfirmed) : undefined,
        password: confirmationRaw && typeof confirmationRaw.password === "string" ? String(confirmationRaw.password) : undefined,
        passphrase: confirmationRaw && typeof confirmationRaw.passphrase === "string" ? String(confirmationRaw.passphrase) : undefined,
        ownerSyncToken: confirmationRaw && typeof confirmationRaw.ownerSyncToken === "string" ? String(confirmationRaw.ownerSyncToken) : undefined
      }
    });
  });
  methods.register("security.identity.status", async () => {
    const state = readOwnerIdentityState(projectDir);
    return {
      ...state,
      passwordHash: state.passwordHash ? "***" : undefined,
      passphraseHash: state.passphraseHash ? "***" : undefined
    };
  });
  methods.register("security.identity.init", async (params) => {
    const password = parseText(params.password);
    const passphrase = parseText(params.passphrase);
    if (!password || !passphrase)
      throw new Error("invalid_owner_secret_input");
    const next = initOwnerIdentity(projectDir, {
      password,
      passphrase,
      voiceprintEmbeddingID: parseText(params.voiceprintEmbeddingID) || undefined,
      voiceprintModelPath: parseText(params.voiceprintModelPath) || undefined,
      voiceprintSampleDir: parseText(params.voiceprintSampleDir) || undefined,
      voiceprintThresholds: {
        ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : undefined,
        guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : undefined,
        ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : undefined,
        guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : undefined,
        ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : undefined,
        minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : undefined,
        farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : undefined,
        frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : undefined
      }
    });
    return {
      ...next,
      passwordHash: "***",
      passphraseHash: "***"
    };
  });
  methods.register("security.identity.rotate", async (params) => {
    const newPassword = parseText(params.newPassword);
    const newPassphrase = parseText(params.newPassphrase);
    if (!newPassword || !newPassphrase)
      throw new Error("invalid_new_owner_secret");
    const next = rotateOwnerSecrets(projectDir, {
      currentPassword: parseText(params.currentPassword) || undefined,
      currentPassphrase: parseText(params.currentPassphrase) || undefined,
      newPassword,
      newPassphrase
    });
    return {
      ...next,
      passwordHash: "***",
      passphraseHash: "***"
    };
  });
  methods.register("security.voiceprint.threshold.get", async () => {
    const state = readOwnerIdentityState(projectDir);
    return {
      ...state.voiceprintThresholds
    };
  });
  methods.register("security.voiceprint.threshold.set", async (params) => {
    const next = updateVoiceprintThresholds(projectDir, {
      ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : undefined,
      guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : undefined,
      ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : undefined,
      guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : undefined,
      ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : undefined,
      minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : undefined,
      farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : undefined,
      frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : undefined
    });
    return {
      ...next.voiceprintThresholds
    };
  });
  methods.register("security.owner_sync.issue", async (params) => {
    const action = parseText(params.action) || "outbound.high_risk.send";
    const payloadHash = parseText(params.payloadHash);
    if (!payloadHash)
      throw new Error("invalid_payload_hash");
    return issueOwnerSyncToken(projectDir, {
      action,
      payloadHash,
      ttlMs: typeof params.ttlMs === "number" ? Number(params.ttlMs) : undefined
    });
  });
  methods.register("policy.get", async () => {
    const policy = readPolicy(projectDir);
    return {
      policy,
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("daemon.python.env.status", async () => {
    const daemon = getMiyaClient(projectDir);
    const status = await daemon.getPythonRuntimeStatus();
    if (!status)
      return null;
    const recommendations = normalizeRuntimeDependencyRecommendations(status);
    const assist = await maybeTriggerDependencyAssist(projectDir, runtime, status);
    return {
      ...status,
      repairPlan: {
        ...status.repairPlan ?? {},
        recommendations
      },
      opencodeAssist: assist
    };
  });
  methods.register("daemon.python.env.repair.plan", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const status = await daemon.getPythonRuntimeStatus();
    if (!status)
      throw new Error("python_runtime_status_unavailable");
    const recommendations = normalizeRuntimeDependencyRecommendations(status);
    const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
    const route = await routeSessionMessage(projectDir, {
      sessionID: parseText(params.sessionID) || "main",
      source: "daemon.python.env.repair.plan",
      text: prompt
    });
    return {
      issueType: status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok",
      warnings: status.repairPlan?.warnings ?? [],
      conflicts: status.repairPlan?.conflicts ?? [],
      oneShotCommand: status.repairPlan?.oneShotCommand,
      recommendations,
      routed: route
    };
  });
  methods.register("daemon.model.lock.status", async () => {
    const daemon = getMiyaClient(projectDir);
    return daemon.getModelLockStatus();
  });
  methods.register("daemon.model.update.plan", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    return daemon.getModelUpdatePlan(target || undefined);
  });
  methods.register("daemon.model.update.apply", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    return daemon.applyModelUpdate(target || undefined);
  });
  methods.register("daemon.model.update.wizard", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    const plan = await daemon.getModelUpdatePlan(target || undefined);
    const pending = Array.isArray(plan.items) ? plan.items.filter((item) => item && item.ok === false) : [];
    const models = pending.map((item) => String(item.model ?? "").trim()).filter(Boolean);
    return {
      pending: typeof plan.pending === "number" ? plan.pending : pending.length,
      models,
      blockers: pending.map((item) => ({
        model: String(item.model ?? ""),
        reason: String(item.reason ?? "metadata_mismatch")
      })),
      suggestedCommands: {
        plan: models.length > 0 ? models.map((model) => `daemon.model.update.plan target=${model}`) : ["daemon.model.update.plan"],
        apply: models.length > 0 ? models.map((model) => `daemon.model.update.apply target=${model}`) : ["daemon.model.update.apply"]
      },
      nextAction: pending.length > 0 ? "apply model update before inference/training" : "model metadata is synchronized"
    };
  });
  methods.register("policy.domains.list", async () => {
    const policy = readPolicy(projectDir);
    return {
      domains: POLICY_DOMAINS.map((domain3) => ({
        domain: domain3,
        status: policy.domains[domain3]
      })),
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("policy.incidents.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return {
      incidents: listPolicyIncidents(projectDir, limit)
    };
  });
  methods.register("policy.domain.pause", async (params) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) {
      throw new Error("invalid_policy_domain");
    }
    const state = transitionSafetyState(projectDir, {
      source: "policy.domain.pause",
      reason: `manual_pause:${domain3}`,
      policyHash: currentPolicyHash(projectDir),
      domains: {
        [domain3]: "paused"
      }
    });
    appendPolicyIncident(projectDir, {
      type: "manual_pause",
      reason: `manual_pause:${domain3}`,
      pausedDomains: [domain3],
      statusByDomain: {
        [domain3]: state.domains[domain3] === "running" ? "running" : "paused"
      },
      policyHash: currentPolicyHash(projectDir)
    });
    return {
      domain: domain3,
      status: state.domains[domain3] === "running" ? "running" : "paused",
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("policy.domain.resume", async (params) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) {
      throw new Error("invalid_policy_domain");
    }
    const kill = readKillSwitch(projectDir);
    const safety = readSafetyState(projectDir);
    if (kill.active || safety.globalState === "killed") {
      throw new Error("kill_switch_active");
    }
    const state = transitionSafetyState(projectDir, {
      source: "policy.domain.resume",
      reason: `manual_resume:${domain3}`,
      policyHash: currentPolicyHash(projectDir),
      domains: {
        [domain3]: "running"
      }
    });
    appendPolicyIncident(projectDir, {
      type: "manual_resume",
      reason: `manual_resume:${domain3}`,
      pausedDomains: [domain3],
      statusByDomain: {
        [domain3]: state.domains[domain3] === "running" ? "running" : "paused"
      },
      policyHash: currentPolicyHash(projectDir)
    });
    return {
      domain: domain3,
      status: state.domains[domain3] === "running" ? "running" : "paused",
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("killswitch.set_mode", async (params) => {
    const modeRaw = parseText(params.mode)?.toLowerCase();
    const mode = modeRaw === "all_stop" || modeRaw === "outbound_only" || modeRaw === "desktop_only" || modeRaw === "off" ? modeRaw : null;
    if (!mode)
      throw new Error("invalid_killswitch_mode");
    const reason = parseText(params.reason) || `manual_mode:${mode}`;
    if (mode === "all_stop") {
      const traceID = randomUUID16();
      activateKillSwitch(projectDir, reason, traceID);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        traceID,
        policyHash: currentPolicyHash(projectDir),
        globalState: "killed",
        domains: {
          outbound_send: "killed",
          desktop_control: "killed"
        }
      });
    } else if (mode === "off") {
      releaseKillSwitch(projectDir);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        policyHash: currentPolicyHash(projectDir),
        globalState: "running",
        domains: {
          outbound_send: "running",
          desktop_control: "running"
        }
      });
    } else {
      releaseKillSwitch(projectDir);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        policyHash: currentPolicyHash(projectDir),
        globalState: "running",
        domains: {
          outbound_send: mode === "desktop_only" ? "running" : "paused",
          desktop_control: mode === "outbound_only" ? "running" : "paused"
        }
      });
    }
    runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, readKillSwitch(projectDir));
    appendNexusInsight(runtime, {
      text: `KillSwitch mode -> ${runtime.nexus.killSwitchMode}`
    });
    publishGatewayEvent(runtime, "gateway.killswitch.mode", {
      mode: runtime.nexus.killSwitchMode,
      at: nowIso23()
    });
    return {
      mode: runtime.nexus.killSwitchMode,
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("intervention.approve", async (params, context) => {
    const sessionID = parseText(params.sessionID) || "main";
    const permission = parseText(params.permission) || "external_message";
    const action = parseText(params.action) || `intervention_approve:${permission}`;
    const tierText = normalizeApprovalTier(parseText(params.tier).toLowerCase());
    const patternsRaw = Array.isArray(params.patterns) ? params.patterns : ["*"];
    const patterns = patternsRaw.map((item) => String(item).trim()).filter(Boolean);
    const normalizedPatterns = patterns.length > 0 ? patterns : ["*"];
    const requestHash = buildRequestHash({
      permission,
      patterns: normalizedPatterns,
      toolCallID: "",
      messageID: ""
    }, false);
    const token = saveApprovalToken(projectDir, sessionID, {
      trace_id: randomUUID16(),
      request_hash: requestHash,
      tier: tierText,
      action
    });
    const auditID = appendInterventionAudit(projectDir, {
      command: "approve",
      actor: context.clientID,
      sourceRole: context.role,
      payload: {
        sessionID,
        permission,
        patterns: normalizedPatterns,
        tier: tierText,
        requestHash,
        tokenExpiresAt: token.expires_at
      }
    });
    appendNexusInsight(runtime, {
      text: `Intervention approve -> ${permission} (${sessionID})`,
      auditID
    });
    publishGatewayEvent(runtime, "intervention.approve", {
      at: nowIso23(),
      auditID,
      sessionID,
      permission,
      tier: tierText,
      tokenExpiresAt: token.expires_at
    });
    return {
      status: "recorded",
      auditID,
      grant: {
        sessionID,
        permission,
        requestHash,
        expiresAt: token.expires_at
      }
    };
  });
  methods.register("intervention.pause", async (params, context) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3))
      throw new Error("invalid_policy_domain");
    const result = await methods.invoke("policy.domain.pause", { domain: domain3 }, { clientID: context.clientID, role: "admin" });
    const auditID = appendInterventionAudit(projectDir, {
      command: "pause",
      actor: context.clientID,
      sourceRole: context.role,
      payload: { domain: domain3, result }
    });
    publishGatewayEvent(runtime, "intervention.pause", {
      at: nowIso23(),
      auditID,
      domain: domain3,
      result
    });
    return {
      status: "recorded",
      auditID,
      domain: domain3,
      result
    };
  });
  methods.register("intervention.kill", async (params, context) => {
    const reason = parseText(params.reason) || "intervention_kill";
    const result = await methods.invoke("killswitch.set_mode", { mode: "all_stop", reason }, { clientID: context.clientID, role: "admin" });
    const auditID = appendInterventionAudit(projectDir, {
      command: "kill",
      actor: context.clientID,
      sourceRole: context.role,
      payload: { reason, result }
    });
    publishGatewayEvent(runtime, "intervention.kill", {
      at: nowIso23(),
      auditID,
      reason,
      result
    });
    return {
      status: "recorded",
      auditID,
      result
    };
  });
  methods.register("intervention.annotate", async (params, context) => {
    const text = parseText(params.text);
    if (!text)
      throw new Error("invalid_annotation_text");
    const at = parseText(params.at) || nowIso23();
    const targetAuditID = parseText(params.auditID) || undefined;
    const annotation = await methods.invoke("insight.append", {
      text,
      at,
      auditID: targetAuditID
    }, { clientID: context.clientID, role: "admin" });
    const auditID = appendInterventionAudit(projectDir, {
      command: "annotate",
      actor: context.clientID,
      sourceRole: context.role,
      payload: {
        text,
        at,
        targetAuditID
      }
    });
    publishGatewayEvent(runtime, "intervention.annotate", {
      at,
      auditID,
      targetAuditID,
      text
    });
    return {
      status: "recorded",
      auditID,
      annotation
    };
  });
  methods.register("trust.set_mode", async (params) => {
    const silentMinRaw = Number(params.silentMin);
    const modalMaxRaw = Number(params.modalMax);
    if (!Number.isFinite(silentMinRaw) || !Number.isFinite(modalMaxRaw)) {
      throw new Error("invalid_trust_mode_thresholds");
    }
    const next = writeTrustModeConfig(projectDir, {
      silentMin: silentMinRaw,
      modalMax: modalMaxRaw
    });
    runtime.nexus.trustMode = next;
    appendNexusInsight(runtime, {
      text: `Trust mode updated: silent>=${next.silentMin}, modal<=${next.modalMax}`
    });
    publishGatewayEvent(runtime, "trust.mode.update", {
      at: nowIso23(),
      mode: next
    });
    return {
      mode: next
    };
  });
  methods.register("psyche.mode.get", async () => {
    const mode = readPsycheModeConfig(projectDir);
    runtime.nexus.psycheMode = mode;
    return {
      mode,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, mode)
    };
  });
  methods.register("psyche.mode.set", async (params) => {
    const next = writePsycheModeConfig(projectDir, {
      resonanceEnabled: typeof params.resonanceEnabled === "boolean" ? Boolean(params.resonanceEnabled) : undefined,
      captureProbeEnabled: typeof params.captureProbeEnabled === "boolean" ? Boolean(params.captureProbeEnabled) : undefined
    });
    runtime.nexus.psycheMode = next;
    appendNexusInsight(runtime, {
      text: `守门员模式已更新：共鸣层=${next.resonanceEnabled ? "开启" : "关闭"}，截图核验=${next.captureProbeEnabled ? "开启" : "关闭"}`
    });
    publishGatewayEvent(runtime, "psyche.mode.update", {
      at: nowIso23(),
      mode: next,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, next)
    });
    return {
      mode: next,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, next)
    };
  });
  methods.register("learning.gate.get", async () => {
    const gate = readLearningGateConfig(projectDir);
    runtime.nexus.learningGate = gate;
    return { gate };
  });
  methods.register("learning.gate.set", async (params) => {
    const next = writeLearningGateConfig(projectDir, {
      candidateMode: params.candidateMode === "silent_audit" || params.candidateMode === "toast_gate" ? params.candidateMode : undefined,
      persistentRequiresApproval: typeof params.persistentRequiresApproval === "boolean" ? Boolean(params.persistentRequiresApproval) : undefined
    });
    runtime.nexus.learningGate = next;
    appendNexusInsight(runtime, {
      text: `学习闸门已更新：candidate=${next.candidateMode}, persistent_requires_approval=${next.persistentRequiresApproval ? "1" : "0"}`
    });
    publishGatewayEvent(runtime, "learning.gate.update", {
      at: nowIso23(),
      gate: next
    });
    return { gate: next };
  });
  methods.register("insight.append", async (params) => {
    const text = parseText(params.text);
    if (!text)
      throw new Error("invalid_insight_text");
    const at = parseText(params.at) || nowIso23();
    const auditID = parseText(params.auditID);
    appendNexusInsight(runtime, { text, at, auditID: auditID || undefined });
    publishGatewayEvent(runtime, "insight.append", {
      at,
      text,
      auditID: auditID || undefined
    });
    return {
      ok: true,
      at,
      text,
      auditID: auditID || undefined
    };
  });
  methods.register("nodes.register", async (params, context) => {
    const nodeID = parseText(params.nodeID);
    const deviceID = parseText(params.deviceID);
    if (!nodeID || !deviceID)
      throw new Error("invalid_nodes_register_args");
    const node = registerNode(projectDir, {
      nodeID,
      deviceID,
      type: params.type === "cli" || params.type === "desktop" || params.type === "mobile" || params.type === "browser" ? params.type : undefined,
      platform: parseText(params.platform) || process.platform,
      capabilities: Array.isArray(params.capabilities) ? params.capabilities.map(String) : [],
      token: parseText(params.token) || undefined,
      permissions: params.permissions && typeof params.permissions === "object" ? {
        screenRecording: typeof params.permissions.screenRecording === "boolean" ? Boolean(params.permissions.screenRecording) : undefined,
        accessibility: typeof params.permissions.accessibility === "boolean" ? Boolean(params.permissions.accessibility) : undefined,
        filesystem: params.permissions.filesystem === "none" || params.permissions.filesystem === "read" || params.permissions.filesystem === "full" ? params.permissions.filesystem : undefined,
        network: typeof params.permissions.network === "boolean" ? Boolean(params.permissions.network) : undefined
      } : undefined
    });
    const pair = createNodePairRequest(projectDir, { nodeID, deviceID });
    const ws = context.ws;
    if (ws)
      runtime.nodeSockets.set(nodeID, ws);
    return { node, pair };
  });
  methods.register("nodes.list", async () => listNodes(projectDir));
  methods.register("nodes.heartbeat", async (params) => {
    const nodeID = parseText(params.nodeID);
    if (!nodeID)
      throw new Error("invalid_node_id");
    const node = touchNodeHeartbeat(projectDir, nodeID);
    if (!node)
      throw new Error("node_not_found");
    return node;
  });
  methods.register("nodes.token.issue", async (params) => {
    const nodeID = parseText(params.nodeID);
    if (!nodeID)
      throw new Error("invalid_node_id");
    const issued = issueNodeToken(projectDir, nodeID);
    if (!issued)
      throw new Error("node_not_found");
    return issued;
  });
  methods.register("nodes.status", async () => ({
    nodes: listNodes(projectDir),
    pendingPairs: listNodePairs(projectDir, "pending")
  }));
  methods.register("nodes.describe", async (params) => {
    const nodeID = parseText(params.nodeID);
    if (!nodeID)
      throw new Error("invalid_node_id");
    return describeNode(projectDir, nodeID);
  });
  methods.register("nodes.pair.list", async (params) => {
    if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
      return listNodePairs(projectDir, params.status);
    }
    return listNodePairs(projectDir);
  });
  methods.register("nodes.pair.approve", async (params) => {
    const pairID = parseText(params.pairID);
    if (!pairID)
      throw new Error("invalid_pair_id");
    return resolveNodePair(projectDir, pairID, "approved");
  });
  methods.register("nodes.pair.reject", async (params) => {
    const pairID = parseText(params.pairID);
    if (!pairID)
      throw new Error("invalid_pair_id");
    return resolveNodePair(projectDir, pairID, "rejected");
  });
  methods.register("nodes.invoke", async (params) => {
    const nodeID = parseText(params.nodeID);
    const capability = parseText(params.capability);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || undefined;
    const args = params.args && typeof params.args === "object" ? params.args : {};
    if (!nodeID || !capability)
      throw new Error("invalid_nodes_invoke_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "desktop_control");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "node_invoke",
      patterns: [
        `nodeId=${nodeID}`,
        `cap=${capability}`,
        `args_sha256=${hashText2(JSON.stringify(args))}`
      ]
    });
    if (!token.ok)
      throw new Error(`approval_required:${token.reason}`);
    const invoke = createInvokeRequest(projectDir, { nodeID, capability, args });
    markInvokeSent(projectDir, invoke.id);
    const nodeSocket = runtime.nodeSockets.get(nodeID);
    if (nodeSocket) {
      nodeSocket.send(JSON.stringify(toEventFrame({
        event: "node.invoke.request",
        payload: invoke,
        stateVersion: { gateway: runtime.stateVersion }
      })));
    }
    return invoke;
  });
  methods.register("nodes.invoke.result", async (params) => {
    const invokeID = parseText(params.invokeID);
    if (!invokeID)
      throw new Error("invalid_invoke_id");
    return resolveInvokeResult(projectDir, invokeID, {
      ok: Boolean(params.ok),
      result: params.result && typeof params.result === "object" ? params.result : undefined,
      error: parseText(params.error) || undefined
    });
  });
  methods.register("devices.list", async () => listDevices(projectDir));
  methods.register("skills.status", async () => ({
    enabled: listEnabledSkills(projectDir),
    discovered: discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? [])
  }));
  methods.register("miya.sync.list", async () => listEcosystemBridge(projectDir));
  methods.register("miya.sync.diff", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    if (!sourcePackID)
      throw new Error("invalid_source_pack_id");
    return diffSourcePack(projectDir, sourcePackID);
  });
  methods.register("miya.sync.pull", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || undefined;
    if (!sourcePackID)
      throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, "action=pull"]
    });
    if (!token.ok)
      throw new Error(`approval_required:${token.reason}`);
    return pullSourcePack(projectDir, sourcePackID);
  });
  methods.register("miya.sync.apply", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const revision = parseText(params.revision) || undefined;
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || undefined;
    if (!sourcePackID)
      throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, `revision=${revision ?? "latest"}`]
    });
    if (!token.ok)
      throw new Error(`approval_required:${token.reason}`);
    return applySourcePack(projectDir, sourcePackID, { revision });
  });
  methods.register("miya.sync.rollback", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || undefined;
    if (!sourcePackID)
      throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, "action=rollback"]
    });
    if (!token.ok)
      throw new Error(`approval_required:${token.reason}`);
    return rollbackSourcePack(projectDir, sourcePackID);
  });
  methods.register("mcp.capabilities.list", async (params) => {
    const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
    const mcps = createBuiltinMcps(disabled);
    return {
      mcps: Object.entries(mcps).map(([name, config4]) => {
        const caps = "capabilities" in config4 ? config4.capabilities : undefined;
        return {
          name,
          type: config4.type,
          sampling: Boolean(caps?.sampling),
          mcpUi: Boolean(caps?.mcpUi),
          serviceExpose: Boolean(caps?.serviceExpose)
        };
      })
    };
  });
  methods.register("mcp.service.expose", async (params) => {
    const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
    return buildMcpServiceManifest(disabled);
  });
  methods.register("skills.enable", async (params) => {
    const skillID = parseText(params.skillID);
    if (!skillID)
      throw new Error("invalid_skill_id");
    const discovered = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []);
    const descriptor = discovered.find((item) => item.id === skillID || item.name === skillID);
    if (!descriptor)
      throw new Error(`skill_not_found:${skillID}`);
    if (!descriptor.gate.loadable) {
      throw new Error(`skill_not_loadable:${descriptor.gate.reasons.join("|")}`);
    }
    return { enabled: setSkillEnabled(projectDir, descriptor.id, true) };
  });
  methods.register("skills.disable", async (params) => {
    const skillID = parseText(params.skillID);
    if (!skillID)
      throw new Error("invalid_skill_id");
    return { enabled: setSkillEnabled(projectDir, skillID, false) };
  });
  methods.register("skills.install", async (params) => {
    const repo = parseText(params.repo);
    const targetName = parseText(params.targetName) || undefined;
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || undefined;
    if (!repo)
      throw new Error("invalid_repo");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`repo=${repo}`]
    });
    if (!token.ok)
      throw new Error(`approval_required:${token.reason}`);
    const root = path41.join(os5.homedir(), ".config", "opencode", "miya", "skills");
    fs41.mkdirSync(root, { recursive: true });
    const name = targetName || repo.split("/").filter(Boolean).pop()?.replace(/\.git$/i, "") || `skill-${Date.now().toString(36)}`;
    const target = path41.join(root, name);
    if (fs41.existsSync(target))
      return { ok: false, message: `target_exists:${target}` };
    const proc = spawnSync4("git", ["clone", "--depth", "1", repo, target], {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "pipe"]
    });
    if (proc.status !== 0) {
      return {
        ok: false,
        message: String(proc.stderr || "").trim() || "git_clone_failed"
      };
    }
    const installed = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []).find((item) => path41.resolve(item.dir) === path41.resolve(target));
    if (!installed) {
      fs41.rmSync(target, { recursive: true, force: true });
      return {
        ok: false,
        message: "installed_skill_invalid:manifest_not_found"
      };
    }
    if (installed.gate.reasons.includes("missing_permission_metadata")) {
      fs41.rmSync(target, { recursive: true, force: true });
      return {
        ok: false,
        message: "installed_skill_invalid:missing_permission_metadata"
      };
    }
    return {
      ok: true,
      message: "installed",
      dir: target,
      gate: installed.gate
    };
  });
  methods.register("skills.update", async (params) => {
    const dir = parseText(params.dir);
    const sessionID = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || undefined;
    if (!dir)
      throw new Error("invalid_dir");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID,
      permission: "skills_install",
      patterns: [`dir=${dir}`]
    });
    if (!token.ok)
      throw new Error(`approval_required:${token.reason}`);
    const proc = spawnSync4("git", ["-C", dir, "pull", "--ff-only"], {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "pipe"]
    });
    if (proc.status !== 0) {
      return {
        ok: false,
        message: String(proc.stderr || "").trim() || "git_pull_failed"
      };
    }
    return {
      ok: true,
      message: String(proc.stdout || "").trim() || "updated"
    };
  });
  methods.register("media.ingest", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    const source = parseText(params.source);
    const mimeType = parseText(params.mimeType);
    const fileName = parseText(params.fileName);
    if (!source || !mimeType || !fileName)
      throw new Error("invalid_media_ingest_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (params.kind !== "image" && params.kind !== "audio" && params.kind !== "video" && params.kind !== "file") {
      throw new Error("invalid_media_kind");
    }
    return ingestMedia(projectDir, {
      source,
      kind: params.kind,
      mimeType,
      fileName,
      contentBase64: parseText(params.contentBase64) || undefined,
      sizeBytes: typeof params.sizeBytes === "number" ? Number(params.sizeBytes) : undefined,
      ttlHours: typeof params.ttlHours === "number" ? Number(params.ttlHours) : undefined,
      metadata: params.metadata && typeof params.metadata === "object" ? params.metadata : undefined
    });
  });
  methods.register("media.get", async (params) => {
    const mediaID = parseText(params.mediaID);
    if (!mediaID)
      throw new Error("invalid_media_id");
    return getMediaItem(projectDir, mediaID);
  });
  methods.register("media.gc.run", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return runMediaGc(projectDir);
  });
  methods.register("media.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return listMediaItems(projectDir, limit);
  });
  methods.register("voice.status", async () => readVoiceState(projectDir));
  methods.register("voice.wake.enable", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      enabled: true,
      wakeWordEnabled: true
    });
  });
  methods.register("voice.wake.disable", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      wakeWordEnabled: false
    });
  });
  methods.register("voice.talk.start", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      enabled: true,
      talkMode: true,
      routeSessionID: parseText(params.sessionID) || readVoiceState(projectDir).routeSessionID
    });
  });
  methods.register("voice.talk.stop", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      talkMode: false
    });
  });
  methods.register("voice.input.ingest", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const mediaID = parseText(params.mediaID) || undefined;
    const source = parseText(params.source) === "wake" || parseText(params.source) === "talk" || parseText(params.source) === "media" ? parseText(params.source) : "manual";
    const language = parseText(params.language) || undefined;
    const speakerHint = parseText(params.speakerHint) || undefined;
    const speakerScore = typeof params.speakerScore === "number" ? Number(params.speakerScore) : undefined;
    const mediaPath = mediaID ? getMediaItem(projectDir, mediaID)?.localPath : undefined;
    const voiceprint = await verifyVoiceprintWithLocalModel(projectDir, {
      mediaPath,
      speakerHint,
      speakerScore
    });
    const mode = voiceprint.mode;
    setInteractionMode(projectDir, mode);
    if (mode !== "owner") {
      transitionSafetyState(projectDir, {
        source: "speaker_gate",
        reason: `speaker_mode_${mode}`,
        domains: {
          outbound_send: "paused",
          desktop_control: "paused",
          memory_read: "paused"
        }
      });
    }
    let text = parseText(params.text);
    if (!text && mediaID) {
      const media = getMediaItem(projectDir, mediaID);
      const transcript = media?.metadata?.transcript;
      text = typeof transcript === "string" && transcript.trim() ? transcript.trim() : `[media:${mediaID}]`;
    }
    if (!text)
      throw new Error("invalid_voice_input");
    if (mode === "guest") {
      const guestReply = "不好意思，我现在只能听主人的指令哦，但我可以陪你聊天。";
      appendGuestConversation(projectDir, {
        text,
        source,
        sessionID: parseText(params.sessionID) || "main"
      });
      return {
        item: appendVoiceHistory(projectDir, {
          text,
          source,
          language,
          mediaID
        }),
        routed: {
          delivered: false,
          queued: false,
          reason: "guest_mode_restricted"
        },
        mode,
        voiceprint,
        reply: guestReply,
        voice: readVoiceState(projectDir)
      };
    }
    const item = appendVoiceHistory(projectDir, {
      text,
      source,
      language,
      mediaID
    });
    const voice = readVoiceState(projectDir);
    const targetSessionID = parseText(params.sessionID) || voice.routeSessionID || "main";
    const routed = await routeSessionMessage(projectDir, {
      sessionID: targetSessionID,
      text,
      source: `voice:${source}`
    });
    return {
      item,
      routed,
      mode,
      voiceprint,
      voice: readVoiceState(projectDir)
    };
  });
  methods.register("voice.history.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return readVoiceState(projectDir).history.slice(0, limit);
  });
  methods.register("voice.history.clear", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_delete");
    return clearVoiceHistory(projectDir);
  });
  methods.register("canvas.status", async () => {
    const state = readCanvasState(projectDir);
    return {
      activeDocID: state.activeDocID,
      docs: listCanvasDocs(projectDir),
      events: state.events.slice(0, 100)
    };
  });
  methods.register("canvas.list", async () => listCanvasDocs(projectDir));
  methods.register("canvas.get", async (params) => {
    const docID = parseText(params.docID);
    if (!docID)
      throw new Error("invalid_doc_id");
    return getCanvasDoc(projectDir, docID);
  });
  methods.register("canvas.open", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    const title = parseText(params.title);
    const type = parseText(params.type);
    const content = parseText(params.content);
    if (!title)
      throw new Error("invalid_canvas_title");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (type && type !== "text" && type !== "markdown" && type !== "json" && type !== "html") {
      throw new Error("invalid_canvas_type");
    }
    const docType = type === "text" || type === "markdown" || type === "json" || type === "html" ? type : undefined;
    return openCanvasDoc(projectDir, {
      title,
      type: docType,
      content,
      actor: parseText(params.actor) || "gateway"
    });
  });
  methods.register("canvas.render", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    const docID = parseText(params.docID);
    const content = parseText(params.content);
    if (!docID || !content)
      throw new Error("invalid_canvas_render_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return renderCanvasDoc(projectDir, {
      docID,
      content,
      merge: Boolean(params.merge),
      actor: parseText(params.actor) || "gateway"
    });
  });
  methods.register("canvas.close", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    const docID = parseText(params.docID);
    if (!docID)
      throw new Error("invalid_doc_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return closeCanvasDoc(projectDir, docID, parseText(params.actor) || "gateway");
  });
  methods.register("companion.status", async () => readCompanionProfile(projectDir));
  methods.register("companion.wizard.start", async (params) => {
    const sessionId = parseText(params.sessionID) || "wizard:companion";
    const session = upsertSession(projectDir, {
      id: "wizard:companion",
      kind: "wizard",
      groupId: "wizard:companion",
      title: "Companion Onboarding",
      routingSessionID: "main",
      agent: "1-task-manager"
    });
    const profile = readCompanionProfile(projectDir);
    const forceReset = Boolean(params.forceReset);
    const wizard = !forceReset && !isCompanionWizardEmpty(projectDir, sessionId) ? readCompanionWizardState(projectDir, sessionId) : startCompanionWizard(projectDir, {
      sessionId,
      forceReset
    });
    return {
      session,
      profile,
      wizard,
      checklist: wizardChecklist(wizard),
      state: wizard.state,
      message: wizardPromptByState(wizard.state),
      instruction: "将照片拖拽到聊天中"
    };
  });
  methods.register("companion.wizard.status", async (params) => {
    const wizard = readCompanionWizardState(projectDir, parseText(params.sessionID) || "main");
    return {
      wizard,
      checklist: wizardChecklist(wizard),
      prompt: wizardPromptByState(wizard.state)
    };
  });
  methods.register("companion.wizard.photos.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const mediaIDs = Array.isArray(params.photoMediaIDs) ? params.photoMediaIDs.map(String) : Array.isArray(params.imageMediaIDs) ? params.imageMediaIDs.map(String) : [];
    const sessionId = parseText(params.sessionID) || "main";
    const { state, job } = submitWizardPhotos(projectDir, { mediaIDs, sessionId });
    return {
      state: state.state,
      message: "收到照片，开始训练图像模型...",
      jobId: job.id,
      estimatedTime: job.estimatedTime,
      fallbackStrategy: job.fallbackStrategy,
      checklist: wizardChecklist(state)
    };
  });
  methods.register("companion.wizard.voice.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const mediaID = parseText(params.mediaID) || parseText(params.audioMediaID);
    if (!mediaID)
      throw new Error("invalid_voice_media_id");
    const sessionId = parseText(params.sessionID) || "main";
    const { state, job } = submitWizardVoice(projectDir, { mediaID, sessionId });
    return {
      state: state.state,
      message: "收到语音样本，开始训练声音模型...",
      jobId: job.id,
      estimatedTime: job.estimatedTime,
      checklist: wizardChecklist(state)
    };
  });
  methods.register("companion.wizard.personality.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const personalityText = parseText(params.personalityText);
    const sessionId = parseText(params.sessionID) || "main";
    const wizard = submitWizardPersonality(projectDir, {
      personalityText,
      sessionId
    });
    patchCompanionProfile(projectDir, {
      onboardingCompleted: true
    });
    return {
      state: wizard.state,
      message: WIZARD_PROMPT_DONE,
      personaPreview: wizard.assets.personalityText.slice(0, 120),
      checklist: wizardChecklist(wizard)
    };
  });
  methods.register("companion.wizard.cancel", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const sessionId = parseText(params.sessionID) || "main";
    const daemon = getMiyaClient(projectDir);
    const state = readCompanionWizardState(projectDir, sessionId);
    const cancelRequests = [];
    for (const job of state.jobs) {
      if (job.status === "queued" || job.status === "training") {
        cancelRequests.push(daemon.requestTrainingCancel(job.id));
      }
    }
    if (cancelRequests.length > 0) {
      await Promise.allSettled(cancelRequests);
    }
    const canceled = cancelCompanionWizardTraining(projectDir, sessionId);
    return {
      state: canceled.state,
      checklist: wizardChecklist(canceled),
      message: WIZARD_CANCELLED_MESSAGE
    };
  });
  methods.register("companion.wizard.submit", async (params) => {
    if (Array.isArray(params.photoMediaIDs) || Array.isArray(params.imageMediaIDs)) {
      return invokeGatewayMethod(projectDir, runtime, "companion.wizard.photos.submit", params, { clientID: "gateway", role: "admin" });
    }
    if (typeof params.mediaID === "string" || typeof params.audioMediaID === "string") {
      return invokeGatewayMethod(projectDir, runtime, "companion.wizard.voice.submit", params, { clientID: "gateway", role: "admin" });
    }
    if (typeof params.personalityText === "string") {
      return invokeGatewayMethod(projectDir, runtime, "companion.wizard.personality.submit", params, { clientID: "gateway", role: "admin" });
    }
    throw new Error("invalid_wizard_submit_payload");
  });
  methods.register("companion.wizard.tick", async () => {
    await runWizardTrainingWorker(projectDir, runtime);
    return {
      wizard: readCompanionWizardState(projectDir, "main")
    };
  });
  methods.register("companion.wizard.progress.get", async (params) => {
    const jobID = parseText(params.jobId) || parseText(params.jobID);
    if (!jobID)
      throw new Error("invalid_job_id");
    const job = getWizardJobById(projectDir, jobID);
    if (!job)
      throw new Error("job_not_found");
    const status = job.status === "queued" ? "pending" : job.status;
    const nextStep = status === "completed" || status === "degraded" ? readCompanionWizardState(projectDir, job.sessionId).state : undefined;
    return {
      status,
      progress: job.progress,
      currentTier: job.currentTier,
      message: job.message ?? "",
      nextStep,
      checkpointPath: job.checkpointPath,
      sessionId: job.sessionId
    };
  });
  methods.register("companion.profile.update", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    return patchCompanionProfile(projectDir, {
      enabled: typeof params.enabled === "boolean" ? Boolean(params.enabled) : undefined,
      onboardingCompleted: typeof params.onboardingCompleted === "boolean" ? Boolean(params.onboardingCompleted) : undefined,
      name: parseText(params.name) || undefined,
      persona: parseText(params.persona) || undefined,
      relationship: parseText(params.relationship) || undefined,
      style: parseText(params.style) || undefined
    });
  });
  methods.register("companion.memory.add", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    const fact = parseText(params.fact);
    if (!fact)
      throw new Error("invalid_memory_fact");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const created = upsertCompanionMemoryVector(projectDir, {
      text: fact,
      source: "conversation",
      activate: false,
      sourceType: parseText(params.sourceType) === "direct_correction" ? "direct_correction" : "conversation"
    });
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    const learningGate = runtime.nexus.learningGate;
    return {
      memory: created,
      stage: created.status,
      learningGate: {
        stage: "candidate",
        approvalMode: learningGate.candidateMode,
        interruptsUser: false
      },
      needsCorrectionWizard: Boolean(created.conflictWizardID),
      message: created.conflictWizardID ? "memory_pending_conflict_requires_correction_wizard" : "memory_pending_confirmation_required",
      profile
    };
  });
  methods.register("companion.memory.list", async () => {
    requireOwnerMode(projectDir);
    return readCompanionProfile(projectDir).memoryFacts;
  });
  methods.register("companion.memory.pending.list", async () => {
    requireOwnerMode(projectDir);
    return listPendingCompanionMemoryVectors(projectDir);
  });
  methods.register("companion.memory.corrections.list", async () => {
    requireOwnerMode(projectDir);
    return listCompanionMemoryCorrections(projectDir);
  });
  methods.register("companion.memory.confirm", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText(params.memoryID);
    const sessionID = parseText(params.sessionID) || "main";
    if (!memoryID)
      throw new Error("invalid_memory_id");
    if (runtime.nexus.learningGate.persistentRequiresApproval) {
      const ticket = resolveApprovalTicket({
        projectDir,
        sessionID,
        permission: "memory_write",
        patterns: [
          "memory_stage=persistent",
          `memory_id=${memoryID}`,
          "action=confirm"
        ]
      });
      if (!ticket.ok)
        throw new Error(`approval_required:${ticket.reason}`);
    }
    const confirm = typeof params.confirm === "boolean" ? Boolean(params.confirm) : true;
    const updated = confirmCompanionMemoryVector(projectDir, {
      memoryID,
      confirm,
      supersedeConflicts: typeof params.supersedeConflicts === "boolean" ? Boolean(params.supersedeConflicts) : true
    });
    if (!updated)
      throw new Error("memory_not_found");
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return {
      memory: updated,
      stage: updated.status,
      learningGate: {
        stage: "persistent",
        approvalMode: runtime.nexus.learningGate.persistentRequiresApproval ? "modal_approval" : "toast_gate",
        interruptsUser: runtime.nexus.learningGate.persistentRequiresApproval
      },
      profile
    };
  });
  methods.register("companion.memory.update", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText(params.memoryID);
    if (!memoryID)
      throw new Error("invalid_memory_id");
    const updated = updateCompanionMemoryVector(projectDir, {
      memoryID,
      text: parseText(params.text) || undefined,
      memoryKind: parseText(params.memoryKind) === "Fact" || parseText(params.memoryKind) === "Insight" || parseText(params.memoryKind) === "UserPreference" ? parseText(params.memoryKind) : undefined,
      confidence: typeof params.confidence === "number" && Number.isFinite(params.confidence) ? Number(params.confidence) : undefined,
      tier: parseText(params.tier) === "L1" || parseText(params.tier) === "L2" || parseText(params.tier) === "L3" ? parseText(params.tier) : undefined,
      status: parseText(params.status) === "pending" || parseText(params.status) === "active" || parseText(params.status) === "superseded" ? parseText(params.status) : undefined
    });
    if (!updated)
      throw new Error("memory_not_found");
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return { memory: updated, profile };
  });
  methods.register("companion.memory.archive", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText(params.memoryID);
    if (!memoryID)
      throw new Error("invalid_memory_id");
    const archived = typeof params.archived === "boolean" ? Boolean(params.archived) : true;
    const updated = archiveCompanionMemoryVector(projectDir, {
      memoryID,
      archived
    });
    if (!updated)
      throw new Error("memory_not_found");
    return { memory: updated };
  });
  methods.register("companion.memory.search", async (params) => {
    requireOwnerMode(projectDir);
    const query = parseText(params.query);
    if (!query)
      throw new Error("invalid_memory_query");
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(20, Number(params.limit)) : 5;
    const threshold = typeof params.threshold === "number" && params.threshold >= 0 ? Number(params.threshold) : undefined;
    const recencyHalfLifeDays = typeof params.recencyHalfLifeDays === "number" && params.recencyHalfLifeDays > 0 ? Number(params.recencyHalfLifeDays) : undefined;
    return searchCompanionMemoryVectors(projectDir, query, limit, {
      threshold,
      recencyHalfLifeDays
    });
  });
  methods.register("companion.memory.decay", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const halfLifeDays = typeof params.halfLifeDays === "number" && params.halfLifeDays > 0 ? Number(params.halfLifeDays) : 30;
    return decayCompanionMemoryVectors(projectDir, halfLifeDays);
  });
  methods.register("companion.memory.vector.list", async () => {
    requireOwnerMode(projectDir);
    return listCompanionMemoryVectors(projectDir);
  });
  methods.register("miya.memory.sqlite.stats", async () => {
    requireOwnerMode(projectDir);
    return getCompanionMemorySqliteStats(projectDir);
  });
  methods.register("miya.memory.log.append", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    const text = parseText(params.text);
    if (!text)
      throw new Error("invalid_memory_log_text");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const senderRaw = parseText(params.sender);
    const sender = senderRaw === "assistant" || senderRaw === "system" ? senderRaw : "user";
    const entry2 = appendShortTermMemoryLog(projectDir, {
      sessionID: parseText(params.sessionID) || "main",
      sender,
      text,
      at: parseText(params.at) || undefined,
      messageID: parseText(params.messageID) || undefined
    });
    return {
      entry: entry2,
      learningGate: {
        stage: "ephemeral",
        approvalMode: "silent_audit",
        interruptsUser: false
      }
    };
  });
  methods.register("miya.memory.reflect", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const force = typeof params.force === "boolean" ? Boolean(params.force) : false;
    const minLogs = typeof params.minLogs === "number" && params.minLogs > 0 ? Number(params.minLogs) : 1;
    const maxLogs = typeof params.maxLogs === "number" && params.maxLogs > 0 ? Math.min(500, Number(params.maxLogs)) : 50;
    const cooldownMinutes = typeof params.cooldownMinutes === "number" && params.cooldownMinutes >= 0 ? Number(params.cooldownMinutes) : 0;
    const idempotencyKey = parseText(params.idempotencyKey) || undefined;
    const result = reflectCompanionMemory(projectDir, {
      force,
      minLogs,
      maxLogs,
      cooldownMinutes,
      idempotencyKey
    });
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return {
      ...result,
      learningGate: {
        stage: "candidate",
        approvalMode: runtime.nexus.learningGate.candidateMode,
        interruptsUser: false
      },
      profile
    };
  });
  methods.register("companion.asset.add", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    const type = parseText(params.type);
    const pathOrUrl = parseText(params.pathOrUrl);
    if (!pathOrUrl)
      throw new Error("invalid_asset_path");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (type !== "image" && type !== "audio")
      throw new Error("invalid_asset_type");
    return addCompanionAsset(projectDir, {
      type,
      pathOrUrl,
      label: parseText(params.label) || undefined
    });
  });
  methods.register("companion.asset.list", async () => readCompanionProfile(projectDir).assets);
  methods.register("companion.reset", async (params) => {
    const policyHash = parseText(params.policyHash) || undefined;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_delete");
    const profile = resetCompanionProfile(projectDir);
    const wizard = resetCompanionWizard(projectDir);
    return { profile, wizard };
  });
  methods.register("companion.intent.handle", async (params) => {
    const text = parseText(params.text);
    if (!text)
      throw new Error("invalid_intent_text");
    const channel = parseChannel(params.channel) ?? "wechat";
    const destination = parseText(params.destination);
    const sessionID = parseText(params.sessionID) || "main";
    const intent = detectMultimodalIntent(text);
    if (intent.type === "selfie") {
      const generated = await generateImage(projectDir, {
        prompt: intent.prompt,
        model: "local:flux.1-schnell",
        registerAsCompanionAsset: true
      });
      if (!destination) {
        return {
          intent: "selfie",
          sent: false,
          mediaID: generated.media.id,
          path: generated.media.localPath,
          message: "selfie_generated_destination_missing"
        };
      }
      const send = await sendChannelMessageGuarded(projectDir, runtime, {
        channel,
        destination,
        text: "给你一张我的自拍",
        mediaPath: generated.media.localPath,
        sessionID,
        policyHash: currentPolicyHash(projectDir),
        outboundCheck: {
          archAdvisorApproved: true,
          intent: "reply"
        }
      });
      return {
        intent: "selfie",
        sent: send.sent,
        send,
        mediaID: generated.media.id,
        path: generated.media.localPath
      };
    }
    if (intent.type === "voice_to_friend") {
      const resolvedDestination = destination || intent.friend;
      if (!resolvedDestination)
        throw new Error("voice_destination_missing");
      const voice = await synthesizeVoiceOutput(projectDir, {
        text,
        voice: "companion",
        model: "local:gpt-sovits-v2pro",
        format: "wav",
        registerAsCompanionAsset: true
      });
      const send = await sendChannelMessageGuarded(projectDir, runtime, {
        channel: "wechat",
        destination: resolvedDestination,
        text: "语音消息已生成",
        mediaPath: voice.media.localPath,
        sessionID,
        policyHash: currentPolicyHash(projectDir),
        outboundCheck: {
          archAdvisorApproved: true,
          intent: "reply"
        }
      });
      return {
        intent: "voice_to_friend",
        friend: resolvedDestination,
        sent: send.sent,
        send,
        mediaID: voice.media.id,
        path: voice.media.localPath
      };
    }
    return { intent: "unknown", message: "no_multimodal_intent_matched" };
  });
  methods.register("daemon.vram.budget", async (params) => {
    const scheduler = getResourceScheduler(projectDir);
    const modelID = parseText(params.modelID) || "local:flux.1-schnell";
    const kindRaw = parseText(params.kind);
    const kind = kindRaw === "image.generate" || kindRaw === "vision.analyze" || kindRaw === "voice.tts" || kindRaw === "voice.asr" || kindRaw === "training.image" || kindRaw === "training.voice" || kindRaw === "shell.exec" ? kindRaw : "generic";
    const requestVram = typeof params.vramMB === "number" ? Number(params.vramMB) : 1024;
    const modelVram = typeof params.modelVramMB === "number" ? Number(params.modelVramMB) : 2048;
    const snapshot = scheduler.snapshot();
    const budget = calculateVramBudget({
      snapshot,
      task: {
        taskID: kind,
        taskVramMB: requestVram
      },
      models: [{ modelID, vramMB: modelVram, required: true }]
    });
    return {
      snapshot,
      budget,
      swapAction: decideModelSwapAction({
        currentModelID: snapshot.loadedModels[0]?.modelID,
        targetModelID: modelID,
        budget
      })
    };
  });
  return methods;
}
function normalizeNodeHeaders(headers) {
  const normalized = {};
  for (const [key, value] of Object.entries(headers)) {
    if (typeof value === "string") {
      normalized[key] = value;
      continue;
    }
    if (Array.isArray(value) && value.length > 0) {
      normalized[key] = value.join(", ");
    }
  }
  return normalized;
}
function toNodeRequest(req, hostname5, port) {
  const hostHeader = typeof req.headers.host === "string" && req.headers.host.trim() ? req.headers.host.trim() : `${hostname5}:${port}`;
  const requestUrl = new URL(req.url || "/", `http://${hostHeader}`);
  return new Request(requestUrl, {
    method: req.method ?? "GET",
    headers: normalizeNodeHeaders(req.headers)
  });
}
async function sendNodeResponse(req, res, response) {
  res.statusCode = response.status;
  for (const [key, value] of response.headers.entries()) {
    res.setHeader(key, value);
  }
  if ((req.method ?? "GET").toUpperCase() === "HEAD") {
    res.end();
    return;
  }
  if (!response.body) {
    res.end();
    return;
  }
  const body = Buffer.from(await response.arrayBuffer());
  res.end(body);
}
function normalizeWsInput(message) {
  if (typeof message === "string")
    return message;
  if (Buffer.isBuffer(message))
    return message.toString("utf-8");
  if (Array.isArray(message))
    return Buffer.concat(message).toString("utf-8");
  return Buffer.from(message).toString("utf-8");
}
function reserveGatewayPort(hostname5, configuredPort) {
  if (configuredPort > 0) {
    return configuredPort;
  }
  const script = [
    "const net=require('node:net');",
    'const host=process.argv[1]||"127.0.0.1";',
    "const s=net.createServer();",
    "s.listen(0,host,()=>{",
    "const address=s.address();",
    "if(address&&typeof address==='object'){process.stdout.write(String(address.port));}",
    "s.close(()=>process.exit(0));",
    "});",
    "s.on('error',()=>process.exit(1));"
  ].join("");
  const probe = spawnSync4("node", ["-e", script, hostname5], {
    encoding: "utf-8",
    stdio: ["ignore", "pipe", "pipe"],
    windowsHide: true
  });
  if (probe.status !== 0) {
    throw new Error(`gateway_port_reservation_failed:${String(probe.stderr || "").trim()}`);
  }
  const reserved = Number(String(probe.stdout || "").trim());
  if (!Number.isFinite(reserved) || reserved <= 0) {
    throw new Error("gateway_port_reservation_invalid");
  }
  return Math.floor(reserved);
}
async function routeGatewayHttpRequest(projectDir, runtime, request, controlUi) {
  const url3 = new URL(request.url);
  if (url3.pathname === "/api/status") {
    return Response.json(buildSnapshot(projectDir, runtime), {
      headers: { "cache-control": "no-store" }
    });
  }
  const controlUiResponse = handleControlUiHttpRequest(request, controlUi);
  if (controlUiResponse) {
    const missingUiFallback = controlUiResponse.status === 503 && controlUi.root?.kind !== "resolved";
    if (missingUiFallback) {
      logControlUiFallback(projectDir, url3.pathname, controlUi, controlUiResponse.status);
    }
    if (!missingUiFallback)
      return controlUiResponse;
  }
  if (url3.pathname === "/webchat") {
    return new Response(renderWebChatHtml(), {
      headers: {
        "content-type": "text/html; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  if (url3.pathname.startsWith("/api/webhooks/")) {
    return new Response("HTTP control API disabled; use WebSocket RPC (/ws).", {
      status: 410,
      headers: {
        "content-type": "text/plain; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  if (url3.pathname === "/" || url3.pathname === "/index.html") {
    return new Response(renderConsoleHtml(buildSnapshot(projectDir, runtime)), {
      headers: {
        "content-type": "text/html; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  return new Response("Not Found", { status: 404 });
}
function ensureGatewayRunning(projectDir) {
  const existing = runtimes.get(projectDir);
  if (existing) {
    const owner2 = acquireGatewayOwner(projectDir);
    if (owner2.owned) {
      touchOwnerLock(projectDir);
    }
    log("[gateway] runtime already active; reused existing runtime", {
      projectDir,
      owner: describeOwnerLock(owner2.owner ?? null)
    });
    return syncGatewayState(projectDir, existing);
  }
  const owner = acquireGatewayOwner(projectDir);
  if (!owner.owned) {
    const state = readGatewayStateFile(projectDir);
    const ownerAlive = owner.owner ? isProcessAlive(owner.owner.pid) : false;
    const ownerFresh = owner.owner ? isOwnerLockFresh(owner.owner) : false;
    log("[gateway] owner lock held by another process", {
      projectDir,
      owner: describeOwnerLock(owner.owner ?? null),
      state: describeGatewayState(state)
    });
    if (state && owner.owner && state.pid !== owner.owner.pid) {
      clearGatewayStateFile(projectDir);
      log("[gateway] cleared stale gateway state file due to pid mismatch", {
        projectDir,
        statePid: state.pid,
        ownerPid: owner.owner.pid
      });
    }
    if (state && isProcessAlive(state.pid)) {
      log("[gateway] follower mode attached to existing owner state", {
        projectDir,
        state: describeGatewayState(state)
      });
      return state;
    }
    if (state && !isProcessAlive(state.pid)) {
      clearGatewayStateFile(projectDir);
      log("[gateway] removed dead gateway state pid", {
        projectDir,
        statePid: state.pid
      });
    }
    if (owner.owner && !ownerAlive) {
      const retry = acquireGatewayOwner(projectDir);
      if (!retry.owned) {
        log("[gateway] ownership reacquire failed after dead owner detected", {
          projectDir,
          previousOwner: describeOwnerLock(owner.owner),
          retryOwner: describeOwnerLock(retry.owner ?? null)
        });
        throw new Error("gateway_owned_by_other_process");
      }
      log("[gateway] ownership reacquired after dead owner detected", {
        projectDir,
        retryOwner: describeOwnerLock(retry.owner ?? null)
      });
    } else {
      log("[gateway] follower refused ownership takeover", {
        projectDir,
        ownerAlive,
        ownerFresh
      });
      throw new Error("gateway_owned_by_other_process");
    }
  }
  let runtime;
  const methods = new GatewayMethodRegistry;
  const controlUi = createControlUiRequestOptions(projectDir);
  const channelRuntime = new ChannelRuntime(projectDir, {
    onInbound: async (message) => {
      await onInboundMessage(projectDir, runtime, message);
    },
    onPairRequested: async () => {
      maybeBroadcast(projectDir, runtime);
    }
  });
  const listen = resolveGatewayListenOptions(projectDir);
  log("[gateway] creating runtime server", {
    projectDir,
    listen,
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
    controlUiRoot: controlUi.root?.kind ?? "unknown"
  });
  try {
    const port = reserveGatewayPort(listen.hostname, listen.port);
    const wsServer = new import_websocket_server.default({ noServer: true });
    const httpServer = createServer((req, res) => {
      (async () => {
        const request = toNodeRequest(req, listen.hostname, port);
        const response = await routeGatewayHttpRequest(projectDir, runtime, request, controlUi);
        await sendNodeResponse(req, res, response);
      })().catch((error92) => {
        log("[gateway] http request failed", {
          projectDir,
          error: error92 instanceof Error ? error92.message : String(error92)
        });
        if (!res.headersSent) {
          res.statusCode = 500;
          res.setHeader("content-type", "text/plain; charset=utf-8");
        }
        if (!res.writableEnded) {
          res.end("Internal Server Error");
        }
      });
    });
    httpServer.on("upgrade", (req, socket, head) => {
      const requestUrl = new URL(req.url || "/", `http://${req.headers.host || "127.0.0.1"}`);
      if (requestUrl.pathname !== "/ws") {
        socket.write(`HTTP/1.1 404 Not Found\r
\r
`);
        socket.destroy();
        return;
      }
      wsServer.handleUpgrade(req, socket, head, (ws) => {
        wsServer.emit("connection", ws, req);
      });
    });
    runtime = {
      startedAt: nowIso23(),
      server: {
        hostname: listen.hostname,
        port,
        httpServer,
        wsServer
      },
      methods,
      stateVersion: 1,
      controlUi,
      channelRuntime,
      outboundSendDedupe: new Map,
      wsClients: new Set,
      nodeSockets: new Map,
      wsMeta: new WeakMap,
      wizardTickTimer: undefined,
      ownerBeatTimer: undefined,
      memoryReflectTimer: undefined,
      wizardRunnerBusy: false,
      dependencyAssistHashes: new Set,
      daemonLauncherUnsubscribe: undefined,
      negotiationBudgets: new Map,
      nexus: {
        sessionId: "main",
        activeTool: undefined,
        permission: undefined,
        pendingTickets: 0,
        killSwitchMode: "off",
        insights: [],
        trust: undefined,
        trustMode: readTrustModeConfig(projectDir),
        psycheMode: readPsycheModeConfig(projectDir),
        learningGate: readLearningGateConfig(projectDir),
        guardianSafeHoldReason: undefined
      }
    };
    runtime.methods = createMethods(projectDir, runtime);
    wsServer.on("connection", (ws) => {
      runtime.wsClients.add(ws);
      ensureWsData(runtime, ws);
      ws.on("close", () => {
        const wsData = ensureWsData(runtime, ws);
        if (wsData.nodeID) {
          runtime.nodeSockets.delete(wsData.nodeID);
          markNodeDisconnected(projectDir, wsData.nodeID);
        }
        runtime.wsClients.delete(ws);
        runtime.wsMeta.delete(ws);
      });
      ws.on("message", async (input) => {
        const wsData = ensureWsData(runtime, ws);
        const parsed = parseIncomingFrame(normalizeWsInput(input));
        if (!parsed.frame) {
          ws.send(JSON.stringify(toResponseFrame({
            id: "invalid",
            ok: false,
            errorCode: "bad_request",
            errorMessage: parsed.error ?? "invalid_frame"
          })));
          return;
        }
        const frame = parsed.frame;
        if (frame.type === "ping") {
          ws.send(JSON.stringify(toPongFrame(frame.ts)));
          return;
        }
        if (frame.type === "hello") {
          const requiredToken = process.env.MIYA_GATEWAY_TOKEN;
          const incomingToken = frame.auth?.token;
          if (requiredToken && incomingToken !== requiredToken) {
            ws.send(JSON.stringify(toResponseFrame({
              id: "hello",
              ok: false,
              errorCode: "unauthorized",
              errorMessage: "invalid_gateway_token"
            })));
            ws.close();
            return;
          }
          wsData.authenticated = true;
          if (frame.clientID)
            wsData.clientID = frame.clientID;
          if (frame.role)
            wsData.role = frame.role;
          ws.send(JSON.stringify(toResponseFrame({
            id: "hello",
            ok: true,
            result: {
              clientID: wsData.clientID,
              role: wsData.role,
              methods: runtime.methods.list()
            }
          })));
          return;
        }
        if (!wsData.authenticated) {
          ws.send(JSON.stringify(toResponseFrame({
            id: frame.id,
            ok: false,
            errorCode: "unauthorized",
            errorMessage: "send_hello_with_auth_first"
          })));
          return;
        }
        if (frame.method === "gateway.subscribe") {
          wsData.subscriptions = new Set(Array.isArray(frame.params?.events) ? frame.params.events.map(String) : ["*"]);
          ws.send(JSON.stringify(toResponseFrame({
            id: frame.id,
            ok: true,
            result: {
              subscribed: [...wsData.subscriptions]
            }
          })));
          setTimeout(() => {
            try {
              ws.send(JSON.stringify(toEventFrame({
                event: "gateway.snapshot",
                payload: buildSnapshot(projectDir, runtime),
                stateVersion: { gateway: runtime.stateVersion }
              })));
            } catch {}
          }, 0);
          return;
        }
        if (frame.method === "nodes.register") {
          const nodeID = parseText(frame.params?.nodeID);
          if (nodeID) {
            wsData.nodeID = nodeID;
            runtime.nodeSockets.set(nodeID, ws);
          }
        }
        runtime.nexus.activeTool = frame.method;
        const frameSessionID = parseText(frame.params?.sessionID);
        if (frameSessionID) {
          runtime.nexus.sessionId = frameSessionID;
        }
        try {
          const result = await invokeGatewayMethod(projectDir, runtime, frame.method, frame.params ?? {}, {
            clientID: wsData.clientID,
            role: wsData.role,
            ws
          });
          ws.send(JSON.stringify(toResponseFrame({ id: frame.id, ok: true, result })));
          if (frame.method !== "gateway.status.get") {
            maybeBroadcast(projectDir, runtime);
          }
        } catch (error92) {
          const messageText = error92 instanceof Error ? error92.message : String(error92);
          ws.send(JSON.stringify(toResponseFrame({
            id: frame.id,
            ok: false,
            errorCode: messageText.startsWith("unknown_method:") ? "unknown_method" : "method_failed",
            errorMessage: messageText
          })));
        }
      });
    });
    httpServer.listen(port, listen.hostname);
  } catch (error92) {
    clearGatewayStateFile(projectDir);
    removeOwnerLock(projectDir);
    log("[gateway] failed to bind server", {
      projectDir,
      listen,
      error: error92 instanceof Error ? error92.message : String(error92)
    });
    throw error92;
  }
  runtimes.set(projectDir, runtime);
  runtime.wizardTickTimer = setInterval(() => {
    runWizardTrainingWorker(projectDir, runtime);
  }, 1200);
  runtime.ownerBeatTimer = setInterval(() => {
    touchOwnerLock(projectDir);
  }, 5000);
  runtime.memoryReflectTimer = setInterval(() => {
    const reflected = maybeAutoReflectCompanionMemory(projectDir, {
      idleMinutes: 5,
      minPendingLogs: 1,
      cooldownMinutes: 3,
      maxLogs: 120
    });
    if (reflected) {
      syncCompanionProfileMemoryFacts(projectDir);
    }
  }, 20000);
  runtime.daemonLauncherUnsubscribe = subscribeLauncherEvents(projectDir, (event) => {
    appendDaemonProgressAudit(projectDir, event);
    if (event.type === "job.progress") {
      publishGatewayEvent(runtime, "daemon.job_progress", event);
      const phase = String(event.payload?.phase ?? "");
      if (phase === "audio.filler") {
        publishGatewayEvent(runtime, "daemon.audio_filler", event);
      }
      const config3 = readConfig(projectDir);
      const notifyOnTerminal = config3.runtime?.notifications?.job_toast !== false;
      const status = String(event.payload?.status ?? "").trim().toLowerCase();
      if (notifyOnTerminal && (status === "completed" || status === "failed" || status === "degraded" || status === "canceled")) {
        publishGatewayEvent(runtime, "daemon.job_terminal", event);
      }
      return;
    }
    publishGatewayEvent(runtime, event.type, event);
  });
  runtime.channelRuntime.start();
  log("[gateway] runtime started", {
    projectDir,
    state: toGatewayState(projectDir, runtime),
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir))
  });
  return syncGatewayState(projectDir, runtime);
}
function createGatewayTools(ctx) {
  const miya_gateway_start = tool({
    description: "Start Miya Gateway and persist .opencode/miya/gateway.json.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      const state = ensureGatewayRunning(ctx.directory);
      const persisted = readPersistedAgentRuntime(ctx.directory);
      const owner = ownerSummary(ctx.directory);
      const healthy = await probeGatewayAlive(state.url, 1000);
      return [
        formatGatewayStateWithRuntime(state, owner.ownerPID, owner.isOwner, persisted.activeAgentId, persisted.revision),
        `gateway_healthy=${healthy}`
      ].join(`
`);
    }
  });
  const miya_gateway_status = tool({
    description: "Read current Miya Gateway state.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      const state = ensureGatewayRunning(ctx.directory);
      const persisted = readPersistedAgentRuntime(ctx.directory);
      const owner = ownerSummary(ctx.directory);
      const healthy = await probeGatewayAlive(state.url, 1000);
      return [
        formatGatewayStateWithRuntime(state, owner.ownerPID, owner.isOwner, persisted.activeAgentId, persisted.revision),
        `gateway_healthy=${healthy}`
      ].join(`
`);
    }
  });
  const miya_gateway_doctor = tool({
    description: "Run control-plane doctor checks.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      ensureGatewayRunning(ctx.directory);
      const runtime = runtimes.get(ctx.directory);
      if (!runtime)
        return "doctor_failed=gateway_unavailable";
      const issues = buildSnapshot(ctx.directory, runtime).doctor.issues;
      if (issues.length === 0)
        return `doctor=ok
issues=0`;
      return [
        "doctor=issues",
        `issues=${issues.length}`,
        ...issues.map((issue3) => `- [${issue3.severity}] ${issue3.code} | ${issue3.message}`)
      ].join(`
`);
    }
  });
  const miya_gateway_shutdown = tool({
    description: "Stop Miya Gateway runtime.",
    args: {},
    async execute() {
      const result = stopGateway(ctx.directory);
      if (!result.stopped)
        return `stopped=false
reason=not_running`;
      return [
        "stopped=true",
        `url=${result.previous?.url ?? ""}`,
        `port=${result.previous?.port ?? 0}`
      ].join(`
`);
    }
  });
  const miya_memory_reflect = tool({
    description: "Trigger Miya memory reflection (Memory Consolidation Loop) and sync long-term graph.",
    args: {
      force: z2.boolean().optional().describe("Force reflection even with low pending logs"),
      minLogs: z2.number().optional().describe("Minimum pending logs required"),
      maxLogs: z2.number().optional().describe("Maximum logs processed in this run"),
      cooldownMinutes: z2.number().optional().describe("Cooldown window in minutes"),
      idempotencyKey: z2.string().optional().describe("Optional idempotency key")
    },
    async execute(args) {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      ensureGatewayRunning(ctx.directory);
      const runtime = runtimes.get(ctx.directory);
      if (!runtime)
        throw new Error("gateway_runtime_unavailable");
      const result = await invokeGatewayMethod(ctx.directory, runtime, "miya.memory.reflect", {
        policyHash: currentPolicyHash(ctx.directory),
        force: Boolean(args.force),
        minLogs: typeof args.minLogs === "number" ? Math.floor(args.minLogs) : undefined,
        maxLogs: typeof args.maxLogs === "number" ? Math.floor(args.maxLogs) : undefined,
        cooldownMinutes: typeof args.cooldownMinutes === "number" ? Number(args.cooldownMinutes) : undefined,
        idempotencyKey: typeof args.idempotencyKey === "string" && args.idempotencyKey.trim().length > 0 ? args.idempotencyKey.trim() : undefined
      }, { clientID: "gateway-tool", role: "admin" });
      return JSON.stringify(result, null, 2);
    }
  });
  return {
    miya_gateway_start,
    miya_gateway_status,
    miya_gateway_doctor,
    miya_gateway_shutdown,
    miya_memory_reflect
  };
}
function startGatewayWithLog(projectDir) {
  const stateFile3 = gatewayFile(projectDir);
  const ownerFile = gatewayOwnerLockFile(projectDir);
  log("[gateway] startup requested", {
    projectDir,
    pid: process.pid,
    stateFile: stateFile3,
    ownerFile,
    existingState: describeGatewayState(readGatewayStateFile(projectDir)),
    existingOwner: describeOwnerLock(readGatewayOwnerLock(projectDir))
  });
  try {
    const state = ensureGatewayRunning(projectDir);
    const owner = ownerSummary(projectDir);
    log("[gateway] started", {
      ...state,
      owner
    });
    probeGatewayAlive(state.url, 1500).then((healthy) => {
      log("[gateway] startup health probe result", {
        projectDir,
        url: state.url,
        healthy
      });
    }).catch((error92) => {
      log("[gateway] startup health probe failed", {
        projectDir,
        url: state.url,
        error: error92 instanceof Error ? error92.message : String(error92)
      });
    });
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    if (message === "gateway_owned_by_other_process") {
      const owner = readGatewayOwnerLock(projectDir);
      const state = readGatewayStateFile(projectDir);
      log("[gateway] follower mode: owner is another process", {
        projectDir,
        owner: describeOwnerLock(owner),
        state: describeGatewayState(state)
      });
      const timerKey = projectDir;
      if (!followerRecoveryTimers.has(timerKey)) {
        const timer = setTimeout(() => {
          followerRecoveryTimers.delete(timerKey);
          try {
            const recovered = ensureGatewayRunning(projectDir);
            log("[gateway] follower delayed recovery succeeded", {
              projectDir,
              state: recovered
            });
          } catch (recoveryError) {
            log("[gateway] follower delayed recovery still blocked", {
              projectDir,
              error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError),
              owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
              state: describeGatewayState(readGatewayStateFile(projectDir))
            });
          }
        }, 6000);
        followerRecoveryTimers.set(timerKey, timer);
      }
      return;
    }
    log("[gateway] failed to start", {
      projectDir,
      error: message,
      owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
      state: describeGatewayState(readGatewayStateFile(projectDir))
    });
  }
}
var z2, runtimes, dependencies, ownerTokens, controlUiFallbackLoggedAtByDir, followerRecoveryTimers, DEFAULT_TRUST_MODE, DEFAULT_PSYCHE_MODE, DEFAULT_LEARNING_GATE, WIZARD_PROMPT_PHOTOS = "给我展示我应该是什么样子。发送1到5张照片。", WIZARD_PROMPT_VOICE = "我应该用什么声音？录音或发送文件。", WIZARD_PROMPT_PERSONALITY = "我是谁？告诉我我的性格、习惯和我们的关系。", WIZARD_PROMPT_DONE = "设置完成。你好，亲爱的！", WIZARD_CANCELLED_MESSAGE = "训练已取消/可重试", WIZARD_REQUEUE_MESSAGE = "训练中断，已从checkpoint自动重排队恢复", UI_ALLOWED_METHODS;
var init_gateway = __esm(() => {
  init_dist();
  init_wrapper();
  init_channel();
  init_channel();
  init_channel();
  init_store3();
  init_state_machine();
  init_risk();
  init_policy2();
  init_incident();
  init_nodes();
  init_store2();
  init_daemon();
  init_owner_identity();
  init_owner_sync();
  init_settings();
  init_state2();
  init_agent_model_persistence();
  init_provider_override_audit();
  init_agent_model_api();
  init_state3();
  init_store4();
  init_memory_vector();
  init_memory_sqlite();
  init_memory_reflect();
  init_wizard();
  init_multimodal();
  init_resource_scheduler();
  init_sessions();
  init_router2();
  init_loader();
  init_state4();
  init_sync();
  init_mcp();
  init_logger();
  init_workflow();
  init_learning();
  init_autoflow();
  init_control_ui();
  init_sanitizer();
  init_protocol();
  z2 = tool.schema;
  runtimes = new Map;
  dependencies = new Map;
  ownerTokens = new Map;
  controlUiFallbackLoggedAtByDir = new Map;
  followerRecoveryTimers = new Map;
  DEFAULT_TRUST_MODE = {
    silentMin: 90,
    modalMax: 50
  };
  DEFAULT_PSYCHE_MODE = {
    resonanceEnabled: true,
    captureProbeEnabled: true
  };
  DEFAULT_LEARNING_GATE = {
    candidateMode: "toast_gate",
    persistentRequiresApproval: true
  };
  UI_ALLOWED_METHODS = new Set([
    "gateway.status.get",
    "gateway.backpressure.stats",
    "daemon.backpressure.stats",
    "doctor.run",
    "config.center.get",
    "provider.override.audit.list",
    "sessions.list",
    "sessions.get",
    "cron.list",
    "cron.runs.list",
    "cron.approvals.list",
    "channels.list",
    "channels.status",
    "channels.pair.list",
    "channels.contact.tier.get",
    "channels.contact.tier.list",
    "security.identity.status",
    "security.voiceprint.threshold.get",
    "policy.get",
    "policy.domains.list",
    "policy.incidents.list",
    "psyche.mode.get",
    "learning.gate.get",
    "nodes.list",
    "nodes.status",
    "nodes.describe",
    "nodes.pair.list",
    "devices.list",
    "skills.status",
    "miya.sync.list",
    "miya.sync.diff",
    "mcp.capabilities.list",
    "media.get",
    "media.list",
    "voice.status",
    "voice.history.list",
    "canvas.status",
    "canvas.list",
    "canvas.get",
    "companion.status",
    "companion.wizard.status",
    "companion.memory.list",
    "companion.memory.pending.list",
    "companion.memory.corrections.list",
    "companion.memory.add",
    "companion.memory.confirm",
    "companion.memory.update",
    "companion.memory.archive",
    "companion.memory.search",
    "companion.memory.vector.list",
    "miya.memory.sqlite.stats",
    "daemon.vram.budget",
    "autoflow.status.get",
    "routing.stats.get",
    "learning.drafts.stats",
    "learning.drafts.list",
    "learning.drafts.recommend",
    "intervention.approve",
    "intervention.pause",
    "intervention.kill",
    "intervention.annotate"
  ]);
});

// src/safety/evidence.ts
var LARGE_FILE_LIMIT;
var init_evidence = __esm(() => {
  LARGE_FILE_LIMIT = 2 * 1024 * 1024;
});
// src/settings/tools.ts
var z3;
var init_tools = __esm(() => {
  init_dist();
  init_gateway();
  init_evidence();
  init_store3();
  init_registry();
  init_store();
  z3 = tool.schema;
});

// src/settings/index.ts
var init_settings = __esm(() => {
  init_registry();
  init_store();
  init_tools();
});

// src/daemon/ws-protocol.ts
function parseDaemonOutgoingFrame(input) {
  try {
    const value = typeof input === "string" ? JSON.parse(input) : input;
    const frame = DaemonOutgoingFrameSchema.parse(value);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}
var JsonValue2, JsonObject2, DaemonHelloFrameSchema, DaemonRequestFrameSchema, DaemonResponseFrameSchema, DaemonEventFrameSchema, DaemonPingFrameSchema, DaemonPongFrameSchema, DaemonIncomingFrameSchema, DaemonOutgoingFrameSchema;
var init_ws_protocol = __esm(() => {
  init_zod();
  JsonValue2 = exports_external.lazy(() => exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean(), exports_external.null(), exports_external.array(JsonValue2), exports_external.record(exports_external.string(), JsonValue2)]));
  JsonObject2 = exports_external.record(exports_external.string(), JsonValue2);
  DaemonHelloFrameSchema = exports_external.object({
    type: exports_external.literal("hello"),
    clientID: exports_external.string().min(1).max(120).optional(),
    role: exports_external.enum(["plugin", "ui", "unknown"]).default("plugin"),
    protocolVersion: exports_external.string().default("1.0"),
    auth: exports_external.object({
      token: exports_external.string().min(1)
    }).optional()
  });
  DaemonRequestFrameSchema = exports_external.object({
    type: exports_external.literal("request"),
    id: exports_external.string().min(1),
    method: exports_external.string().min(1),
    params: JsonObject2.default({})
  });
  DaemonResponseFrameSchema = exports_external.object({
    type: exports_external.literal("response"),
    id: exports_external.string(),
    ok: exports_external.boolean(),
    result: JsonValue2.optional(),
    error: exports_external.object({
      code: exports_external.string(),
      message: exports_external.string(),
      details: JsonValue2.optional()
    }).optional()
  });
  DaemonEventFrameSchema = exports_external.object({
    type: exports_external.literal("event"),
    event: exports_external.string().min(1),
    payload: JsonValue2
  });
  DaemonPingFrameSchema = exports_external.object({
    type: exports_external.literal("ping"),
    ts: exports_external.number().int().nonnegative()
  });
  DaemonPongFrameSchema = exports_external.object({
    type: exports_external.literal("pong"),
    ts: exports_external.number().int().nonnegative()
  });
  DaemonIncomingFrameSchema = exports_external.union([
    DaemonHelloFrameSchema,
    DaemonRequestFrameSchema,
    DaemonPingFrameSchema
  ]);
  DaemonOutgoingFrameSchema = exports_external.union([
    DaemonResponseFrameSchema,
    DaemonEventFrameSchema,
    DaemonPongFrameSchema
  ]);
});

// src/daemon/launcher.ts
import { randomUUID as randomUUID17 } from "node:crypto";
import * as fs42 from "node:fs";
import * as path42 from "node:path";
import { spawn as spawn2, spawnSync as spawnSync5 } from "node:child_process";
import { fileURLToPath as fileURLToPath4 } from "node:url";
function emitLauncherEvent(runtime, type, payload) {
  if (runtime.listeners.size === 0)
    return;
  const event = {
    type,
    at: nowIso24(),
    payload,
    snapshot: { ...runtime.snapshot }
  };
  for (const listener of runtime.listeners) {
    try {
      listener(event);
    } catch {}
  }
}
function syncBackpressureSnapshot(runtime) {
  runtime.snapshot.pendingRequests = runtime.pending.size;
  runtime.snapshot.rejectedRequests = runtime.rejectedRequests;
  runtime.snapshot.lastRejectReason = runtime.lastRejectReason;
}
function nowIso24() {
  return new Date().toISOString();
}
function daemonDir(projectDir) {
  return path42.join(getMiyaRuntimeDir(projectDir), "daemon");
}
function daemonPidFile(projectDir) {
  return path42.join(daemonDir(projectDir), "daemon.pid");
}
function ensureDaemonDir(projectDir) {
  fs42.mkdirSync(daemonDir(projectDir), { recursive: true });
}
function safeWriteJson2(filePath13, payload) {
  fs42.mkdirSync(path42.dirname(filePath13), { recursive: true });
  fs42.writeFileSync(filePath13, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
}
function safeReadJson2(filePath13) {
  if (!fs42.existsSync(filePath13))
    return null;
  try {
    const parsed = JSON.parse(fs42.readFileSync(filePath13, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed))
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function toDaemonLock(raw) {
  if (!raw)
    return null;
  const pid = Number(raw.pid);
  const wsPort = Number(raw.wsPort);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  if (!Number.isFinite(pid) || !Number.isFinite(wsPort) || !token || !updatedAt)
    return null;
  return { pid, wsPort, token, updatedAt };
}
function resolveHostScriptPath(projectDir) {
  const here = path42.dirname(fileURLToPath4(import.meta.url));
  const candidates = [
    path42.join(here, "host.ts"),
    path42.join(here, "host.js"),
    path42.join(projectDir, "src", "daemon", "host.ts"),
    path42.join(projectDir, "dist", "daemon", "host.js"),
    path42.join(projectDir, "miya-src", "src", "daemon", "host.ts"),
    path42.join(projectDir, "miya-src", "dist", "daemon", "host.js")
  ];
  for (const candidate of candidates) {
    if (fs42.existsSync(candidate))
      return candidate;
  }
  return path42.join(here, "host.js");
}
function noteLaunchFailure(runtime, reason) {
  runtime.consecutiveLaunchFailures += 1;
  runtime.lastRejectReason = reason;
  if (runtime.consecutiveLaunchFailures >= runtime.maxConsecutiveLaunchFailures) {
    runtime.retryHalted = true;
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = `Miya Daemon Retry Halted (${reason})`;
  }
  syncBackpressureSnapshot(runtime);
}
function resetLaunchFailureState(runtime) {
  runtime.consecutiveLaunchFailures = 0;
  runtime.retryHalted = false;
  runtime.lastRejectReason = undefined;
  syncBackpressureSnapshot(runtime);
}
function resolveNodeBinary() {
  if (resolvedNodeBinaryCache !== undefined)
    return resolvedNodeBinaryCache;
  const configured = process.env.MIYA_NODE_BIN?.trim();
  const windowsNodeCandidates = process.platform === "win32" ? [
    path42.join(process.env.ProgramFiles ?? "C:\\Program Files", "nodejs", "node.exe"),
    path42.join(process.env["ProgramFiles(x86)"] ?? "C:\\Program Files (x86)", "nodejs", "node.exe"),
    path42.join(process.env.LOCALAPPDATA ?? "", "Programs", "nodejs", "node.exe")
  ] : [];
  const candidates = [
    configured || null,
    (() => {
      const execBase = path42.basename(process.execPath).toLowerCase();
      return execBase === "node" || execBase === "node.exe" ? process.execPath : null;
    })(),
    ...windowsNodeCandidates,
    process.platform === "win32" ? "node.exe" : "node"
  ].filter((item) => Boolean(item));
  for (const candidate of candidates) {
    try {
      const probe = spawnSync5(candidate, ["--version"], {
        stdio: ["ignore", "ignore", "ignore"],
        timeout: 2000,
        windowsHide: true
      });
      if (probe.status === 0) {
        resolvedNodeBinaryCache = candidate;
        return candidate;
      }
    } catch {}
  }
  return null;
}
function resolveLifecycleMode(projectDir) {
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "service")
    return "service_experimental";
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "coupled")
    return "coupled";
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime ?? {};
  return runtime.service_mode_experimental === true ? "service_experimental" : "coupled";
}
function spawnDaemon(runtime) {
  if (runtime.retryHalted) {
    return false;
  }
  if (runtime.lifecycleMode === "service_experimental") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Service Mode (attach only)";
    return false;
  }
  const now = Date.now();
  if (now - runtime.lastSpawnAttemptAtMs < 3000) {
    return false;
  }
  runtime.lastSpawnAttemptAtMs = now;
  cleanupExistingDaemon(runtime.projectDir);
  const nodeBinary = resolveNodeBinary();
  if (!nodeBinary) {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (node_not_found)";
    noteLaunchFailure(runtime, "node_not_found");
    return false;
  }
  const binaryBase = path42.basename(nodeBinary).toLowerCase();
  if (binaryBase.includes("powershell") || binaryBase === "pwsh.exe") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (invalid_runtime_binary)";
    noteLaunchFailure(runtime, "invalid_runtime_binary");
    return false;
  }
  const hostScript = resolveHostScriptPath(runtime.projectDir);
  const nodeArgs = [
    ...hostScript.endsWith(".ts") ? ["--import", "tsx"] : [],
    hostScript,
    "--project-dir",
    runtime.projectDir,
    "--parent-lock-file",
    runtime.parentLockFile,
    "--token",
    runtime.daemonToken
  ];
  spawn2(nodeBinary, nodeArgs, {
    cwd: path42.dirname(hostScript),
    detached: true,
    stdio: "ignore",
    windowsHide: true
  }).unref();
  return true;
}
function readPidFile(projectDir) {
  const file3 = daemonPidFile(projectDir);
  if (!fs42.existsSync(file3))
    return null;
  const raw = fs42.readFileSync(file3, "utf-8").trim();
  const pid = Number(raw);
  if (!Number.isFinite(pid) || pid <= 0)
    return null;
  return pid;
}
function isPidAlive(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function cleanupExistingDaemon(projectDir) {
  const stalePid = readPidFile(projectDir);
  if (!stalePid || !isPidAlive(stalePid))
    return;
  try {
    process.kill(stalePid);
  } catch {}
}
function writeParentLock(runtime) {
  safeWriteJson2(runtime.parentLockFile, {
    pid: process.pid,
    plugin: "miya",
    updatedAt: nowIso24()
  });
}
function connectWebSocket(runtime, lock) {
  const url3 = `ws://127.0.0.1:${lock.wsPort}/ws?token=${encodeURIComponent(runtime.daemonToken)}`;
  const ws = new WebSocket(url3);
  runtime.ws = ws;
  ws.onopen = () => {
    resetLaunchFailureState(runtime);
    runtime.connected = true;
    runtime.reconnectBackoffMs = 1000;
    runtime.snapshot.statusText = "Miya Daemon Connected";
    runtime.snapshot.connected = true;
    runtime.snapshot.port = lock.wsPort;
    runtime.snapshot.pid = lock.pid;
    const hello = DaemonHelloFrameSchema.parse({
      type: "hello",
      clientID: `plugin-${process.pid}`,
      role: "plugin",
      protocolVersion: "1.0",
      auth: { token: runtime.daemonToken }
    });
    ws.send(JSON.stringify(hello));
    startHeartbeat(runtime);
    startStatusPoll(runtime);
  };
  ws.onmessage = (event) => {
    const parsed = parseDaemonOutgoingFrame(event.data);
    if (!parsed.frame)
      return;
    const frame = parsed.frame;
    if (frame.type === "pong") {
      runtime.lastPongAt = Date.now();
      if (runtime.pingWatchdog)
        clearTimeout(runtime.pingWatchdog);
      return;
    }
    if (frame.type === "response") {
      if (frame.id === "hello" && frame.ok)
        return;
      const pending = runtime.pending.get(frame.id);
      if (pending) {
        runtime.pending.delete(frame.id);
        clearTimeout(pending.timeout);
        syncBackpressureSnapshot(runtime);
        if (frame.ok) {
          pending.resolve(frame.result);
        } else {
          pending.reject(new Error(frame.error?.message ?? "daemon_request_failed"));
        }
      }
      return;
    }
    if (frame.type === "event" && frame.event === "daemon.ready") {
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.connected = true;
      emitLauncherEvent(runtime, "daemon.ready");
      return;
    }
    if (frame.type === "event" && frame.event === "job.progress") {
      const payload = frame.payload && typeof frame.payload === "object" && !Array.isArray(frame.payload) ? frame.payload : {};
      runtime.snapshot.activeJobID = typeof payload.jobID === "string" ? payload.jobID : runtime.snapshot.activeJobID;
      runtime.snapshot.activeJobProgress = typeof payload.progress === "number" ? Math.floor(payload.progress) : runtime.snapshot.activeJobProgress;
      runtime.snapshot.statusText = typeof payload.status === "string" && payload.status ? payload.status : runtime.snapshot.statusText;
      emitLauncherEvent(runtime, "job.progress", payload);
    }
  };
  ws.onerror = () => {
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Reconnecting";
  };
  ws.onclose = () => {
    noteLaunchFailure(runtime, "ws_closed");
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disconnected";
    emitLauncherEvent(runtime, "daemon.disconnected");
    stopHeartbeat(runtime);
    stopStatusPoll(runtime);
    scheduleReconnect(runtime);
  };
}
function daemonRequest(runtime, method, params, timeoutMs = 8000) {
  if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN) {
    runtime.lastRejectReason = "ws_not_open";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(new Error("daemon_ws_not_open"));
  }
  if (runtime.pending.size >= runtime.maxPendingRequests) {
    runtime.lastRejectReason = "overloaded";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(new Error(`daemon_backpressure_overloaded:pending=${runtime.pending.size}:max=${runtime.maxPendingRequests}`));
  }
  runtime.reqSeq += 1;
  const id = `req-${runtime.reqSeq}`;
  const frame = DaemonRequestFrameSchema.parse({
    type: "request",
    id,
    method,
    params
  });
  return new Promise((resolve4, reject) => {
    const timeout = setTimeout(() => {
      runtime.pending.delete(id);
      runtime.lastRejectReason = "timeout";
      runtime.rejectedRequests += 1;
      syncBackpressureSnapshot(runtime);
      reject(new Error("daemon_request_timeout"));
    }, Math.max(1000, timeoutMs));
    runtime.pending.set(id, { resolve: resolve4, reject, timeout });
    syncBackpressureSnapshot(runtime);
    runtime.ws?.send(JSON.stringify(frame));
  });
}
function startHeartbeat(runtime) {
  stopHeartbeat(runtime);
  runtime.pingTimer = setInterval(() => {
    if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN)
      return;
    const ping = DaemonPingFrameSchema.parse({
      type: "ping",
      ts: Date.now()
    });
    runtime.ws.send(JSON.stringify(ping));
    if (runtime.pingWatchdog)
      clearTimeout(runtime.pingWatchdog);
    runtime.pingWatchdog = setTimeout(() => {
      if (runtime.ws && runtime.ws.readyState === WebSocket.OPEN) {
        runtime.ws.close();
      }
    }, 30000);
  }, 1e4);
}
function stopHeartbeat(runtime) {
  if (runtime.pingTimer)
    clearInterval(runtime.pingTimer);
  runtime.pingTimer = undefined;
  if (runtime.pingWatchdog)
    clearTimeout(runtime.pingWatchdog);
  runtime.pingWatchdog = undefined;
}
function startStatusPoll(runtime) {
  stopStatusPoll(runtime);
  runtime.statusTimer = setInterval(async () => {
    try {
      const data = await daemonRequest(runtime, "daemon.status.get", {});
      if (!data || typeof data !== "object")
        return;
      runtime.snapshot.connected = true;
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.uptimeSec = typeof data.uptimeSec === "number" ? data.uptimeSec : runtime.snapshot.uptimeSec;
      runtime.snapshot.cpuPercent = typeof data.cpuPercent === "number" ? data.cpuPercent : runtime.snapshot.cpuPercent;
      runtime.snapshot.vramUsedMB = typeof data.vramUsedMB === "number" ? data.vramUsedMB : runtime.snapshot.vramUsedMB;
      runtime.snapshot.vramTotalMB = typeof data.vramTotalMB === "number" ? data.vramTotalMB : runtime.snapshot.vramTotalMB;
      runtime.snapshot.lastSeenAt = typeof data.lastSeenAt === "string" ? data.lastSeenAt : runtime.snapshot.lastSeenAt;
    } catch {
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Reconnecting";
    }
  }, 3000);
}
function stopStatusPoll(runtime) {
  if (runtime.statusTimer)
    clearInterval(runtime.statusTimer);
  runtime.statusTimer = undefined;
}
function scheduleReconnect(runtime) {
  if (runtime.retryHalted)
    return;
  if (runtime.reconnectTimer)
    return;
  const wait = runtime.reconnectBackoffMs;
  runtime.reconnectBackoffMs = Math.min(runtime.reconnectBackoffMs * 2, 30000);
  runtime.reconnectTimer = setTimeout(() => {
    runtime.reconnectTimer = undefined;
    ensureDaemonLaunched(runtime);
  }, wait);
}
function ensureDaemonLaunched(runtime) {
  if (runtime.retryHalted) {
    return;
  }
  writeParentLock(runtime);
  if (Date.now() < runtime.launchCooldownUntilMs) {
    return;
  }
  const lock = toDaemonLock(safeReadJson2(runtime.daemonLockFile));
  const lockFresh = lock && Number.isFinite(Date.parse(lock.updatedAt)) && Date.now() - Date.parse(lock.updatedAt) < 30000;
  const lockOwnedByLauncher = runtime.lifecycleMode === "service_experimental" ? Boolean(lock) && (runtime.daemonToken ? lock?.token === runtime.daemonToken : true) : Boolean(lock) && lock?.token === runtime.daemonToken;
  if (!lockFresh || !lockOwnedByLauncher) {
    if (runtime.lifecycleMode === "service_experimental") {
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Service Mode (waiting for daemon lock)";
      scheduleReconnect(runtime);
      return;
    }
    if (runtime.reconnectTimer) {
      return;
    }
    const spawned = spawnDaemon(runtime);
    if (!spawned) {
      runtime.reconnectBackoffMs = Math.max(runtime.reconnectBackoffMs, 15000);
      runtime.launchCooldownUntilMs = Date.now() + 15000;
      if (!runtime.retryHalted) {
        noteLaunchFailure(runtime, "spawn_skipped_or_failed");
      }
    }
    scheduleReconnect(runtime);
    return;
  }
  if (!runtime.ws || runtime.ws.readyState >= WebSocket.CLOSING) {
    connectWebSocket(runtime, lock);
  }
}
function cleanupRuntime(runtime) {
  if (runtime.parentBeatTimer)
    clearInterval(runtime.parentBeatTimer);
  runtime.parentBeatTimer = undefined;
  if (runtime.reconnectTimer)
    clearTimeout(runtime.reconnectTimer);
  runtime.reconnectTimer = undefined;
  stopHeartbeat(runtime);
  stopStatusPoll(runtime);
  for (const pending of runtime.pending.values()) {
    clearTimeout(pending.timeout);
    pending.reject(new Error("launcher_shutdown"));
  }
  runtime.pending.clear();
  syncBackpressureSnapshot(runtime);
  runtime.listeners.clear();
  try {
    runtime.ws?.close();
  } catch {}
  runtime.ws = undefined;
}
function ensureMiyaLauncher(projectDir) {
  const existing = runtimes2.get(projectDir);
  if (existing)
    return { ...existing.snapshot };
  ensureDaemonDir(projectDir);
  const lifecycleMode = resolveLifecycleMode(projectDir);
  const config3 = readConfig(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const configuredMaxPending = typeof backpressure?.daemon_max_pending_requests === "number" ? Number(backpressure.daemon_max_pending_requests) : Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64);
  const configuredMaxFailures = typeof backpressure?.daemon_max_consecutive_failures === "number" ? Number(backpressure.daemon_max_consecutive_failures) : Number(process.env.MIYA_DAEMON_MAX_CONSECUTIVE_FAILURES ?? 5);
  const daemonToken = lifecycleMode === "service_experimental" ? String(process.env.MIYA_DAEMON_SERVICE_TOKEN ?? process.env.MIYA_DAEMON_TOKEN ?? "") : randomUUID17();
  const runtime = {
    projectDir,
    lifecycleMode,
    daemonToken,
    parentLockFile: path42.join(daemonDir(projectDir), "parent.lock.json"),
    daemonLockFile: path42.join(daemonDir(projectDir), "daemon.lock.json"),
    reconnectBackoffMs: 1000,
    connected: false,
    reqSeq: 0,
    pending: new Map,
    maxPendingRequests: Math.max(4, Math.floor(configuredMaxPending)),
    rejectedRequests: 0,
    lastRejectReason: undefined,
    listeners: new Set,
    lastSpawnAttemptAtMs: 0,
    launchCooldownUntilMs: 0,
    consecutiveLaunchFailures: 0,
    retryHalted: false,
    maxConsecutiveLaunchFailures: Math.max(1, Math.floor(configuredMaxFailures)),
    snapshot: {
      connected: false,
      statusText: lifecycleMode === "service_experimental" ? daemonToken ? "Miya Daemon Service Mode (attach only)" : "Miya Daemon Service Mode (token missing)" : "Miya Daemon Booting",
      lifecycleMode,
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso24()
    }
  };
  syncBackpressureSnapshot(runtime);
  runtimes2.set(projectDir, runtime);
  writeParentLock(runtime);
  runtime.parentBeatTimer = setInterval(() => {
    writeParentLock(runtime);
  }, 1e4);
  ensureDaemonLaunched(runtime);
  return { ...runtime.snapshot };
}
function getLauncherDaemonSnapshot(projectDir) {
  const runtime = runtimes2.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      statusText: "Miya Daemon Not Started",
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso24()
    };
  }
  syncBackpressureSnapshot(runtime);
  return { ...runtime.snapshot };
}
function getLauncherBackpressureStats(projectDir) {
  const runtime = runtimes2.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      maxPendingRequests: Math.max(4, Math.floor(Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64))),
      pendingRequests: 0,
      rejectedRequests: 0
    };
  }
  syncBackpressureSnapshot(runtime);
  return {
    connected: runtime.connected,
    maxPendingRequests: runtime.maxPendingRequests,
    pendingRequests: runtime.snapshot.pendingRequests,
    rejectedRequests: runtime.snapshot.rejectedRequests,
    lastRejectReason: runtime.snapshot.lastRejectReason
  };
}
function subscribeLauncherEvents(projectDir, listener) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes2.get(projectDir);
  if (!runtime)
    return () => {};
  runtime.listeners.add(listener);
  return () => {
    const current = runtimes2.get(projectDir);
    current?.listeners.delete(listener);
  };
}
async function waitForDaemonConnection(runtime, timeoutMs) {
  if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected)
    return;
  const startedAt = Date.now();
  while (Date.now() - startedAt < timeoutMs) {
    ensureDaemonLaunched(runtime);
    if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected)
      return;
    await new Promise((resolve4) => setTimeout(resolve4, 150));
  }
  throw new Error("daemon_connect_timeout");
}
async function daemonInvoke(projectDir, method, params, timeoutMs = 60000) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes2.get(projectDir);
  if (!runtime)
    throw new Error("daemon_runtime_missing");
  await waitForDaemonConnection(runtime, Math.min(timeoutMs, 15000));
  return daemonRequest(runtime, method, params, timeoutMs);
}
var runtimes2, resolvedNodeBinaryCache;
var init_launcher = __esm(() => {
  init_workflow();
  init_settings();
  init_ws_protocol();
  runtimes2 = new Map;
  process.on("exit", () => {
    for (const runtime of runtimes2.values()) {
      cleanupRuntime(runtime);
      try {
        fs42.rmSync(runtime.parentLockFile, { force: true });
      } catch {}
    }
  });
});

// src/daemon/client.ts
class MiyaClient {
  projectDir;
  constructor(projectDir) {
    this.projectDir = projectDir;
    ensureMiyaLauncher(projectDir);
  }
  async runFluxImageGenerate(input) {
    return daemonInvoke(this.projectDir, "daemon.flux.generate", input, 240000);
  }
  async runSovitsTts(input) {
    return daemonInvoke(this.projectDir, "daemon.sovits.tts", input, 180000);
  }
  async runFluxTraining(input) {
    return daemonInvoke(this.projectDir, "daemon.training.flux", input, 35 * 60000);
  }
  async runSovitsTraining(input) {
    return daemonInvoke(this.projectDir, "daemon.training.sovits", input, 35 * 60000);
  }
  async requestTrainingCancel(jobID) {
    await daemonInvoke(this.projectDir, "daemon.training.cancel", { jobID }, 15000);
  }
  async getPythonRuntimeStatus() {
    return daemonInvoke(this.projectDir, "daemon.python.env.get", {}, 15000);
  }
  async getModelLockStatus() {
    return daemonInvoke(this.projectDir, "daemon.model.locks.get", {}, 15000);
  }
  async getModelUpdatePlan(target) {
    return daemonInvoke(this.projectDir, "daemon.model.update.plan", target ? { target } : {}, 20000);
  }
  async applyModelUpdate(target) {
    return daemonInvoke(this.projectDir, "daemon.model.update.apply", target ? { target } : {}, 30000);
  }
  async runIsolatedProcess(input) {
    return daemonInvoke(this.projectDir, "daemon.process.run_isolated", input, Math.max(30000, input.timeoutMs ?? 120000) + 1e4);
  }
  async psycheConsult(input) {
    const timeoutMs = Math.max(1000, Math.floor(Number(process.env.MIYA_PSYCHE_CONSULT_TIMEOUT_MS ?? 3000)));
    return daemonInvoke(this.projectDir, "daemon.psyche.consult", input, timeoutMs);
  }
  async psycheOutcome(input) {
    return daemonInvoke(this.projectDir, "daemon.psyche.outcome", input, 15000);
  }
}
function getMiyaClient(projectDir) {
  const existing = clients.get(projectDir);
  if (existing)
    return existing;
  const created = new MiyaClient(projectDir);
  clients.set(projectDir, created);
  return created;
}
var clients;
var init_client = __esm(() => {
  init_launcher();
  clients = new Map;
});

// src/daemon/python-runtime.ts
var init_python_runtime = __esm(() => {
  init_workflow();
});

// src/daemon/index.ts
var init_daemon = __esm(() => {
  init_client();
  init_launcher();
  init_python_runtime();
});

// src/cli/index.ts
import { spawn as spawn3, spawnSync as spawnSync6 } from "node:child_process";
import * as fs44 from "node:fs";
import * as path44 from "node:path";
import { fileURLToPath as fileURLToPath5 } from "node:url";

// src/cli/install.ts
import * as readline from "node:readline/promises";
import * as fs4 from "node:fs";
import * as path4 from "node:path";

// src/cli/model-selection.ts
function defaultTieBreaker(left, right) {
  return left.model.localeCompare(right.model);
}
function rankModels(models, scoreFn, options = {}) {
  const excluded = new Set(options.excludeModels ?? []);
  const tieBreaker = options.tieBreaker ?? defaultTieBreaker;
  return models.filter((model) => !excluded.has(model.model)).map((candidate) => ({
    candidate,
    score: scoreFn(candidate)
  })).sort((left, right) => {
    if (left.score !== right.score)
      return right.score - left.score;
    return tieBreaker(left.candidate, right.candidate);
  });
}
function pickBestModel(models, scoreFn, options = {}) {
  return rankModels(models, scoreFn, options)[0]?.candidate ?? null;
}
function pickPrimaryAndSupport(models, scoring, preferredPrimaryModel) {
  if (models.length === 0)
    return { primary: null, support: null };
  const preferredPrimary = preferredPrimaryModel ? models.find((candidate) => candidate.model === preferredPrimaryModel) : undefined;
  const primary = preferredPrimary ?? pickBestModel(models, scoring.primary);
  if (!primary)
    return { primary: null, support: null };
  const support = pickBestModel(models, scoring.support, {
    excludeModels: [primary.model]
  }) ?? pickBestModel(models, scoring.support);
  return { primary, support };
}

// src/cli/chutes-selection.ts
function speedBonus(modelName) {
  const lower = modelName.toLowerCase();
  let score = 0;
  if (lower.includes("nano"))
    score += 60;
  if (lower.includes("flash"))
    score += 45;
  if (lower.includes("mini"))
    score += 30;
  if (lower.includes("lite"))
    score += 20;
  if (lower.includes("small"))
    score += 15;
  return score;
}
var scoreChutesPrimaryForCoding = (model) => {
  return (model.reasoning ? 120 : 0) + (model.toolcall ? 80 : 0) + (model.attachment ? 20 : 0) + Math.min(model.contextLimit, 1e6) / 9000 + Math.min(model.outputLimit, 300000) / 1e4 + (model.status === "active" ? 10 : 0);
};
var scoreChutesSupportForCoding = (model) => {
  return (model.toolcall ? 90 : 0) + (model.reasoning ? 35 : 0) + speedBonus(model.model) + Math.min(model.contextLimit, 400000) / 20000 + (model.status === "active" ? 8 : 0);
};
function pickBestCodingChutesModel(models) {
  return pickBestModel(models, scoreChutesPrimaryForCoding);
}
function pickSupportChutesModel(models, primaryModel) {
  const { support } = pickPrimaryAndSupport(models, {
    primary: scoreChutesPrimaryForCoding,
    support: scoreChutesSupportForCoding
  }, primaryModel);
  return support;
}
// src/cli/config-io.ts
import {
  copyFileSync as copyFileSync2,
  existsSync as existsSync6,
  readFileSync as readFileSync4,
  renameSync as renameSync2,
  statSync as statSync2,
  writeFileSync as writeFileSync3
} from "node:fs";

// src/cli/paths.ts
import { existsSync, mkdirSync } from "node:fs";
import { homedir } from "node:os";
import { join } from "node:path";
function getConfigDir() {
  const userConfigDir = process.env.XDG_CONFIG_HOME ? process.env.XDG_CONFIG_HOME : join(homedir(), ".config");
  return join(userConfigDir, "opencode");
}
function getConfigJson() {
  return join(getConfigDir(), "opencode.json");
}
function getConfigJsonc() {
  return join(getConfigDir(), "opencode.jsonc");
}
function getLiteConfig() {
  return join(getConfigDir(), "miya.json");
}
function getLiteConfigCandidates() {
  const configDir = getConfigDir();
  return [join(configDir, "miya.json")];
}
function getExistingLiteConfigPath() {
  const candidates = getLiteConfigCandidates();
  for (const candidate of candidates) {
    if (existsSync(candidate))
      return candidate;
  }
  return getLiteConfig();
}
function getExistingConfigPath() {
  const jsonPath = getConfigJson();
  if (existsSync(jsonPath))
    return jsonPath;
  const jsoncPath = getConfigJsonc();
  if (existsSync(jsoncPath))
    return jsoncPath;
  return jsonPath;
}
function ensureConfigDir() {
  const configDir = getConfigDir();
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
}

// src/config/index.ts
init_constants();

// src/config/loader.ts
init_agent_model_persistence();

// src/config/schema.ts
init_zod();
var AgentModelChainSchema = exports_external.array(exports_external.string()).min(1);
var FallbackChainsSchema = exports_external.object({
  "1-task-manager": AgentModelChainSchema.optional(),
  "2-code-search": AgentModelChainSchema.optional(),
  "3-docs-helper": AgentModelChainSchema.optional(),
  "4-architecture-advisor": AgentModelChainSchema.optional(),
  "5-code-fixer": AgentModelChainSchema.optional(),
  "6-ui-designer": AgentModelChainSchema.optional(),
  "7-code-simplicity-reviewer": AgentModelChainSchema.optional(),
  orchestrator: AgentModelChainSchema.optional(),
  explorer: AgentModelChainSchema.optional(),
  librarian: AgentModelChainSchema.optional(),
  oracle: AgentModelChainSchema.optional(),
  fixer: AgentModelChainSchema.optional(),
  designer: AgentModelChainSchema.optional(),
  "code-simplicity-reviewer": AgentModelChainSchema.optional()
}).strict();
var AgentOverrideConfigSchema = exports_external.object({
  model: exports_external.string().optional(),
  temperature: exports_external.number().min(0).max(2).optional(),
  variant: exports_external.string().optional().catch(undefined),
  providerID: exports_external.string().optional(),
  options: exports_external.record(exports_external.string(), exports_external.unknown()).optional(),
  apiKey: exports_external.string().optional(),
  baseURL: exports_external.string().optional(),
  skills: exports_external.array(exports_external.string()).optional(),
  mcps: exports_external.array(exports_external.string()).optional()
});
var TmuxLayoutSchema = exports_external.enum([
  "main-horizontal",
  "main-vertical",
  "tiled",
  "even-horizontal",
  "even-vertical"
]);
var TmuxConfigSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  layout: TmuxLayoutSchema.default("main-vertical"),
  main_pane_size: exports_external.number().min(20).max(80).default(60)
});
var PresetSchema = exports_external.record(exports_external.string(), AgentOverrideConfigSchema);
var McpNameSchema = exports_external.enum(["websearch", "context7", "grep_app"]);
var BackgroundTaskConfigSchema = exports_external.object({
  maxConcurrentStarts: exports_external.number().min(1).max(50).default(10)
});
var UiConfigSchema = exports_external.object({
  dashboard: exports_external.object({
    openOnStart: exports_external.boolean().optional(),
    dockAutoLaunch: exports_external.boolean().optional(),
    autoOpenCooldownMs: exports_external.number().min(1e4).max(24 * 60000).optional()
  }).optional()
});
var SlimCompatConfigSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  useSlimOrchestratorPrompt: exports_external.boolean().default(false),
  enableCodeSimplicityReviewer: exports_external.boolean().default(false),
  enablePostWriteSimplicityNudge: exports_external.boolean().default(false)
});
var ContextGovernanceConfigSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  toolOutputMaxChars: exports_external.number().min(1200).max(200000).default(12000),
  toolOutputHeadChars: exports_external.number().min(200).max(1e5).default(4200),
  toolOutputTailChars: exports_external.number().min(100).max(1e5).default(2800),
  recordTtlMs: exports_external.number().min(1e4).max(86400000).default(12 * 60 * 1000),
  maxRecordsPerSession: exports_external.number().min(5).max(200).default(30),
  maxInjectedRecords: exports_external.number().min(1).max(20).default(3),
  maxInjectedChars: exports_external.number().min(400).max(20000).default(2400)
});
var FailoverConfigSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  timeoutMs: exports_external.number().min(1000).max(120000).default(15000),
  chains: FallbackChainsSchema.default({})
});
var PluginConfigSchema = exports_external.object({
  preset: exports_external.string().optional(),
  presets: exports_external.record(exports_external.string(), PresetSchema).optional(),
  agents: exports_external.record(exports_external.string(), AgentOverrideConfigSchema).optional(),
  provider: exports_external.record(exports_external.string(), exports_external.unknown()).optional(),
  disabled_mcps: exports_external.array(exports_external.string()).optional(),
  tmux: TmuxConfigSchema.optional(),
  ui: UiConfigSchema.optional(),
  background: BackgroundTaskConfigSchema.optional(),
  fallback: FailoverConfigSchema.optional(),
  slimCompat: SlimCompatConfigSchema.optional(),
  contextGovernance: ContextGovernanceConfigSchema.optional()
});

// src/config/index.ts
init_model_health();

// src/config/utils.ts
init_constants();
// src/config/agent-mcps.ts
var DEFAULT_AGENT_MCPS = {
  "1-task-manager": ["websearch"],
  "2-code-search": [],
  "3-docs-helper": ["websearch", "context7", "grep_app"],
  "4-architecture-advisor": [],
  "5-code-fixer": [],
  "6-ui-designer": [],
  "7-code-simplicity-reviewer": []
};

// src/cli/providers.ts
init_constants();

// src/cli/skills.ts
import { spawnSync } from "node:child_process";

// src/cli/custom-skills.ts
import {
  copyFileSync,
  existsSync as existsSync5,
  mkdirSync as mkdirSync4,
  readdirSync,
  statSync
} from "node:fs";
import { homedir as homedir3 } from "node:os";
import { dirname as dirname3, join as join5 } from "node:path";
import { fileURLToPath } from "node:url";
var CUSTOM_SKILLS = [
  {
    name: "cartography",
    description: "Repository understanding and hierarchical codemap generation",
    allowedAgents: ["1-task-manager", "orchestrator"],
    sourcePath: "src/skills/cartography"
  }
];
function getUserConfigDir() {
  return process.env.XDG_CONFIG_HOME || join5(homedir3(), ".config");
}
function getCustomSkillsDir() {
  return join5(getUserConfigDir(), "opencode", "skills");
}
function copyDirRecursive(src, dest) {
  if (!existsSync5(dest)) {
    mkdirSync4(dest, { recursive: true });
  }
  const entries = readdirSync(src);
  for (const entry of entries) {
    const srcPath = join5(src, entry);
    const destPath = join5(dest, entry);
    const stat = statSync(srcPath);
    if (stat.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      const destDir = dirname3(destPath);
      if (!existsSync5(destDir)) {
        mkdirSync4(destDir, { recursive: true });
      }
      copyFileSync(srcPath, destPath);
    }
  }
}
function installCustomSkill(skill) {
  try {
    const packageRoot = fileURLToPath(new URL("../..", import.meta.url));
    const sourcePath = join5(packageRoot, skill.sourcePath);
    const targetPath = join5(getCustomSkillsDir(), skill.name);
    if (!existsSync5(sourcePath)) {
      console.error(`Custom skill source not found: ${sourcePath}`);
      return false;
    }
    copyDirRecursive(sourcePath, targetPath);
    return true;
  } catch (error48) {
    console.error(`Failed to install custom skill: ${skill.name}`, error48);
    return false;
  }
}

// src/cli/skills.ts
var RECOMMENDED_SKILLS = [
  {
    name: "simplify",
    repo: "https://github.com/brianlovin/claude-config",
    skillName: "simplify",
    allowedAgents: ["1-task-manager", "orchestrator"],
    description: "YAGNI code simplification expert"
  },
  {
    name: "agent-browser",
    repo: "https://github.com/vercel-labs/agent-browser",
    skillName: "agent-browser",
    allowedAgents: ["6-ui-designer", "designer"],
    description: "High-performance browser automation",
    postInstallCommands: [
      "npm install -g agent-browser",
      "agent-browser install"
    ]
  }
];
function installSkill(skill) {
  const args = [
    "skills",
    "add",
    skill.repo,
    "--skill",
    skill.skillName,
    "-a",
    "opencode",
    "-y",
    "--global"
  ];
  try {
    const result = spawnSync("npx", args, { stdio: "inherit" });
    if (result.status !== 0) {
      return false;
    }
    if (skill.postInstallCommands && skill.postInstallCommands.length > 0) {
      console.log(`Running post-install commands for ${skill.name}...`);
      for (const cmd of skill.postInstallCommands) {
        console.log(`> ${cmd}`);
        const [command, ...cmdArgs] = cmd.split(" ");
        const cmdResult = spawnSync(command, cmdArgs, { stdio: "inherit" });
        if (cmdResult.status !== 0) {
          console.warn(`Post-install command failed: ${cmd}`);
        }
      }
    }
    return true;
  } catch (error48) {
    console.error(`Failed to install skill: ${skill.name}`, error48);
    return false;
  }
}

// src/cli/providers.ts
var AGENT_NAMES = [
  "orchestrator",
  "oracle",
  "designer",
  "explorer",
  "librarian",
  "fixer"
];
function normalizeAgentName2(agentName) {
  return AGENT_ALIASES[agentName] ?? agentName;
}
function normalizeAgentsRecord(agents) {
  const normalized = {};
  for (const [name, config2] of Object.entries(agents)) {
    normalized[normalizeAgentName2(name)] = config2;
  }
  return normalized;
}
function normalizeFallbackChains(chains) {
  const normalized = {};
  for (const [name, chain] of Object.entries(chains)) {
    normalized[normalizeAgentName2(name)] = chain;
  }
  return normalized;
}
function normalizeGeneratedConfig(config2) {
  const presets = config2.presets;
  if (presets) {
    for (const [presetName, preset] of Object.entries(presets)) {
      presets[presetName] = normalizeAgentsRecord(preset);
    }
  }
  const fallback = config2.fallback;
  if (fallback?.chains) {
    fallback.chains = normalizeFallbackChains(fallback.chains);
  }
}
var MODEL_MAPPINGS = {
  kimi: {
    orchestrator: { model: "kimi-for-coding/k2p5" },
    oracle: { model: "kimi-for-coding/k2p5", variant: "high" },
    librarian: { model: "kimi-for-coding/k2p5", variant: "low" },
    explorer: { model: "kimi-for-coding/k2p5", variant: "low" },
    designer: { model: "kimi-for-coding/k2p5", variant: "medium" },
    fixer: { model: "kimi-for-coding/k2p5", variant: "low" }
  },
  openai: {
    orchestrator: { model: "openai/gpt-5.3-codex" },
    oracle: { model: "openai/gpt-5.3-codex", variant: "high" },
    librarian: { model: "openai/gpt-5.1-codex-mini", variant: "low" },
    explorer: { model: "openai/gpt-5.1-codex-mini", variant: "low" },
    designer: { model: "openai/gpt-5.1-codex-mini", variant: "medium" },
    fixer: { model: "openai/gpt-5.1-codex-mini", variant: "low" }
  },
  anthropic: {
    orchestrator: { model: "anthropic/claude-opus-4-6" },
    oracle: { model: "anthropic/claude-opus-4-6", variant: "high" },
    librarian: { model: "anthropic/claude-sonnet-4-5", variant: "low" },
    explorer: { model: "anthropic/claude-haiku-4-5", variant: "low" },
    designer: { model: "anthropic/claude-sonnet-4-5", variant: "medium" },
    fixer: { model: "anthropic/claude-sonnet-4-5", variant: "low" }
  },
  copilot: {
    orchestrator: { model: "github-copilot/grok-code-fast-1" },
    oracle: { model: "github-copilot/grok-code-fast-1", variant: "high" },
    librarian: { model: "github-copilot/grok-code-fast-1", variant: "low" },
    explorer: { model: "github-copilot/grok-code-fast-1", variant: "low" },
    designer: { model: "github-copilot/grok-code-fast-1", variant: "medium" },
    fixer: { model: "github-copilot/grok-code-fast-1", variant: "low" }
  },
  "zai-plan": {
    orchestrator: { model: "zai-coding-plan/glm-4.7" },
    oracle: { model: "zai-coding-plan/glm-4.7", variant: "high" },
    librarian: { model: "zai-coding-plan/glm-4.7", variant: "low" },
    explorer: { model: "zai-coding-plan/glm-4.7", variant: "low" },
    designer: { model: "zai-coding-plan/glm-4.7", variant: "medium" },
    fixer: { model: "zai-coding-plan/glm-4.7", variant: "low" }
  },
  antigravity: {
    orchestrator: { model: "google/antigravity-gemini-3-flash" },
    oracle: { model: "google/antigravity-gemini-3-pro" },
    librarian: {
      model: "google/antigravity-gemini-3-flash",
      variant: "low"
    },
    explorer: {
      model: "google/antigravity-gemini-3-flash",
      variant: "low"
    },
    designer: {
      model: "google/antigravity-gemini-3-flash",
      variant: "medium"
    },
    fixer: { model: "google/antigravity-gemini-3-flash", variant: "low" }
  },
  chutes: {
    orchestrator: { model: "chutes/kimi-k2.5" },
    oracle: { model: "chutes/kimi-k2.5", variant: "high" },
    librarian: { model: "chutes/minimax-m2.1", variant: "low" },
    explorer: { model: "chutes/minimax-m2.1", variant: "low" },
    designer: { model: "chutes/kimi-k2.5", variant: "medium" },
    fixer: { model: "chutes/minimax-m2.1", variant: "low" }
  },
  "zen-free": {
    orchestrator: { model: "opencode/big-pickle" },
    oracle: { model: "opencode/big-pickle", variant: "high" },
    librarian: { model: "opencode/big-pickle", variant: "low" },
    explorer: { model: "opencode/big-pickle", variant: "low" },
    designer: { model: "opencode/big-pickle", variant: "medium" },
    fixer: { model: "opencode/big-pickle", variant: "low" }
  }
};
function generateAntigravityMixedPreset(config2, existingPreset) {
  const result = existingPreset ? { ...existingPreset } : {};
  const createAgentConfig = (agentName, modelInfo) => {
    const normalizedAgentName = normalizeAgentName2(agentName);
    const isOrchestrator = normalizedAgentName === "1-task-manager";
    const skills = isOrchestrator ? ["*"] : RECOMMENDED_SKILLS.filter((s) => s.allowedAgents.includes("*") || s.allowedAgents.includes(agentName)).map((s) => s.skillName);
    if ((agentName === "designer" || normalizedAgentName === "6-ui-designer") && !skills.includes("agent-browser")) {
      skills.push("agent-browser");
    }
    return {
      model: modelInfo.model,
      variant: modelInfo.variant,
      skills,
      mcps: DEFAULT_AGENT_MCPS[normalizedAgentName] ?? []
    };
  };
  const antigravityFlash = {
    model: "google/antigravity-gemini-3-flash"
  };
  const chutesPrimary = config2.selectedChutesPrimaryModel ?? MODEL_MAPPINGS.chutes.orchestrator.model;
  const chutesSupport = config2.selectedChutesSecondaryModel ?? MODEL_MAPPINGS.chutes.explorer.model;
  if (config2.hasKimi) {
    result.orchestrator = createAgentConfig("orchestrator", MODEL_MAPPINGS.kimi.orchestrator);
  } else if (config2.hasChutes) {
    result.orchestrator = createAgentConfig("orchestrator", {
      model: chutesPrimary
    });
  } else if (!result.orchestrator) {
    result.orchestrator = createAgentConfig("orchestrator", MODEL_MAPPINGS.antigravity.orchestrator);
  }
  if (config2.hasOpenAI) {
    result.oracle = createAgentConfig("oracle", MODEL_MAPPINGS.openai.oracle);
  } else if (!result.oracle) {
    result.oracle = createAgentConfig("oracle", MODEL_MAPPINGS.antigravity.oracle);
  }
  result.explorer = createAgentConfig("explorer", {
    ...antigravityFlash,
    variant: "low"
  });
  if (config2.hasChutes) {
    result.librarian = createAgentConfig("librarian", {
      model: chutesSupport,
      variant: "low"
    });
    result.designer = createAgentConfig("designer", {
      model: chutesPrimary,
      variant: "medium"
    });
  } else {
    result.librarian = createAgentConfig("librarian", {
      ...antigravityFlash,
      variant: "low"
    });
    result.designer = createAgentConfig("designer", {
      ...antigravityFlash,
      variant: "medium"
    });
  }
  if (config2.hasOpenAI) {
    result.fixer = createAgentConfig("fixer", {
      ...MODEL_MAPPINGS.openai.oracle,
      variant: "low"
    });
  } else if (config2.hasChutes) {
    result.fixer = createAgentConfig("fixer", {
      model: chutesSupport,
      variant: "low"
    });
  } else {
    result.fixer = createAgentConfig("fixer", {
      ...antigravityFlash,
      variant: "low"
    });
  }
  return normalizeAgentsRecord(result);
}
function generateLiteConfig(installConfig) {
  const config2 = {
    preset: "zen-free",
    presets: {},
    slimCompat: {
      enabled: true,
      useSlimOrchestratorPrompt: false,
      enableCodeSimplicityReviewer: true,
      enablePostWriteSimplicityNudge: true
    }
  };
  let activePreset = "zen-free";
  if (installConfig.hasAntigravity && installConfig.hasKimi && installConfig.hasOpenAI) {
    activePreset = "antigravity-mixed-both";
  } else if (installConfig.hasAntigravity && installConfig.hasKimi) {
    activePreset = "antigravity-mixed-kimi";
  } else if (installConfig.hasAntigravity && installConfig.hasOpenAI) {
    activePreset = "antigravity-mixed-openai";
  } else if (installConfig.hasAntigravity) {
    activePreset = "antigravity";
  } else if (installConfig.hasKimi) {
    activePreset = "kimi";
  } else if (installConfig.hasOpenAI) {
    activePreset = "openai";
  } else if (installConfig.hasAnthropic) {
    activePreset = "anthropic";
  } else if (installConfig.hasCopilot) {
    activePreset = "copilot";
  } else if (installConfig.hasZaiPlan) {
    activePreset = "zai-plan";
  } else if (installConfig.hasChutes) {
    activePreset = "chutes";
  }
  config2.preset = activePreset;
  const createAgentConfig = (agentName, modelInfo) => {
    const normalizedAgentName = normalizeAgentName2(agentName);
    const isOrchestrator = normalizedAgentName === "1-task-manager";
    const skills = isOrchestrator ? ["*"] : RECOMMENDED_SKILLS.filter((s) => s.allowedAgents.includes("*") || s.allowedAgents.includes(agentName)).map((s) => s.skillName);
    if ((agentName === "designer" || normalizedAgentName === "6-ui-designer") && !skills.includes("agent-browser")) {
      skills.push("agent-browser");
    }
    return {
      model: modelInfo.model,
      variant: modelInfo.variant,
      skills,
      mcps: DEFAULT_AGENT_MCPS[normalizedAgentName] ?? []
    };
  };
  if (installConfig.dynamicModelPlan) {
    const dynamicPreset = Object.fromEntries(Object.entries(installConfig.dynamicModelPlan.agents).map(([agentName, assignment]) => [
      agentName,
      createAgentConfig(agentName, assignment)
    ]));
    config2.preset = "dynamic";
    config2.presets.dynamic = normalizeAgentsRecord(dynamicPreset);
    config2.fallback = {
      enabled: true,
      timeoutMs: 15000,
      chains: normalizeFallbackChains(installConfig.dynamicModelPlan.chains)
    };
    if (installConfig.hasTmux) {
      config2.tmux = {
        enabled: true,
        layout: "main-vertical",
        main_pane_size: 60
      };
    }
    normalizeGeneratedConfig(config2);
    return config2;
  }
  const applyOpenCodeFreeAssignments = (presetAgents, hasExternalProviders) => {
    if (!installConfig.useOpenCodeFreeModels)
      return;
    const primaryModel = installConfig.selectedOpenCodePrimaryModel;
    const secondaryModel = installConfig.selectedOpenCodeSecondaryModel ?? primaryModel;
    if (!primaryModel || !secondaryModel)
      return;
    const setAgent = (agentName, model) => {
      presetAgents[agentName] = createAgentConfig(agentName, { model });
    };
    if (!hasExternalProviders) {
      setAgent("orchestrator", primaryModel);
      setAgent("oracle", primaryModel);
      setAgent("designer", primaryModel);
    }
    setAgent("librarian", secondaryModel);
    setAgent("explorer", secondaryModel);
    setAgent("fixer", secondaryModel);
  };
  const applyChutesAssignments = (presetAgents) => {
    if (!installConfig.hasChutes)
      return;
    const hasExternalProviders = installConfig.hasKimi || installConfig.hasOpenAI || installConfig.hasAntigravity;
    if (hasExternalProviders && activePreset !== "chutes")
      return;
    const primaryModel = installConfig.selectedChutesPrimaryModel;
    const secondaryModel = installConfig.selectedChutesSecondaryModel ?? primaryModel;
    if (!primaryModel || !secondaryModel)
      return;
    const setAgent = (agentName, model) => {
      presetAgents[agentName] = createAgentConfig(agentName, { model });
    };
    setAgent("orchestrator", primaryModel);
    setAgent("oracle", primaryModel);
    setAgent("designer", primaryModel);
    setAgent("librarian", secondaryModel);
    setAgent("explorer", secondaryModel);
    setAgent("fixer", secondaryModel);
  };
  const dedupeModels = (models) => {
    const seen = new Set;
    const result = [];
    for (const model of models) {
      if (!model || seen.has(model))
        continue;
      seen.add(model);
      result.push(model);
    }
    return result;
  };
  const getOpenCodeFallbackForAgent = (agentName) => {
    if (!installConfig.useOpenCodeFreeModels)
      return;
    const isSupport = agentName === "explorer" || agentName === "librarian" || agentName === "fixer";
    if (isSupport) {
      return installConfig.selectedOpenCodeSecondaryModel ?? installConfig.selectedOpenCodePrimaryModel;
    }
    return installConfig.selectedOpenCodePrimaryModel;
  };
  const getChutesFallbackForAgent = (agentName) => {
    if (!installConfig.hasChutes)
      return;
    const isSupport = agentName === "explorer" || agentName === "librarian" || agentName === "fixer";
    if (isSupport) {
      return installConfig.selectedChutesSecondaryModel ?? installConfig.selectedChutesPrimaryModel ?? MODEL_MAPPINGS.chutes[agentName].model;
    }
    return installConfig.selectedChutesPrimaryModel ?? MODEL_MAPPINGS.chutes[agentName].model;
  };
  const attachFallbackConfig = (presetAgents) => {
    const chains = {};
    for (const agentName of AGENT_NAMES) {
      const currentModel = presetAgents[agentName]?.model;
      const chain = dedupeModels([
        currentModel,
        installConfig.hasOpenAI ? MODEL_MAPPINGS.openai[agentName].model : undefined,
        installConfig.hasAnthropic ? MODEL_MAPPINGS.anthropic[agentName].model : undefined,
        installConfig.hasCopilot ? MODEL_MAPPINGS.copilot[agentName].model : undefined,
        installConfig.hasZaiPlan ? MODEL_MAPPINGS["zai-plan"][agentName].model : undefined,
        installConfig.hasKimi ? MODEL_MAPPINGS.kimi[agentName].model : undefined,
        installConfig.hasAntigravity ? MODEL_MAPPINGS.antigravity[agentName].model : undefined,
        getChutesFallbackForAgent(agentName),
        getOpenCodeFallbackForAgent(agentName),
        MODEL_MAPPINGS["zen-free"][agentName].model
      ]);
      if (chain.length > 0) {
        chains[agentName] = chain;
      }
    }
    config2.fallback = {
      enabled: true,
      timeoutMs: 15000,
      chains
    };
  };
  const buildPreset = (mappingName) => {
    const mapping = MODEL_MAPPINGS[mappingName];
    return Object.fromEntries(Object.entries(mapping).map(([agentName, modelInfo]) => {
      let activeModelInfo = { ...modelInfo };
      if (activePreset === "kimi" && installConfig.hasOpenAI && agentName === "oracle") {
        activeModelInfo = { ...MODEL_MAPPINGS.openai.oracle };
      }
      return [agentName, createAgentConfig(agentName, activeModelInfo)];
    }));
  };
  if (activePreset === "antigravity-mixed-both" || activePreset === "antigravity-mixed-kimi" || activePreset === "antigravity-mixed-openai") {
    config2.presets[activePreset] = generateAntigravityMixedPreset(installConfig);
    applyOpenCodeFreeAssignments(config2.presets[activePreset], installConfig.hasKimi || installConfig.hasOpenAI || installConfig.hasAnthropic || installConfig.hasCopilot || installConfig.hasZaiPlan || installConfig.hasAntigravity || installConfig.hasChutes === true);
    applyChutesAssignments(config2.presets[activePreset]);
    attachFallbackConfig(config2.presets[activePreset]);
  } else {
    config2.presets[activePreset] = buildPreset(activePreset);
    applyOpenCodeFreeAssignments(config2.presets[activePreset], installConfig.hasKimi || installConfig.hasOpenAI || installConfig.hasAnthropic || installConfig.hasCopilot || installConfig.hasZaiPlan || installConfig.hasAntigravity || installConfig.hasChutes === true);
    applyChutesAssignments(config2.presets[activePreset]);
    attachFallbackConfig(config2.presets[activePreset]);
  }
  if (installConfig.hasTmux) {
    config2.tmux = {
      enabled: true,
      layout: "main-vertical",
      main_pane_size: 60
    };
  }
  normalizeGeneratedConfig(config2);
  return config2;
}

// src/cli/config-io.ts
var PACKAGE_NAME = "miya";
function stripJsonComments(json2) {
  const commentPattern = /\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g;
  const trailingCommaPattern = /\\"|"(?:\\"|[^"])*"|(,)(\s*[}\]])/g;
  return json2.replace(commentPattern, (match, commentGroup) => commentGroup ? "" : match).replace(trailingCommaPattern, (match, comma, closing) => comma ? closing : match);
}
function parseConfigFile(path4) {
  try {
    if (!existsSync6(path4))
      return { config: null };
    const stat = statSync2(path4);
    if (stat.size === 0)
      return { config: null };
    const content = readFileSync4(path4, "utf-8");
    if (content.trim().length === 0)
      return { config: null };
    return { config: JSON.parse(stripJsonComments(content)) };
  } catch (err) {
    return { config: null, error: String(err) };
  }
}
function parseConfig(path4) {
  const result = parseConfigFile(path4);
  if (result.config || result.error)
    return result;
  if (path4.endsWith(".json")) {
    const jsoncPath = path4.replace(/\.json$/, ".jsonc");
    return parseConfigFile(jsoncPath);
  }
  return { config: null };
}
function writeConfig(configPath, config2) {
  if (configPath.endsWith(".jsonc")) {
    console.warn("[config-manager] Writing to .jsonc file - comments will not be preserved");
  }
  const tmpPath = `${configPath}.tmp`;
  const bakPath = `${configPath}.bak`;
  const content = `${JSON.stringify(config2, null, 2)}
`;
  if (existsSync6(configPath)) {
    copyFileSync2(configPath, bakPath);
  }
  writeFileSync3(tmpPath, content);
  renameSync2(tmpPath, configPath);
}
async function addPluginToOpenCodeConfig() {
  try {
    ensureConfigDir();
  } catch (err) {
    return {
      success: false,
      configPath: getConfigDir(),
      error: `Failed to create config directory: ${err}`
    };
  }
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error48 } = parseConfig(configPath);
    if (error48) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error48}`
      };
    }
    const config2 = parsedConfig ?? {};
    const plugins = config2.plugin ?? [];
    const filteredPlugins = plugins.filter((p) => p !== PACKAGE_NAME && !p.startsWith(`${PACKAGE_NAME}@`));
    filteredPlugins.push(PACKAGE_NAME);
    config2.plugin = filteredPlugins;
    writeConfig(configPath, config2);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to update opencode config: ${err}`
    };
  }
}
function writeLiteConfig(installConfig) {
  const configPath = getLiteConfig();
  try {
    ensureConfigDir();
    const config2 = generateLiteConfig(installConfig);
    const tmpPath = `${configPath}.tmp`;
    const bakPath = `${configPath}.bak`;
    const content = `${JSON.stringify(config2, null, 2)}
`;
    if (existsSync6(configPath)) {
      copyFileSync2(configPath, bakPath);
    }
    writeFileSync3(tmpPath, content);
    renameSync2(tmpPath, configPath);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to write lite config: ${err}`
    };
  }
}
function disableDefaultAgents() {
  const configPath = getExistingConfigPath();
  try {
    ensureConfigDir();
    const { config: parsedConfig, error: error48 } = parseConfig(configPath);
    if (error48) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error48}`
      };
    }
    const config2 = parsedConfig ?? {};
    const agent = config2.agent ?? {};
    agent.explore = { disable: true };
    agent.general = { disable: true };
    config2.agent = agent;
    writeConfig(configPath, config2);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to disable default agents: ${err}`
    };
  }
}
function addAntigravityPlugin() {
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error48 } = parseConfig(configPath);
    if (error48) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error48}`
      };
    }
    const config2 = parsedConfig ?? {};
    const plugins = config2.plugin ?? [];
    const pluginName = "opencode-antigravity-auth@latest";
    if (!plugins.includes(pluginName)) {
      plugins.push(pluginName);
    }
    config2.plugin = plugins;
    writeConfig(configPath, config2);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to add antigravity plugin: ${err}`
    };
  }
}
function addGoogleProvider() {
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error48 } = parseConfig(configPath);
    if (error48) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error48}`
      };
    }
    const config2 = parsedConfig ?? {};
    const providers = config2.provider ?? {};
    providers.google = {
      models: {
        "antigravity-gemini-3-pro": {
          name: "Gemini 3 Pro (Antigravity)",
          limit: { context: 1048576, output: 65535 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            low: { thinkingLevel: "low" },
            high: { thinkingLevel: "high" }
          }
        },
        "antigravity-gemini-3-flash": {
          name: "Gemini 3 Flash (Antigravity)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            minimal: { thinkingLevel: "minimal" },
            low: { thinkingLevel: "low" },
            medium: { thinkingLevel: "medium" },
            high: { thinkingLevel: "high" }
          }
        },
        "antigravity-claude-sonnet-4-5": {
          name: "Claude Sonnet 4.5 (Antigravity)",
          limit: { context: 200000, output: 64000 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "antigravity-claude-sonnet-4-5-thinking": {
          name: "Claude Sonnet 4.5 Thinking (Antigravity)",
          limit: { context: 200000, output: 64000 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            low: { thinkingConfig: { thinkingBudget: 8192 } },
            max: { thinkingConfig: { thinkingBudget: 32768 } }
          }
        },
        "antigravity-claude-opus-4-5-thinking": {
          name: "Claude Opus 4.5 Thinking (Antigravity)",
          limit: { context: 200000, output: 64000 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] },
          variants: {
            low: { thinkingConfig: { thinkingBudget: 8192 } },
            max: { thinkingConfig: { thinkingBudget: 32768 } }
          }
        },
        "gemini-2.5-flash": {
          name: "Gemini 2.5 Flash (Gemini CLI)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "gemini-2.5-pro": {
          name: "Gemini 2.5 Pro (Gemini CLI)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "gemini-3-flash-preview": {
          name: "Gemini 3 Flash Preview (Gemini CLI)",
          limit: { context: 1048576, output: 65536 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        },
        "gemini-3-pro-preview": {
          name: "Gemini 3 Pro Preview (Gemini CLI)",
          limit: { context: 1048576, output: 65535 },
          modalities: { input: ["text", "image", "pdf"], output: ["text"] }
        }
      }
    };
    config2.provider = providers;
    writeConfig(configPath, config2);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to add google provider: ${err}`
    };
  }
}
function addChutesProvider() {
  const configPath = getExistingConfigPath();
  try {
    const { config: parsedConfig, error: error48 } = parseConfig(configPath);
    if (error48) {
      return {
        success: false,
        configPath,
        error: `Failed to parse config: ${error48}`
      };
    }
    const config2 = parsedConfig ?? {};
    const providers = config2.provider ?? {};
    providers.chutes = {
      npm: "@ai-sdk/openai-compatible",
      name: "Chutes",
      options: {
        baseURL: "https://llm.chutes.ai/v1",
        apiKey: "{env:CHUTES_API_KEY}"
      }
    };
    config2.provider = providers;
    writeConfig(configPath, config2);
    return { success: true, configPath };
  } catch (err) {
    return {
      success: false,
      configPath,
      error: `Failed to add chutes provider: ${err}`
    };
  }
}
function detectCurrentConfig() {
  const result = {
    isInstalled: false,
    hasKimi: false,
    hasOpenAI: false,
    hasAnthropic: false,
    hasCopilot: false,
    hasZaiPlan: false,
    hasAntigravity: false,
    hasChutes: false,
    hasOpencodeZen: false,
    hasTmux: false
  };
  const { config: config2 } = parseConfig(getExistingConfigPath());
  if (!config2)
    return result;
  const plugins = config2.plugin ?? [];
  result.isInstalled = plugins.some((p) => p.startsWith(PACKAGE_NAME));
  result.hasAntigravity = plugins.some((p) => p.startsWith("opencode-antigravity-auth"));
  const providers = config2.provider;
  result.hasKimi = !!providers?.kimi;
  result.hasAnthropic = !!providers?.anthropic;
  result.hasCopilot = !!providers?.["github-copilot"];
  result.hasZaiPlan = !!providers?.["zai-coding-plan"];
  result.hasChutes = !!providers?.chutes;
  if (providers?.google)
    result.hasAntigravity = true;
  const { config: liteConfig } = parseConfig(getExistingLiteConfigPath());
  if (liteConfig && typeof liteConfig === "object") {
    const configObj = liteConfig;
    const presetName = configObj.preset;
    const presets = configObj.presets;
    const agents = presets?.[presetName];
    if (agents) {
      const models = Object.values(agents).map((a) => a?.model).filter(Boolean);
      result.hasOpenAI = models.some((m) => m?.startsWith("openai/"));
      result.hasAnthropic = models.some((m) => m?.startsWith("anthropic/"));
      result.hasCopilot = models.some((m) => m?.startsWith("github-copilot/"));
      result.hasZaiPlan = models.some((m) => m?.startsWith("zai-coding-plan/"));
      result.hasOpencodeZen = models.some((m) => m?.startsWith("opencode/"));
      if (models.some((m) => m?.startsWith("google/"))) {
        result.hasAntigravity = true;
      }
      if (models.some((m) => m?.startsWith("chutes/"))) {
        result.hasChutes = true;
      }
    }
    if (configObj.tmux && typeof configObj.tmux === "object") {
      const tmuxConfig = configObj.tmux;
      result.hasTmux = tmuxConfig.enabled === true;
    }
  }
  return result;
}
// src/cli/dynamic-model-selection.ts
init_constants();
var AGENTS = [
  "orchestrator",
  "oracle",
  "designer",
  "explorer",
  "librarian",
  "fixer"
];
function normalizeAgentName3(agentName) {
  return AGENT_ALIASES[agentName] ?? agentName;
}
var ROLE_VARIANT = {
  orchestrator: undefined,
  oracle: "high",
  designer: "medium",
  explorer: "low",
  librarian: "low",
  fixer: "low"
};
function getEnabledProviders(config2) {
  const providers = [];
  if (config2.hasOpenAI)
    providers.push("openai");
  if (config2.hasAnthropic)
    providers.push("anthropic");
  if (config2.hasCopilot)
    providers.push("github-copilot");
  if (config2.hasZaiPlan)
    providers.push("zai-coding-plan");
  if (config2.hasKimi)
    providers.push("kimi-for-coding");
  if (config2.hasAntigravity)
    providers.push("google");
  if (config2.hasChutes)
    providers.push("chutes");
  if (config2.useOpenCodeFreeModels)
    providers.push("opencode");
  return providers;
}
function tokenScore(name, re, points) {
  return re.test(name) ? points : 0;
}
function statusScore(status) {
  if (status === "active")
    return 20;
  if (status === "beta")
    return 8;
  if (status === "alpha")
    return -5;
  return -40;
}
function baseScore(model) {
  const lowered = `${model.model} ${model.name}`.toLowerCase();
  const context = Math.min(model.contextLimit, 1e6) / 50000;
  const output = Math.min(model.outputLimit, 300000) / 30000;
  const deep = tokenScore(lowered, /(opus|pro|thinking|reason|r1|gpt-5|k2\.5)/i, 12);
  const fast = tokenScore(lowered, /(nano|flash|mini|lite|fast|turbo|haiku|small)/i, 12);
  const code = tokenScore(lowered, /(codex|coder|code|dev|program)/i, 12);
  const versionBoost = tokenScore(lowered, /gpt-5\.3/i, 12) + tokenScore(lowered, /gpt-5\.2/i, 8) + tokenScore(lowered, /k2\.5/i, 6);
  return statusScore(model.status) + context + output + deep + fast + code + versionBoost + (model.toolcall ? 25 : 0);
}
function roleScore(agent, model) {
  const lowered = `${model.model} ${model.name}`.toLowerCase();
  const reasoning = model.reasoning ? 1 : 0;
  const toolcall = model.toolcall ? 1 : 0;
  const attachment = model.attachment ? 1 : 0;
  const context = Math.min(model.contextLimit, 1e6) / 60000;
  const output = Math.min(model.outputLimit, 300000) / 40000;
  const deep = tokenScore(lowered, /(opus|pro|thinking|reason|r1|gpt-5|k2\.5)/i, 1);
  const fast = tokenScore(lowered, /(nano|flash|mini|lite|fast|turbo|haiku|small)/i, 1);
  const code = tokenScore(lowered, /(codex|coder|code|dev|program)/i, 1);
  if ((agent === "orchestrator" || agent === "explorer" || agent === "librarian" || agent === "fixer") && !model.toolcall) {
    return -1e4;
  }
  if (model.status === "deprecated") {
    return -5000;
  }
  const score = baseScore(model);
  if (agent === "orchestrator") {
    return score + reasoning * 40 + toolcall * 25 + deep * 10 + code * 8 + context;
  }
  if (agent === "oracle") {
    return score + reasoning * 55 + deep * 18 + context * 1.2 + toolcall * 10;
  }
  if (agent === "designer") {
    return score + attachment * 25 + reasoning * 18 + toolcall * 15 + context * 0.8 + output;
  }
  if (agent === "explorer") {
    return score + fast * 35 + toolcall * 28 + reasoning * 8 + context * 0.7;
  }
  if (agent === "librarian") {
    return score + context * 30 + toolcall * 22 + reasoning * 15 + output * 10;
  }
  return score + code * 28 + toolcall * 24 + fast * 18 + reasoning * 14 + output * 8;
}
function rankModels2(models, agent) {
  return [...models].sort((a, b) => roleScore(agent, b) - roleScore(agent, a));
}
function dedupe(models) {
  const seen = new Set;
  const result = [];
  for (const model of models) {
    if (!model || seen.has(model))
      continue;
    seen.add(model);
    result.push(model);
  }
  return result;
}
function buildDynamicModelPlan(catalog, config2) {
  const enabledProviders = new Set(getEnabledProviders(config2));
  const providerCandidates = catalog.filter((m) => enabledProviders.has(m.providerID));
  if (providerCandidates.length === 0) {
    return null;
  }
  const agents = {};
  const chains = {};
  for (const agent of AGENTS) {
    const ranked = rankModels2(providerCandidates, agent);
    const primary = ranked[0];
    if (!primary)
      continue;
    const providerOrder = dedupe(ranked.map((m) => m.providerID));
    const perProviderBest = providerOrder.map((providerID) => ranked.find((m) => m.providerID === providerID)?.model).filter((m) => Boolean(m));
    const selectedOpencode = agent === "explorer" || agent === "librarian" || agent === "fixer" ? config2.selectedOpenCodeSecondaryModel ?? config2.selectedOpenCodePrimaryModel : config2.selectedOpenCodePrimaryModel;
    const selectedChutes = agent === "explorer" || agent === "librarian" || agent === "fixer" ? config2.selectedChutesSecondaryModel ?? config2.selectedChutesPrimaryModel : config2.selectedChutesPrimaryModel;
    const chain = dedupe([
      primary.model,
      ...perProviderBest,
      selectedChutes,
      selectedOpencode,
      "opencode/big-pickle"
    ]).slice(0, 7);
    agents[normalizeAgentName3(agent)] = {
      model: chain[0] ?? primary.model,
      variant: ROLE_VARIANT[agent]
    };
    chains[normalizeAgentName3(agent)] = chain;
  }
  if (Object.keys(agents).length === 0) {
    return null;
  }
  return { agents, chains };
}
// src/cli/process.ts
import { spawn } from "node:child_process";
async function runCommand(command, args, timeoutMs = 30000) {
  return await new Promise((resolve, reject) => {
    let stdout = "";
    let stderr = "";
    let settled = false;
    const proc = spawn(command, args, {
      stdio: ["ignore", "pipe", "pipe"],
      windowsHide: true
    });
    proc.stdout?.setEncoding("utf8");
    proc.stdout?.on("data", (chunk) => {
      stdout += String(chunk);
    });
    proc.stderr?.setEncoding("utf8");
    proc.stderr?.on("data", (chunk) => {
      stderr += String(chunk);
    });
    const timer = setTimeout(() => {
      if (settled)
        return;
      settled = true;
      try {
        proc.kill();
      } catch {}
      reject(new Error("command_timeout"));
    }, Math.max(1000, timeoutMs));
    proc.on("error", (error48) => {
      if (settled)
        return;
      settled = true;
      clearTimeout(timer);
      reject(error48);
    });
    proc.on("close", (code) => {
      if (settled)
        return;
      settled = true;
      clearTimeout(timer);
      resolve({
        exitCode: code,
        stdout,
        stderr
      });
    });
  });
}

// src/cli/opencode-models.ts
function isFreeModel(record2) {
  const inputCost = record2.cost?.input ?? 0;
  const outputCost = record2.cost?.output ?? 0;
  const cacheReadCost = record2.cost?.cache?.read ?? 0;
  const cacheWriteCost = record2.cost?.cache?.write ?? 0;
  return inputCost === 0 && outputCost === 0 && cacheReadCost === 0 && cacheWriteCost === 0;
}
function parseDailyRequestLimit(record2) {
  const explicitLimit = record2.quota?.requestsPerDay ?? record2.meta?.requestsPerDay ?? record2.meta?.dailyLimit;
  if (typeof explicitLimit === "number" && Number.isFinite(explicitLimit)) {
    return explicitLimit;
  }
  const source = `${record2.id} ${record2.name ?? ""}`.toLowerCase();
  const match = source.match(/\b(300|2000|5000)\b(?:\s*(?:req|requests|rpd|\/day))?/);
  if (!match)
    return;
  const parsed = Number.parseInt(match[1], 10);
  return Number.isFinite(parsed) ? parsed : undefined;
}
function normalizeDiscoveredModel(record2, providerFilter) {
  if (providerFilter && record2.providerID !== providerFilter)
    return null;
  const fullModel = `${record2.providerID}/${record2.id}`;
  return {
    providerID: record2.providerID,
    model: fullModel,
    name: record2.name ?? record2.id,
    status: record2.status ?? "active",
    contextLimit: record2.limit?.context ?? 0,
    outputLimit: record2.limit?.output ?? 0,
    reasoning: record2.capabilities?.reasoning === true,
    toolcall: record2.capabilities?.toolcall === true,
    attachment: record2.capabilities?.attachment === true,
    dailyRequestLimit: parseDailyRequestLimit(record2),
    costInput: record2.cost?.input,
    costOutput: record2.cost?.output
  };
}
function parseOpenCodeModelsVerboseOutput(output, providerFilter, freeOnly = true) {
  const lines = output.split(/\r?\n/);
  const models = [];
  for (let index = 0;index < lines.length; index++) {
    const line = lines[index]?.trim();
    if (!line || !line.includes("/"))
      continue;
    const isModelHeader = /^[a-z0-9-]+\/[a-z0-9._-]+$/i.test(line);
    if (!isModelHeader)
      continue;
    let jsonStart = -1;
    for (let search = index + 1;search < lines.length; search++) {
      if (lines[search]?.trim().startsWith("{")) {
        jsonStart = search;
        break;
      }
      if (/^[a-z0-9-]+\/[a-z0-9._-]+$/i.test(lines[search]?.trim() ?? "")) {
        break;
      }
    }
    if (jsonStart === -1)
      continue;
    let braceDepth = 0;
    const jsonLines = [];
    let jsonEnd = -1;
    for (let cursor = jsonStart;cursor < lines.length; cursor++) {
      const current = lines[cursor] ?? "";
      jsonLines.push(current);
      for (const char of current) {
        if (char === "{")
          braceDepth++;
        if (char === "}")
          braceDepth--;
      }
      if (braceDepth === 0 && jsonLines.length > 0) {
        jsonEnd = cursor;
        break;
      }
    }
    if (jsonEnd === -1)
      continue;
    try {
      const parsed = JSON.parse(jsonLines.join(`
`));
      const normalized = normalizeDiscoveredModel(parsed, providerFilter);
      if (!normalized)
        continue;
      if (freeOnly && !isFreeModel(parsed))
        continue;
      if (normalized)
        models.push(normalized);
    } catch {}
    index = jsonEnd;
  }
  return models;
}
async function discoverFreeModelsByProvider(providerID) {
  try {
    const result = await runCommand("opencode", ["models", "--refresh", "--verbose"], 45000);
    if (result.exitCode !== 0) {
      return {
        models: [],
        error: result.stderr.trim() || "Failed to fetch OpenCode models."
      };
    }
    return {
      models: parseOpenCodeModelsVerboseOutput(result.stdout, providerID, true)
    };
  } catch {
    return {
      models: [],
      error: "Unable to run `opencode models --refresh --verbose`."
    };
  }
}
async function discoverModelCatalog() {
  try {
    const result = await runCommand("opencode", ["models", "--refresh", "--verbose"], 45000);
    if (result.exitCode !== 0) {
      return {
        models: [],
        error: result.stderr.trim() || "Failed to fetch OpenCode models."
      };
    }
    return {
      models: parseOpenCodeModelsVerboseOutput(result.stdout, undefined, false)
    };
  } catch {
    return {
      models: [],
      error: "Unable to run `opencode models --refresh --verbose`."
    };
  }
}
async function discoverOpenCodeFreeModels() {
  return discoverFreeModelsByProvider("opencode");
}
async function discoverProviderFreeModels(providerID) {
  return discoverFreeModelsByProvider(providerID);
}
// src/cli/opencode-selection.ts
var scoreOpenCodePrimaryForCoding = (model) => {
  return (model.reasoning ? 100 : 0) + (model.toolcall ? 80 : 0) + (model.attachment ? 20 : 0) + Math.min(model.contextLimit, 1e6) / 1e4 + Math.min(model.outputLimit, 300000) / 1e4 + (model.status === "active" ? 10 : 0);
};
function speedBonus2(modelName) {
  const lower = modelName.toLowerCase();
  let score = 0;
  if (lower.includes("nano"))
    score += 60;
  if (lower.includes("flash"))
    score += 45;
  if (lower.includes("mini"))
    score += 25;
  if (lower.includes("preview"))
    score += 10;
  return score;
}
var scoreOpenCodeSupportForCoding = (model) => {
  return (model.toolcall ? 90 : 0) + (model.reasoning ? 50 : 0) + speedBonus2(model.model) + Math.min(model.contextLimit, 400000) / 20000 + (model.status === "active" ? 5 : 0);
};
function pickBestCodingOpenCodeModel(models) {
  return pickBestModel(models, scoreOpenCodePrimaryForCoding);
}
function pickSupportOpenCodeModel(models, primaryModel) {
  const { support } = pickPrimaryAndSupport(models, {
    primary: scoreOpenCodePrimaryForCoding,
    support: scoreOpenCodeSupportForCoding
  }, primaryModel);
  return support;
}
// src/cli/system.ts
async function isOpenCodeInstalled() {
  try {
    const result = await runCommand("opencode", ["--version"], 8000);
    return result.exitCode === 0;
  } catch {
    return false;
  }
}
async function isTmuxInstalled() {
  try {
    const result = await runCommand("tmux", ["-V"], 8000);
    return result.exitCode === 0;
  } catch {
    return false;
  }
}
async function getOpenCodeVersion() {
  try {
    const result = await runCommand("opencode", ["--version"], 8000);
    return result.exitCode === 0 ? result.stdout.trim() : null;
  } catch {
    return null;
  }
}
// src/cli/install.ts
var GREEN = "\x1B[32m";
var BLUE = "\x1B[34m";
var YELLOW = "\x1B[33m";
var RED = "\x1B[31m";
var BOLD = "\x1B[1m";
var DIM = "\x1B[2m";
var RESET = "\x1B[0m";
var SYMBOLS = {
  check: `${GREEN}✓${RESET}`,
  cross: `${RED}✗${RESET}`,
  arrow: `${BLUE}→${RESET}`,
  bullet: `${DIM}•${RESET}`,
  info: `${BLUE}ℹ${RESET}`,
  warn: `${YELLOW}⚠${RESET}`,
  star: `${YELLOW}★${RESET}`
};
function printHeader(isUpdate) {
  console.log();
  console.log(`${BOLD}miya ${isUpdate ? "Update" : "Install"}${RESET}`);
  console.log("=".repeat(30));
  console.log();
}
function printStep(step, total, message) {
  console.log(`${DIM}[${step}/${total}]${RESET} ${message}`);
}
function printSuccess(message) {
  console.log(`${SYMBOLS.check} ${message}`);
}
function printError(message) {
  console.log(`${SYMBOLS.cross} ${RED}${message}${RESET}`);
}
function printInfo(message) {
  console.log(`${SYMBOLS.info} ${message}`);
}
function printWarning(message) {
  console.log(`${SYMBOLS.warn} ${YELLOW}${message}${RESET}`);
}
async function checkOpenCodeInstalled() {
  const installed = await isOpenCodeInstalled();
  if (!installed) {
    printError("OpenCode is not installed on this system.");
    printInfo("Install it with:");
    console.log(`     ${BLUE}curl -fsSL https://opencode.ai/install | bash${RESET}`);
    return { ok: false };
  }
  const version2 = await getOpenCodeVersion();
  printSuccess(`OpenCode ${version2 ?? ""} detected`);
  return { ok: true, version: version2 ?? undefined };
}
function handleStepResult(result, successMsg) {
  if (!result.success) {
    printError(`Failed: ${result.error}`);
    return false;
  }
  printSuccess(`${successMsg} ${SYMBOLS.arrow} ${DIM}${result.configPath}${RESET}`);
  return true;
}
function formatConfigSummary(config2) {
  const liteConfig = generateLiteConfig(config2);
  const preset = liteConfig.preset || "unknown";
  const lines = [];
  lines.push(`${BOLD}Configuration Summary${RESET}`);
  lines.push("");
  lines.push(`  ${BOLD}Preset:${RESET} ${BLUE}${preset}${RESET}`);
  lines.push(`  ${config2.hasKimi ? SYMBOLS.check : `${DIM}○${RESET}`} Kimi`);
  lines.push(`  ${config2.hasOpenAI ? SYMBOLS.check : `${DIM}○${RESET}`} OpenAI`);
  lines.push(`  ${config2.hasAnthropic ? SYMBOLS.check : `${DIM}○${RESET}`} Anthropic`);
  lines.push(`  ${config2.hasCopilot ? SYMBOLS.check : `${DIM}○${RESET}`} GitHub Copilot`);
  lines.push(`  ${config2.hasZaiPlan ? SYMBOLS.check : `${DIM}○${RESET}`} ZAI Coding Plan`);
  lines.push(`  ${config2.hasAntigravity ? SYMBOLS.check : `${DIM}○${RESET}`} Antigravity (Google)`);
  lines.push(`  ${config2.hasChutes ? SYMBOLS.check : `${DIM}○${RESET}`} Chutes`);
  lines.push(`  ${SYMBOLS.check} Opencode Zen`);
  if (config2.useOpenCodeFreeModels && config2.selectedOpenCodePrimaryModel) {
    lines.push(`  ${SYMBOLS.check} OpenCode Free Primary: ${BLUE}${config2.selectedOpenCodePrimaryModel}${RESET}`);
  }
  if (config2.useOpenCodeFreeModels && config2.selectedOpenCodeSecondaryModel) {
    lines.push(`  ${SYMBOLS.check} OpenCode Free Support: ${BLUE}${config2.selectedOpenCodeSecondaryModel}${RESET}`);
  }
  if (config2.hasChutes && config2.selectedChutesPrimaryModel) {
    lines.push(`  ${SYMBOLS.check} Chutes Primary: ${BLUE}${config2.selectedChutesPrimaryModel}${RESET}`);
  }
  if (config2.hasChutes && config2.selectedChutesSecondaryModel) {
    lines.push(`  ${SYMBOLS.check} Chutes Support: ${BLUE}${config2.selectedChutesSecondaryModel}${RESET}`);
  }
  lines.push(`  ${config2.hasTmux ? SYMBOLS.check : `${DIM}○${RESET}`} Tmux Integration`);
  return lines.join(`
`);
}
function printAgentModels(config2) {
  const liteConfig = generateLiteConfig(config2);
  const presetName = liteConfig.preset || "unknown";
  const presets = liteConfig.presets;
  const agents = presets?.[presetName];
  if (!agents || Object.keys(agents).length === 0)
    return;
  console.log(`${BOLD}Agent Configuration (Preset: ${BLUE}${presetName}${RESET}):${RESET}`);
  console.log();
  const maxAgentLen = Math.max(...Object.keys(agents).map((a) => a.length));
  for (const [agent, info] of Object.entries(agents)) {
    const padding = " ".repeat(maxAgentLen - agent.length);
    const skillsStr = info.skills.length > 0 ? ` ${DIM}[${info.skills.join(", ")}]${RESET}` : "";
    console.log(`  ${DIM}${agent}${RESET}${padding} ${SYMBOLS.arrow} ${BLUE}${info.model}${RESET}${skillsStr}`);
  }
  console.log();
}
function argsToConfig(args) {
  return {
    hasKimi: args.kimi === "yes",
    hasOpenAI: args.openai === "yes",
    hasAnthropic: args.anthropic === "yes",
    hasCopilot: args.copilot === "yes",
    hasZaiPlan: args.zaiPlan === "yes",
    hasAntigravity: args.antigravity === "yes",
    hasChutes: args.chutes === "yes",
    hasOpencodeZen: true,
    useOpenCodeFreeModels: args.opencodeFree === "yes",
    preferredOpenCodeModel: args.opencodeFreeModel && args.opencodeFreeModel !== "auto" ? args.opencodeFreeModel : undefined,
    hasTmux: args.tmux === "yes",
    installSkills: args.skills === "yes",
    installCustomSkills: args.skills === "yes",
    isolated: args.isolated === "yes"
  };
}
function applyIsolatedConfigHomeIfNeeded(enable) {
  if (!enable)
    return null;
  const isolatedHome = path4.join(process.cwd(), ".opencode", "miya-isolated-xdg");
  fs4.mkdirSync(isolatedHome, { recursive: true });
  process.env.XDG_CONFIG_HOME = isolatedHome;
  return isolatedHome;
}
async function askModelSelection(rl, models, defaultModel, prompt) {
  const defaultIndex = Math.max(0, models.findIndex((model) => model.model === defaultModel));
  for (const [index, model] of models.entries()) {
    const marker = model.model === defaultModel ? `${BOLD}(recommended)${RESET}` : "";
    console.log(`  ${DIM}${index + 1}.${RESET} ${BLUE}${model.model}${RESET} ${DIM}${model.name}${RESET} ${marker}`);
  }
  const answer = (await rl.question(`${BLUE}${prompt}${RESET} ${DIM}[default: ${defaultIndex + 1}]${RESET}: `)).trim().toLowerCase();
  if (!answer)
    return defaultModel;
  const asNumber = Number.parseInt(answer, 10);
  if (Number.isFinite(asNumber)) {
    const chosen = models[asNumber - 1];
    if (chosen)
      return chosen.model;
  }
  const byId = models.find((model) => model.model.toLowerCase() === answer);
  return byId?.model ?? defaultModel;
}
async function askYesNo(rl, prompt, defaultValue = "no") {
  const hint = defaultValue === "yes" ? "[Y/n]" : "[y/N]";
  const answer = (await rl.question(`${BLUE}${prompt}${RESET} ${hint}: `)).trim().toLowerCase();
  if (answer === "")
    return defaultValue;
  if (answer === "y" || answer === "yes")
    return "yes";
  if (answer === "n" || answer === "no")
    return "no";
  return defaultValue;
}
async function runInteractiveMode(detected) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  const tmuxInstalled = await isTmuxInstalled();
  const totalQuestions = tmuxInstalled ? 9 : 8;
  try {
    console.log(`${BOLD}Question 1/${totalQuestions}:${RESET}`);
    const useOpenCodeFree = await askYesNo(rl, "Use only OpenCode free models (opencode/*) with live refresh?", "yes");
    console.log();
    let availableOpenCodeFreeModels;
    let selectedOpenCodePrimaryModel;
    let selectedOpenCodeSecondaryModel;
    let availableChutesFreeModels;
    let selectedChutesPrimaryModel;
    let selectedChutesSecondaryModel;
    if (useOpenCodeFree === "yes") {
      printInfo("Refreshing models with: opencode models --refresh --verbose");
      const discovery = await discoverOpenCodeFreeModels();
      if (discovery.models.length === 0) {
        printWarning(discovery.error ?? "No OpenCode free models found. Continuing without OpenCode free-model assignment.");
      } else {
        availableOpenCodeFreeModels = discovery.models;
        const recommendedPrimary = pickBestCodingOpenCodeModel(discovery.models)?.model ?? discovery.models[0]?.model;
        if (recommendedPrimary) {
          console.log(`${BOLD}OpenCode Free Models:${RESET}`);
          selectedOpenCodePrimaryModel = await askModelSelection(rl, discovery.models, recommendedPrimary, "Choose primary model for 1-task-manager/4-architecture-advisor");
        }
        if (selectedOpenCodePrimaryModel) {
          const recommendedSecondary = pickSupportOpenCodeModel(discovery.models, selectedOpenCodePrimaryModel)?.model ?? selectedOpenCodePrimaryModel;
          selectedOpenCodeSecondaryModel = await askModelSelection(rl, discovery.models, recommendedSecondary, "Choose support model for 2-code-search/3-docs-helper/5-code-fixer");
        }
        console.log();
      }
    }
    console.log(`${BOLD}Question 2/${totalQuestions}:${RESET}`);
    const kimi = await askYesNo(rl, "Do you want to use Kimi For Coding?", detected.hasKimi ? "yes" : "no");
    console.log();
    console.log(`${BOLD}Question 3/${totalQuestions}:${RESET}`);
    const openai = await askYesNo(rl, "Do you have access to OpenAI API?", detected.hasOpenAI ? "yes" : "no");
    console.log();
    console.log(`${BOLD}Question 4/${totalQuestions}:${RESET}`);
    const anthropic = await askYesNo(rl, "Do you have access to Anthropic models?", detected.hasAnthropic ? "yes" : "no");
    console.log();
    console.log(`${BOLD}Question 5/${totalQuestions}:${RESET}`);
    const copilot = await askYesNo(rl, "Do you have access to GitHub Copilot models?", detected.hasCopilot ? "yes" : "no");
    console.log();
    console.log(`${BOLD}Question 6/${totalQuestions}:${RESET}`);
    const zaiPlan = await askYesNo(rl, "Do you have access to ZAI Coding Plan models?", detected.hasZaiPlan ? "yes" : "no");
    console.log();
    console.log(`${BOLD}Question 7/${totalQuestions}:${RESET}`);
    const antigravity = await askYesNo(rl, "Enable Antigravity authentication for Google models?", detected.hasAntigravity ? "yes" : "no");
    console.log();
    console.log(`${BOLD}Question 8/${totalQuestions}:${RESET}`);
    const chutes = await askYesNo(rl, "Enable Chutes provider with free daily capped models?", detected.hasChutes ? "yes" : "no");
    console.log();
    if (chutes === "yes") {
      printInfo("Refreshing Chutes model list with: opencode models --refresh --verbose");
      const discovery = await discoverProviderFreeModels("chutes");
      if (discovery.models.length === 0) {
        printWarning(discovery.error ?? "No free Chutes models found. Continuing without Chutes dynamic assignment.");
      } else {
        availableChutesFreeModels = discovery.models;
        const recommendedPrimary = pickBestCodingChutesModel(discovery.models)?.model ?? discovery.models[0]?.model;
        if (recommendedPrimary) {
          console.log(`${BOLD}Chutes Free Models:${RESET}`);
          selectedChutesPrimaryModel = await askModelSelection(rl, discovery.models, recommendedPrimary, "Choose Chutes primary model for 1-task-manager/4-architecture-advisor/6-ui-designer");
        }
        if (selectedChutesPrimaryModel) {
          const recommendedSecondary = pickSupportChutesModel(discovery.models, selectedChutesPrimaryModel)?.model ?? selectedChutesPrimaryModel;
          selectedChutesSecondaryModel = await askModelSelection(rl, discovery.models, recommendedSecondary, "Choose Chutes support model for 2-code-search/3-docs-helper/5-code-fixer");
        }
        console.log();
      }
    }
    let tmux = "no";
    if (tmuxInstalled) {
      console.log(`${BOLD}Question 9/${totalQuestions}:${RESET}`);
      printInfo(`${BOLD}Tmux detected!${RESET} We can enable tmux integration for sub-agent panes.`);
      tmux = await askYesNo(rl, "Enable tmux integration?", detected.hasTmux ? "yes" : "no");
      console.log();
    }
    console.log(`${BOLD}Recommended Skills:${RESET}`);
    for (const skill of RECOMMENDED_SKILLS) {
      console.log(`  ${SYMBOLS.bullet} ${BOLD}${skill.name}${RESET}: ${skill.description}`);
    }
    console.log();
    const skills = await askYesNo(rl, "Install recommended skills?", "yes");
    console.log();
    console.log(`${BOLD}Custom Skills:${RESET}`);
    for (const skill of CUSTOM_SKILLS) {
      console.log(`  ${SYMBOLS.bullet} ${BOLD}${skill.name}${RESET}: ${skill.description}`);
    }
    console.log();
    const customSkills = await askYesNo(rl, "Install custom skills?", "yes");
    console.log();
    return {
      hasKimi: kimi === "yes",
      hasOpenAI: openai === "yes",
      hasAnthropic: anthropic === "yes",
      hasCopilot: copilot === "yes",
      hasZaiPlan: zaiPlan === "yes",
      hasAntigravity: antigravity === "yes",
      hasChutes: chutes === "yes",
      hasOpencodeZen: true,
      useOpenCodeFreeModels: useOpenCodeFree === "yes" && selectedOpenCodePrimaryModel !== undefined,
      selectedOpenCodePrimaryModel,
      selectedOpenCodeSecondaryModel,
      availableOpenCodeFreeModels,
      selectedChutesPrimaryModel,
      selectedChutesSecondaryModel,
      availableChutesFreeModels,
      hasTmux: tmux === "yes",
      installSkills: skills === "yes",
      installCustomSkills: customSkills === "yes"
    };
  } finally {
    rl.close();
  }
}
async function runInstall(config2) {
  const resolvedConfig = {
    ...config2
  };
  const detected = detectCurrentConfig();
  const isUpdate = detected.isInstalled;
  printHeader(isUpdate);
  const hasAnyEnabledProvider = resolvedConfig.hasKimi || resolvedConfig.hasOpenAI || resolvedConfig.hasAnthropic || resolvedConfig.hasCopilot || resolvedConfig.hasZaiPlan || resolvedConfig.hasAntigravity || resolvedConfig.hasChutes || resolvedConfig.useOpenCodeFreeModels;
  let totalSteps = 4;
  if (resolvedConfig.useOpenCodeFreeModels)
    totalSteps += 1;
  if (resolvedConfig.hasAntigravity)
    totalSteps += 2;
  if (resolvedConfig.hasChutes)
    totalSteps += 1;
  if (hasAnyEnabledProvider)
    totalSteps += 1;
  if (resolvedConfig.installSkills)
    totalSteps += 1;
  if (resolvedConfig.installCustomSkills)
    totalSteps += 1;
  let step = 1;
  printStep(step++, totalSteps, "Checking OpenCode installation...");
  const { ok } = await checkOpenCodeInstalled();
  if (!ok)
    return 1;
  if (resolvedConfig.useOpenCodeFreeModels && (resolvedConfig.availableOpenCodeFreeModels?.length ?? 0) === 0) {
    printStep(step++, totalSteps, "Refreshing OpenCode free models (opencode/*)...");
    const discovery = await discoverOpenCodeFreeModels();
    if (discovery.models.length === 0) {
      printWarning(discovery.error ?? "No OpenCode free models found. Continuing without dynamic OpenCode assignment.");
      resolvedConfig.useOpenCodeFreeModels = false;
    } else {
      resolvedConfig.availableOpenCodeFreeModels = discovery.models;
      const selectedPrimary = resolvedConfig.preferredOpenCodeModel && discovery.models.some((model) => model.model === resolvedConfig.preferredOpenCodeModel) ? resolvedConfig.preferredOpenCodeModel : resolvedConfig.selectedOpenCodePrimaryModel ?? pickBestCodingOpenCodeModel(discovery.models)?.model;
      resolvedConfig.selectedOpenCodePrimaryModel = selectedPrimary ?? discovery.models[0]?.model;
      resolvedConfig.selectedOpenCodeSecondaryModel = resolvedConfig.selectedOpenCodeSecondaryModel ?? pickSupportOpenCodeModel(discovery.models, resolvedConfig.selectedOpenCodePrimaryModel)?.model ?? resolvedConfig.selectedOpenCodePrimaryModel;
      printSuccess(`OpenCode free models ready (${discovery.models.length} models found)`);
    }
  } else if (resolvedConfig.useOpenCodeFreeModels && (resolvedConfig.availableOpenCodeFreeModels?.length ?? 0) > 0) {
    const availableModels = resolvedConfig.availableOpenCodeFreeModels ?? [];
    resolvedConfig.selectedOpenCodePrimaryModel = resolvedConfig.selectedOpenCodePrimaryModel ?? pickBestCodingOpenCodeModel(availableModels)?.model;
    resolvedConfig.selectedOpenCodeSecondaryModel = resolvedConfig.selectedOpenCodeSecondaryModel ?? pickSupportOpenCodeModel(availableModels, resolvedConfig.selectedOpenCodePrimaryModel)?.model ?? resolvedConfig.selectedOpenCodePrimaryModel;
    printStep(step++, totalSteps, "Using previously refreshed OpenCode free model list...");
    printSuccess(`OpenCode free models ready (${availableModels.length} models found)`);
  }
  if (resolvedConfig.hasChutes && (resolvedConfig.availableChutesFreeModels?.length ?? 0) === 0) {
    printStep(step++, totalSteps, "Refreshing Chutes free models (chutes/*)...");
    const discovery = await discoverProviderFreeModels("chutes");
    if (discovery.models.length === 0) {
      printWarning(discovery.error ?? "No free Chutes models found. Continuing with fallback Chutes mapping.");
    } else {
      resolvedConfig.availableChutesFreeModels = discovery.models;
      resolvedConfig.selectedChutesPrimaryModel = resolvedConfig.selectedChutesPrimaryModel ?? pickBestCodingChutesModel(discovery.models)?.model ?? discovery.models[0]?.model;
      resolvedConfig.selectedChutesSecondaryModel = resolvedConfig.selectedChutesSecondaryModel ?? pickSupportChutesModel(discovery.models, resolvedConfig.selectedChutesPrimaryModel)?.model ?? resolvedConfig.selectedChutesPrimaryModel;
      printSuccess(`Chutes models ready (${discovery.models.length} models found)`);
    }
  } else if (resolvedConfig.hasChutes && (resolvedConfig.availableChutesFreeModels?.length ?? 0) > 0) {
    const availableChutes = resolvedConfig.availableChutesFreeModels ?? [];
    resolvedConfig.selectedChutesPrimaryModel = resolvedConfig.selectedChutesPrimaryModel ?? pickBestCodingChutesModel(availableChutes)?.model;
    resolvedConfig.selectedChutesSecondaryModel = resolvedConfig.selectedChutesSecondaryModel ?? pickSupportChutesModel(availableChutes, resolvedConfig.selectedChutesPrimaryModel)?.model ?? resolvedConfig.selectedChutesPrimaryModel;
    printStep(step++, totalSteps, "Using previously refreshed Chutes free model list...");
    printSuccess(`Chutes models ready (${availableChutes.length} models found)`);
  }
  printStep(step++, totalSteps, "Adding miya plugin...");
  const pluginResult = await addPluginToOpenCodeConfig();
  if (!handleStepResult(pluginResult, "Plugin added"))
    return 1;
  if (resolvedConfig.hasAntigravity) {
    printStep(step++, totalSteps, "Adding Antigravity plugin...");
    const antigravityPluginResult = addAntigravityPlugin();
    if (!handleStepResult(antigravityPluginResult, "Antigravity plugin added"))
      return 1;
    printStep(step++, totalSteps, "Configuring Google Provider...");
    const googleProviderResult = addGoogleProvider();
    if (!handleStepResult(googleProviderResult, "Google Provider configured"))
      return 1;
  }
  if (resolvedConfig.hasChutes) {
    printStep(step++, totalSteps, "Configuring Chutes Provider...");
    const chutesProviderResult = addChutesProvider();
    if (!handleStepResult(chutesProviderResult, "Chutes Provider configured"))
      return 1;
  }
  if (hasAnyEnabledProvider) {
    printStep(step++, totalSteps, "Resolving dynamic model assignments...");
    const catalogDiscovery = await discoverModelCatalog();
    if (catalogDiscovery.models.length === 0) {
      printWarning(catalogDiscovery.error ?? "Unable to discover model catalog. Falling back to static mappings.");
    } else {
      const dynamicPlan = buildDynamicModelPlan(catalogDiscovery.models, resolvedConfig);
      if (!dynamicPlan) {
        printWarning("Dynamic planner found no suitable models. Using static mappings.");
      } else {
        resolvedConfig.dynamicModelPlan = dynamicPlan;
        printSuccess(`Dynamic assignments ready (${Object.keys(dynamicPlan.agents).length} agents)`);
      }
    }
  }
  printStep(step++, totalSteps, "Disabling OpenCode default agents...");
  const agentResult = disableDefaultAgents();
  if (!handleStepResult(agentResult, "Default agents disabled"))
    return 1;
  printStep(step++, totalSteps, "Writing miya configuration...");
  const liteResult = writeLiteConfig(resolvedConfig);
  if (!handleStepResult(liteResult, "Config written"))
    return 1;
  if (resolvedConfig.installSkills) {
    printStep(step++, totalSteps, "Installing recommended skills...");
    let skillsInstalled = 0;
    for (const skill of RECOMMENDED_SKILLS) {
      printInfo(`Installing ${skill.name}...`);
      if (installSkill(skill)) {
        printSuccess(`Installed: ${skill.name}`);
        skillsInstalled++;
      } else {
        printWarning(`Failed to install: ${skill.name}`);
      }
    }
    printSuccess(`${skillsInstalled}/${RECOMMENDED_SKILLS.length} skills installed`);
  }
  if (resolvedConfig.installCustomSkills) {
    printStep(step++, totalSteps, "Installing custom skills...");
    let customSkillsInstalled = 0;
    for (const skill of CUSTOM_SKILLS) {
      printInfo(`Installing ${skill.name}...`);
      if (installCustomSkill(skill)) {
        printSuccess(`Installed: ${skill.name}`);
        customSkillsInstalled++;
      } else {
        printWarning(`Failed to install: ${skill.name}`);
      }
    }
    printSuccess(`${customSkillsInstalled}/${CUSTOM_SKILLS.length} custom skills installed`);
  }
  console.log();
  console.log(formatConfigSummary(resolvedConfig));
  console.log();
  printAgentModels(resolvedConfig);
  if (!resolvedConfig.hasKimi && !resolvedConfig.hasOpenAI && !resolvedConfig.hasAnthropic && !resolvedConfig.hasCopilot && !resolvedConfig.hasZaiPlan && !resolvedConfig.hasAntigravity && !resolvedConfig.hasChutes) {
    printWarning("No providers configured. Zen Big Pickle models will be used as fallback.");
  }
  console.log(`${SYMBOLS.star} ${BOLD}${GREEN}${isUpdate ? "Configuration updated!" : "Installation complete!"}${RESET}`);
  console.log();
  console.log(`${BOLD}Next steps:${RESET}`);
  console.log();
  let nextStep = 1;
  if (resolvedConfig.hasKimi || resolvedConfig.hasOpenAI || resolvedConfig.hasAnthropic || resolvedConfig.hasCopilot || resolvedConfig.hasZaiPlan || resolvedConfig.hasAntigravity || resolvedConfig.hasChutes) {
    console.log(`  ${nextStep++}. Authenticate with your providers:`);
    console.log(`     ${BLUE}$ opencode auth login${RESET}`);
    if (resolvedConfig.hasKimi) {
      console.log();
      console.log(`     Then select ${BOLD}Kimi For Coding${RESET} provider.`);
    }
    if (resolvedConfig.hasAntigravity) {
      console.log();
      console.log(`     Then select ${BOLD}google${RESET} provider.`);
    }
    if (resolvedConfig.hasAnthropic) {
      console.log();
      console.log(`     Then select ${BOLD}anthropic${RESET} provider.`);
    }
    if (resolvedConfig.hasCopilot) {
      console.log();
      console.log(`     Then select ${BOLD}github-copilot${RESET} provider.`);
    }
    if (resolvedConfig.hasZaiPlan) {
      console.log();
      console.log(`     Then select ${BOLD}zai-coding-plan${RESET} provider.`);
    }
    if (resolvedConfig.hasChutes) {
      console.log();
      console.log(`     Then set ${BOLD}CHUTES_API_KEY${RESET} in your shell.`);
    }
    console.log();
  }
  if (resolvedConfig.hasTmux) {
    console.log(`  ${nextStep++}. Run OpenCode inside tmux:`);
    console.log(`     ${BLUE}$ tmux${RESET}`);
    console.log(`     ${BLUE}$ opencode${RESET}`);
  } else {
    console.log(`  ${nextStep++}. Start OpenCode:`);
    console.log(`     ${BLUE}$ opencode${RESET}`);
  }
  console.log();
  return 0;
}
async function install(args) {
  const isolatedHome = applyIsolatedConfigHomeIfNeeded(args.isolated === "yes");
  if (isolatedHome) {
    printInfo(`Isolated mode enabled: XDG_CONFIG_HOME=${isolatedHome}`);
  }
  if (!args.tui) {
    const requiredArgs = [
      "kimi",
      "openai",
      "anthropic",
      "copilot",
      "zaiPlan",
      "antigravity",
      "chutes",
      "tmux"
    ];
    const errors3 = requiredArgs.filter((key) => {
      const value = args[key];
      return value === undefined || !["yes", "no"].includes(value);
    });
    if (errors3.length > 0) {
      printHeader(false);
      printError("Missing or invalid arguments:");
      for (const key of errors3) {
        const flagName = key === "zaiPlan" ? "zai-plan" : key;
        console.log(`  ${SYMBOLS.bullet} --${flagName}=<yes|no>`);
      }
      console.log();
      printInfo("Usage: miya install --no-tui --kimi=<yes|no> --openai=<yes|no> --anthropic=<yes|no> --copilot=<yes|no> --zai-plan=<yes|no> --antigravity=<yes|no> --chutes=<yes|no> --tmux=<yes|no> [--isolated=<yes|no>]");
      console.log();
      return 1;
    }
    return runInstall(argsToConfig(args));
  }
  const detected = detectCurrentConfig();
  printHeader(detected.isInstalled);
  printStep(1, 1, "Checking OpenCode installation...");
  const { ok } = await checkOpenCodeInstalled();
  if (!ok)
    return 1;
  console.log();
  const config2 = await runInteractiveMode(detected);
  return runInstall(config2);
}

// src/nodes/client.ts
init_daemon();
init_workflow();
import { randomUUID as randomUUID18 } from "node:crypto";
import * as fs43 from "node:fs";
import * as os6 from "node:os";
import * as path43 from "node:path";
var DEFAULT_CAPABILITIES = ["system.info", "system.which", "system.run"];
function runtimeDir(projectDir) {
  return path43.join(getMiyaRuntimeDir(projectDir), "node-host");
}
function approvalFile(projectDir) {
  return path43.join(runtimeDir(projectDir), "approval-rules.json");
}
function historyFile(projectDir) {
  return path43.join(runtimeDir(projectDir), "invocation-history.jsonl");
}
function ensureRuntimeDir(projectDir) {
  fs43.mkdirSync(runtimeDir(projectDir), { recursive: true });
}
function loadApprovalConfig(projectDir) {
  ensureRuntimeDir(projectDir);
  const file3 = approvalFile(projectDir);
  if (!fs43.existsSync(file3)) {
    const defaults = {
      allowAllReadOnly: true,
      requireExplicitForRun: true,
      allow: [
        { capability: "system.run", pattern: "^echo\\b" },
        { capability: "system.run", pattern: "^pwd\\b" },
        { capability: "system.run", pattern: "^dir\\b" },
        { capability: "system.run", pattern: "^ls\\b" }
      ],
      deny: [
        { capability: "system.run", pattern: "(?i)\\brm\\s+-rf\\b" },
        { capability: "system.run", pattern: "(?i)\\bdel\\b" },
        { capability: "system.run", pattern: "(?i)\\bformat\\b" }
      ]
    };
    fs43.writeFileSync(file3, `${JSON.stringify(defaults, null, 2)}
`, "utf-8");
    return defaults;
  }
  try {
    const parsed = JSON.parse(fs43.readFileSync(file3, "utf-8"));
    return {
      allowAllReadOnly: parsed.allowAllReadOnly ?? true,
      requireExplicitForRun: parsed.requireExplicitForRun ?? true,
      allow: Array.isArray(parsed.allow) ? parsed.allow : [],
      deny: Array.isArray(parsed.deny) ? parsed.deny : []
    };
  } catch {
    return {
      allowAllReadOnly: true,
      requireExplicitForRun: true,
      allow: [],
      deny: []
    };
  }
}
function evaluateRule(rule, capability, payload) {
  if (rule.capability !== capability)
    return false;
  if (!rule.pattern)
    return true;
  try {
    return new RegExp(rule.pattern).test(payload);
  } catch {
    return false;
  }
}
function isAllowedByLocalPolicy(config3, capability, args) {
  const payload = JSON.stringify(args ?? {});
  if (config3.deny.some((rule) => evaluateRule(rule, capability, payload))) {
    return { ok: false, reason: "blocked_by_local_deny_rule" };
  }
  if (config3.allowAllReadOnly && (capability === "system.info" || capability === "system.which")) {
    return { ok: true };
  }
  if (capability === "system.run" && config3.requireExplicitForRun) {
    const allowed = config3.allow.some((rule) => evaluateRule(rule, capability, payload));
    return allowed ? { ok: true } : { ok: false, reason: "system.run_requires_allow_rule" };
  }
  if (config3.allow.some((rule) => evaluateRule(rule, capability, payload))) {
    return { ok: true };
  }
  return { ok: false, reason: "no_matching_allow_rule" };
}
function appendHistory(projectDir, row) {
  ensureRuntimeDir(projectDir);
  fs43.appendFileSync(historyFile(projectDir), `${JSON.stringify(row)}
`, "utf-8");
}
function runShellCommand(command, timeoutMs) {
  const cmd = process.platform === "win32" ? ["powershell", "-NoProfile", "-Command", command] : ["sh", "-lc", command];
  const proc = Bun.spawnSync(cmd, {
    stdout: "pipe",
    stderr: "pipe",
    timeout: Math.max(1000, Math.min(timeoutMs, 10 * 60 * 1000))
  });
  return {
    ok: proc.exitCode === 0,
    exitCode: proc.exitCode,
    stdout: Buffer.from(proc.stdout).toString("utf-8"),
    stderr: Buffer.from(proc.stderr).toString("utf-8")
  };
}
async function executeCapability(projectDir, payload) {
  if (payload.capability === "system.info") {
    return {
      ok: true,
      result: {
        platform: process.platform,
        arch: process.arch,
        hostname: os6.hostname(),
        cpus: os6.cpus().length,
        memory: os6.totalmem()
      }
    };
  }
  if (payload.capability === "system.which") {
    const binary = typeof payload.args.binary === "string" ? payload.args.binary : "";
    if (!binary)
      return { ok: false, error: "missing_binary" };
    const cmd = process.platform === "win32" ? `where ${binary}` : `which ${binary}`;
    const result = runShellCommand(cmd, 1e4);
    return {
      ok: result.ok,
      result: result.ok ? { binary, path: result.stdout.trim() } : undefined,
      error: result.ok ? undefined : result.stderr.trim() || "binary_not_found"
    };
  }
  if (payload.capability === "system.run") {
    const command = typeof payload.args.command === "string" ? payload.args.command : "";
    const timeoutMs = typeof payload.args.timeoutMs === "number" ? Number(payload.args.timeoutMs) : 120000;
    if (!command)
      return { ok: false, error: "missing_command" };
    const daemon = getMiyaClient(projectDir);
    const result = await daemon.runIsolatedProcess({
      kind: "shell.exec",
      command: process.platform === "win32" ? "powershell" : "sh",
      args: process.platform === "win32" ? ["-NoProfile", "-Command", command] : ["-lc", command],
      timeoutMs,
      resource: {
        priority: 70,
        vramMB: 0
      },
      metadata: {
        capability: payload.capability
      }
    });
    return {
      ok: result.exitCode === 0 && !result.timedOut,
      result: {
        exitCode: result.exitCode,
        stdout: result.stdout.trim(),
        stderr: result.stderr.trim()
      },
      error: result.exitCode === 0 && !result.timedOut ? undefined : result.timedOut ? "timeout" : `exit_${result.exitCode}`
    };
  }
  if (payload.capability === "canvas.render") {
    const content = typeof payload.args.content === "string" ? payload.args.content : "";
    if (!content)
      return { ok: false, error: "missing_canvas_content" };
    const canvasDir = path43.join(runtimeDir(projectDir), "canvas");
    fs43.mkdirSync(canvasDir, { recursive: true });
    const file3 = path43.join(canvasDir, `canvas-${Date.now()}.txt`);
    fs43.writeFileSync(file3, content, "utf-8");
    return {
      ok: true,
      result: {
        saved: true,
        path: file3
      }
    };
  }
  return { ok: false, error: `unsupported_capability:${payload.capability}` };
}
async function sendFrame(socket, frame) {
  socket.send(JSON.stringify(frame));
}
async function runNodeHost(options) {
  const projectDir = options.projectDir;
  const nodeID = options.nodeID || process.env.MIYA_NODE_ID || `node-${os6.hostname()}-${randomUUID18().slice(0, 8)}`;
  const deviceID = options.deviceID || process.env.MIYA_DEVICE_ID || `${os6.hostname()}-${process.platform}-${process.arch}`;
  const capabilities = [...new Set(options.capabilities ?? DEFAULT_CAPABILITIES)];
  const nodeType = options.nodeType ?? "cli";
  const wsUrl = `${options.gatewayUrl.replace(/^http/, "ws")}/ws`;
  const gatewayToken = process.env.MIYA_GATEWAY_TOKEN;
  const nodeToken = options.nodeToken || process.env.MIYA_NODE_TOKEN;
  let stopRequested = false;
  let socket;
  let reconnectTimer;
  let heartbeatTimer;
  const connect = async () => {
    if (stopRequested)
      return;
    socket = new WebSocket(wsUrl);
    socket.onopen = () => {
      sendFrame(socket, {
        type: "hello",
        role: "node",
        protocolVersion: "1.0",
        clientID: nodeID,
        auth: gatewayToken ? { token: gatewayToken } : undefined,
        capabilities
      });
      sendFrame(socket, {
        type: "request",
        id: `register-${Date.now()}`,
        method: "nodes.register",
        params: {
          nodeID,
          deviceID,
          type: nodeType,
          token: nodeToken,
          platform: process.platform,
          capabilities,
          permissions: options.permissions
        }
      });
      if (heartbeatTimer)
        clearInterval(heartbeatTimer);
      heartbeatTimer = setInterval(() => {
        if (!socket || socket.readyState !== WebSocket.OPEN)
          return;
        sendFrame(socket, {
          type: "request",
          id: `hb-${Date.now()}`,
          method: "nodes.heartbeat",
          params: {
            nodeID
          }
        });
      }, 30000);
      sendFrame(socket, {
        type: "request",
        id: `sub-${Date.now()}`,
        method: "gateway.subscribe",
        params: { events: ["*"] }
      });
    };
    socket.onmessage = (event) => {
      (async () => {
        const text = String(event.data ?? "");
        if (!text.trim())
          return;
        const frame = JSON.parse(text);
        if (frame.type !== "event" || frame.event !== "node.invoke.request")
          return;
        const payload = frame.payload;
        if (!payload || payload.nodeID !== nodeID)
          return;
        const policy = loadApprovalConfig(projectDir);
        const allowed = isAllowedByLocalPolicy(policy, payload.capability, payload.args);
        let response;
        if (!allowed.ok) {
          response = { ok: false, error: allowed.reason ?? "blocked_by_local_policy" };
        } else {
          response = await executeCapability(projectDir, payload);
        }
        appendHistory(projectDir, {
          at: new Date().toISOString(),
          nodeID,
          invokeID: payload.id,
          capability: payload.capability,
          args: payload.args,
          ok: response.ok,
          error: response.error
        });
        await sendFrame(socket, {
          type: "request",
          id: `invoke-result-${payload.id}`,
          method: "nodes.invoke.result",
          params: {
            invokeID: payload.id,
            ok: response.ok,
            result: response.result,
            error: response.error
          }
        });
      })();
    };
    socket.onclose = () => {
      if (stopRequested)
        return;
      if (heartbeatTimer) {
        clearInterval(heartbeatTimer);
        heartbeatTimer = undefined;
      }
      reconnectTimer = setTimeout(() => {
        connect();
      }, 3000);
    };
    socket.onerror = () => {
      try {
        socket?.close();
      } catch {}
    };
  };
  await connect();
  const shutdown = () => {
    stopRequested = true;
    if (reconnectTimer)
      clearTimeout(reconnectTimer);
    if (heartbeatTimer)
      clearInterval(heartbeatTimer);
    try {
      socket?.close();
    } catch {}
  };
  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
  await new Promise((resolve4) => {
    const timer = setInterval(() => {
      if (stopRequested) {
        clearInterval(timer);
        resolve4();
      }
    }, 200);
  });
}

// src/cli/index.ts
init_policy2();
function parseInstallArgs(args) {
  const result = {
    tui: true
  };
  for (const arg of args) {
    if (arg === "--no-tui") {
      result.tui = false;
    } else if (arg.startsWith("--kimi=")) {
      result.kimi = arg.split("=")[1];
    } else if (arg.startsWith("--openai=")) {
      result.openai = arg.split("=")[1];
    } else if (arg.startsWith("--anthropic=")) {
      result.anthropic = arg.split("=")[1];
    } else if (arg.startsWith("--copilot=")) {
      result.copilot = arg.split("=")[1];
    } else if (arg.startsWith("--zai-plan=")) {
      result.zaiPlan = arg.split("=")[1];
    } else if (arg.startsWith("--antigravity=")) {
      result.antigravity = arg.split("=")[1];
    } else if (arg.startsWith("--chutes=")) {
      result.chutes = arg.split("=")[1];
    } else if (arg.startsWith("--tmux=")) {
      result.tmux = arg.split("=")[1];
    } else if (arg.startsWith("--skills=")) {
      result.skills = arg.split("=")[1];
    } else if (arg.startsWith("--opencode-free=")) {
      result.opencodeFree = arg.split("=")[1];
    } else if (arg.startsWith("--opencode-free-model=")) {
      result.opencodeFreeModel = arg.split("=")[1];
    } else if (arg.startsWith("--isolated=")) {
      result.isolated = arg.split("=")[1];
    }
  }
  return result;
}
function printHelp() {
  console.log(`
miya cli

Usage:
  miya install [OPTIONS]
  miya gateway <start|status|doctor|shutdown>
  miya sessions <list|get|send|policy>
  miya channels <list|status|pairs|approve|reject|send>
  miya nodes <list|status|describe|pairs|approve|reject|invoke>
  miya skills <status|enable|disable|install|update>
  miya sync <list|pull|diff|apply|rollback>
  miya cron <list|runs|add|run|remove|approvals|approve|reject>
  miya voice <status|wake-on|wake-off|talk-start|talk-stop|ingest|history|clear>
  miya canvas <status|list|get|open|render|close>
  miya companion <status|wizard|profile|memory-add|memory-list|asset-add|asset-list|reset>

Examples:
  miya gateway status
  miya sessions send webchat:main "hello"
  miya channels send telegram 123456 "hi"
  miya nodes invoke node-1 system.run '{"command":"pwd"}'
  miya sync list
  miya node-host --gateway http://127.0.0.1:17321
  miya install --no-tui --kimi=yes --openai=no --anthropic=no --copilot=no --zai-plan=no --antigravity=no --chutes=no --tmux=no --skills=yes --isolated=yes
`);
}
function runtimeGatewayFile(cwd) {
  return path44.join(cwd, ".opencode", "miya", "gateway.json");
}
function runtimeGatewayStartGuardFile(cwd) {
  return path44.join(cwd, ".opencode", "miya", "gateway-start.guard.json");
}
function readGatewayStartGuard(cwd) {
  const file3 = runtimeGatewayStartGuardFile(cwd);
  if (!fs44.existsSync(file3))
    return null;
  try {
    const parsed = JSON.parse(fs44.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object")
      return null;
    if (parsed.status !== "idle" && parsed.status !== "starting" && parsed.status !== "failed") {
      return null;
    }
    if (!parsed.updatedAt || !Number.isFinite(Date.parse(parsed.updatedAt)))
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function writeGatewayStartGuard(cwd, guard) {
  const file3 = runtimeGatewayStartGuardFile(cwd);
  fs44.mkdirSync(path44.dirname(file3), { recursive: true });
  fs44.writeFileSync(file3, `${JSON.stringify(guard, null, 2)}
`, "utf-8");
}
function resolveWorkspaceDir(cwd) {
  const nested = path44.join(cwd, "miya-src");
  if (fs44.existsSync(path44.join(nested, "src", "index.ts"))) {
    return nested;
  }
  return cwd;
}
function resolveNodeBinary2() {
  const configured = process.env.MIYA_NODE_BIN?.trim();
  const windowsNodeCandidates = process.platform === "win32" ? [
    path44.join(process.env.ProgramFiles ?? "C:\\Program Files", "nodejs", "node.exe"),
    path44.join(process.env["ProgramFiles(x86)"] ?? "C:\\Program Files (x86)", "nodejs", "node.exe"),
    path44.join(process.env.LOCALAPPDATA ?? "", "Programs", "nodejs", "node.exe")
  ] : [];
  const candidates = [
    configured || null,
    (() => {
      const execBase = path44.basename(process.execPath).toLowerCase();
      return execBase === "node" || execBase === "node.exe" ? process.execPath : null;
    })(),
    ...windowsNodeCandidates,
    process.platform === "win32" ? "node.exe" : "node"
  ].filter((item) => Boolean(item));
  for (const candidate of candidates) {
    try {
      const probe = spawnSync6(candidate, ["--version"], {
        stdio: ["ignore", "ignore", "ignore"],
        timeout: 2000,
        windowsHide: true
      });
      if (probe.status === 0)
        return candidate;
    } catch {}
  }
  return null;
}
function resolveCliScriptPath() {
  return fileURLToPath5(import.meta.url);
}
function clearGatewayStateFile2(cwd) {
  try {
    fs44.unlinkSync(runtimeGatewayFile(cwd));
  } catch {}
}
function readGatewayUrl(cwd) {
  const file3 = runtimeGatewayFile(cwd);
  if (!fs44.existsSync(file3))
    return null;
  try {
    const parsed = JSON.parse(fs44.readFileSync(file3, "utf-8"));
    return parsed.url ?? null;
  } catch {
    return null;
  }
}
function candidateGatewayRuntimeDirs(cwd) {
  const workspace = resolveWorkspaceDir(cwd);
  if (workspace === cwd)
    return [cwd];
  return [workspace, cwd];
}
function isPidAlive2(pid) {
  if (!Number.isFinite(pid) || pid <= 0)
    return false;
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function readGatewayState(cwd) {
  const file3 = runtimeGatewayFile(cwd);
  if (!fs44.existsSync(file3))
    return null;
  try {
    const parsed = JSON.parse(fs44.readFileSync(file3, "utf-8"));
    const url3 = String(parsed.url ?? "").trim();
    const pid = Number(parsed.pid);
    if (!url3 || !Number.isFinite(pid))
      return null;
    return { url: url3, pid };
  } catch {
    return null;
  }
}
async function waitGatewayReady(cwd, timeoutMs = 15000) {
  const startedAt = Date.now();
  while (Date.now() - startedAt < timeoutMs) {
    const state = readGatewayState(cwd);
    if (state && isPidAlive2(state.pid)) {
      try {
        await callGatewayMethod(state.url, "gateway.status.get", {});
        return true;
      } catch {}
    }
    await new Promise((resolve4) => setTimeout(resolve4, 400));
  }
  return false;
}
async function runGatewayStart(cwd) {
  const workspace = resolveWorkspaceDir(cwd);
  const guard = readGatewayStartGuard(workspace);
  const now = Date.now();
  if (guard?.status === "starting") {
    const ageMs = now - Date.parse(guard.updatedAt);
    if (ageMs < 30000) {
      return {
        ok: false,
        workspace,
        reason: "guard_starting",
        detail: `gateway_start_guard_active ageMs=${ageMs}`
      };
    }
  }
  if (guard?.cooldownUntil && now < Date.parse(guard.cooldownUntil)) {
    return {
      ok: false,
      workspace,
      reason: "guard_cooldown",
      detail: `cooldown_until=${guard.cooldownUntil}`
    };
  }
  writeGatewayStartGuard(workspace, {
    status: "starting",
    updatedAt: new Date(now).toISOString()
  });
  const nodeBinary = resolveNodeBinary2();
  if (!nodeBinary) {
    writeGatewayStartGuard(workspace, {
      status: "failed",
      updatedAt: new Date().toISOString(),
      cooldownUntil: new Date(Date.now() + 60000).toISOString()
    });
    return {
      ok: false,
      workspace,
      reason: "node_not_found",
      detail: "Cannot resolve a runnable Node.js binary."
    };
  }
  const sourceCliScript = path44.join(workspace, "src", "cli", "index.ts");
  const cliScript = fs44.existsSync(sourceCliScript) ? sourceCliScript : resolveCliScriptPath();
  const nodeArgs = [
    ...cliScript.endsWith(".ts") ? ["--import", "tsx"] : [],
    cliScript,
    "gateway",
    "serve",
    "--workspace",
    workspace
  ];
  for (let attempt = 0;attempt < 2; attempt += 1) {
    try {
      const proc = spawn3(nodeBinary, nodeArgs, {
        cwd: workspace,
        detached: true,
        stdio: "ignore",
        windowsHide: true,
        env: {
          ...process.env,
          MIYA_AUTO_UI_OPEN: "0",
          MIYA_DOCK_AUTO_LAUNCH: "0"
        }
      });
      proc.unref();
    } catch (error92) {
      writeGatewayStartGuard(workspace, {
        status: "failed",
        updatedAt: new Date().toISOString(),
        cooldownUntil: new Date(Date.now() + 60000).toISOString()
      });
      return {
        ok: false,
        workspace,
        reason: "spawn_failed",
        detail: error92 instanceof Error ? error92.message : String(error92)
      };
    }
    if (await waitGatewayReady(workspace, 15000)) {
      writeGatewayStartGuard(workspace, {
        status: "idle",
        updatedAt: new Date().toISOString()
      });
      return {
        ok: true,
        workspace,
        url: readGatewayUrl(workspace) ?? undefined,
        reason: "started"
      };
    }
    clearGatewayStateFile2(workspace);
  }
  writeGatewayStartGuard(workspace, {
    status: "failed",
    updatedAt: new Date().toISOString(),
    cooldownUntil: new Date(Date.now() + 60000).toISOString()
  });
  return {
    ok: false,
    workspace,
    reason: "start_timeout",
    detail: "Gateway did not become ready within timeout window."
  };
}
async function callGatewayMethod(url3, method, params) {
  const wsUrl = url3.replace(/^http/, "ws");
  const socket = new WebSocket(`${wsUrl}/ws`);
  return await new Promise((resolve4, reject) => {
    const timeout = setTimeout(() => {
      try {
        socket.close();
      } catch {}
      reject(new Error("gateway_timeout"));
    }, 1e4);
    socket.addEventListener("open", () => {
      const token = process.env.MIYA_GATEWAY_TOKEN;
      socket.send(JSON.stringify({
        type: "hello",
        role: "admin",
        protocolVersion: "1.0",
        auth: token ? { token } : undefined
      }));
      socket.send(JSON.stringify({
        type: "request",
        id: "cli-1",
        method,
        params
      }));
    });
    socket.addEventListener("message", (event) => {
      try {
        const frame = JSON.parse(String(event.data));
        if (frame.type !== "response" || frame.id !== "cli-1")
          return;
        clearTimeout(timeout);
        socket.close();
        if (frame.ok) {
          resolve4(frame.result);
        } else {
          reject(new Error(frame.error?.message ?? "gateway_method_failed"));
        }
      } catch (error92) {
        clearTimeout(timeout);
        reject(error92 instanceof Error ? error92 : new Error(String(error92)));
      }
    });
    socket.addEventListener("error", () => {
      clearTimeout(timeout);
      reject(new Error("gateway_socket_error"));
    });
  });
}
async function ensureGatewayUrl(cwd, autoStart = true) {
  const candidateDirs = candidateGatewayRuntimeDirs(cwd);
  for (const dir of candidateDirs) {
    const url3 = readGatewayUrl(dir);
    if (!url3)
      continue;
    try {
      await callGatewayMethod(url3, "gateway.status.get", {});
      return url3;
    } catch {
      clearGatewayStateFile2(dir);
    }
  }
  if (autoStart && (await runGatewayStart(cwd)).ok) {
    for (const dir of candidateDirs) {
      const url3 = readGatewayUrl(dir);
      if (!url3)
        continue;
      try {
        await callGatewayMethod(url3, "gateway.status.get", {});
        return url3;
      } catch {
        clearGatewayStateFile2(dir);
      }
    }
  }
  throw new Error("gateway_unavailable");
}
async function runGatewayServe(cwd, args) {
  const workspace = readFlagValue(args, "--workspace") ?? resolveWorkspaceDir(cwd);
  const { ensureGatewayRunning: ensureGatewayRunning2, stopGateway: stopGateway2 } = await Promise.resolve().then(() => (init_gateway(), exports_gateway));
  try {
    const state = ensureGatewayRunning2(workspace);
    console.log(JSON.stringify(state, null, 2));
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    if (message === "gateway_owned_by_other_process") {
      return 0;
    }
    throw error92;
  }
  await new Promise((resolve4) => {
    const stop = () => {
      try {
        stopGateway2(workspace);
      } finally {
        resolve4();
      }
    };
    process.once("SIGINT", stop);
    process.once("SIGTERM", stop);
  });
  return 0;
}
async function runGatewayCommand(cwd, args) {
  const action = args[0] ?? "status";
  if (action === "start") {
    const allowCliStart = args.includes("--force") || process.env.MIYA_GATEWAY_CLI_START_ENABLE === "1";
    if (!allowCliStart) {
      console.error("gateway_start_blocked:safety_guard (use `miya gateway start --force` or set MIYA_GATEWAY_CLI_START_ENABLE=1)");
      return 2;
    }
    const result = await runGatewayStart(cwd);
    const output = {
      ok: result.ok,
      reason: result.reason,
      workspace: result.workspace,
      url: result.url ?? null,
      detail: result.detail ?? null
    };
    console.log(JSON.stringify(output, null, 2));
    return result.ok ? 0 : 1;
  }
  if (action === "serve") {
    return await runGatewayServe(cwd, args.slice(1));
  }
  let url3 = "";
  try {
    url3 = await ensureGatewayUrl(cwd, false);
  } catch (error92) {
    if (action === "shutdown") {
      console.log(JSON.stringify({ ok: true, stopped: false, reason: "not_running" }, null, 2));
      return 0;
    }
    throw error92;
  }
  if (action === "status") {
    const result = await callGatewayMethod(url3, "gateway.status.get", {});
    console.log(JSON.stringify(result, null, 2));
    return 0;
  }
  if (action === "doctor") {
    const result = await callGatewayMethod(url3, "doctor.run", {});
    console.log(JSON.stringify(result, null, 2));
    return 0;
  }
  if (action === "shutdown") {
    const result = await callGatewayMethod(url3, "gateway.shutdown", {});
    console.log(JSON.stringify(result, null, 2));
    return 0;
  }
  throw new Error(`unknown_gateway_action:${action}`);
}
async function runSubcommand(cwd, top, args) {
  const url3 = await ensureGatewayUrl(cwd);
  const workspace = resolveWorkspaceDir(cwd);
  const withPolicyHash = (params2) => ({
    ...params2,
    policyHash: currentPolicyHash(workspace)
  });
  const method = (() => {
    if (top === "sessions") {
      const action = args[0] ?? "list";
      if (action === "list")
        return ["sessions.list", {}];
      if (action === "get")
        return ["sessions.get", { sessionID: args[1] }];
      if (action === "send")
        return [
          "sessions.send",
          {
            sessionID: args[1],
            text: args[2],
            source: args[3] ?? "cli"
          }
        ];
      if (action === "policy")
        return [
          "sessions.policy.set",
          {
            sessionID: args[1],
            activation: args[2],
            reply: args[3]
          }
        ];
    }
    if (top === "channels") {
      const action = args[0] ?? "status";
      if (action === "list")
        return ["channels.list", {}];
      if (action === "status")
        return ["channels.status", {}];
      if (action === "pairs")
        return ["channels.pair.list", { status: args[1] }];
      if (action === "approve")
        return ["channels.pair.approve", { pairID: args[1] }];
      if (action === "reject")
        return ["channels.pair.reject", { pairID: args[1] }];
      if (action === "send")
        return [
          "channels.message.send",
          {
            channel: args[1],
            destination: args[2],
            text: args[3],
            sessionID: args[4] ?? "main"
          }
        ];
    }
    if (top === "nodes") {
      const action = args[0] ?? "status";
      if (action === "list")
        return ["nodes.list", {}];
      if (action === "status")
        return ["nodes.status", {}];
      if (action === "describe")
        return ["nodes.describe", { nodeID: args[1] }];
      if (action === "pairs")
        return ["nodes.pair.list", { status: args[1] }];
      if (action === "approve")
        return ["nodes.pair.approve", { pairID: args[1] }];
      if (action === "reject")
        return ["nodes.pair.reject", { pairID: args[1] }];
      if (action === "invoke")
        return [
          "nodes.invoke",
          {
            nodeID: args[1],
            capability: args[2],
            args: args[3] ? JSON.parse(args[3]) : {},
            sessionID: args[4] ?? "main"
          }
        ];
    }
    if (top === "skills") {
      const action = args[0] ?? "status";
      if (action === "status")
        return ["skills.status", {}];
      if (action === "enable")
        return ["skills.enable", { skillID: args[1] }];
      if (action === "disable")
        return ["skills.disable", { skillID: args[1] }];
      if (action === "install")
        return [
          "skills.install",
          withPolicyHash({
            repo: args[1],
            targetName: args[2],
            sessionID: args[3] ?? "main"
          })
        ];
      if (action === "update")
        return [
          "skills.update",
          withPolicyHash({
            dir: args[1],
            sessionID: args[2] ?? "main"
          })
        ];
    }
    if (top === "sync") {
      const action = args[0] ?? "list";
      if (action === "list")
        return ["miya.sync.list", {}];
      if (action === "diff")
        return ["miya.sync.diff", { sourcePackID: args[1] }];
      if (action === "pull")
        return [
          "miya.sync.pull",
          withPolicyHash({
            sourcePackID: args[1],
            sessionID: args[2] ?? "main"
          })
        ];
      if (action === "apply")
        return [
          "miya.sync.apply",
          withPolicyHash({
            sourcePackID: args[1],
            revision: args[2],
            sessionID: args[3] ?? "main"
          })
        ];
      if (action === "rollback")
        return [
          "miya.sync.rollback",
          withPolicyHash({
            sourcePackID: args[1],
            sessionID: args[2] ?? "main"
          })
        ];
    }
    if (top === "cron") {
      const action = args[0] ?? "list";
      if (action === "list")
        return ["cron.list", {}];
      if (action === "runs")
        return ["cron.runs.list", { limit: Number(args[1] ?? 50) }];
      if (action === "add")
        return [
          "cron.add",
          {
            name: args[1],
            time: args[2],
            command: args[3],
            requireApproval: args[4] === "true"
          }
        ];
      if (action === "run")
        return ["cron.run.now", { jobID: args[1] }];
      if (action === "remove")
        return ["cron.remove", { jobID: args[1] }];
      if (action === "approvals")
        return ["cron.approvals.list", {}];
      if (action === "approve")
        return ["cron.approvals.approve", { approvalID: args[1] }];
      if (action === "reject")
        return ["cron.approvals.reject", { approvalID: args[1] }];
    }
    if (top === "voice") {
      const action = args[0] ?? "status";
      if (action === "status")
        return ["voice.status", {}];
      if (action === "wake-on")
        return ["voice.wake.enable", {}];
      if (action === "wake-off")
        return ["voice.wake.disable", {}];
      if (action === "talk-start")
        return ["voice.talk.start", { sessionID: args[1] }];
      if (action === "talk-stop")
        return ["voice.talk.stop", {}];
      if (action === "ingest")
        return [
          "voice.input.ingest",
          {
            text: args[1],
            mediaID: args[2],
            source: args[3] ?? "manual",
            sessionID: args[4] ?? "main"
          }
        ];
      if (action === "history")
        return ["voice.history.list", { limit: Number(args[1] ?? 50) }];
      if (action === "clear")
        return ["voice.history.clear", {}];
    }
    if (top === "canvas") {
      const action = args[0] ?? "status";
      if (action === "status")
        return ["canvas.status", {}];
      if (action === "list")
        return ["canvas.list", {}];
      if (action === "get")
        return ["canvas.get", { docID: args[1] }];
      if (action === "open")
        return [
          "canvas.open",
          {
            title: args[1],
            type: args[2] ?? "markdown",
            content: args[3] ?? ""
          }
        ];
      if (action === "render")
        return [
          "canvas.render",
          {
            docID: args[1],
            content: args[2],
            merge: args[3] === "true"
          }
        ];
      if (action === "close")
        return ["canvas.close", { docID: args[1] }];
    }
    if (top === "companion") {
      const action = args[0] ?? "status";
      if (action === "status")
        return ["companion.status", {}];
      if (action === "wizard")
        return ["companion.wizard.start", {}];
      if (action === "profile")
        return [
          "companion.profile.update",
          {
            name: args[1],
            relationship: args[2],
            persona: args[3],
            style: args[4],
            enabled: args[5] === "true"
          }
        ];
      if (action === "memory-add")
        return ["companion.memory.add", { fact: args[1] }];
      if (action === "memory-list")
        return ["companion.memory.list", {}];
      if (action === "asset-add")
        return [
          "companion.asset.add",
          {
            type: args[1],
            pathOrUrl: args[2],
            label: args[3]
          }
        ];
      if (action === "asset-list")
        return ["companion.asset.list", {}];
      if (action === "reset")
        return ["companion.reset", {}];
    }
    return null;
  })();
  if (!method) {
    throw new Error(`unknown_subcommand:${top}`);
  }
  const [methodName, params] = method;
  const result = await callGatewayMethod(url3, methodName, params);
  console.log(JSON.stringify(result, null, 2));
  return 0;
}
function readFlagValue(args, key) {
  const direct = args.find((item) => item.startsWith(`${key}=`));
  if (direct)
    return direct.slice(key.length + 1);
  const index = args.indexOf(key);
  if (index >= 0 && index < args.length - 1) {
    return args[index + 1];
  }
  return;
}
async function runNodeHostCommand(cwd, args) {
  const gateway = readFlagValue(args, "--gateway") ?? await ensureGatewayUrl(cwd);
  const nodeID = readFlagValue(args, "--node-id");
  const deviceID = readFlagValue(args, "--device-id");
  const capabilitiesValue = readFlagValue(args, "--capabilities");
  const capabilities = capabilitiesValue ? capabilitiesValue.split(",").map((item) => item.trim()).filter(Boolean) : undefined;
  await runNodeHost({
    projectDir: cwd,
    gatewayUrl: gateway,
    nodeID,
    deviceID,
    capabilities
  });
  return 0;
}
async function main() {
  const args = process.argv.slice(2);
  const cwd = process.cwd();
  if (args.length === 0 || args[0] === "install") {
    const installArgs = parseInstallArgs(args.slice(args[0] === "install" ? 1 : 0));
    const exitCode = await install(installArgs);
    process.exit(exitCode);
  }
  if (args[0] === "-h" || args[0] === "--help") {
    printHelp();
    process.exit(0);
  }
  if (args[0] === "gateway") {
    const exitCode = await runGatewayCommand(cwd, args.slice(1));
    process.exit(exitCode);
  }
  if (args[0] === "node-host") {
    const exitCode = await runNodeHostCommand(cwd, args.slice(1));
    process.exit(exitCode);
  }
  const top = args[0];
  if (top === "sessions" || top === "channels" || top === "nodes" || top === "skills" || top === "sync" || top === "cron" || top === "voice" || top === "canvas" || top === "companion") {
    const exitCode = await runSubcommand(cwd, top, args.slice(1));
    process.exit(exitCode);
  }
  throw new Error(`unknown_command:${args[0]}`);
}
main().catch((error92) => {
  console.error(error92 instanceof Error ? error92.message : String(error92));
  process.exit(1);
});
