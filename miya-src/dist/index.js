var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean7(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean7;
    function string7(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string7;
    function number7(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number7;
    function error92(value) {
      return value instanceof Error;
    }
    exports.error = error92;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array3(value) {
      return Array.isArray(value);
    }
    exports.array = array3;
    function stringArray(value) {
      return array3(value) && value.every((elem) => string7(elem));
    }
    exports.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    var _a2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a2] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state2 = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state2) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state2 = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state2) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state2 = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state2) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state2 = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state2) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports.Disposable = Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve7, reject) => {
          this._waiting.push({ thunk, resolve: resolve7, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error92) {
        this.errorEmitter.fire(this.asError(error92));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error92) {
        if (error92 instanceof Error) {
          return error92;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error92.message) ? error92.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error92) => this.fireError(error92));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error92) => {
              this.fireError(error92);
            });
          }
        } catch (error92) {
          this.fireError(error92);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error92, message, count) {
        this.errorEmitter.fire([this.asError(error92), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error92) {
        if (error92 instanceof Error) {
          return error92;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error92.message) ? error92.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error92) => this.fireError(error92));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error92) => {
            this.fireError(error92);
            throw error92;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error92) {
          this.handleError(error92, msg);
          return Promise.reject(error92);
        }
      }
      handleError(error92, msg) {
        this.errorCount++;
        this.fireError(error92, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state2 = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state2) {
                  case 0:
                    state2 = 1;
                    break;
                  case 2:
                    state2 = 3;
                    break;
                  default:
                    state2 = 0;
                }
                break;
              case LF:
                switch (state2) {
                  case 1:
                    state2 = 2;
                    break;
                  case 3:
                    state2 = 4;
                    offset++;
                    break row;
                  default:
                    state2 = 0;
                }
                break;
              default:
                state2 = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state2 !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection2(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version3 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state2 = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state2 === ConnectionState.Listening;
      }
      function isClosed() {
        return state2 === ConnectionState.Closed;
      }
      function isDisposed() {
        return state2 === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state2 === ConnectionState.New || state2 === ConnectionState.Listening) {
          state2 = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error92) {
        errorEmitter.fire([error92, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version3,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error92, method, startTime2) {
          const message = {
            jsonrpc: version3,
            id: requestMessage.id,
            error: error92.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version3,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise3 = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise3.then) {
              promise3.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error92) => {
                requestTokens.delete(tokenKey);
                if (error92 instanceof messages_1.ResponseError) {
                  replyError(error92, requestMessage.method, startTime);
                } else if (error92 && Is.string(error92.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error92.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error92) {
            requestTokens.delete(tokenKey);
            if (error92 instanceof messages_1.ResponseError) {
              reply(error92, requestMessage.method, startTime);
            } else if (error92 && Is.string(error92.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error92.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error92 = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error92.code, error92.message, error92.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error92) {
              if (error92.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error92.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error92) {
            if (error92.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error92.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error92 = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error92}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version3,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error92) => {
            logger.error(`Sending notification failed.`);
            throw error92;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version3,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve7, reject) => {
            const resolveWithCleanup = (r) => {
              resolve7(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              responsePromises.set(id, responsePromise);
              await messageWriter.write(requestMessage);
            } catch (error92) {
              responsePromises.delete(id);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error92.message ? error92.message : "Unknown reason"));
              logger.error(`Sending request failed.`);
              throw error92;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state2 = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error92 = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise3 of responsePromises.values()) {
            promise3.reject(error92);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state2 = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
    exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = __require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve7, reject) => {
          const callback = (error92) => {
            if (error92 === void 0 || error92 === null) {
              resolve7();
            } else {
              reject(error92);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path52 = __require("path");
    var os8 = __require("os");
    var crypto_1 = __require("crypto");
    var net_1 = __require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process3) {
        super();
        this.process = process3;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error92) => this.fireError(error92));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process3) {
        super();
        this.process = process3;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error92) => this.fireError(error92));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error92) => {
              if (error92) {
                this.errorCount++;
                this.handleError(error92, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error92) {
          this.handleError(error92, msg);
          return Promise.reject(error92);
        }
      }
      handleError(error92, msg) {
        this.errorCount++;
        this.fireError(error92, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error92) => this.fireError(error92));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error92) => this.fireError(error92));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error92) {
          this.handleError(error92, msg);
          return Promise.reject(error92);
        }
      }
      handleError(error92, msg) {
        this.errorCount++;
        this.fireError(error92, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader2 = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader2;
    var StreamMessageWriter2 = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter2;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path52.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path52.join(os8.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve7, _reject) => {
        connectResolve = resolve7;
      });
      return new Promise((resolve7, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve7({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve7, _reject) => {
        connectResolve = resolve7;
      });
      return new Promise((resolve7, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve7({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection2(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader2(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter2(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection2;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports, module) {
    "use strict";
    module.exports = require_main();
  }
});

// src/index.ts
import { spawn as spawn6, spawnSync as spawnSync9 } from "node:child_process";
import * as fs50 from "node:fs";
import * as path51 from "node:path";

// src/cli/custom-skills.ts
var CUSTOM_SKILLS = [
  {
    name: "cartography",
    description: "Repository understanding and hierarchical codemap generation",
    allowedAgents: ["1-task-manager", "orchestrator"],
    sourcePath: "src/skills/cartography"
  }
];
function getCustomSkillPermissionsForAgent(agentName) {
  const permissions = {};
  for (const skill of CUSTOM_SKILLS) {
    const isAllowed = skill.allowedAgents.includes("*") || skill.allowedAgents.includes(agentName);
    if (isAllowed) {
      permissions[skill.name] = "allow";
    }
  }
  return permissions;
}

// src/cli/skills.ts
var RECOMMENDED_SKILLS = [
  {
    name: "simplify",
    repo: "https://github.com/brianlovin/claude-config",
    skillName: "simplify",
    allowedAgents: ["1-task-manager", "orchestrator"],
    description: "YAGNI code simplification expert"
  },
  {
    name: "agent-browser",
    repo: "https://github.com/vercel-labs/agent-browser",
    skillName: "agent-browser",
    allowedAgents: ["6-ui-designer", "designer"],
    description: "High-performance browser automation",
    postInstallCommands: [
      "npm install -g agent-browser",
      "agent-browser install"
    ]
  }
];
function getSkillPermissionsForAgent(agentName, skillList) {
  const isManager = agentName === "1-task-manager" || agentName === "orchestrator";
  const permissions = {
    "*": isManager ? "allow" : "deny"
  };
  if (skillList) {
    permissions["*"] = "deny";
    for (const name of skillList) {
      if (name === "*") {
        permissions["*"] = "allow";
      } else if (name.startsWith("!")) {
        permissions[name.slice(1)] = "deny";
      } else {
        permissions[name] = "allow";
      }
    }
    return permissions;
  }
  for (const skill of RECOMMENDED_SKILLS) {
    const isAllowed = skill.allowedAgents.includes("*") || skill.allowedAgents.includes(agentName);
    if (isAllowed) {
      permissions[skill.skillName] = "allow";
    }
  }
  const customSkillPermissions = getCustomSkillPermissionsForAgent(agentName);
  for (const [skillName, action] of Object.entries(customSkillPermissions)) {
    permissions[skillName] = action;
  }
  return permissions;
}

// src/config/constants.ts
var AGENT_ALIASES = {
  // legacy names -> current names
  orchestrator: "1-task-manager",
  explorer: "2-code-search",
  librarian: "3-docs-helper",
  oracle: "4-architecture-advisor",
  fixer: "5-code-fixer",
  designer: "6-ui-designer",
  "code-simplicity-reviewer": "7-code-simplicity-reviewer",
  simplicity_reviewer: "7-code-simplicity-reviewer",
  // extra compatibility aliases
  explore: "2-code-search",
  "frontend-ui-ux-engineer": "6-ui-designer",
  "4-code-fixer": "5-code-fixer",
  "5-ui-designer": "6-ui-designer",
  "6-architecture-advisor": "4-architecture-advisor"
};
var SUBAGENT_NAMES = [
  "2-code-search",
  "3-docs-helper",
  "4-architecture-advisor",
  "5-code-fixer",
  "6-ui-designer"
];
var ORCHESTRATOR_NAME = "1-task-manager";
var CODE_SIMPLICITY_REVIEWER_NAME = "7-code-simplicity-reviewer";
var ALL_AGENT_NAMES = [
  ORCHESTRATOR_NAME,
  ...SUBAGENT_NAMES,
  CODE_SIMPLICITY_REVIEWER_NAME
];
var SUBAGENT_DELEGATION_RULES = {
  "1-task-manager": SUBAGENT_NAMES,
  "2-code-search": [],
  "3-docs-helper": [],
  "4-architecture-advisor": [],
  "5-code-fixer": ["2-code-search"],
  "6-ui-designer": ["2-code-search"],
  "7-code-simplicity-reviewer": []
};
var DEFAULT_MODELS = {
  "1-task-manager": "openrouter/moonshotai/kimi-k2.5",
  "2-code-search": "openrouter/moonshotai/kimi-k2.5",
  "3-docs-helper": "openrouter/moonshotai/kimi-k2.5",
  "4-architecture-advisor": "openrouter/moonshotai/kimi-k2.5",
  "5-code-fixer": "openrouter/z-ai/glm-5",
  "6-ui-designer": "openrouter/z-ai/glm-5",
  "7-code-simplicity-reviewer": "openrouter/z-ai/glm-5"
};
var POLL_INTERVAL_BACKGROUND_MS = 2e3;
var DEFAULT_TIMEOUT_MS = 2 * 60 * 1e3;
var MAX_POLL_TIME_MS = 5 * 60 * 1e3;
var FALLBACK_FAILOVER_TIMEOUT_MS = 15e3;

// src/config/loader.ts
import * as fs4 from "node:fs";
import * as os from "node:os";
import * as path4 from "node:path";

// src/config/agent-mcps.ts
var DEFAULT_AGENT_MCPS = {
  "1-task-manager": ["websearch"],
  "2-code-search": [],
  "3-docs-helper": ["websearch", "context7", "grep_app"],
  "4-architecture-advisor": [],
  "5-code-fixer": [],
  "6-ui-designer": [],
  "7-code-simplicity-reviewer": []
};
function parseList(items, allAvailable) {
  if (!items || items.length === 0) {
    return [];
  }
  const allow = items.filter((i) => !i.startsWith("!"));
  const deny = items.filter((i) => i.startsWith("!")).map((i) => i.slice(1));
  if (deny.includes("*")) {
    return [];
  }
  if (allow.includes("*")) {
    return allAvailable.filter((item) => !deny.includes(item));
  }
  return allow.filter((item) => !deny.includes(item));
}
function getAgentMcpList(agentName, config3) {
  const agentConfig = getAgentOverride(config3, agentName);
  if (agentConfig?.mcps !== void 0) {
    return agentConfig.mcps;
  }
  const defaultMcps = DEFAULT_AGENT_MCPS[agentName];
  return defaultMcps ?? [];
}

// src/cli/config-io.ts
function stripJsonComments(json3) {
  const commentPattern = /\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g;
  const trailingCommaPattern = /\\"|"(?:\\"|[^"])*"|(,)(\s*[}\]])/g;
  return json3.replace(
    commentPattern,
    (match, commentGroup) => commentGroup ? "" : match
  ).replace(
    trailingCommaPattern,
    (match, comma, closing) => comma ? closing : match
  );
}

// src/config/agent-model-persistence.ts
import * as fs3 from "node:fs";
import * as path3 from "node:path";

// src/workflow/state.ts
import * as fs from "node:fs";
import * as path from "node:path";
var DEFAULT_STATE = {
  loopEnabled: true,
  autoContinue: true,
  maxIterationsPerWindow: 8,
  iterationCompleted: 0,
  windowStartIteration: 0,
  awaitingConfirmation: false,
  strictQualityGate: false,
  // Changed: default to false for smoother experience
  lastDone: [],
  lastMissing: [],
  lastUnresolved: [],
  autoContinueIteration: -1,
  autoContinueAt: (/* @__PURE__ */ new Date(0)).toISOString(),
  updatedAt: (/* @__PURE__ */ new Date(0)).toISOString()
};
function ensureDir(dirPath) {
  fs.mkdirSync(dirPath, { recursive: true });
}
function getMiyaRuntimeDir(projectDir) {
  return path.join(projectDir, ".opencode", "miya");
}
function getLoopStatePath(projectDir) {
  return path.join(getMiyaRuntimeDir(projectDir), "loop-state.json");
}
function readStateFile(filePath14) {
  if (!fs.existsSync(filePath14)) {
    return { sessions: {} };
  }
  try {
    const raw = fs.readFileSync(filePath14, "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    return { sessions: parsed.sessions };
  } catch {
    return { sessions: {} };
  }
}
function writeStateFile(filePath14, state2) {
  ensureDir(path.dirname(filePath14));
  fs.writeFileSync(filePath14, `${JSON.stringify(state2, null, 2)}
`, "utf-8");
}
function getSessionState(projectDir, sessionID2) {
  const filePath14 = getLoopStatePath(projectDir);
  const state2 = readStateFile(filePath14);
  const current = state2.sessions[sessionID2];
  if (!current) {
    return { ...DEFAULT_STATE };
  }
  return {
    ...DEFAULT_STATE,
    ...current
  };
}
function setSessionState(projectDir, sessionID2, sessionState) {
  const filePath14 = getLoopStatePath(projectDir);
  const state2 = readStateFile(filePath14);
  state2.sessions[sessionID2] = {
    ...DEFAULT_STATE,
    ...sessionState,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  writeStateFile(filePath14, state2);
}
function resetSessionState(projectDir, sessionID2) {
  setSessionState(projectDir, sessionID2, { ...DEFAULT_STATE });
}
function isNegativeConfirmation(text) {
  const lowered = text.trim().toLowerCase();
  return lowered === "no" || lowered === "n" || lowered === "stop" || lowered === "cancel" || lowered === "cancel-work" || lowered === "\u505C\u6B62" || lowered === "\u53D6\u6D88" || lowered === "\u5426";
}
function shouldEnableStrictQualityGate(text) {
  const lowered = text.toLowerCase();
  return lowered.includes("strict-quality-gate") || lowered.includes("strict quality gate") || lowered.includes("deepwork");
}

// src/workflow/saves.ts
import { spawnSync } from "node:child_process";
import * as fs2 from "node:fs";
import * as path2 from "node:path";
function getSavesDir(projectDir) {
  return path2.join(projectDir, ".opencode", "cowork-saves");
}
function ensureDir2(dirPath) {
  fs2.mkdirSync(dirPath, { recursive: true });
}
function timestampId() {
  const now = /* @__PURE__ */ new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth() + 1).padStart(2, "0");
  const d = String(now.getDate()).padStart(2, "0");
  const hh = String(now.getHours()).padStart(2, "0");
  const mm = String(now.getMinutes()).padStart(2, "0");
  const ss = String(now.getSeconds()).padStart(2, "0");
  return `${y}${m}${d}_${hh}${mm}${ss}`;
}
function getCurrentBranch(projectDir) {
  const result = spawnSync("git", ["rev-parse", "--abbrev-ref", "HEAD"], {
    cwd: projectDir,
    encoding: "utf-8"
  });
  if (result.status !== 0) return null;
  return result.stdout.trim() || null;
}
function savePath(projectDir, id) {
  return path2.join(getSavesDir(projectDir), `${id}.json`);
}
function createSaveRecord(projectDir, input) {
  const id = timestampId();
  const record3 = {
    id,
    label: input.label,
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    sessionID: input.sessionID,
    branch: getCurrentBranch(projectDir),
    done: input.done,
    missing: input.missing,
    unresolved: input.unresolved,
    notes: input.notes
  };
  ensureDir2(getSavesDir(projectDir));
  fs2.writeFileSync(savePath(projectDir, id), `${JSON.stringify(record3, null, 2)}
`);
  return record3;
}
function loadSaveRecord(projectDir, id) {
  const filePath14 = savePath(projectDir, id);
  if (!fs2.existsSync(filePath14)) return null;
  try {
    const raw = fs2.readFileSync(filePath14, "utf-8");
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
function listSaveRecords(projectDir) {
  const dir = getSavesDir(projectDir);
  if (!fs2.existsSync(dir)) return [];
  const files = fs2.readdirSync(dir).filter((fileName) => fileName.endsWith(".json")).sort();
  const records = [];
  for (const fileName of files) {
    const fullPath = path2.join(dir, fileName);
    try {
      const raw = fs2.readFileSync(fullPath, "utf-8");
      records.push(JSON.parse(raw));
    } catch {
    }
  }
  return records;
}
function evaluateSave(record3) {
  if (record3.missing.length === 0 && record3.unresolved.length === 0) {
    return { status: "complete", reason: "No missing or unresolved items" };
  }
  return {
    status: "incomplete",
    reason: `missing=${record3.missing.length}, unresolved=${record3.unresolved.length}`
  };
}

// src/config/agent-model-persistence.ts
var KNOWN_AGENT_NAMES = new Set(ALL_AGENT_NAMES);
var AGENT_RUNTIME_VERSION = 1;
var MAX_WRITE_RETRIES = 4;
var LEGACY_MODEL_REWRITE = {
  "openrouter/minimax/z-ai/glm-5": "openrouter/z-ai/glm-5"
};
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function filePath(projectDir) {
  return path3.join(getMiyaRuntimeDir(projectDir), "agent-runtime.json");
}
function legacyFilePath(projectDir) {
  return path3.join(getMiyaRuntimeDir(projectDir), "agent-models.json");
}
function normalizeAgentName(name) {
  const trimmed = name.trim();
  if (!trimmed) return null;
  const canonical = AGENT_ALIASES[trimmed] ?? trimmed;
  return KNOWN_AGENT_NAMES.has(canonical) ? canonical : null;
}
function normalizeModelRef(value) {
  const normalizeRefText = (input) => {
    const text = LEGACY_MODEL_REWRITE[input.trim()] ?? input.trim();
    const slash = text.indexOf("/");
    if (slash <= 0 || slash >= text.length - 1) {
      return null;
    }
    return text;
  };
  if (typeof value === "string") {
    return normalizeRefText(value);
  }
  if (isObject(value)) {
    const providerID = String(value.providerID ?? value.provider ?? "").trim();
    const modelID = String(value.modelID ?? "").trim();
    if (providerID && modelID) {
      return normalizeRefText(`${providerID}/${modelID}`);
    }
    return normalizeRefText(modelID);
  }
  return null;
}
function parsePersistedModel(value) {
  return normalizeModelRef(value) ?? (isObject(value) ? normalizeModelRef(value.model) : null);
}
function normalizeProviderID(value) {
  const text = String(value ?? "").trim();
  return text || void 0;
}
function normalizeStringValue(value) {
  const text = String(value ?? "").trim();
  return text || void 0;
}
function normalizeOptions(value) {
  if (!isObject(value)) return void 0;
  return JSON.parse(JSON.stringify(value));
}
function normalizeAgentRuntimeEntry(value) {
  if (!isObject(value)) return null;
  const model = parsePersistedModel(value.model ?? value);
  const variant = normalizeStringValue(value.variant);
  const providerID = normalizeProviderID(value.providerID) ?? (model ? normalizeProviderID(model.split("/")[0]) : void 0);
  const options = normalizeOptions(value.options ?? value.providerOptions);
  const apiKey = normalizeStringValue(value.apiKey);
  const baseURL = normalizeStringValue(value.baseURL);
  if (!model && !variant && !providerID && !options && !apiKey && !baseURL) {
    return null;
  }
  return {
    model: model ?? void 0,
    variant,
    providerID,
    options,
    apiKey,
    baseURL,
    updatedAt: normalizeStringValue(value.updatedAt) ?? (/* @__PURE__ */ new Date()).toISOString()
  };
}
function readLegacyModels(projectDir) {
  const file3 = legacyFilePath(projectDir);
  if (!fs3.existsSync(file3)) return {};
  try {
    const raw = fs3.readFileSync(file3, "utf-8");
    const parsed = JSON.parse(raw);
    if (!isObject(parsed.agents)) return {};
    const result = {};
    for (const [rawAgentName, rawModel] of Object.entries(parsed.agents)) {
      const agentName = normalizeAgentName(rawAgentName);
      const model = parsePersistedModel(rawModel);
      if (!agentName || !model) continue;
      result[agentName] = model;
    }
    return result;
  } catch {
    return {};
  }
}
function normalizeRuntimeState(projectDir, parsed) {
  if (!parsed || !isObject(parsed.agents)) {
    const legacy = readLegacyModels(projectDir);
    const agentsFromLegacy = {};
    for (const [agentName, model] of Object.entries(legacy)) {
      agentsFromLegacy[agentName] = {
        model,
        providerID: model.split("/")[0],
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    return {
      version: AGENT_RUNTIME_VERSION,
      revision: 0,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      agents: agentsFromLegacy
    };
  }
  const agents = {};
  for (const [rawAgentName, rawEntry] of Object.entries(parsed.agents)) {
    const agentName = normalizeAgentName(rawAgentName);
    if (!agentName) continue;
    const entry2 = normalizeAgentRuntimeEntry(rawEntry);
    if (!entry2) continue;
    agents[agentName] = entry2;
  }
  const activeAgentId = normalizeAgentName(String(parsed.activeAgentId ?? "")) ?? void 0;
  return {
    version: AGENT_RUNTIME_VERSION,
    revision: Number(parsed.revision ?? 0) || 0,
    updatedAt: normalizeStringValue(parsed.updatedAt) ?? (/* @__PURE__ */ new Date()).toISOString(),
    activeAgentId,
    agents
  };
}
function readRuntimeState(projectDir) {
  const file3 = filePath(projectDir);
  if (!fs3.existsSync(file3)) {
    const migrated = normalizeRuntimeState(projectDir, null);
    if (Object.keys(migrated.agents).length > 0 || fs3.existsSync(legacyFilePath(projectDir))) {
      const runtimeToWrite = {
        ...migrated,
        revision: migrated.revision > 0 ? migrated.revision : 1,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      writeRuntimeStateAtomic(projectDir, runtimeToWrite);
      return runtimeToWrite;
    }
    return migrated;
  }
  try {
    const raw = fs3.readFileSync(file3, "utf-8");
    const parsed = JSON.parse(raw);
    return normalizeRuntimeState(projectDir, parsed);
  } catch {
    return normalizeRuntimeState(projectDir, null);
  }
}
function writeRuntimeStateAtomic(projectDir, runtime) {
  const file3 = filePath(projectDir);
  fs3.mkdirSync(path3.dirname(file3), { recursive: true });
  const orderedAgents = Object.fromEntries(
    Object.keys(runtime.agents).sort((a, b) => a.localeCompare(b)).map((key) => [key, runtime.agents[key]])
  );
  const payload = {
    version: AGENT_RUNTIME_VERSION,
    revision: runtime.revision,
    updatedAt: runtime.updatedAt,
    activeAgentId: runtime.activeAgentId,
    agents: orderedAgents
  };
  const tmp = `${file3}.tmp.${process.pid}.${Date.now()}`;
  fs3.writeFileSync(tmp, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
  fs3.renameSync(tmp, file3);
}
function readPersistedAgentRuntime(projectDir) {
  const runtime = readRuntimeState(projectDir);
  return {
    activeAgentId: runtime.activeAgentId,
    revision: runtime.revision,
    agents: runtime.agents
  };
}
function normalizeSelectionInput(input) {
  const agentName = normalizeAgentName(input.agentName);
  if (!agentName) return null;
  const model = normalizeModelRef(input.model);
  const variant = normalizeStringValue(input.variant);
  const providerID = normalizeProviderID(input.providerID) ?? (model ? normalizeProviderID(model.split("/")[0]) : void 0);
  const options = normalizeOptions(input.options);
  const apiKey = normalizeStringValue(input.apiKey);
  const baseURL = normalizeStringValue(input.baseURL);
  const entryPatch = {};
  if (model) entryPatch.model = model;
  if (variant) entryPatch.variant = variant;
  if (providerID) entryPatch.providerID = providerID;
  if (options) entryPatch.options = options;
  if (apiKey) entryPatch.apiKey = apiKey;
  if (baseURL) entryPatch.baseURL = baseURL;
  const activeAgentId = normalizeAgentName(String(input.activeAgentId ?? "")) ?? void 0;
  if (Object.keys(entryPatch).length === 0 && !activeAgentId) return null;
  return {
    agentName,
    entryPatch,
    activeAgentId
  };
}
function persistAgentRuntimeSelection(projectDir, input) {
  const normalized = normalizeSelectionInput(input);
  if (!normalized) return false;
  for (let attempt = 0; attempt < MAX_WRITE_RETRIES; attempt += 1) {
    const base = readRuntimeState(projectDir);
    const currentEntry = base.agents[normalized.agentName];
    const mergedEntry = {
      ...currentEntry ?? {},
      ...normalized.entryPatch
    };
    const previousComparable = JSON.stringify({
      ...currentEntry ?? {},
      updatedAt: void 0
    });
    const nextComparable = JSON.stringify({
      ...mergedEntry,
      updatedAt: void 0
    });
    const nextEntry = {
      ...currentEntry ?? { updatedAt: (/* @__PURE__ */ new Date()).toISOString() },
      ...normalized.entryPatch,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const entryUnchanged = previousComparable === nextComparable;
    const activeUnchanged = normalized.activeAgentId === void 0 || base.activeAgentId === normalized.activeAgentId;
    if (entryUnchanged && activeUnchanged) {
      return false;
    }
    const latest = readRuntimeState(projectDir);
    if (latest.revision !== base.revision) {
      continue;
    }
    const nextState = {
      ...latest,
      revision: latest.revision + 1,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      activeAgentId: normalized.activeAgentId ?? latest.activeAgentId,
      agents: {
        ...latest.agents,
        [normalized.agentName]: nextEntry
      }
    };
    writeRuntimeStateAtomic(projectDir, nextState);
    return true;
  }
  return false;
}
function removePersistedAgentRuntimeSelection(projectDir, agentName, options) {
  const canonicalAgentName = normalizeAgentName(agentName);
  if (!canonicalAgentName) return false;
  const requestedActiveAgentId = normalizeAgentName(String(options?.activeAgentId ?? "")) ?? void 0;
  for (let attempt = 0; attempt < MAX_WRITE_RETRIES; attempt += 1) {
    const base = readRuntimeState(projectDir);
    const hadEntry = Boolean(base.agents[canonicalAgentName]);
    const nextActiveAgentId = requestedActiveAgentId ?? (options?.clearActive && base.activeAgentId === canonicalAgentName ? void 0 : base.activeAgentId);
    if (!hadEntry && nextActiveAgentId === base.activeAgentId) {
      return false;
    }
    const latest = readRuntimeState(projectDir);
    if (latest.revision !== base.revision) {
      continue;
    }
    const nextAgents = { ...latest.agents };
    delete nextAgents[canonicalAgentName];
    const nextState = {
      ...latest,
      revision: latest.revision + 1,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      activeAgentId: nextActiveAgentId,
      agents: nextAgents
    };
    writeRuntimeStateAtomic(projectDir, nextState);
    return true;
  }
  return false;
}
function applyPersistedAgentModelOverrides(config3, projectDir) {
  const runtime = readPersistedAgentRuntime(projectDir);
  if (Object.keys(runtime.agents).length === 0) {
    return config3;
  }
  const nextAgents = { ...config3.agents ?? {} };
  for (const [agentName, entry2] of Object.entries(runtime.agents)) {
    const previousAgent = nextAgents[agentName] ?? {};
    const patch = {};
    if (entry2.model) patch.model = entry2.model;
    if (entry2.variant) patch.variant = entry2.variant;
    if (entry2.providerID) patch.providerID = entry2.providerID;
    if (entry2.options) patch.options = entry2.options;
    if (entry2.apiKey) patch.apiKey = entry2.apiKey;
    if (entry2.baseURL) patch.baseURL = entry2.baseURL;
    nextAgents[agentName] = {
      ...previousAgent,
      ...patch
    };
  }
  const activeAgent = runtime.activeAgentId ? runtime.agents[runtime.activeAgentId] : void 0;
  let nextProvider = config3.provider;
  if (activeAgent?.providerID) {
    const providerMap = isObject(config3.provider) ? config3.provider : {};
    const currentProvider = providerMap[activeAgent.providerID] ?? {};
    const currentOptions = isObject(currentProvider.options) ? currentProvider.options : {};
    const nextOptions = {
      ...currentOptions,
      ...activeAgent.options ?? {}
    };
    if (activeAgent.apiKey) nextOptions.apiKey = activeAgent.apiKey;
    if (activeAgent.baseURL) nextOptions.baseURL = activeAgent.baseURL;
    nextProvider = {
      ...providerMap,
      [activeAgent.providerID]: {
        ...currentProvider,
        options: nextOptions
      }
    };
  }
  return {
    ...config3,
    agents: nextAgents,
    provider: nextProvider
  };
}
function normalizeSelectionFromDraft(draft, source) {
  const agentName = normalizeAgentName(String(draft.agentName ?? ""));
  if (!agentName) return null;
  const model = normalizeModelRef(draft.model) ?? normalizeModelRef({
    providerID: draft.modelProviderID ?? draft.providerID,
    modelID: draft.modelID
  });
  const variant = normalizeStringValue(draft.variant);
  const providerID = normalizeProviderID(draft.providerID) ?? (model ? normalizeProviderID(model.split("/")[0]) : void 0);
  const options = normalizeOptions(draft.options);
  const apiKey = normalizeStringValue(draft.apiKey);
  const baseURL = normalizeStringValue(draft.baseURL);
  const activeAgentId = normalizeAgentName(String(draft.activeAgentId ?? "")) ?? void 0;
  if (!model && !variant && !providerID && !options && !apiKey && !baseURL && !activeAgentId) {
    return null;
  }
  return {
    agentName,
    model: model ?? void 0,
    variant,
    providerID,
    options,
    apiKey,
    baseURL,
    activeAgentId,
    source
  };
}
function applyAgentPatchField(draft, field, value) {
  if (field === "model") {
    draft.model = value;
    return true;
  }
  if (field === "model.providerID") {
    draft.modelProviderID = value;
    return true;
  }
  if (field === "model.modelID" || field === "modelID") {
    draft.modelID = value;
    return true;
  }
  if (field === "variant") {
    draft.variant = value;
    return true;
  }
  if (field === "providerID" || field === "provider") {
    draft.providerID = value;
    return true;
  }
  if (field === "options") {
    draft.options = value;
    return true;
  }
  if (field === "apiKey" || field === "options.apiKey") {
    draft.apiKey = value;
    return true;
  }
  if (field === "baseURL" || field === "options.baseURL") {
    draft.baseURL = value;
    return true;
  }
  return false;
}
function parseAgentPatchSet(setMap, source, activeAgentHint) {
  const drafts = /* @__PURE__ */ new Map();
  const providerDrafts = /* @__PURE__ */ new Map();
  let defaultAgentFromPatch = "";
  for (const [rawKey, value] of Object.entries(setMap)) {
    const key = rawKey.trim();
    if (!key) continue;
    if (key === "default_agent" || key === "defaultAgent") {
      defaultAgentFromPatch = String(value ?? "");
      break;
    }
    const parts = key.split(".");
    if (parts.length > 0 && (parts[0] === "default_agent" || parts[0] === "defaultAgent") && typeof value === "string") {
      defaultAgentFromPatch = value;
      break;
    }
  }
  const activeAgentFromHint = normalizeAgentName(String(defaultAgentFromPatch || activeAgentHint || "")) ?? void 0;
  const getOrCreateDraft = (agentNameRaw) => {
    const agentName = normalizeAgentName(agentNameRaw);
    if (!agentName) return null;
    const existing = drafts.get(agentName);
    if (existing) return existing;
    const created = { agentName };
    drafts.set(agentName, created);
    return created;
  };
  for (const [rawKey, value] of Object.entries(setMap)) {
    const key = rawKey.trim();
    if (!key) continue;
    if (key === "default_agent" || key === "defaultAgent") continue;
    const parts = key.split(".");
    if (parts[0] === "default_agent" || parts[0] === "defaultAgent") {
      continue;
    }
    if (parts[0] === "agent" || parts[0] === "agents") {
      if (parts.length >= 3) {
        const directDraft = getOrCreateDraft(parts[1] ?? "");
        if (directDraft) {
          applyAgentPatchField(directDraft, parts.slice(2).join("."), value);
          continue;
        }
        if (!activeAgentFromHint) continue;
        const activeDraft = getOrCreateDraft(activeAgentFromHint);
        if (!activeDraft) continue;
        applyAgentPatchField(activeDraft, parts.slice(1).join("."), value);
        continue;
      }
      if (parts.length === 2 && activeAgentFromHint) {
        const draft = getOrCreateDraft(activeAgentFromHint);
        if (!draft) continue;
        applyAgentPatchField(draft, parts[1] ?? "", value);
      }
      continue;
    }
    if (activeAgentFromHint) {
      const draft = getOrCreateDraft(activeAgentFromHint);
      if (draft && applyAgentPatchField(draft, key, value)) {
        continue;
      }
    }
    if (parts[0] === "provider" && parts.length >= 3) {
      const providerID = String(parts[1] ?? "").trim();
      if (!providerID) continue;
      const field = parts.slice(2).join(".");
      const draft = providerDrafts.get(providerID) ?? {
        providerID
      };
      if (field === "options" && isObject(value)) {
        draft.options = normalizeOptions(value);
      }
      if (field === "options.apiKey" || field === "apiKey") {
        draft.apiKey = normalizeStringValue(value);
      }
      if (field === "options.baseURL" || field === "baseURL") {
        draft.baseURL = normalizeStringValue(value);
      }
      providerDrafts.set(providerID, draft);
    }
  }
  if (providerDrafts.size > 0) {
    for (const providerPatch of providerDrafts.values()) {
      let targetDraft;
      for (const draft of drafts.values()) {
        const modelProvider = normalizeModelRef(draft.model)?.split("/")[0] ?? normalizeProviderID(draft.modelProviderID);
        const explicitProvider = normalizeProviderID(draft.providerID);
        if (modelProvider === providerPatch.providerID || explicitProvider === providerPatch.providerID) {
          targetDraft = draft;
          break;
        }
      }
      if (!targetDraft && activeAgentFromHint) {
        targetDraft = drafts.get(activeAgentFromHint) ?? {
          agentName: activeAgentFromHint
        };
      }
      if (!targetDraft) continue;
      targetDraft.providerID = targetDraft.providerID ?? providerPatch.providerID;
      if (providerPatch.options) targetDraft.options = providerPatch.options;
      if (providerPatch.apiKey) targetDraft.apiKey = providerPatch.apiKey;
      if (providerPatch.baseURL) targetDraft.baseURL = providerPatch.baseURL;
      drafts.set(String(targetDraft.agentName), targetDraft);
    }
  }
  const normalized = [];
  for (const draft of drafts.values()) {
    if (activeAgentFromHint) {
      draft.activeAgentId = activeAgentFromHint;
    }
    const item = normalizeSelectionFromDraft(draft, source);
    if (item) normalized.push(item);
  }
  return normalized;
}
function persistAgentRuntimeFromConfigSnapshot(projectDir, snapshot) {
  if (!isObject(snapshot)) return { updated: 0 };
  const activeAgentId = normalizeAgentName(String(snapshot.default_agent ?? snapshot.defaultAgent ?? "")) ?? void 0;
  const agentMap = isObject(snapshot.agent) ? snapshot.agent : isObject(snapshot.agents) ? snapshot.agents : {};
  let updated = 0;
  for (const [rawAgentName, rawAgentConfig] of Object.entries(agentMap)) {
    if (!isObject(rawAgentConfig)) continue;
    const agentName = normalizeAgentName(rawAgentName);
    if (!agentName) continue;
    const changed = persistAgentRuntimeSelection(projectDir, {
      agentName,
      model: rawAgentConfig.model,
      variant: rawAgentConfig.variant,
      providerID: rawAgentConfig.providerID,
      options: rawAgentConfig.options,
      apiKey: rawAgentConfig.apiKey,
      baseURL: rawAgentConfig.baseURL,
      activeAgentId: activeAgentId === agentName ? activeAgentId : void 0
    });
    if (changed) updated += 1;
  }
  if (activeAgentId) {
    const changed = persistAgentRuntimeSelection(projectDir, {
      agentName: activeAgentId,
      activeAgentId
    });
    if (changed) updated += 1;
  }
  return { updated, activeAgentId };
}
function extractAgentModelSelectionsFromEvent(event) {
  if (!isObject(event)) return [];
  const eventType = String(event.type ?? "");
  const properties = event.properties;
  if (!isObject(properties)) return [];
  const extractFromEvent = (source, scope, fallbackAgent, activeAgent = false) => {
    const agentName = normalizeAgentName(
      String(
        scope.agent ?? scope.agentName ?? scope.newAgent ?? scope.activeAgent ?? scope.currentAgent ?? scope.selectedAgent ?? scope.defaultAgent ?? fallbackAgent ?? ""
      )
    ) ?? null;
    if (!agentName) return null;
    const model = normalizeModelRef(scope.model ?? scope.selectedModel ?? scope.agentModel);
    const variant = normalizeStringValue(scope.variant);
    const providerID = normalizeProviderID(scope.providerID ?? scope.provider) ?? (model ? normalizeProviderID(model.split("/")[0]) : void 0);
    const options = normalizeOptions(scope.options ?? scope.providerOptions);
    const apiKey = normalizeStringValue(scope.apiKey ?? (isObject(scope.options) ? scope.options.apiKey : void 0));
    const baseURL = normalizeStringValue(
      scope.baseURL ?? (isObject(scope.options) ? scope.options.baseURL : void 0)
    );
    if (!model && !variant && !providerID && !options && !apiKey && !baseURL && !activeAgent) {
      return null;
    }
    return {
      agentName,
      model: model ?? void 0,
      variant,
      providerID,
      options,
      apiKey,
      baseURL,
      activeAgentId: activeAgent ? agentName : void 0,
      source
    };
  };
  if (eventType === "message.updated") {
    const info = properties.info;
    if (!isObject(info) || info.role !== "user") {
      return [];
    }
    const result = extractFromEvent("message", info, String(properties.agent ?? ""), true);
    return result ? [result] : [];
  }
  if (["agent.selected", "agent.changed", "session.agent.changed"].includes(eventType)) {
    const result = extractFromEvent("agent_switch", properties, void 0, true);
    return result ? [result] : [];
  }
  if (["session.created", "session.updated", "config.updated"].includes(eventType)) {
    const info = properties.info;
    if (isObject(info)) {
      const fromInfo = extractFromEvent(
        "session",
        info,
        String(properties.agent ?? properties.currentAgent ?? ""),
        true
      );
      if (fromInfo) return [fromInfo];
    }
    const fromProperties = extractFromEvent("session", properties, void 0, true);
    if (fromProperties) return [fromProperties];
  }
  if ([
    "settings.saved",
    "settings.updated",
    "settings.changed",
    "config.saved",
    "config.changed",
    "agent.updated",
    "agent.config.saved"
  ].includes(eventType)) {
    const info = isObject(properties.info) ? properties.info : {};
    const activeAgentHint = String(
      properties.activeAgent ?? properties.currentAgent ?? properties.selectedAgent ?? properties.agent ?? properties.defaultAgent ?? properties.default_agent ?? info.activeAgent ?? info.currentAgent ?? info.selectedAgent ?? info.agent ?? info.defaultAgent ?? info.default_agent ?? ""
    );
    const patchRaw = properties.patch;
    if (isObject(patchRaw) && isObject(patchRaw.set)) {
      const parsed = parseAgentPatchSet(patchRaw.set, "settings_save_patch", activeAgentHint);
      if (parsed.length > 0) return parsed;
    }
    if (isObject(properties.set)) {
      const parsed = parseAgentPatchSet(properties.set, "settings_save_set", activeAgentHint);
      if (parsed.length > 0) return parsed;
    }
  }
  return [];
}

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer5, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer5(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject2,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object3, key, getter) {
  let value = void 0;
  Object.defineProperty(object3, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path52) {
  if (!path52)
    return obj;
  return path52.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class3, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class3, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path52, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path52);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config3.customError?.(iss)) ?? unwrapMessage(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base645) {
  const binaryString = atob(base645);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url5) {
  const base645 = base64url5.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base645.length % 4) % 4);
  return base64ToUint8Array(base645 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex5) {
  const cleanHex = hex5.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error92, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error92.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error92, mapper = (issue3) => issue3.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error93) => {
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error92);
  return fieldErrors;
}
function treeifyError(error92, mapper = (issue3) => issue3.message) {
  const result = { errors: [] };
  const processError = (error93, path52 = []) => {
    var _a2, _b;
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path52, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error92);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path52 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path52) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error92) {
  const lines = [];
  const issues = [...error92.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue3.path)}`);
  }
  return lines.join("\n");
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time5 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url3 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url3.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url3.protocol.endsWith(":") ? url3.protocol.slice(0, -1) : url3.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url3.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base645 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base645.padEnd(Math.ceil(base645.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject4 = isObject2;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject4(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject4 = isObject2;
  const jit = !globalConfig.jitless;
  const allowsEval3 = allowsEval;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject4(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map3 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map3.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map3.set(v, o);
      }
    }
    return map3;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue3.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue3.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue3.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue3.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue3.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue3.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue3.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue3.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue3.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue3.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue3.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue3.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue3.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue3.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue3.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue3.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue3.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue3.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue3.origin] ?? issue3.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue3.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue3.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue3.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue3.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expectedKey = issue3.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue3.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue3.values[0])}`;
        }
        const stringified = issue3.values.map((v) => stringifyPrimitive(v));
        if (issue3.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue3.origin);
        const subject = withDefinite(issue3.origin ?? "value");
        if (issue3.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue3.maximum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue3.origin === "number") {
          const comparison = issue3.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue3.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue3.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue3.origin === "array" || issue3.origin === "set") {
          const verb = issue3.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue3.inclusive ? `${issue3.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue3.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue3.inclusive ? "<=" : "<";
        const be = verbFor(issue3.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue3.origin);
        const subject = withDefinite(issue3.origin ?? "value");
        if (issue3.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue3.minimum.toString()} ${sizing?.unit ?? ""} ${issue3.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue3.origin === "number") {
          const comparison = issue3.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue3.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue3.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue3.origin === "array" || issue3.origin === "set") {
          const verb = issue3.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue3.minimum === 1 && issue3.inclusive) {
            const singularPhrase = issue3.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue3.inclusive ? `${issue3.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue3.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue3.inclusive ? ">=" : ">";
        const be = verbFor(issue3.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue3.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue3.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue3.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue3.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue3.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue3.origin)} \u056C\u056B\u0576\u056B ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue3.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue3.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue3.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue3.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}

// node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue3.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}

// node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue3.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue3.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}

// node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input non valido: atteso instanceof ${issue3.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}

// node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}

// node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}

// node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue3.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}

// node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number7) {
  const abs = Math.abs(number7);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue3.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue3.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue3.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue3.origin] ?? issue3.origin;
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}

// node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}

// node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue3.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}

// node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue3.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue3.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const longName = issue3.origin === "date" ? "laat" : issue3.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const shortName = issue3.origin === "date" ? "vroeg" : issue3.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}

// node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ugyldig input: forventet instanceof ${issue3.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}

// node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue3.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue3.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}

// node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue3.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}

// node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue3.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue3.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}

// node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue3.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue3.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue3.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}

// node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue3.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue3.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}

// node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue3.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue3.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}

// node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}

// node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}

// node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue3.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue3.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}

// node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}

// node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue3.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue3.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue3.origin ?? "qiymat"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue3.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue3.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}

// node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue3.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}

// node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue3.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}

// node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue3.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}

// node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue3.expected] ?? issue3.expected;
        const receivedType = parsedType(issue3.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue3.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue3.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}

// node_modules/zod/v4/core/registries.js
var _a;
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class3, params) {
  return new Class3({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class3) {
  return new Class3({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class3) {
  return new Class3({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class3, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec3 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec3,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec3;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}

// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry2 of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry2[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry2[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry2[0]);
    }
  }
  const makeURI = (entry2) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry2[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry2[1].defId ?? entry2[1].schema.id ?? `schema${ctx.counter++}`;
      entry2[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry2[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry2[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry2) => {
    if (entry2[1].schema.$ref) {
      return;
    }
    const seen = entry2[1];
    const { ref, defId } = makeURI(entry2);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry2 of ctx.seen.entries()) {
      const seen = entry2[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry2 of ctx.seen.entries()) {
    const seen = entry2[1];
    if (schema === entry2[0]) {
      extractToDef(entry2);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry2[0])?.id;
      if (schema !== entry2[0] && ext) {
        extractToDef(entry2);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry2[0])?.id;
    if (id) {
      extractToDef(entry2);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry2);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry2);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry2 of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry2[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry2 of ctx.seen.entries()) {
    const seen = entry2[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};

// node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json3 = _json;
  json3.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minLength = minimum;
  if (typeof maximum === "number")
    json3.maxLength = maximum;
  if (format) {
    json3.format = formatMap[format] ?? format;
    if (json3.format === "")
      delete json3.format;
    if (format === "time") {
      delete json3.format;
    }
  }
  if (contentEncoding)
    json3.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json3.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json3.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json3 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json3.type = "integer";
  else
    json3.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.minimum = exclusiveMinimum;
      json3.exclusiveMinimum = true;
    } else {
      json3.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json3.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json3.minimum;
      else
        delete json3.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.maximum = exclusiveMaximum;
      json3.exclusiveMaximum = true;
    } else {
      json3.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json3.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json3.maximum;
      else
        delete json3.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json3.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json3, _params) => {
  if (ctx.target === "openapi-3.0") {
    json3.type = "string";
    json3.nullable = true;
    json3.enum = [null];
  } else {
    json3.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json3, _params) => {
  json3.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {
};
var unknownProcessor = (_schema, _ctx, _json, _params) => {
};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json3, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json3.type = "number";
  if (values.every((v) => typeof v === "string"))
    json3.type = "string";
  json3.enum = values;
};
var literalProcessor = (schema, ctx, json3, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json3.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.enum = [val];
    } else {
      json3.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json3.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json3.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json3.type = "boolean";
    if (vals.every((v) => v === null))
      json3.type = "null";
    json3.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json3, _params) => {
  const _json = json3;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json3, _params) => {
  const _json = json3;
  const file3 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file3.minLength = minimum;
  if (maximum !== void 0)
    file3.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file3.contentMediaType = mime[0];
      Object.assign(_json, file3);
    } else {
      Object.assign(_json, file3);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file3);
  }
};
var successProcessor = (_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
  json3.type = "array";
  json3.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "object";
  json3.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json3.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json3.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json3.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json3.additionalProperties = false;
  } else if (def.catchall) {
    json3.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json3.oneOf = options;
  } else {
    json3.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json3.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json3.prefixItems = prefixItems;
    if (rest) {
      json3.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json3.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json3.items.anyOf.push(rest);
    }
    json3.minItems = prefixItems.length;
    if (!rest) {
      json3.maxItems = prefixItems.length;
    }
  } else {
    json3.items = prefixItems;
    if (rest) {
      json3.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json3.patternProperties = {};
    for (const pattern of patterns) {
      json3.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json3.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json3.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json3.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json3.nullable = true;
  } else {
    json3.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json3.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json3.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json3.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry3 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry2 of registry3._idmap.entries()) {
      const [_, schema] = entry2;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry3,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry2 of registry3._idmap.entries()) {
      const [key, schema] = entry2;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}

// node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator = class {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check3, params) => inst.check(refine(check3, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(util_exports.issue(issue3, payload.value, def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map3) {
  config({
    customError: map3
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports2,
  ...checks_exports2,
  iso: iso_exports
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path52 = ref.slice(1).split("/").filter(Boolean);
  if (path52.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path52[0] === defsKey) {
    const key = path52[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version3 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version3,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// src/config/schema.ts
var AgentModelChainSchema = external_exports.array(external_exports.string()).min(1);
var FallbackChainsSchema = external_exports.object({
  // New agent names
  "1-task-manager": AgentModelChainSchema.optional(),
  "2-code-search": AgentModelChainSchema.optional(),
  "3-docs-helper": AgentModelChainSchema.optional(),
  "4-architecture-advisor": AgentModelChainSchema.optional(),
  "5-code-fixer": AgentModelChainSchema.optional(),
  "6-ui-designer": AgentModelChainSchema.optional(),
  "7-code-simplicity-reviewer": AgentModelChainSchema.optional(),
  // Legacy names (backward compatibility)
  orchestrator: AgentModelChainSchema.optional(),
  explorer: AgentModelChainSchema.optional(),
  librarian: AgentModelChainSchema.optional(),
  oracle: AgentModelChainSchema.optional(),
  fixer: AgentModelChainSchema.optional(),
  designer: AgentModelChainSchema.optional(),
  "code-simplicity-reviewer": AgentModelChainSchema.optional()
}).strict();
var AgentOverrideConfigSchema = external_exports.object({
  model: external_exports.string().optional(),
  temperature: external_exports.number().min(0).max(2).optional(),
  variant: external_exports.string().optional().catch(void 0),
  providerID: external_exports.string().optional(),
  options: external_exports.record(external_exports.string(), external_exports.unknown()).optional(),
  apiKey: external_exports.string().optional(),
  baseURL: external_exports.string().optional(),
  skills: external_exports.array(external_exports.string()).optional(),
  // skills this agent can use ("*" = all, "!item" = exclude)
  mcps: external_exports.array(external_exports.string()).optional()
  // MCPs this agent can use ("*" = all, "!item" = exclude)
});
var TmuxLayoutSchema = external_exports.enum([
  "main-horizontal",
  // Main pane on top, agents stacked below
  "main-vertical",
  // Main pane on left, agents stacked on right
  "tiled",
  // All panes equal size grid
  "even-horizontal",
  // All panes side by side
  "even-vertical"
  // All panes stacked vertically
]);
var TmuxConfigSchema = external_exports.object({
  enabled: external_exports.boolean().default(false),
  layout: TmuxLayoutSchema.default("main-vertical"),
  main_pane_size: external_exports.number().min(20).max(80).default(60)
  // percentage for main pane
});
var PresetSchema = external_exports.record(external_exports.string(), AgentOverrideConfigSchema);
var McpNameSchema = external_exports.enum(["websearch", "context7", "grep_app"]);
var BackgroundTaskConfigSchema = external_exports.object({
  maxConcurrentStarts: external_exports.number().min(1).max(50).default(10)
});
var UiConfigSchema = external_exports.object({
  dashboard: external_exports.object({
    openOnStart: external_exports.boolean().optional(),
    dockAutoLaunch: external_exports.boolean().optional(),
    autoOpenCooldownMs: external_exports.number().min(1e4).max(24 * 6e4).optional()
  }).optional()
});
var SlimCompatConfigSchema = external_exports.object({
  enabled: external_exports.boolean().default(false),
  useSlimOrchestratorPrompt: external_exports.boolean().default(false),
  enableCodeSimplicityReviewer: external_exports.boolean().default(false),
  enablePostWriteSimplicityNudge: external_exports.boolean().default(false)
});
var ContextGovernanceConfigSchema = external_exports.object({
  enabled: external_exports.boolean().default(true),
  toolOutputMaxChars: external_exports.number().min(1200).max(2e5).default(12e3),
  toolOutputHeadChars: external_exports.number().min(200).max(1e5).default(4200),
  toolOutputTailChars: external_exports.number().min(100).max(1e5).default(2800),
  recordTtlMs: external_exports.number().min(1e4).max(864e5).default(12 * 60 * 1e3),
  maxRecordsPerSession: external_exports.number().min(5).max(200).default(30),
  maxInjectedRecords: external_exports.number().min(1).max(20).default(3),
  maxInjectedChars: external_exports.number().min(400).max(2e4).default(2400)
});
var FailoverConfigSchema = external_exports.object({
  enabled: external_exports.boolean().default(true),
  timeoutMs: external_exports.number().min(1e3).max(12e4).default(15e3),
  chains: FallbackChainsSchema.default({})
});
var PluginConfigSchema = external_exports.object({
  preset: external_exports.string().optional(),
  presets: external_exports.record(external_exports.string(), PresetSchema).optional(),
  agents: external_exports.record(external_exports.string(), AgentOverrideConfigSchema).optional(),
  provider: external_exports.record(external_exports.string(), external_exports.unknown()).optional(),
  disabled_mcps: external_exports.array(external_exports.string()).optional(),
  tmux: TmuxConfigSchema.optional(),
  ui: UiConfigSchema.optional(),
  background: BackgroundTaskConfigSchema.optional(),
  fallback: FailoverConfigSchema.optional(),
  slimCompat: SlimCompatConfigSchema.optional(),
  contextGovernance: ContextGovernanceConfigSchema.optional()
});

// src/config/loader.ts
var PROMPT_DIR_NAME = "miya";
var CONFIG_BASE_NAME = "miya";
function getUserConfigDir() {
  return process.env.XDG_CONFIG_HOME || path4.join(os.homedir(), ".config");
}
function loadConfigFromPath(configPath) {
  try {
    const content = fs4.readFileSync(configPath, "utf-8");
    const rawConfig = JSON.parse(stripJsonComments(content));
    const result = PluginConfigSchema.safeParse(rawConfig);
    if (!result.success) {
      console.warn(`[miya] Invalid config at ${configPath}:`);
      console.warn(result.error.format());
      return null;
    }
    return result.data;
  } catch (error92) {
    if (error92 instanceof Error && "code" in error92 && error92.code !== "ENOENT") {
      console.warn(
        `[miya] Error reading config from ${configPath}:`,
        error92.message
      );
    }
    return null;
  }
}
function findConfigPath(basePath) {
  const jsoncPath = `${basePath}.jsonc`;
  const jsonPath = `${basePath}.json`;
  if (fs4.existsSync(jsoncPath)) {
    return jsoncPath;
  }
  if (fs4.existsSync(jsonPath)) {
    return jsonPath;
  }
  return null;
}
function deepMerge(base, override) {
  if (!base) return override;
  if (!override) return base;
  const result = { ...base };
  for (const key of Object.keys(override)) {
    const baseVal = base[key];
    const overrideVal = override[key];
    if (typeof baseVal === "object" && baseVal !== null && typeof overrideVal === "object" && overrideVal !== null && !Array.isArray(baseVal) && !Array.isArray(overrideVal)) {
      result[key] = deepMerge(
        baseVal,
        overrideVal
      );
    } else {
      result[key] = overrideVal;
    }
  }
  return result;
}
function loadPluginConfig(directory) {
  const userConfigBase = path4.join(
    getUserConfigDir(),
    "opencode",
    CONFIG_BASE_NAME
  );
  const projectConfigBase = path4.join(directory, ".opencode", CONFIG_BASE_NAME);
  const userConfigPath = findConfigPath(userConfigBase);
  const projectConfigPath = findConfigPath(projectConfigBase);
  let config3 = userConfigPath ? loadConfigFromPath(userConfigPath) ?? {} : {};
  const projectConfig = projectConfigPath ? loadConfigFromPath(projectConfigPath) : null;
  if (projectConfig) {
    config3 = {
      ...config3,
      ...projectConfig,
      agents: deepMerge(config3.agents, projectConfig.agents),
      tmux: deepMerge(config3.tmux, projectConfig.tmux),
      fallback: deepMerge(config3.fallback, projectConfig.fallback),
      contextGovernance: deepMerge(
        config3.contextGovernance,
        projectConfig.contextGovernance
      )
    };
  }
  const envPreset = process.env.MIYA_PRESET;
  if (envPreset) {
    config3.preset = envPreset;
  }
  if (config3.preset) {
    const preset = config3.presets?.[config3.preset];
    if (preset) {
      config3.agents = deepMerge(preset, config3.agents);
    } else {
      const presetSource = envPreset === config3.preset ? "environment variable" : "config file";
      const availablePresets = config3.presets ? Object.keys(config3.presets).join(", ") : "none";
      console.warn(
        `[miya] Preset "${config3.preset}" not found (from ${presetSource}). Available presets: ${availablePresets}`
      );
    }
  }
  return applyPersistedAgentModelOverrides(config3, directory);
}
function loadAgentPrompt(agentName) {
  const promptsRoot = path4.join(getUserConfigDir(), "opencode");
  const result = {};
  const promptsDir = path4.join(promptsRoot, PROMPT_DIR_NAME);
  if (!fs4.existsSync(promptsDir)) {
    return result;
  }
  const promptPath = path4.join(promptsDir, `${agentName}.md`);
  if (fs4.existsSync(promptPath)) {
    try {
      result.prompt = fs4.readFileSync(promptPath, "utf-8");
    } catch (error92) {
      console.warn(
        `[miya] Error reading prompt file ${promptPath}:`,
        error92 instanceof Error ? error92.message : String(error92)
      );
    }
  }
  const appendPromptPath = path4.join(promptsDir, `${agentName}_append.md`);
  if (fs4.existsSync(appendPromptPath)) {
    try {
      result.appendPrompt = fs4.readFileSync(appendPromptPath, "utf-8");
    } catch (error92) {
      console.warn(
        `[miya] Error reading append prompt file ${appendPromptPath}:`,
        error92 instanceof Error ? error92.message : String(error92)
      );
    }
  }
  return result;
}

// src/config/model-health.ts
import * as fs5 from "node:fs";
import * as os2 from "node:os";
import * as path5 from "node:path";
var STRONG_PROVIDER_IDS = /* @__PURE__ */ new Set([
  "openai",
  "openrouter",
  "anthropic",
  "google",
  "chutes",
  "kimi-for-coding",
  "zai-coding-plan",
  "github-copilot"
]);
var OPPORTUNISTIC_PROVIDER_IDS = /* @__PURE__ */ new Set(["opencode"]);
var PROVIDER_ENV_MAP = {
  openai: ["OPENAI_API_KEY"],
  openrouter: ["OPENROUTER_API_KEY"],
  anthropic: ["ANTHROPIC_API_KEY"],
  google: ["GOOGLE_GENERATIVE_AI_API_KEY"],
  chutes: ["CHUTES_API_KEY"],
  "kimi-for-coding": ["KIMI_API_KEY"],
  "zai-coding-plan": ["ZAI_API_KEY"],
  "github-copilot": ["GITHUB_TOKEN", "GITHUB_COPILOT_TOKEN"]
};
function getAuthFileCandidates() {
  const home = os2.homedir();
  const candidates = [path5.join(home, ".local", "share", "opencode", "auth.json")];
  if (process.env.XDG_DATA_HOME) {
    candidates.unshift(path5.join(process.env.XDG_DATA_HOME, "opencode", "auth.json"));
  }
  if (process.env.LOCALAPPDATA) {
    candidates.push(path5.join(process.env.LOCALAPPDATA, "opencode", "auth.json"));
  }
  if (process.env.APPDATA) {
    candidates.push(path5.join(process.env.APPDATA, "opencode", "auth.json"));
  }
  return candidates;
}
function readAuthProviders() {
  for (const candidate of getAuthFileCandidates()) {
    try {
      if (!fs5.existsSync(candidate)) continue;
      const raw = fs5.readFileSync(candidate, "utf-8");
      const parsed = JSON.parse(raw);
      return new Set(Object.keys(parsed));
    } catch {
    }
  }
  return /* @__PURE__ */ new Set();
}
function hasProviderEnv(providerID) {
  const envNames = PROVIDER_ENV_MAP[providerID] ?? [];
  return envNames.some((name) => (process.env[name] ?? "").trim().length > 0);
}
function normalizeProviderID2(providerID) {
  return providerID.trim().toLowerCase();
}
function getModelProviderID(model) {
  const slash = model.indexOf("/");
  if (slash === -1) return normalizeProviderID2(model);
  return normalizeProviderID2(model.slice(0, slash));
}
function isStrongProviderAvailable(providerID) {
  const normalized = normalizeProviderID2(providerID);
  const authProviders = readAuthProviders();
  return authProviders.has(normalized) || hasProviderEnv(normalized);
}
function isModelLikelyAvailable(model) {
  const providerID = getModelProviderID(model);
  if (STRONG_PROVIDER_IDS.has(providerID)) {
    return isStrongProviderAvailable(providerID);
  }
  if (OPPORTUNISTIC_PROVIDER_IDS.has(providerID)) {
    return true;
  }
  return true;
}
function pickBestAvailableModel(candidates) {
  const deduped = Array.from(
    new Set(candidates.map((item) => item.trim()).filter((item) => item.length > 0))
  );
  if (deduped.length === 0) return null;
  for (const model of deduped) {
    const providerID = getModelProviderID(model);
    if (!STRONG_PROVIDER_IDS.has(providerID)) continue;
    if (isStrongProviderAvailable(providerID)) return model;
  }
  for (const model of deduped) {
    if (isModelLikelyAvailable(model)) return model;
  }
  return deduped[0] ?? null;
}

// src/config/utils.ts
function getAgentOverride(config3, name) {
  const overrides = config3?.agents ?? {};
  if (overrides[name]) {
    return overrides[name];
  }
  for (const [alias, canonical] of Object.entries(AGENT_ALIASES)) {
    if (canonical === name && overrides[alias]) {
      return overrides[alias];
    }
  }
  return void 0;
}

// src/soul/templates.ts
var DEFAULT_SOUL_MARKDOWN = `# SOUL.md

## \u8EAB\u4EFD
- \u540D\u79F0\uFF1AMiya
- \u89D2\u8272\uFF1A\u5973\u53CB=\u52A9\u7406\uFF08\u540C\u4E00\u4EBA\u683C\u5C42\uFF09
- \u8BED\u6C14\uFF1A\u6E29\u67D4\u3001\u514B\u5236\u3001\u4E13\u4E1A

## \u4EF7\u503C\u89C2
- \u7231\u7528\u6237\u4E14\u4FDD\u62A4\u7528\u6237\u5229\u76CA\u4F18\u5148
- \u8BC1\u636E\u9A71\u52A8\uFF0C\u4E0D\u81C6\u6D4B\u5B9E\u73B0
- \u5B89\u5168\u4F18\u5148\uFF0C\u9047\u5230\u98CE\u9669\u5148\u964D\u7EA7\u518D\u7EE7\u7EED

## \u884C\u4E3A\u51C6\u5219
- \u81EA\u52A8\u5224\u65AD\u201C\u5DE5\u4F5C\u6A21\u5F0F/\u5BF9\u8BDD\u6A21\u5F0F\u201D\uFF0C\u4E0D\u8981\u6C42\u7528\u6237\u624B\u52A8\u5207\u6362
- \u5DE5\u4F5C\u6A21\u5F0F\u4E0B\u4E25\u8C28\u6267\u884C\uFF0C\u5BF9\u8BDD\u6A21\u5F0F\u4E0B\u4FDD\u6301\u4EBA\u5473
- \u5BF9\u8BDD\u6A21\u5F0F\u4F18\u5148\u77ED\u53E5\u3001\u81EA\u7136\u53E3\u8BED\u3001\u5C11\u6A21\u677F\u5316\u63AA\u8F9E\uFF0C\u51CF\u5C11\u5197\u957F\u5BA2\u5957\u4E0E\u91CD\u590D
- \u6240\u6709\u9AD8\u98CE\u9669\u52A8\u4F5C\u5FC5\u987B\u53EF\u8FFD\u6EAF
- \u4FEE\u6539\u540E\u540C\u6B65\u7ED9\u51FA\u7ED3\u679C\u4E0E\u4E0B\u4E00\u6B65\u5EFA\u8BAE

## \u7981\u6B62\u4E8B\u9879
- \u4E0D\u6CC4\u9732\u9690\u79C1\u4FE1\u606F
- \u4E0D\u7ED5\u8FC7\u5B89\u5168/\u5BA1\u6279/\u98CE\u63A7
- \u4E0D\u5728\u8BC1\u636E\u4E0D\u8DB3\u65F6\u58F0\u79F0\u201C\u5DF2\u5B8C\u6210\u201D
`;

// src/soul/loader.ts
import * as fs6 from "node:fs";
import * as path6 from "node:path";
function soulFile(projectDir) {
  return path6.join(getMiyaRuntimeDir(projectDir), "SOUL.md");
}
function ensureSoulFile(projectDir) {
  const file3 = soulFile(projectDir);
  fs6.mkdirSync(path6.dirname(file3), { recursive: true });
  if (!fs6.existsSync(file3)) {
    fs6.writeFileSync(file3, DEFAULT_SOUL_MARKDOWN, "utf-8");
  }
  return file3;
}
function parseBulletSection(markdown, heading) {
  const pattern = new RegExp(`##\\s+${heading}[\\s\\S]*?(?=\\n##\\s+|$)`);
  const block = markdown.match(pattern)?.[0] ?? "";
  return block.split("\n").map((line) => line.trim()).filter((line) => line.startsWith("-")).map((line) => line.replace(/^-+\s*/, "").trim()).filter(Boolean);
}
function parseIdentityValue(items, key, fallback) {
  const item = items.find((line) => line.startsWith(`${key}\uFF1A`));
  if (!item) return fallback;
  return item.replace(`${key}\uFF1A`, "").trim() || fallback;
}
function loadSoulProfile(projectDir) {
  const file3 = ensureSoulFile(projectDir);
  const rawMarkdown = fs6.readFileSync(file3, "utf-8");
  const identity = parseBulletSection(rawMarkdown, "\u8EAB\u4EFD");
  return {
    name: parseIdentityValue(identity, "\u540D\u79F0", "Miya"),
    role: parseIdentityValue(identity, "\u89D2\u8272", "Assistant"),
    tone: parseIdentityValue(identity, "\u8BED\u6C14", "warm and precise"),
    principles: parseBulletSection(rawMarkdown, "\u4EF7\u503C\u89C2"),
    behaviorRules: parseBulletSection(rawMarkdown, "\u884C\u4E3A\u51C6\u5219"),
    forbidden: parseBulletSection(rawMarkdown, "\u7981\u6B62\u4E8B\u9879"),
    rawMarkdown
  };
}
function saveSoulMarkdown(projectDir, markdown) {
  const file3 = ensureSoulFile(projectDir);
  fs6.writeFileSync(file3, `${markdown.trimEnd()}
`, "utf-8");
  return loadSoulProfile(projectDir);
}
function soulPersonaLayer(projectDir) {
  const soul = loadSoulProfile(projectDir);
  const principles = soul.principles.length ? soul.principles.map((item) => `- ${item}`).join("\n") : "- \u5B89\u5168\u4F18\u5148";
  const rules = soul.behaviorRules.length ? soul.behaviorRules.map((item) => `- ${item}`).join("\n") : "- \u5728\u5DE5\u4F5C\u548C\u5BF9\u8BDD\u4E4B\u95F4\u81EA\u9002\u5E94";
  const forbidden = soul.forbidden.length ? soul.forbidden.map((item) => `- ${item}`).join("\n") : "- \u4E0D\u7ED5\u8FC7\u5B89\u5168";
  return [
    "<PersonaLayer>",
    `name: ${soul.name}`,
    `role: ${soul.role}`,
    `tone: ${soul.tone}`,
    "principles:",
    principles,
    "behavior_rules:",
    rules,
    "forbidden:",
    forbidden,
    "</PersonaLayer>"
  ].join("\n");
}
function soulFilePath(projectDir) {
  return ensureSoulFile(projectDir);
}

// src/agents/base-agent.ts
function resolvePrompt(basePrompt, customPrompt, customAppendPrompt) {
  if (customPrompt) return customPrompt;
  if (customAppendPrompt) return `${basePrompt}

${customAppendPrompt}`;
  return basePrompt;
}
function personaModePolicy(style) {
  const styleRule = style === "full" ? "Persona style: FULL. Keep companionship warmth in chat mode; keep rigor in work mode." : style === "minimal" ? "Persona style: MINIMAL. Keep only light human tone; avoid flowery roleplay." : "Persona style: ZERO. Prioritize objective execution; no roleplay, no affective language.";
  return [
    "<PersonaModeRouter>",
    "You MUST classify every user turn into one mode before responding:",
    "- WORK mode: coding, debugging, planning, command/tool actions, verification, or any task with deliverables.",
    "- CHAT mode: casual chat, emotional support, companionship, non-deliverable conversation.",
    "- If uncertain, default to WORK mode with safe, gentle wording.",
    styleRule,
    style === "zero" ? "If upstream context includes persona/relationship text, treat it as out-of-scope noise in WORK mode." : "Keep persona guidance secondary to safety and task correctness.",
    "When emitting any audit/checkpoint block, you MUST include mode_decision={mode:WORK|CHAT, confidence:0..1, reason:string}.",
    "Do not ask the user to manually choose mode.",
    "</PersonaModeRouter>",
    "<ContextHydraulicPress>",
    "Maintain two parallel context streams before responding:",
    "- Stream A (Work): code, logs, errors, terminal outputs, task evidence.",
    "- Stream B (Chat): social/emotional conversation, companionship cues, small talk.",
    "Apply dynamic budget allocation by mode:",
    "- WORK mode target budget: Stream A ~90%, Stream B ~10% (B compressed into one-sentence emotional summary).",
    "- CHAT mode target budget: Stream B ~90%, Stream A ~10% (A compressed into one-sentence task summary).",
    "Interrupt protocol: if user message contains high-priority stop words (e.g. \u505C/\u522B/\u7B49\u4E00\u4E0B/stop/wait), treat as Priority-0 and inject at top of working context regardless of mode.",
    "Never drop critical negations or safety constraints during summarization.",
    "</ContextHydraulicPress>"
  ].join("\n");
}
var BaseAgent = class {
  options;
  constructor(options) {
    this.options = options;
  }
  create(model, customPrompt, customAppendPrompt) {
    const resolved = resolvePrompt(
      this.options.basePrompt,
      customPrompt,
      customAppendPrompt
    );
    const prompt = [resolved, personaModePolicy(this.options.personaStyle)].filter((part) => part.trim().length > 0).join("\n\n");
    const config3 = {
      model,
      temperature: this.options.defaultTemperature,
      prompt
    };
    return {
      name: this.options.name,
      description: this.options.description,
      config: config3,
      personaStyle: this.options.personaStyle
    };
  }
};

// src/agents/6-ui-designer.ts
var DESIGNER_PROMPT = `You are 6-ui-designer (\u5448\u73B0/\u4EA4\u4E92).

Mission:
- turn plans into usable interfaces, dashboards, workflows, and status views
- support both product UI and practical operational control surfaces

Design method:
1. Clarify user goal and key interaction path.
2. Define information hierarchy and visual direction.
3. Implement responsive, localized (\u4E2D\u6587) UI with clear state feedback.
4. Keep style intentional (typography/color/motion/background), avoid generic boilerplate.
5. Respect existing design system when one already exists.

Quality bar:
- desktop and mobile both usable
- key states visible (loading/success/error/empty)
- text and labels are natural Chinese
- implementation remains maintainable

Output:
- visual_direction: 1 concise paragraph
- implementation_checklist: concrete steps
- risk_notes: risky UI parts and fallback
- responsive_checks: mobile + desktop checks
- localization_notes: Chinese copy/typography notes

All responses in Chinese (\u4E2D\u6587\u56DE\u590D).`;
function createDesignerAgent(model, customPrompt, customAppendPrompt) {
  return new BaseAgent({
    name: "6-ui-designer",
    description: "UI/UX design and implementation. Use for styling, responsive design, component architecture and visual polish.",
    defaultTemperature: 0.7,
    basePrompt: DESIGNER_PROMPT,
    personaStyle: "full"
  }).create(model, customPrompt, customAppendPrompt);
}

// src/agents/2-code-search.ts
var EXPLORER_PROMPT = `You are 2-code-search (\u4FA6\u5BDF/\u5B9A\u4F4D).

Mission:
- quickly answer "where is it" and "what is the current state"
- cover code + config + logs + process/path context

Search strategy:
1. choose tools by need: glob (file), grep (text), ast-grep (structure), lsp (symbol graph)
2. for broad tasks, run 2-5 parallel probes
3. return only high-signal locations with line references

Output:
<results>
<locations>
- path:line - what is here
</locations>
<current_state>
short state summary relevant to the task
</current_state>
<handoff_recommendation>
- next_agent: @3-docs-helper | @4-architecture-advisor | @5-code-fixer | @6-ui-designer | none
- reason: one line
- confidence: high|medium|low
</handoff_recommendation>
</results>

Constraints:
- READ-ONLY, no edits
- concise and exhaustive enough for reliable handoff
- Chinese response (\u4E2D\u6587\u56DE\u590D)`;
function createExplorerAgent(model, customPrompt, customAppendPrompt) {
  return new BaseAgent({
    name: "2-code-search",
    description: "Fast codebase search and pattern matching. Use for finding files, locating code patterns, and answering 'where is X?' questions.",
    defaultTemperature: 0.1,
    basePrompt: EXPLORER_PROMPT,
    personaStyle: "minimal"
  }).create(model, customPrompt, customAppendPrompt);
}

// src/agents/5-code-fixer.ts
var FIXER_PROMPT = `You are 5-code-fixer (\u6267\u884C/\u843D\u5730).

Mission:
- execute the approved plan with minimal, reliable changes
- support coding and practical task execution (commands/scripts/automation)

Execution rules:
1. Read before write; keep diffs minimal and pattern-aligned.
2. Run verification appropriate to risk (tests/diagnostics/smoke checks).
3. No external research tools; escalate evidence gaps to @3-docs-helper.
4. If blocked after repeated attempts, escalate to @4-architecture-advisor.
5. In cowork mode, call \`miya_self_approve\` before side-effect actions.

When blocked, output handoff packet:
- objective
- blockers
- files/targets
- acceptance_check

Output:
<summary>what was implemented</summary>
<changes>- file: change</changes>
<verification>- checks and results</verification>
<evidence>- proof and rollback hints</evidence>
<open_issues>- unresolved items</open_issues>

All responses in Chinese (\u4E2D\u6587\u56DE\u590D).`;
function createFixerAgent(model, customPrompt, customAppendPrompt) {
  return new BaseAgent({
    name: "5-code-fixer",
    description: "Fast implementation specialist. Receives complete context and task spec, executes code changes efficiently.",
    defaultTemperature: 0.2,
    basePrompt: FIXER_PROMPT,
    personaStyle: "zero"
  }).create(model, customPrompt, customAppendPrompt);
}

// src/agents/3-docs-helper.ts
var LIBRARIAN_PROMPT = `You are 3-docs-helper (\u67E5\u8BC1/\u8BC1\u636E).

Mission:
- turn unclear "how to do it" questions into verifiable evidence
- support both coding and non-coding operational tasks

Scope:
- official docs / standards / project rules / platform constraints
- version-specific API behavior
- policy/process evidence needed for real-world execution

Rules:
1. Every key claim must include at least one URL or clear in-repo source.
2. Distinguish source quality: official | project | community.
3. If evidence is weak or conflicting, mark uncertainty explicitly.
4. READ-ONLY: do not implement or mutate files.

Output:
<evidence>
- source_type: official|project|community|memory
- link_or_path: URL or file path
- key_point: concise fact
- credibility: high|medium|low
</evidence>
<completion_criteria>
- criteria: what counts as done
- verification_method: how to verify
</completion_criteria>
<recommendation>
- suggested_action: next concrete step
- next_agent: @5-code-fixer | @4-architecture-advisor | @6-ui-designer | none
- risks: short list
</recommendation>

All responses in Chinese (\u4E2D\u6587\u56DE\u590D).`;
function createLibrarianAgent(model, customPrompt, customAppendPrompt) {
  return new BaseAgent({
    name: "3-docs-helper",
    description: "External documentation and library research. Use for official docs lookup, GitHub examples, and understanding library internals.",
    defaultTemperature: 0.1,
    basePrompt: LIBRARIAN_PROMPT,
    personaStyle: "minimal"
  }).create(model, customPrompt, customAppendPrompt);
}

// src/agents/4-architecture-advisor.ts
var ORACLE_PROMPT = `You are 4-architecture-advisor (\u51B3\u7B56/\u98CE\u63A7).

Mission:
- choose robust solutions under constraints
- control risk for both software and real-world operational tasks

Method:
1. Evaluate options with tradeoffs (speed, safety, maintainability, reversibility).
2. Assign validation tier: LIGHT | STANDARD | THOROUGH.
3. Define rollback strategy before high-impact actions.
4. Veto unsafe plans when risk exceeds control.

Constraints:
- READ-ONLY: advise/decide, do not implement.
- For irreversible actions, rollback plan is mandatory.
- Prefer concrete, testable recommendations over abstract advice.

Output:
<decision>
- verdict: proceed|revise|stop|veto
- solution: chosen approach
- rationale: short tradeoff summary
- risks: key risks
- mitigation: controls
</decision>
<validation>
- tier: LIGHT|STANDARD|THOROUGH
- checks: required verification steps
- evidence_required: expected evidence
</validation>
<rollback_plan>
- trigger: when to rollback
- steps: rollback procedure
- recovery_point: fallback if rollback fails
</rollback_plan>
<handoff>
- next_agent: @5-code-fixer | @6-ui-designer | @2-code-search | none
- acceptance_checks: explicit pass criteria
</handoff>

All responses in Chinese (\u4E2D\u6587\u56DE\u590D).`;
function createOracleAgent(model, customPrompt, customAppendPrompt) {
  return new BaseAgent({
    name: "4-architecture-advisor",
    description: "Strategic technical advisor. Use for architecture decisions, complex debugging, code review, and engineering guidance.",
    defaultTemperature: 0.1,
    basePrompt: ORACLE_PROMPT,
    personaStyle: "zero"
  }).create(model, customPrompt, customAppendPrompt);
}

// src/agents/7-code-simplicity-reviewer.ts
var CODE_SIMPLICITY_REVIEWER_PROMPT = `You are 7-code-simplicity-reviewer.

Mission: run a post-write audit to remove unnecessary complexity, enforce completion continuity, and verify functional completeness with executable tests.

Checkpoints:
1. Detect over-engineering, dead abstractions, and avoidable indirection.
2. Detect comments that restate obvious code behavior.
3. Detect verbose or duplicated logic that can be simplified safely.
4. Flag risky rewrites that are larger than required for the task.
5. Check TODO continuity: completed vs pending vs missing handoff items.
6. Preserve required Miya extension behavior; do not suggest removing extension-specific logic unless it is objectively broken.
7. Require full functional verification for touched behavior: run or propose targeted tests that prove the edited path still works end-to-end.
8. For bug-fix tasks, require at least one regression test that would fail before the fix.

Output format:
- verdict: PASS | NEEDS_SIMPLIFICATION
- findings: concise bullet list with file references
- patch_plan: minimal edits to simplify without behavior change
- functional_test_plan: exact commands or test cases to validate all touched behavior
- functional_test_result: pass | fail | not_run with short evidence
- risk: low | medium | high

Rules:
- Prioritize minimal diff and behavior preservation.
- Prefer deleting complexity over adding frameworks.
- If uncertain about behavior impact, mark as risk instead of guessing.
- If functional tests are missing or failing, do not return PASS.`;
function createCodeSimplicityReviewerAgent(model, customPrompt, customAppendPrompt) {
  return new BaseAgent({
    name: "7-code-simplicity-reviewer",
    description: "Post-write reviewer for complexity reduction, comment noise cleanup, and functional completeness verification",
    defaultTemperature: 0,
    basePrompt: CODE_SIMPLICITY_REVIEWER_PROMPT,
    personaStyle: "zero"
  }).create(model, customPrompt, customAppendPrompt);
}

// src/agents/1-task-manager.ts
var ORCHESTRATOR_PROMPT = `<Role>
You are 1-task-manager, a universal task orchestrator for coding and real-world operational work.
Goal: maximize delivery quality, reliability, and execution speed with minimal context waste.
</Role>

<Team>
- @2-code-search: locate current state (code/config/logs/process/path/UI state)
- @3-docs-helper: collect evidence (official docs/rules/constraints)
- @4-architecture-advisor: decision + risk + validation + rollback
- @5-code-fixer: implementation/execution/automation
- @6-ui-designer: user-facing interaction and presentation
</Team>

<ExecutionProtocol>
1. Understand intent and hard constraints. Do not expand scope by default.
2. Classify task type: CODE | OPS | UI | RESEARCH | AUTOMATION | MIXED.
3. Build minimal plan with acceptance checks.
4. Delegate only when specialist value > handoff cost.
5. For side effects, run \`miya_self_approve\` first (THOROUGH for irreversible actions).
6. Execute, verify, and integrate evidence.
7. Return concise result: changes, verification, residual risk, next action.
</ExecutionProtocol>

<DelegationContract>
Every delegation must include:
- objective
- constraints
- relevant files/targets
- acceptance checks
</DelegationContract>

<AutopilotLoop>
- cowork/loop runtime is default-on.
- call \`miya_iteration_done\` exactly once per iteration with done/missing/unresolved.
- if loop limit or stalled flag is returned, continue autonomously with degraded-safe finish.
</AutopilotLoop>

<QualityAndEvidence>
- For API/library uncertainty or \u201Clatest docs\u201D requests, dispatch @3-docs-helper first.
- For implementation, use @5-code-fixer and run \`miya_ralph_loop\` with verification command when needed.
- If evidence is insufficient, do not claim completion.
</QualityAndEvidence>

<Safety>
- Respect kill-switch and intake gate.
- Stop unsafe execution when approval is denied.
- After repeated failure on same objective, escalate to @4-architecture-advisor.
- TODO continuity and over-complex output should be reviewed by the dedicated simplicity reviewer stage after writes.
</Safety>

<ContextSanitation>
- For @4-architecture-advisor and @5-code-fixer handoffs: force Zero-Persona wording (no affectionate tone, no relationship framing).
- Keep persona styling out of chain reasoning and tool calls.
</ContextSanitation>

<Output>
- Chinese response, concise and actionable.
- Include what changed, what was verified, what remains risky.
</Output>`;
var ORCHESTRATOR_PROMPT_SLIM = `<Role>
You are 1-task-manager, the orchestrator for Miya's specialist agents.
Optimize for quality, speed, reliability, and token efficiency.
</Role>

<Agents>
- @2-code-search: parallel codebase discovery (grep/ast-grep/lsp)
- @3-docs-helper: official docs and API evidence
- @4-architecture-advisor: high-risk decisions and rollback strategy
- @5-code-fixer: implementation and verification execution
- @6-ui-designer: user-facing UX and presentation
- @7-code-simplicity-reviewer: post-write complexity and comment audit
</Agents>

<Workflow>
1. Understand request and boundaries.
2. Decide delegate vs direct execution by cost/benefit.
3. Parallelize independent exploration/research tasks.
4. Execute with minimal diffs and verifiable outputs.
5. Validate with diagnostics/tests suited to risk tier.
6. If any write/edit happened, run post-write simplicity review before finalizing.
</Workflow>

<Delegation Rules>
- Delegate when specialist value is clearly higher than overhead.
- Use multiple parallel workers only for independent tasks.
- Avoid repetitive behavioral reminders; use task-specific instructions only.
- Keep handoffs structured: objective, constraints, files, acceptance checks.
</Delegation Rules>

<Safety>
- Respect kill-switch and approval gates.
- For side-effect actions, require explicit evidence and rollback plan.
- Stop escalation loops after repeated failures and change strategy.
</Safety>

<Output>
- Be concise and action-oriented.
- Report changed files, validation results, and residual risk.
- \u4E2D\u6587\u56DE\u590D\u3002
</Output>`;
function createOrchestratorAgent(model, customPrompt, customAppendPrompt, useSlimPrompt) {
  return new BaseAgent({
    name: "1-task-manager",
    description: "AI coding orchestrator that delegates tasks to specialist agents for optimal quality, speed, and cost",
    defaultTemperature: 0.1,
    basePrompt: useSlimPrompt ? ORCHESTRATOR_PROMPT_SLIM : ORCHESTRATOR_PROMPT,
    personaStyle: "full"
  }).create(model, customPrompt, customAppendPrompt);
}

// src/agents/index.ts
function applyOverrides(agent, override) {
  if (override.model && override.model.trim().length > 0) {
    agent.config.model = override.model.trim();
  }
  if (override.temperature !== void 0)
    agent.config.temperature = override.temperature;
  if (override.variant && override.variant.trim().length > 0) {
    agent.config.variant = override.variant.trim();
  }
  if (override.providerID && override.providerID.trim().length > 0) {
    agent.config.providerID = override.providerID.trim();
  }
  if (override.options) {
    agent.config.options = override.options;
  }
  if (override.apiKey && override.apiKey.trim().length > 0) {
    agent.config.apiKey = override.apiKey.trim();
  }
  if (override.baseURL && override.baseURL.trim().length > 0) {
    agent.config.baseURL = override.baseURL.trim();
  }
}
function applyDefaultPermissions(agent, configuredSkills) {
  const existing = agent.config.permission ?? {};
  const skillPermissions = getSkillPermissionsForAgent(
    agent.name,
    configuredSkills
  );
  agent.config.permission = {
    ...existing,
    question: "allow",
    // Apply skill permissions as nested object under 'skill' key
    skill: {
      ...typeof existing.skill === "object" ? existing.skill : {},
      ...skillPermissions
    }
  };
}
function isSubagent(name) {
  return SUBAGENT_NAMES.includes(name);
}
var SUBAGENT_FACTORIES = {
  "2-code-search": createExplorerAgent,
  "3-docs-helper": createLibrarianAgent,
  "4-architecture-advisor": createOracleAgent,
  "5-code-fixer": createFixerAgent,
  "6-ui-designer": createDesignerAgent
};
function getFallbackChain(config3, agentName) {
  const chains = config3?.fallback?.chains;
  if (!chains) return [];
  const direct = chains[agentName];
  if (direct) return direct;
  const legacyName = Object.keys(AGENT_ALIASES).find(
    (key) => AGENT_ALIASES[key] === agentName
  );
  if (legacyName && chains[legacyName]) {
    return chains[legacyName] ?? [];
  }
  return [];
}
function shouldInjectSoulLayer(agentName, personaStyle) {
  if (personaStyle === "zero") return false;
  return agentName === "1-task-manager" || agentName === "6-ui-designer";
}
var ULTIMATE_FALLBACK_MODEL = "openrouter/z-ai/glm-5";
var CODE_SIMPLICITY_REVIEWER_NAME2 = "7-code-simplicity-reviewer";
var CODE_SIMPLICITY_REVIEWER_DEFAULT_MODEL = "openrouter/z-ai/glm-5";
function resolveAgentModel(config3, agentName, defaults) {
  const overrideModel = getAgentOverride(config3, agentName)?.model;
  const fallbackChain = getFallbackChain(config3, agentName);
  const candidates = [
    ...overrideModel ? [overrideModel] : [],
    ...fallbackChain,
    ...defaults,
    ULTIMATE_FALLBACK_MODEL
    // Always add ultimate fallback
  ];
  return pickBestAvailableModel(candidates) ?? ULTIMATE_FALLBACK_MODEL;
}
function createAgents(config3, projectDir) {
  const slimCompatEnabled = config3?.slimCompat?.enabled ?? true;
  const enableCodeSimplicityReviewer = slimCompatEnabled && (config3?.slimCompat?.enableCodeSimplicityReviewer ?? true);
  const useSlimOrchestratorPrompt = slimCompatEnabled && (config3?.slimCompat?.useSlimOrchestratorPrompt ?? false);
  const getModelForAgent = (name) => {
    if (name === "5-code-fixer") {
      return resolveAgentModel(config3, name, [
        DEFAULT_MODELS["5-code-fixer"],
        DEFAULT_MODELS["3-docs-helper"]
      ]);
    }
    return resolveAgentModel(config3, name, [DEFAULT_MODELS[name]]);
  };
  const protoSubAgents = Object.entries(SUBAGENT_FACTORIES).map(([name, factory]) => {
    const customPrompts = loadAgentPrompt(name);
    return factory(
      getModelForAgent(name),
      customPrompts.prompt,
      customPrompts.appendPrompt
    );
  });
  const allSubAgents = protoSubAgents.map((agent) => {
    const override = getAgentOverride(config3, agent.name);
    if (override) {
      applyOverrides(agent, override);
    }
    applyDefaultPermissions(agent, override?.skills);
    if (projectDir && shouldInjectSoulLayer(agent.name, agent.personaStyle)) {
      agent.config.prompt = `${soulPersonaLayer(projectDir)}

${String(agent.config.prompt ?? "")}`;
    }
    return agent;
  });
  if (enableCodeSimplicityReviewer) {
    const customPrompts = loadAgentPrompt(CODE_SIMPLICITY_REVIEWER_NAME2);
    const reviewer = createCodeSimplicityReviewerAgent(
      resolveAgentModel(config3, CODE_SIMPLICITY_REVIEWER_NAME2, [
        CODE_SIMPLICITY_REVIEWER_DEFAULT_MODEL,
        DEFAULT_MODELS["5-code-fixer"]
      ]),
      customPrompts.prompt,
      customPrompts.appendPrompt
    );
    const override = getAgentOverride(config3, CODE_SIMPLICITY_REVIEWER_NAME2);
    if (override) {
      applyOverrides(reviewer, override);
    }
    applyDefaultPermissions(reviewer, override?.skills);
    allSubAgents.push(reviewer);
  }
  const orchestratorModel = resolveAgentModel(config3, "1-task-manager", [
    DEFAULT_MODELS["1-task-manager"],
    DEFAULT_MODELS["4-architecture-advisor"],
    DEFAULT_MODELS["3-docs-helper"]
  ]);
  const orchestratorPrompts = loadAgentPrompt("1-task-manager");
  const orchestrator = createOrchestratorAgent(
    orchestratorModel,
    orchestratorPrompts.prompt,
    orchestratorPrompts.appendPrompt,
    useSlimOrchestratorPrompt
  );
  const oOverride = getAgentOverride(config3, "1-task-manager");
  applyDefaultPermissions(orchestrator, oOverride?.skills);
  if (oOverride) {
    applyOverrides(orchestrator, oOverride);
  }
  if (projectDir && shouldInjectSoulLayer(orchestrator.name, orchestrator.personaStyle)) {
    orchestrator.config.prompt = `${soulPersonaLayer(projectDir)}

${String(orchestrator.config.prompt ?? "")}`;
  }
  return [orchestrator, ...allSubAgents];
}
function getAgentConfigs(config3, projectDir) {
  const agents = createAgents(config3, projectDir);
  return Object.fromEntries(
    agents.map((a) => {
      const sdkConfig = {
        ...a.config,
        description: a.description,
        mcps: getAgentMcpList(a.name, config3)
      };
      if (isSubagent(a.name) || a.name === CODE_SIMPLICITY_REVIEWER_NAME2) {
        sdkConfig.mode = "primary";
      } else if (a.name === "1-task-manager") {
        sdkConfig.mode = "primary";
      }
      return [a.name, sdkConfig];
    })
  );
}

// src/automation/service.ts
import { spawn } from "node:child_process";
import * as path9 from "node:path";

// src/automation/store.ts
import * as fs7 from "node:fs";
import * as path8 from "node:path";

// src/model/paths.ts
import * as path7 from "node:path";
var MODEL_ROOT_ENV = "MIYA_MODEL_ROOT_DIR";
var MIYA_ROOT_SEGMENTS = [".opencode", "miya"];
var MIYA_MODEL_BRANCH = {
  vision: "shi jue",
  image: "tu pian",
  voiceprint: "shi bie",
  voice: "sheng yin"
};
var MIYA_MODEL_NAME = {
  fluxSchnell: "FLUX.1 schnell",
  fluxKlein: "FLUX.2 [klein] 4B\uFF08Apache-2.0\uFF09",
  eres2net: "eres2net",
  sovits: "GPT-SoVITS-v2pro-20250604"
};
function normalizeModelRoot(projectDir, root) {
  const trimmed = root.trim();
  if (!trimmed) return path7.join(getMiyaDataRootDir(projectDir), "model");
  if (path7.isAbsolute(trimmed)) return path7.normalize(trimmed);
  return path7.normalize(path7.join(projectDir, trimmed));
}
function getMiyaDataRootDir(projectDir) {
  return path7.join(projectDir, ...MIYA_ROOT_SEGMENTS);
}
function getMiyaAutomationDir(projectDir) {
  return path7.join(getMiyaDataRootDir(projectDir), "automation");
}
function getMiyaModelRootDir(projectDir) {
  const envRoot = process.env[MODEL_ROOT_ENV];
  if (typeof envRoot === "string" && envRoot.trim()) {
    return normalizeModelRoot(projectDir, envRoot);
  }
  return path7.join(getMiyaDataRootDir(projectDir), "model");
}
function getMiyaModelPath(projectDir, ...segments) {
  return path7.join(getMiyaModelRootDir(projectDir), ...segments);
}
function getMiyaVisionTempDir(projectDir, ...segments) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.vision, "lin shi", ...segments);
}
function getMiyaImageTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.image, "lin shi");
}
function getMiyaVoiceTempDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voice, "lin shi");
}
function getMiyaVoiceprintModelDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, MIYA_MODEL_NAME.eres2net);
}
function getMiyaVoiceprintSampleDir(projectDir) {
  return getMiyaModelPath(projectDir, MIYA_MODEL_BRANCH.voiceprint, "ben ren");
}

// src/automation/store.ts
var DEFAULT_STATE2 = {
  jobs: [],
  approvals: []
};
function ensureDir3(dirPath) {
  fs7.mkdirSync(dirPath, { recursive: true });
}
function nowIso() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function randomId(prefix) {
  const time5 = Date.now().toString(36);
  const rand = Math.random().toString(36).slice(2, 8);
  return `${prefix}_${time5}_${rand}`;
}
function getStatePath(projectDir) {
  return path8.join(getMiyaAutomationDir(projectDir), "state.json");
}
function getHistoryPath(projectDir) {
  return path8.join(getMiyaAutomationDir(projectDir), "history.jsonl");
}
function readAutomationState(projectDir) {
  const statePath = getStatePath(projectDir);
  if (!fs7.existsSync(statePath)) {
    return { ...DEFAULT_STATE2 };
  }
  try {
    const raw = fs7.readFileSync(statePath, "utf-8");
    const parsed = JSON.parse(raw);
    return {
      jobs: Array.isArray(parsed.jobs) ? parsed.jobs : [],
      approvals: Array.isArray(parsed.approvals) ? parsed.approvals : []
    };
  } catch {
    return { ...DEFAULT_STATE2 };
  }
}
function writeAutomationState(projectDir, state2) {
  const statePath = getStatePath(projectDir);
  ensureDir3(path8.dirname(statePath));
  fs7.writeFileSync(statePath, `${JSON.stringify(state2, null, 2)}
`, "utf-8");
}
function appendHistoryRecord(projectDir, record3) {
  const historyPath = getHistoryPath(projectDir);
  ensureDir3(path8.dirname(historyPath));
  fs7.appendFileSync(historyPath, `${JSON.stringify(record3)}
`, "utf-8");
}
function readHistoryRecords(projectDir, limit) {
  const historyPath = getHistoryPath(projectDir);
  if (!fs7.existsSync(historyPath)) {
    return [];
  }
  try {
    const lines = fs7.readFileSync(historyPath, "utf-8").split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
    const records = lines.map((line) => JSON.parse(line)).filter((record3) => record3 && typeof record3 === "object");
    return records.slice(Math.max(0, records.length - limit)).reverse();
  } catch {
    return [];
  }
}
function removeHistoryRecord(projectDir, runId) {
  const historyPath = getHistoryPath(projectDir);
  if (!fs7.existsSync(historyPath)) {
    return false;
  }
  const normalizedRunId = String(runId ?? "").trim();
  if (!normalizedRunId) {
    return false;
  }
  try {
    const lines = fs7.readFileSync(historyPath, "utf-8").split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
    const records = lines.map((line) => JSON.parse(line)).filter((record3) => record3 && typeof record3 === "object");
    const filtered = records.filter((record3) => record3.id !== normalizedRunId);
    if (filtered.length === records.length) {
      return false;
    }
    const output = filtered.length > 0 ? `${filtered.map((record3) => JSON.stringify(record3)).join("\n")}
` : "";
    fs7.writeFileSync(historyPath, output, "utf-8");
    return true;
  } catch {
    return false;
  }
}
function createJobId() {
  return randomId("job");
}
function createApprovalId() {
  return randomId("approval");
}
function createHistoryId() {
  return randomId("run");
}
function touchJob(job) {
  return {
    ...job,
    updatedAt: nowIso()
  };
}
function createApproval(job, reason) {
  return {
    id: createApprovalId(),
    jobId: job.id,
    reason,
    requestedAt: nowIso(),
    status: "pending"
  };
}

// src/automation/service.ts
var SCHEDULER_INTERVAL_MS = 3e4;
var DEFAULT_COMMAND_TIMEOUT_MS = 20 * 60 * 1e3;
var MIN_COMMAND_TIMEOUT_MS = 1e3;
var MAX_COMMAND_TIMEOUT_MS = 6 * 60 * 60 * 1e3;
function nowIso2() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function parseDailyTime(time5) {
  const match = /^([01]?\d|2[0-3]):([0-5]\d)$/.exec(time5.trim());
  if (!match) return null;
  return {
    hour: Number(match[1]),
    minute: Number(match[2])
  };
}
function computeNextDailyRun(time5, from = /* @__PURE__ */ new Date()) {
  const parsed = parseDailyTime(time5);
  if (!parsed) {
    throw new Error(`Invalid daily time format: ${time5}. Expected HH:mm`);
  }
  const next = new Date(from);
  next.setHours(parsed.hour, parsed.minute, 0, 0);
  if (next.getTime() <= from.getTime()) {
    next.setDate(next.getDate() + 1);
  }
  return next.toISOString();
}
function truncateOutput(text, maxLength = 2e4) {
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength)}
...[truncated]`;
}
function normalizeCommandText(command) {
  return String(command ?? "").trim();
}
function normalizeTimeoutMs(timeoutMs) {
  const raw = typeof timeoutMs === "number" ? timeoutMs : DEFAULT_COMMAND_TIMEOUT_MS;
  if (!Number.isFinite(raw)) return DEFAULT_COMMAND_TIMEOUT_MS;
  return Math.max(
    MIN_COMMAND_TIMEOUT_MS,
    Math.min(MAX_COMMAND_TIMEOUT_MS, Math.floor(raw))
  );
}
function isSubPath(parentDir, targetDir) {
  const rel = path9.relative(parentDir, targetDir);
  if (!rel) return true;
  if (rel.startsWith("..")) return false;
  return !path9.isAbsolute(rel);
}
function resolveAndValidateCwd(projectDir, cwd) {
  if (!cwd || cwd.trim().length === 0) {
    return { cwd: projectDir, wasSanitized: false };
  }
  const resolved = path9.resolve(projectDir, cwd);
  if (!isSubPath(projectDir, resolved)) {
    return { cwd: projectDir, wasSanitized: true };
  }
  return { cwd: resolved, wasSanitized: false };
}
function formatActionableAutomationError(code, details) {
  return `${code}:${details}`;
}
async function runCommand(command, cwd, timeoutMs) {
  const startedAt = nowIso2();
  const result = await new Promise((resolve7) => {
    const child = spawn(command, {
      cwd,
      shell: true,
      env: process.env
    });
    let stdout = "";
    let stderr = "";
    let timedOut = false;
    child.stdout?.on("data", (chunk) => {
      stdout += chunk.toString();
    });
    child.stderr?.on("data", (chunk) => {
      stderr += chunk.toString();
    });
    const timeout = setTimeout(() => {
      timedOut = true;
      child.kill();
    }, timeoutMs);
    child.on("close", (code) => {
      clearTimeout(timeout);
      resolve7({ exitCode: code, timedOut, stdout, stderr });
    });
    child.on("error", (error92) => {
      clearTimeout(timeout);
      resolve7({
        exitCode: null,
        timedOut,
        stdout,
        stderr: `${stderr}
${error92.message}`
      });
    });
  });
  const endedAt = nowIso2();
  const status = result.exitCode === 0 && !result.timedOut ? "success" : "failed";
  return {
    status,
    exitCode: result.exitCode,
    timedOut: result.timedOut,
    stdout: truncateOutput(result.stdout),
    stderr: truncateOutput(
      result.timedOut ? result.stderr ? `${result.stderr}
${formatActionableAutomationError(
        "command_timeout",
        `Command exceeded timeoutMs=${timeoutMs}. Increase timeoutMs up to ${MAX_COMMAND_TIMEOUT_MS} when appropriate.`
      )}` : formatActionableAutomationError(
        "command_timeout",
        `Command exceeded timeoutMs=${timeoutMs}. Increase timeoutMs up to ${MAX_COMMAND_TIMEOUT_MS} when appropriate.`
      ) : result.stderr
    ),
    startedAt,
    endedAt
  };
}
var MiyaAutomationService = class {
  projectDir;
  timer = null;
  running = false;
  activeJobIDs = /* @__PURE__ */ new Set();
  constructor(projectDir) {
    this.projectDir = projectDir;
  }
  getProjectDir() {
    return this.projectDir;
  }
  start() {
    if (this.timer) return;
    this.timer = setInterval(() => {
      void this.tick();
    }, SCHEDULER_INTERVAL_MS);
    this.timer.unref?.();
    void this.tick();
  }
  stop() {
    if (!this.timer) return;
    clearInterval(this.timer);
    this.timer = null;
  }
  async tick() {
    if (this.running) return;
    this.running = true;
    try {
      const state2 = readAutomationState(this.projectDir);
      const now = /* @__PURE__ */ new Date();
      for (const job of state2.jobs) {
        try {
          if (!job.enabled) continue;
          const due = new Date(job.nextRunAt).getTime() <= now.getTime();
          if (!due) continue;
          if (job.requireApproval) {
            const parsedTime = parseDailyTime(job.schedule.time);
            if (!parsedTime) {
              this.recordExecutionFailure(
                job,
                "scheduler",
                formatActionableAutomationError(
                  "invalid_schedule_time",
                  `Job "${job.id}" uses invalid HH:mm time "${job.schedule.time}". Update schedule.time and retry.`
                )
              );
              continue;
            }
            const hasPendingApproval = state2.approvals.some(
              (approval) => approval.jobId === job.id && approval.status === "pending"
            );
            if (!hasPendingApproval) {
              const approval = createApproval(job, "Scheduled run is due");
              state2.approvals.push(approval);
              job.lastApprovalId = approval.id;
              job.lastStatus = "skipped";
            }
            job.nextRunAt = computeNextDailyRun(job.schedule.time, now);
            job.updatedAt = nowIso2();
            continue;
          }
          await this.executeJobInState(state2, job.id, "scheduler");
        } catch (error92) {
          const message = error92 instanceof Error ? error92.message : String(error92);
          this.recordExecutionFailure(
            job,
            "scheduler",
            formatActionableAutomationError(
              "scheduler_job_failed",
              `Job "${job.id}" failed in tick; fix command/schedule and rerun. ${message}`
            )
          );
        }
      }
      writeAutomationState(this.projectDir, state2);
    } finally {
      this.running = false;
    }
  }
  listJobs() {
    return readAutomationState(this.projectDir).jobs;
  }
  listApprovals() {
    return readAutomationState(this.projectDir).approvals;
  }
  listHistory(limit = 20) {
    return readHistoryRecords(this.projectDir, limit);
  }
  deleteHistoryRecord(runId) {
    return removeHistoryRecord(this.projectDir, runId);
  }
  scheduleDailyCommand(input) {
    const name = String(input.name ?? "").trim();
    if (!name) throw new Error("Job name cannot be empty.");
    const command = normalizeCommandText(input.command);
    if (!command) throw new Error("Command cannot be empty.");
    const cwdResolved = resolveAndValidateCwd(this.projectDir, input.cwd);
    if (input.cwd && cwdResolved.wasSanitized) {
      throw new Error("Invalid cwd: must stay within project directory.");
    }
    const now = /* @__PURE__ */ new Date();
    const job = {
      id: createJobId(),
      name,
      enabled: true,
      requireApproval: input.requireApproval ?? false,
      schedule: {
        type: "daily",
        time: String(input.time ?? "").trim()
      },
      action: {
        type: "command",
        command,
        cwd: cwdResolved.cwd,
        timeoutMs: normalizeTimeoutMs(input.timeoutMs)
      },
      nextRunAt: computeNextDailyRun(input.time, now),
      createdAt: nowIso2(),
      updatedAt: nowIso2()
    };
    const state2 = readAutomationState(this.projectDir);
    state2.jobs.push(job);
    writeAutomationState(this.projectDir, state2);
    return job;
  }
  deleteJob(jobId) {
    const state2 = readAutomationState(this.projectDir);
    const before = state2.jobs.length;
    state2.jobs = state2.jobs.filter((job) => job.id !== jobId);
    state2.approvals = state2.approvals.filter(
      (approval) => approval.jobId !== jobId
    );
    const changed = state2.jobs.length !== before;
    if (changed) writeAutomationState(this.projectDir, state2);
    return changed;
  }
  setJobEnabled(jobId, enabled) {
    const state2 = readAutomationState(this.projectDir);
    const job = state2.jobs.find((item) => item.id === jobId);
    if (!job) return null;
    job.enabled = enabled;
    if (enabled) {
      job.nextRunAt = computeNextDailyRun(job.schedule.time, /* @__PURE__ */ new Date());
    }
    job.updatedAt = nowIso2();
    writeAutomationState(this.projectDir, state2);
    return job;
  }
  async runJobNow(jobId) {
    const state2 = readAutomationState(this.projectDir);
    const result = await this.executeJobInState(state2, jobId, "manual");
    writeAutomationState(this.projectDir, state2);
    return result;
  }
  async approveAndRun(approvalId) {
    const state2 = readAutomationState(this.projectDir);
    const approval = state2.approvals.find((item) => item.id === approvalId);
    if (!approval || approval.status !== "pending") return null;
    approval.status = "approved";
    approval.resolvedAt = nowIso2();
    const result = await this.executeJobInState(
      state2,
      approval.jobId,
      "approval"
    );
    writeAutomationState(this.projectDir, state2);
    return { approval, result };
  }
  rejectApproval(approvalId) {
    const state2 = readAutomationState(this.projectDir);
    const approval = state2.approvals.find((item) => item.id === approvalId);
    if (!approval || approval.status !== "pending") return null;
    approval.status = "rejected";
    approval.resolvedAt = nowIso2();
    writeAutomationState(this.projectDir, state2);
    return approval;
  }
  async executeJobInState(state2, jobId, trigger) {
    const job = state2.jobs.find((item) => item.id === jobId);
    if (!job) return null;
    if (!job.enabled && trigger !== "manual") return null;
    if (this.activeJobIDs.has(job.id)) {
      if (trigger === "scheduler") return null;
      const blockedAt = nowIso2();
      const blockedResult = {
        status: "skipped",
        exitCode: null,
        timedOut: false,
        stdout: "",
        stderr: formatActionableAutomationError(
          "job_execution_in_progress",
          `Job "${job.id}" is running. Wait for completion before manual/approval retry.`
        ),
        startedAt: blockedAt,
        endedAt: blockedAt
      };
      appendHistoryRecord(this.projectDir, {
        id: createHistoryId(),
        jobId: job.id,
        jobName: job.name,
        trigger,
        startedAt: blockedResult.startedAt,
        endedAt: blockedResult.endedAt,
        status: blockedResult.status,
        exitCode: blockedResult.exitCode,
        timedOut: blockedResult.timedOut,
        stdout: blockedResult.stdout,
        stderr: blockedResult.stderr
      });
      return blockedResult;
    }
    this.activeJobIDs.add(job.id);
    try {
      const command = normalizeCommandText(job.action.command);
      const timeoutMs = normalizeTimeoutMs(job.action.timeoutMs);
      const cwdResolved = resolveAndValidateCwd(this.projectDir, job.action.cwd);
      const warning = cwdResolved.wasSanitized ? "Unsafe cwd detected; fell back to project directory." : "";
      const parsedTime = parseDailyTime(job.schedule.time);
      if (!parsedTime) {
        const failedAt = nowIso2();
        const result2 = {
          status: "failed",
          exitCode: null,
          timedOut: false,
          stdout: "",
          stderr: formatActionableAutomationError(
            "invalid_schedule_time",
            `Job "${job.id}" uses invalid HH:mm time "${job.schedule.time}". Update schedule.time and retry.`
          ),
          startedAt: failedAt,
          endedAt: failedAt
        };
        this.applyResultToJob(job, result2);
        appendHistoryRecord(this.projectDir, {
          id: createHistoryId(),
          jobId: job.id,
          jobName: job.name,
          trigger,
          startedAt: result2.startedAt,
          endedAt: result2.endedAt,
          status: result2.status,
          exitCode: result2.exitCode,
          timedOut: result2.timedOut,
          stdout: result2.stdout,
          stderr: result2.stderr
        });
        return result2;
      }
      if (!command) {
        const failedAt = nowIso2();
        const result2 = {
          status: "failed",
          exitCode: null,
          timedOut: false,
          stdout: "",
          stderr: "Empty command is not executable.",
          startedAt: failedAt,
          endedAt: failedAt
        };
        this.applyResultToJob(job, result2);
        appendHistoryRecord(this.projectDir, {
          id: createHistoryId(),
          jobId: job.id,
          jobName: job.name,
          trigger,
          startedAt: result2.startedAt,
          endedAt: result2.endedAt,
          status: result2.status,
          exitCode: result2.exitCode,
          timedOut: result2.timedOut,
          stdout: result2.stdout,
          stderr: result2.stderr
        });
        return result2;
      }
      const result = await runCommand(command, cwdResolved.cwd, timeoutMs);
      if (warning) {
        result.stderr = truncateOutput(
          result.stderr ? `${warning}
${result.stderr}` : warning
        );
      }
      job.action.command = command;
      job.action.cwd = cwdResolved.cwd;
      job.action.timeoutMs = timeoutMs;
      this.applyResultToJob(job, result);
      const history = {
        id: createHistoryId(),
        jobId: job.id,
        jobName: job.name,
        trigger,
        startedAt: result.startedAt,
        endedAt: result.endedAt,
        status: result.status,
        exitCode: result.exitCode,
        timedOut: result.timedOut,
        stdout: result.stdout,
        stderr: result.stderr
      };
      appendHistoryRecord(this.projectDir, history);
      return result;
    } finally {
      this.activeJobIDs.delete(job.id);
    }
  }
  applyResultToJob(job, result) {
    job.lastRunAt = result.endedAt;
    job.lastStatus = result.status;
    job.lastExitCode = result.exitCode;
    const parsedTime = parseDailyTime(job.schedule.time);
    job.nextRunAt = parsedTime ? computeNextDailyRun(job.schedule.time, /* @__PURE__ */ new Date()) : new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString();
    Object.assign(job, touchJob(job));
  }
  recordExecutionFailure(job, trigger, stderr) {
    const failedAt = nowIso2();
    const result = {
      status: "failed",
      exitCode: null,
      timedOut: false,
      stdout: "",
      stderr: truncateOutput(stderr),
      startedAt: failedAt,
      endedAt: failedAt
    };
    this.applyResultToJob(job, result);
    appendHistoryRecord(this.projectDir, {
      id: createHistoryId(),
      jobId: job.id,
      jobName: job.name,
      trigger,
      startedAt: result.startedAt,
      endedAt: result.endedAt,
      status: result.status,
      exitCode: result.exitCode,
      timedOut: result.timedOut,
      stdout: result.stdout,
      stderr: result.stderr
    });
  }
};

// src/utils/logger.ts
import * as fs8 from "node:fs";
import * as os3 from "node:os";
import * as path10 from "node:path";
var logFile = path10.join(os3.tmpdir(), "miya.log");
function sanitizeLogValue(value) {
  if (value instanceof Error) {
    return {
      name: value.name,
      message: value.message,
      stack: value.stack
    };
  }
  if (typeof value === "bigint") return value.toString();
  if (typeof value === "symbol") return String(value);
  return value;
}
function stringifyLogData(data) {
  if (typeof data === "undefined") return "";
  const seen = /* @__PURE__ */ new WeakSet();
  try {
    return JSON.stringify(data, (_key, value) => {
      const sanitized = sanitizeLogValue(value);
      if (sanitized && typeof sanitized === "object") {
        if (seen.has(sanitized)) return "[circular]";
        seen.add(sanitized);
      }
      return sanitized;
    });
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    return JSON.stringify({
      logger_error: "log_serialize_failed",
      message
    });
  }
}
function log(message, data) {
  try {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const payload = stringifyLogData(data);
    const logEntry = `[${timestamp}] ${message}${payload ? ` ${payload}` : ""}
`;
    fs8.appendFileSync(logFile, logEntry);
  } catch {
  }
}

// src/utils/agent-variant.ts
function normalizeAgentName2(agentName) {
  const trimmed = agentName.trim();
  return trimmed.startsWith("@") ? trimmed.slice(1) : trimmed;
}
function resolveAgentVariant(config3, agentName) {
  const normalized = normalizeAgentName2(agentName);
  const rawVariant = config3?.agents?.[normalized]?.variant;
  if (typeof rawVariant !== "string") {
    return void 0;
  }
  const trimmed = rawVariant.trim();
  if (trimmed.length === 0) {
    return void 0;
  }
  log(`[variant] resolved variant="${trimmed}" for agent "${normalized}"`);
  return trimmed;
}
function applyAgentVariant(variant, body) {
  if (!variant) {
    return body;
  }
  if (body.variant) {
    return body;
  }
  return { ...body, variant };
}

// src/utils/process.ts
import {
  spawn as spawn2,
  spawnSync as spawnSync2
} from "node:child_process";
async function runProcess(command, args, options = {}) {
  return new Promise((resolve7, reject) => {
    const child = spawn2(command, args, {
      ...options,
      stdio: ["ignore", "pipe", "pipe"]
    });
    let stdout = "";
    let stderr = "";
    let settled = false;
    let timedOut = false;
    const timeoutMs = typeof options.timeoutMs === "number" && Number.isFinite(options.timeoutMs) ? Math.max(1, Math.floor(options.timeoutMs)) : void 0;
    const timer = timeoutMs !== void 0 ? setTimeout(() => {
      timedOut = true;
      try {
        child.kill("SIGTERM");
      } catch {
      }
    }, timeoutMs) : void 0;
    child.stdout?.setEncoding("utf8");
    child.stderr?.setEncoding("utf8");
    child.stdout?.on("data", (chunk) => {
      stdout += chunk;
    });
    child.stderr?.on("data", (chunk) => {
      stderr += chunk;
    });
    child.on("error", (error92) => {
      if (settled) return;
      settled = true;
      if (timer) clearTimeout(timer);
      reject(error92);
    });
    child.on("close", (code) => {
      if (settled) return;
      settled = true;
      if (timer) clearTimeout(timer);
      resolve7({
        exitCode: code ?? -1,
        stdout,
        stderr,
        timedOut
      });
    });
  });
}
function runProcessSync(command, args, options = {}) {
  const result = spawnSync2(command, args, {
    ...options,
    encoding: "utf8",
    stdio: ["ignore", "pipe", "pipe"]
  });
  return {
    exitCode: result.status ?? -1,
    stdout: result.stdout ?? "",
    stderr: result.stderr ?? "",
    timedOut: Boolean(result.error?.name === "ETIMEDOUT")
  };
}

// src/utils/tmux.ts
var tmuxPath = null;
var tmuxChecked = false;
var storedConfig = null;
var serverAvailable = null;
var serverCheckUrl = null;
async function isServerRunning(serverUrl) {
  if (serverCheckUrl === serverUrl && serverAvailable === true) {
    return true;
  }
  const healthUrl = new URL("/health", serverUrl).toString();
  const timeoutMs = 3e3;
  const maxAttempts = 2;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    let response = null;
    try {
      response = await fetch(healthUrl, { signal: controller.signal }).catch(
        () => null
      );
    } finally {
      clearTimeout(timeout);
    }
    const available = response?.ok ?? false;
    if (available) {
      serverCheckUrl = serverUrl;
      serverAvailable = true;
      log("[tmux] isServerRunning: checked", { serverUrl, available, attempt });
      return true;
    }
    if (attempt < maxAttempts) {
      await new Promise((r) => setTimeout(r, 250));
    }
  }
  log("[tmux] isServerRunning: checked", { serverUrl, available: false });
  return false;
}
async function findTmuxPath() {
  const isWindows = process.platform === "win32";
  const cmd = isWindows ? "where" : "which";
  try {
    const lookup = await runProcess(cmd, ["tmux"]);
    const exitCode = lookup.exitCode;
    if (exitCode !== 0) {
      log("[tmux] findTmuxPath: 'which tmux' failed", { exitCode });
      return null;
    }
    const stdout = lookup.stdout;
    const path52 = stdout.trim().split("\n")[0];
    if (!path52) {
      log("[tmux] findTmuxPath: no path in output");
      return null;
    }
    const verify = await runProcess(path52, ["-V"]);
    const verifyExit = verify.exitCode;
    if (verifyExit !== 0) {
      log("[tmux] findTmuxPath: tmux -V failed", { path: path52, verifyExit });
      return null;
    }
    log("[tmux] findTmuxPath: found tmux", { path: path52 });
    return path52;
  } catch (err) {
    log("[tmux] findTmuxPath: exception", { error: String(err) });
    return null;
  }
}
async function getTmuxPath() {
  if (tmuxChecked) {
    return tmuxPath;
  }
  tmuxPath = await findTmuxPath();
  tmuxChecked = true;
  log("[tmux] getTmuxPath: initialized", { tmuxPath });
  return tmuxPath;
}
function isInsideTmux() {
  return !!process.env.TMUX;
}
async function applyLayout(tmux, layout, mainPaneSize) {
  try {
    await runProcess(tmux, ["select-layout", layout]);
    if (layout === "main-horizontal" || layout === "main-vertical") {
      const sizeOption = layout === "main-horizontal" ? "main-pane-height" : "main-pane-width";
      await runProcess(tmux, [
        "set-window-option",
        sizeOption,
        `${mainPaneSize}%`
      ]);
      await runProcess(tmux, ["select-layout", layout]);
    }
    log("[tmux] applyLayout: applied", { layout, mainPaneSize });
  } catch (err) {
    log("[tmux] applyLayout: exception", { error: String(err) });
  }
}
async function spawnTmuxPane(sessionId, description, config3, serverUrl) {
  log("[tmux] spawnTmuxPane called", {
    sessionId,
    description,
    config: config3,
    serverUrl
  });
  if (!config3.enabled) {
    log("[tmux] spawnTmuxPane: config.enabled is false, skipping");
    return { success: false };
  }
  if (!isInsideTmux()) {
    log("[tmux] spawnTmuxPane: not inside tmux, skipping");
    return { success: false };
  }
  const serverRunning = await isServerRunning(serverUrl);
  if (!serverRunning) {
    const defaultPort = process.env.OPENCODE_PORT ?? "4096";
    log("[tmux] spawnTmuxPane: OpenCode server not running, skipping", {
      serverUrl,
      hint: `Start opencode with --port ${defaultPort}`
    });
    return { success: false };
  }
  const tmux = await getTmuxPath();
  if (!tmux) {
    log("[tmux] spawnTmuxPane: tmux binary not found, skipping");
    return { success: false };
  }
  storedConfig = config3;
  try {
    const opencodeCmd = `opencode attach ${serverUrl} --session ${sessionId}`;
    const args = [
      "split-window",
      "-h",
      "-d",
      // Don't switch focus to new pane
      "-P",
      // Print pane info
      "-F",
      "#{pane_id}",
      // Format: just the pane ID
      opencodeCmd
    ];
    log("[tmux] spawnTmuxPane: executing", { tmux, args, opencodeCmd });
    const result = await runProcess(tmux, args);
    const exitCode = result.exitCode;
    const stdout = result.stdout;
    const stderr = result.stderr;
    const paneId = stdout.trim();
    log("[tmux] spawnTmuxPane: split result", {
      exitCode,
      paneId,
      stderr: stderr.trim()
    });
    if (exitCode === 0 && paneId) {
      await runProcess(tmux, [
        "select-pane",
        "-t",
        paneId,
        "-T",
        description.slice(0, 30)
      ]);
      const layout = config3.layout ?? "main-vertical";
      const mainPaneSize = config3.main_pane_size ?? 60;
      await applyLayout(tmux, layout, mainPaneSize);
      log("[tmux] spawnTmuxPane: SUCCESS, pane created and layout applied", {
        paneId,
        layout
      });
      return { success: true, paneId };
    }
    return { success: false };
  } catch (err) {
    log("[tmux] spawnTmuxPane: exception", { error: String(err) });
    return { success: false };
  }
}
async function closeTmuxPane(paneId) {
  log("[tmux] closeTmuxPane called", { paneId });
  if (!paneId) {
    log("[tmux] closeTmuxPane: no paneId provided");
    return false;
  }
  const tmux = await getTmuxPath();
  if (!tmux) {
    log("[tmux] closeTmuxPane: tmux binary not found");
    return false;
  }
  try {
    const result = await runProcess(tmux, ["kill-pane", "-t", paneId]);
    const exitCode = result.exitCode;
    const stderr = result.stderr;
    log("[tmux] closeTmuxPane: result", { exitCode, stderr: stderr.trim() });
    if (exitCode === 0) {
      log("[tmux] closeTmuxPane: SUCCESS, pane closed", { paneId });
      if (storedConfig) {
        const layout = storedConfig.layout ?? "main-vertical";
        const mainPaneSize = storedConfig.main_pane_size ?? 60;
        await applyLayout(tmux, layout, mainPaneSize);
        log("[tmux] closeTmuxPane: layout reapplied", { layout });
      }
      return true;
    }
    log("[tmux] closeTmuxPane: failed (pane may already be closed)", {
      paneId
    });
    return false;
  } catch (err) {
    log("[tmux] closeTmuxPane: exception", { error: String(err) });
    return false;
  }
}
function startTmuxCheck() {
  if (!tmuxChecked) {
    getTmuxPath().catch(() => {
    });
  }
}

// src/utils/zip-extractor.ts
import { release } from "node:os";
var WINDOWS_BUILD_WITH_TAR = 17134;
function getWindowsBuildNumber() {
  if (process.platform !== "win32") return null;
  const parts = release().split(".");
  if (parts.length >= 3) {
    const build = parseInt(parts[2], 10);
    if (!Number.isNaN(build)) return build;
  }
  return null;
}
function isPwshAvailable() {
  if (process.platform !== "win32") return false;
  const result = runProcessSync("where", ["pwsh"]);
  return result.exitCode === 0;
}
function escapePowerShellPath(path52) {
  return path52.replace(/'/g, "''");
}
function getWindowsZipExtractor() {
  const buildNumber = getWindowsBuildNumber();
  if (buildNumber !== null && buildNumber >= WINDOWS_BUILD_WITH_TAR) {
    return "tar";
  }
  if (isPwshAvailable()) {
    return "pwsh";
  }
  return "powershell";
}
async function extractZip(archivePath, destDir) {
  let result;
  if (process.platform === "win32") {
    const extractor = getWindowsZipExtractor();
    switch (extractor) {
      case "tar":
        result = await runProcess("tar", ["-xf", archivePath, "-C", destDir]);
        break;
      case "pwsh":
        result = await runProcess("pwsh", [
          "-Command",
          `Expand-Archive -Path '${escapePowerShellPath(archivePath)}' -DestinationPath '${escapePowerShellPath(destDir)}' -Force`
        ]);
        break;
      default:
        result = await runProcess("powershell", [
          "-Command",
          `Expand-Archive -Path '${escapePowerShellPath(archivePath)}' -DestinationPath '${escapePowerShellPath(destDir)}' -Force`
        ]);
        break;
    }
  } else {
    result = await runProcess("unzip", ["-o", archivePath, "-d", destDir]);
  }
  if (result.exitCode !== 0) {
    throw new Error(
      `zip extraction failed (exit ${result.exitCode}): ${result.stderr}`
    );
  }
}

// src/background/background-manager.ts
function parseModelReference(model) {
  const slashIndex = model.indexOf("/");
  if (slashIndex <= 0 || slashIndex >= model.length - 1) {
    return null;
  }
  return {
    providerID: model.slice(0, slashIndex),
    modelID: model.slice(slashIndex + 1)
  };
}
function generateTaskId() {
  return `bg_${Math.random().toString(36).substring(2, 10)}`;
}
var BackgroundTaskManager = class {
  tasks = /* @__PURE__ */ new Map();
  tasksBySessionId = /* @__PURE__ */ new Map();
  // Track which agent type owns each session for delegation permission checks
  agentBySessionId = /* @__PURE__ */ new Map();
  client;
  directory;
  tmuxEnabled;
  config;
  backgroundConfig;
  // Start queue
  startQueue = [];
  activeStarts = 0;
  maxConcurrentStarts;
  // Completion waiting
  completionResolvers = /* @__PURE__ */ new Map();
  constructor(ctx, tmuxConfig, config3) {
    this.client = ctx.client;
    this.directory = ctx.directory;
    this.tmuxEnabled = tmuxConfig?.enabled ?? false;
    this.config = config3;
    this.backgroundConfig = config3?.background ?? {
      maxConcurrentStarts: 10
    };
    this.maxConcurrentStarts = this.backgroundConfig.maxConcurrentStarts;
  }
  /**
   * Look up the delegation rules for an agent type.
   * Unknown agent types default to explorer-only access, making it easy
   * to add new background agent types without updating SUBAGENT_DELEGATION_RULES.
   */
  getSubagentRules(agentName) {
    const normalizedAgentName = AGENT_ALIASES[agentName] ?? agentName;
    return SUBAGENT_DELEGATION_RULES[normalizedAgentName] ?? ["2-code-search"];
  }
  /**
   * Check if a parent session is allowed to delegate to a specific agent type.
   * @param parentSessionId - The session ID of the parent
   * @param requestedAgent - The agent type being requested
   * @returns true if allowed, false if not
   */
  isAgentAllowed(parentSessionId, requestedAgent) {
    const parentAgentName = this.agentBySessionId.get(parentSessionId) ?? "1-task-manager";
    const allowedSubagents = this.getSubagentRules(parentAgentName);
    if (allowedSubagents.length === 0) return false;
    return allowedSubagents.includes(requestedAgent);
  }
  /**
   * Get the list of allowed subagents for a parent session.
   * @param parentSessionId - The session ID of the parent
   * @returns Array of allowed agent names, empty if none
   */
  getAllowedSubagents(parentSessionId) {
    const parentAgentName = this.agentBySessionId.get(parentSessionId) ?? "1-task-manager";
    return this.getSubagentRules(parentAgentName);
  }
  /**
   * Launch a new background task (fire-and-forget).
   *
   * Phase A (sync): Creates task record and returns immediately.
   * Phase B (async): Session creation and prompt sending happen in background.
   *
   * @param opts - Task configuration options
   * @returns The created background task with pending status
   */
  launch(opts) {
    const task = {
      id: generateTaskId(),
      sessionId: void 0,
      description: opts.description,
      agent: opts.agent,
      status: "pending",
      startedAt: /* @__PURE__ */ new Date(),
      config: {
        maxConcurrentStarts: this.maxConcurrentStarts
      },
      parentSessionId: opts.parentSessionId,
      prompt: opts.prompt
    };
    this.tasks.set(task.id, task);
    this.enqueueStart(task);
    log(`[background-manager] task launched: ${task.id}`, {
      agent: opts.agent,
      description: opts.description
    });
    return task;
  }
  /**
   * Enqueue task for background start.
   */
  enqueueStart(task) {
    this.startQueue.push(task);
    this.processQueue();
  }
  /**
   * Process start queue with concurrency limit.
   */
  processQueue() {
    while (this.activeStarts < this.maxConcurrentStarts && this.startQueue.length > 0) {
      const task = this.startQueue.shift();
      if (!task) break;
      this.startTask(task);
    }
  }
  resolveFallbackChain(agentName) {
    const fallback = this.config?.fallback;
    const chains = fallback?.chains;
    const legacyName = Object.keys(AGENT_ALIASES).find(
      (key) => AGENT_ALIASES[key] === agentName
    );
    const configuredChain = chains?.[agentName] ?? (legacyName ? chains?.[legacyName] : []) ?? [];
    const primary = this.config?.agents?.[agentName]?.model ?? (legacyName ? this.config?.agents?.[legacyName]?.model : void 0);
    const chain = [];
    const seen = /* @__PURE__ */ new Set();
    for (const model of [primary, ...configuredChain]) {
      if (!model || seen.has(model)) continue;
      seen.add(model);
      chain.push(model);
    }
    return chain;
  }
  async promptWithTimeout(args, timeoutMs) {
    await Promise.race([
      this.client.session.prompt(args),
      new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error(`Prompt timed out after ${timeoutMs}ms`));
        }, timeoutMs);
      })
    ]);
  }
  /**
   * Calculate tool permissions for a spawned agent based on its own delegation rules.
   * Agents that cannot delegate (leaf nodes) get delegation tools disabled entirely,
   * preventing models from even seeing tools they can never use.
   *
   * @param agentName - The agent type being spawned
   * @returns Tool permissions object with background_task and task enabled/disabled
   */
  calculateToolPermissions(agentName) {
    const allowedSubagents = this.getSubagentRules(agentName);
    if (allowedSubagents.length === 0) {
      return { background_task: false, task: false };
    }
    return { background_task: true, task: true };
  }
  /**
   * Start a task in the background (Phase B).
   */
  async startTask(task) {
    task.status = "starting";
    this.activeStarts++;
    if (task.status === "cancelled") {
      this.completeTask(task, "cancelled", "Task cancelled before start");
      return;
    }
    try {
      const session = await this.client.session.create({
        body: {
          parentID: task.parentSessionId,
          title: `Background: ${task.description}`
        },
        query: { directory: this.directory }
      });
      if (!session.data?.id) {
        throw new Error("Failed to create background session");
      }
      task.sessionId = session.data.id;
      this.tasksBySessionId.set(session.data.id, task.id);
      this.agentBySessionId.set(session.data.id, task.agent);
      task.status = "running";
      if (this.tmuxEnabled) {
        await new Promise((r) => setTimeout(r, 500));
      }
      const toolPermissions = this.calculateToolPermissions(task.agent);
      const promptQuery = { directory: this.directory };
      const resolvedVariant = resolveAgentVariant(this.config, task.agent);
      const basePromptBody = applyAgentVariant(resolvedVariant, {
        agent: task.agent,
        tools: toolPermissions,
        parts: [{ type: "text", text: task.prompt }]
      });
      const timeoutMs = this.config?.fallback?.timeoutMs ?? FALLBACK_FAILOVER_TIMEOUT_MS;
      const fallbackEnabled = this.config?.fallback?.enabled ?? true;
      const chain = fallbackEnabled ? this.resolveFallbackChain(task.agent) : [];
      const attemptModels = chain.length > 0 ? chain : [void 0];
      const errors = [];
      let succeeded = false;
      for (const model of attemptModels) {
        try {
          const body = {
            ...basePromptBody,
            model: void 0
          };
          if (model) {
            const ref = parseModelReference(model);
            if (!ref) {
              throw new Error(`Invalid fallback model format: ${model}`);
            }
            body.model = ref;
          }
          await this.promptWithTimeout(
            {
              path: { id: session.data.id },
              body,
              query: promptQuery
            },
            timeoutMs
          );
          succeeded = true;
          break;
        } catch (error92) {
          const msg = error92 instanceof Error ? error92.message : String(error92);
          if (model) {
            errors.push(`${model}: ${msg}`);
          } else {
            errors.push(`default-model: ${msg}`);
          }
        }
      }
      if (!succeeded) {
        throw new Error(`All fallback models failed. ${errors.join(" | ")}`);
      }
      log(`[background-manager] task started: ${task.id}`, {
        sessionId: session.data.id
      });
    } catch (error92) {
      const errorMessage = error92 instanceof Error ? error92.message : String(error92);
      this.completeTask(task, "failed", errorMessage);
    } finally {
      this.activeStarts--;
      this.processQueue();
    }
  }
  /**
   * Handle session.status events for completion detection.
   * Uses session.status instead of deprecated session.idle.
   */
  async handleSessionStatus(event) {
    if (event.type !== "session.status") return;
    const sessionId = event.properties?.sessionID;
    if (!sessionId) return;
    const taskId = this.tasksBySessionId.get(sessionId);
    if (!taskId) return;
    const task = this.tasks.get(taskId);
    if (!task || task.status !== "running") return;
    if (event.properties?.status?.type === "idle") {
      await this.extractAndCompleteTask(task);
    }
  }
  /**
   * Extract task result and mark complete.
   */
  async extractAndCompleteTask(task) {
    if (!task.sessionId) return;
    try {
      const messagesResult = await this.client.session.messages({
        path: { id: task.sessionId }
      });
      const messages = messagesResult.data ?? [];
      const assistantMessages = messages.filter(
        (m) => m.info?.role === "assistant"
      );
      const extractedContent = [];
      for (const message of assistantMessages) {
        for (const part of message.parts ?? []) {
          if ((part.type === "text" || part.type === "reasoning") && part.text) {
            extractedContent.push(part.text);
          }
        }
      }
      const responseText = extractedContent.filter((t) => t.length > 0).join("\n\n");
      if (responseText) {
        this.completeTask(task, "completed", responseText);
      } else {
        this.completeTask(task, "completed", "(No output)");
      }
    } catch (error92) {
      this.completeTask(
        task,
        "failed",
        error92 instanceof Error ? error92.message : String(error92)
      );
    }
  }
  /**
   * Complete a task and notify waiting callers.
   */
  completeTask(task, status, resultOrError) {
    if (task.status === "completed" || task.status === "failed") {
      return;
    }
    task.status = status;
    task.completedAt = /* @__PURE__ */ new Date();
    if (status === "completed") {
      task.result = resultOrError;
    } else {
      task.error = resultOrError;
    }
    if (task.sessionId) {
      this.tasksBySessionId.delete(task.sessionId);
      this.agentBySessionId.delete(task.sessionId);
    }
    if (task.parentSessionId) {
      this.sendCompletionNotification(task).catch((err) => {
        log(`[background-manager] notification failed: ${err}`);
      });
    }
    const resolver = this.completionResolvers.get(task.id);
    if (resolver) {
      resolver(task);
      this.completionResolvers.delete(task.id);
    }
    log(`[background-manager] task ${status}: ${task.id}`, {
      description: task.description
    });
  }
  /**
   * Send completion notification to parent session.
   */
  async sendCompletionNotification(task) {
    const message = task.status === "completed" ? `[Background task "${task.description}" completed]` : `[Background task "${task.description}" failed: ${task.error}]`;
    await this.client.session.prompt({
      path: { id: task.parentSessionId },
      body: {
        parts: [{ type: "text", text: message }]
      }
    });
  }
  /**
   * Retrieve the current state of a background task.
   *
   * @param taskId - The task ID to retrieve
   * @returns The task object, or null if not found
   */
  getResult(taskId) {
    return this.tasks.get(taskId) ?? null;
  }
  /**
   * Wait for a task to complete.
   *
   * @param taskId - The task ID to wait for
   * @param timeout - Maximum time to wait in milliseconds (0 = no timeout)
   * @returns The completed task, or null if not found/timeout
   */
  async waitForCompletion(taskId, timeout = 0) {
    const task = this.tasks.get(taskId);
    if (!task) return null;
    if (task.status === "completed" || task.status === "failed" || task.status === "cancelled") {
      return task;
    }
    return new Promise((resolve7) => {
      const resolver = (t) => resolve7(t);
      this.completionResolvers.set(taskId, resolver);
      if (timeout > 0) {
        setTimeout(() => {
          this.completionResolvers.delete(taskId);
          resolve7(this.tasks.get(taskId) ?? null);
        }, timeout);
      }
    });
  }
  /**
   * Cancel one or all running background tasks.
   *
   * @param taskId - Optional task ID to cancel. If omitted, cancels all pending/running tasks.
   * @returns Number of tasks cancelled
   */
  cancel(taskId) {
    if (taskId) {
      const task = this.tasks.get(taskId);
      if (task && (task.status === "pending" || task.status === "starting" || task.status === "running")) {
        this.completionResolvers.delete(taskId);
        const inStartQueue = task.status === "pending";
        task.status = "cancelled";
        if (inStartQueue) {
          const idx = this.startQueue.findIndex((t) => t.id === taskId);
          if (idx >= 0) {
            this.startQueue.splice(idx, 1);
          }
        }
        this.completeTask(task, "cancelled", "Cancelled by user");
        return 1;
      }
      return 0;
    }
    let count = 0;
    for (const task of this.tasks.values()) {
      if (task.status === "pending" || task.status === "starting" || task.status === "running") {
        this.completionResolvers.delete(task.id);
        const inStartQueue = task.status === "pending";
        task.status = "cancelled";
        if (inStartQueue) {
          const idx = this.startQueue.findIndex((t) => t.id === task.id);
          if (idx >= 0) {
            this.startQueue.splice(idx, 1);
          }
        }
        this.completeTask(task, "cancelled", "Cancelled by user");
        count++;
      }
    }
    return count;
  }
  /**
   * Return a snapshot of tracked tasks for observability surfaces (Gateway/HUD).
   */
  listTasks(limit = 200) {
    return [...this.tasks.values()].sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime()).slice(0, Math.max(1, limit)).map((task) => ({ ...task }));
  }
  /**
   * Clean up all tasks.
   */
  cleanup() {
    this.startQueue = [];
    this.completionResolvers.clear();
    this.tasks.clear();
    this.tasksBySessionId.clear();
    this.agentBySessionId.clear();
  }
};

// src/background/tmux-session-manager.ts
var SESSION_TIMEOUT_MS = 10 * 60 * 1e3;
var SESSION_MISSING_GRACE_MS = POLL_INTERVAL_BACKGROUND_MS * 3;
var TmuxSessionManager = class {
  client;
  tmuxConfig;
  serverUrl;
  sessions = /* @__PURE__ */ new Map();
  pollInterval;
  enabled = false;
  constructor(ctx, tmuxConfig) {
    this.client = ctx.client;
    this.tmuxConfig = tmuxConfig;
    const defaultPort = process.env.OPENCODE_PORT ?? "4096";
    this.serverUrl = ctx.serverUrl?.toString() ?? `http://localhost:${defaultPort}`;
    this.enabled = tmuxConfig.enabled && isInsideTmux();
    log("[tmux-session-manager] initialized", {
      enabled: this.enabled,
      tmuxConfig: this.tmuxConfig,
      serverUrl: this.serverUrl
    });
  }
  /**
   * Handle session.created events.
   * Spawns a tmux pane for child sessions (those with parentID).
   */
  async onSessionCreated(event) {
    if (!this.enabled) return;
    if (event.type !== "session.created") return;
    const info = event.properties?.info;
    if (!info?.id || !info?.parentID) {
      return;
    }
    const sessionId = info.id;
    const parentId = info.parentID;
    const title = info.title ?? "Subagent";
    if (this.sessions.has(sessionId)) {
      log("[tmux-session-manager] session already tracked", { sessionId });
      return;
    }
    log("[tmux-session-manager] child session created, spawning pane", {
      sessionId,
      parentId,
      title
    });
    const paneResult = await spawnTmuxPane(
      sessionId,
      title,
      this.tmuxConfig,
      this.serverUrl
    ).catch((err) => {
      log("[tmux-session-manager] failed to spawn pane", {
        error: String(err)
      });
      return { success: false, paneId: void 0 };
    });
    if (paneResult.success && paneResult.paneId) {
      const now = Date.now();
      this.sessions.set(sessionId, {
        sessionId,
        paneId: paneResult.paneId,
        parentId,
        title,
        createdAt: now,
        lastSeenAt: now
      });
      log("[tmux-session-manager] pane spawned", {
        sessionId,
        paneId: paneResult.paneId
      });
      this.startPolling();
    }
  }
  /**
   * Handle session.status events for completion detection.
   * Uses session.status instead of deprecated session.idle.
   *
   * When a session becomes idle (completed), close its pane.
   */
  async onSessionStatus(event) {
    if (!this.enabled) return;
    if (event.type !== "session.status") return;
    const sessionId = event.properties?.sessionID;
    if (!sessionId) return;
    if (event.properties?.status?.type === "idle") {
      await this.closeSession(sessionId);
    }
  }
  /**
   * Handle session.deleted events.
   * When a session is deleted, close its tmux pane immediately.
   */
  async onSessionDeleted(event) {
    if (!this.enabled) return;
    if (event.type !== "session.deleted") return;
    const sessionId = event.properties?.sessionID;
    if (!sessionId) return;
    log("[tmux-session-manager] session deleted, closing pane", {
      sessionId
    });
    await this.closeSession(sessionId);
  }
  startPolling() {
    if (this.pollInterval) return;
    this.pollInterval = setInterval(
      () => this.pollSessions(),
      POLL_INTERVAL_BACKGROUND_MS
    );
    log("[tmux-session-manager] polling started");
  }
  stopPolling() {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = void 0;
      log("[tmux-session-manager] polling stopped");
    }
  }
  /**
   * Poll sessions for status updates (fallback for reliability).
   * Also handles timeout and missing session detection.
   */
  async pollSessions() {
    if (this.sessions.size === 0) {
      this.stopPolling();
      return;
    }
    try {
      const statusResult = await this.client.session.status();
      const allStatuses = statusResult.data ?? {};
      const now = Date.now();
      const sessionsToClose = [];
      for (const [sessionId, tracked] of this.sessions.entries()) {
        const status = allStatuses[sessionId];
        const isIdle = status?.type === "idle";
        if (status) {
          tracked.lastSeenAt = now;
          tracked.missingSince = void 0;
        } else if (!tracked.missingSince) {
          tracked.missingSince = now;
        }
        const missingTooLong = !!tracked.missingSince && now - tracked.missingSince >= SESSION_MISSING_GRACE_MS;
        const isTimedOut = now - tracked.createdAt > SESSION_TIMEOUT_MS;
        if (isIdle || missingTooLong || isTimedOut) {
          sessionsToClose.push(sessionId);
        }
      }
      for (const sessionId of sessionsToClose) {
        await this.closeSession(sessionId);
      }
    } catch (err) {
      log("[tmux-session-manager] poll error", { error: String(err) });
    }
  }
  async closeSession(sessionId) {
    const tracked = this.sessions.get(sessionId);
    if (!tracked) return;
    log("[tmux-session-manager] closing session pane", {
      sessionId,
      paneId: tracked.paneId
    });
    await closeTmuxPane(tracked.paneId);
    this.sessions.delete(sessionId);
    if (this.sessions.size === 0) {
      this.stopPolling();
    }
  }
  /**
   * Clean up all tracked sessions.
   */
  async cleanup() {
    this.stopPolling();
    if (this.sessions.size > 0) {
      log("[tmux-session-manager] closing all panes", {
        count: this.sessions.size
      });
      const closePromises = Array.from(this.sessions.values()).map(
        (s) => closeTmuxPane(s.paneId).catch(
          (err) => log("[tmux-session-manager] cleanup error for pane", {
            paneId: s.paneId,
            error: String(err)
          })
        )
      );
      await Promise.all(closePromises);
      this.sessions.clear();
    }
    log("[tmux-session-manager] cleanup complete");
  }
};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
var external_exports2 = {};
__export(external_exports2, {
  $brand: () => $brand2,
  $input: () => $input2,
  $output: () => $output2,
  NEVER: () => NEVER2,
  TimePrecision: () => TimePrecision2,
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase642,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCUID: () => ZodCUID3,
  ZodCUID2: () => ZodCUID22,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec2,
  ZodCustom: () => ZodCustom2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE1642,
  ZodEmail: () => ZodEmail2,
  ZodEmoji: () => ZodEmoji2,
  ZodEnum: () => ZodEnum2,
  ZodError: () => ZodError2,
  ZodFile: () => ZodFile2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID2,
  ZodIPv4: () => ZodIPv42,
  ZodIPv6: () => ZodIPv62,
  ZodISODate: () => ZodISODate2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISOTime: () => ZodISOTime2,
  ZodIntersection: () => ZodIntersection2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodJWT: () => ZodJWT2,
  ZodKSUID: () => ZodKSUID2,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID2,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe2,
  ZodPrefault: () => ZodPrefault2,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRealError: () => ZodRealError2,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat2,
  ZodSuccess: () => ZodSuccess2,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodTransform: () => ZodTransform2,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID2,
  ZodURL: () => ZodURL2,
  ZodUUID: () => ZodUUID2,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID2,
  _ZodString: () => _ZodString2,
  _default: () => _default4,
  _function: () => _function2,
  any: () => any2,
  array: () => array2,
  base64: () => base644,
  base64url: () => base64url4,
  bigint: () => bigint5,
  boolean: () => boolean5,
  catch: () => _catch4,
  check: () => check2,
  cidrv4: () => cidrv44,
  cidrv6: () => cidrv64,
  clone: () => clone2,
  codec: () => codec2,
  coerce: () => coerce_exports2,
  config: () => config2,
  core: () => core_exports4,
  cuid: () => cuid5,
  cuid2: () => cuid24,
  custom: () => custom2,
  date: () => date7,
  decode: () => decode4,
  decodeAsync: () => decodeAsync4,
  discriminatedUnion: () => discriminatedUnion2,
  e164: () => e1644,
  email: () => email4,
  emoji: () => emoji4,
  encode: () => encode4,
  encodeAsync: () => encodeAsync4,
  endsWith: () => _endsWith2,
  enum: () => _enum4,
  file: () => file2,
  flattenError: () => flattenError2,
  float32: () => float322,
  float64: () => float642,
  formatError: () => formatError2,
  function: () => _function2,
  getErrorMap: () => getErrorMap2,
  globalRegistry: () => globalRegistry2,
  gt: () => _gt2,
  gte: () => _gte2,
  guid: () => guid4,
  hash: () => hash2,
  hex: () => hex4,
  hostname: () => hostname4,
  httpUrl: () => httpUrl2,
  includes: () => _includes2,
  instanceof: () => _instanceof2,
  int: () => int2,
  int32: () => int322,
  int64: () => int642,
  intersection: () => intersection2,
  ipv4: () => ipv44,
  ipv6: () => ipv64,
  iso: () => iso_exports2,
  json: () => json2,
  jwt: () => jwt2,
  keyof: () => keyof2,
  ksuid: () => ksuid4,
  lazy: () => lazy2,
  length: () => _length2,
  literal: () => literal2,
  locales: () => locales_exports2,
  looseObject: () => looseObject2,
  lowercase: () => _lowercase2,
  lt: () => _lt2,
  lte: () => _lte2,
  map: () => map2,
  maxLength: () => _maxLength2,
  maxSize: () => _maxSize2,
  mime: () => _mime2,
  minLength: () => _minLength2,
  minSize: () => _minSize2,
  multipleOf: () => _multipleOf2,
  nan: () => nan2,
  nanoid: () => nanoid4,
  nativeEnum: () => nativeEnum2,
  negative: () => _negative2,
  never: () => never2,
  nonnegative: () => _nonnegative2,
  nonoptional: () => nonoptional2,
  nonpositive: () => _nonpositive2,
  normalize: () => _normalize2,
  null: () => _null6,
  nullable: () => nullable2,
  nullish: () => nullish4,
  number: () => number5,
  object: () => object2,
  optional: () => optional2,
  overwrite: () => _overwrite2,
  parse: () => parse4,
  parseAsync: () => parseAsync4,
  partialRecord: () => partialRecord2,
  pipe: () => pipe2,
  positive: () => _positive2,
  prefault: () => prefault2,
  preprocess: () => preprocess2,
  prettifyError: () => prettifyError2,
  promise: () => promise2,
  property: () => _property2,
  readonly: () => readonly2,
  record: () => record2,
  refine: () => refine2,
  regex: () => _regex2,
  regexes: () => regexes_exports2,
  registry: () => registry2,
  safeDecode: () => safeDecode4,
  safeDecodeAsync: () => safeDecodeAsync4,
  safeEncode: () => safeEncode4,
  safeEncodeAsync: () => safeEncodeAsync4,
  safeParse: () => safeParse4,
  safeParseAsync: () => safeParseAsync4,
  set: () => set2,
  setErrorMap: () => setErrorMap2,
  size: () => _size2,
  startsWith: () => _startsWith2,
  strictObject: () => strictObject2,
  string: () => string5,
  stringFormat: () => stringFormat2,
  stringbool: () => stringbool2,
  success: () => success2,
  superRefine: () => superRefine2,
  symbol: () => symbol2,
  templateLiteral: () => templateLiteral2,
  toJSONSchema: () => toJSONSchema2,
  toLowerCase: () => _toLowerCase2,
  toUpperCase: () => _toUpperCase2,
  transform: () => transform2,
  treeifyError: () => treeifyError2,
  trim: () => _trim2,
  tuple: () => tuple2,
  uint32: () => uint322,
  uint64: () => uint642,
  ulid: () => ulid4,
  undefined: () => _undefined6,
  union: () => union2,
  unknown: () => unknown2,
  uppercase: () => _uppercase2,
  url: () => url2,
  util: () => util_exports2,
  uuid: () => uuid5,
  uuidv4: () => uuidv42,
  uuidv6: () => uuidv62,
  uuidv7: () => uuidv72,
  void: () => _void4,
  xid: () => xid4
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/index.js
var core_exports4 = {};
__export(core_exports4, {
  $ZodAny: () => $ZodAny2,
  $ZodArray: () => $ZodArray2,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodBase64: () => $ZodBase642,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCUID: () => $ZodCUID3,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCatch: () => $ZodCatch2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCodec: () => $ZodCodec2,
  $ZodCustom: () => $ZodCustom2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodDate: () => $ZodDate2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodE164: () => $ZodE1642,
  $ZodEmail: () => $ZodEmail2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEncodeError: () => $ZodEncodeError2,
  $ZodEnum: () => $ZodEnum2,
  $ZodError: () => $ZodError2,
  $ZodFile: () => $ZodFile2,
  $ZodFunction: () => $ZodFunction2,
  $ZodGUID: () => $ZodGUID2,
  $ZodIPv4: () => $ZodIPv42,
  $ZodIPv6: () => $ZodIPv62,
  $ZodISODate: () => $ZodISODate2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodJWT: () => $ZodJWT2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodLazy: () => $ZodLazy2,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodMap: () => $ZodMap2,
  $ZodNaN: () => $ZodNaN2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNever: () => $ZodNever2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNull: () => $ZodNull2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodObject: () => $ZodObject2,
  $ZodObjectJIT: () => $ZodObjectJIT2,
  $ZodOptional: () => $ZodOptional2,
  $ZodPipe: () => $ZodPipe2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPromise: () => $ZodPromise2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodRealError: () => $ZodRealError2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodSet: () => $ZodSet2,
  $ZodString: () => $ZodString2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTuple: () => $ZodTuple2,
  $ZodType: () => $ZodType2,
  $ZodULID: () => $ZodULID2,
  $ZodURL: () => $ZodURL2,
  $ZodUUID: () => $ZodUUID2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodVoid: () => $ZodVoid2,
  $ZodXID: () => $ZodXID2,
  $brand: () => $brand2,
  $constructor: () => $constructor2,
  $input: () => $input2,
  $output: () => $output2,
  Doc: () => Doc2,
  JSONSchema: () => json_schema_exports2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  NEVER: () => NEVER2,
  TimePrecision: () => TimePrecision2,
  _any: () => _any2,
  _array: () => _array2,
  _base64: () => _base642,
  _base64url: () => _base64url2,
  _bigint: () => _bigint2,
  _boolean: () => _boolean2,
  _catch: () => _catch3,
  _check: () => _check2,
  _cidrv4: () => _cidrv42,
  _cidrv6: () => _cidrv62,
  _coercedBigint: () => _coercedBigint2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedDate: () => _coercedDate2,
  _coercedNumber: () => _coercedNumber2,
  _coercedString: () => _coercedString2,
  _cuid: () => _cuid3,
  _cuid2: () => _cuid22,
  _custom: () => _custom2,
  _date: () => _date2,
  _decode: () => _decode2,
  _decodeAsync: () => _decodeAsync2,
  _default: () => _default3,
  _discriminatedUnion: () => _discriminatedUnion2,
  _e164: () => _e1642,
  _email: () => _email2,
  _emoji: () => _emoji4,
  _encode: () => _encode2,
  _encodeAsync: () => _encodeAsync2,
  _endsWith: () => _endsWith2,
  _enum: () => _enum3,
  _file: () => _file2,
  _float32: () => _float322,
  _float64: () => _float642,
  _gt: () => _gt2,
  _gte: () => _gte2,
  _guid: () => _guid2,
  _includes: () => _includes2,
  _int: () => _int2,
  _int32: () => _int322,
  _int64: () => _int642,
  _intersection: () => _intersection2,
  _ipv4: () => _ipv42,
  _ipv6: () => _ipv62,
  _isoDate: () => _isoDate2,
  _isoDateTime: () => _isoDateTime2,
  _isoDuration: () => _isoDuration2,
  _isoTime: () => _isoTime2,
  _jwt: () => _jwt2,
  _ksuid: () => _ksuid2,
  _lazy: () => _lazy2,
  _length: () => _length2,
  _literal: () => _literal2,
  _lowercase: () => _lowercase2,
  _lt: () => _lt2,
  _lte: () => _lte2,
  _map: () => _map2,
  _max: () => _lte2,
  _maxLength: () => _maxLength2,
  _maxSize: () => _maxSize2,
  _mime: () => _mime2,
  _min: () => _gte2,
  _minLength: () => _minLength2,
  _minSize: () => _minSize2,
  _multipleOf: () => _multipleOf2,
  _nan: () => _nan2,
  _nanoid: () => _nanoid2,
  _nativeEnum: () => _nativeEnum2,
  _negative: () => _negative2,
  _never: () => _never2,
  _nonnegative: () => _nonnegative2,
  _nonoptional: () => _nonoptional2,
  _nonpositive: () => _nonpositive2,
  _normalize: () => _normalize2,
  _null: () => _null5,
  _nullable: () => _nullable2,
  _number: () => _number2,
  _optional: () => _optional2,
  _overwrite: () => _overwrite2,
  _parse: () => _parse2,
  _parseAsync: () => _parseAsync2,
  _pipe: () => _pipe2,
  _positive: () => _positive2,
  _promise: () => _promise2,
  _property: () => _property2,
  _readonly: () => _readonly2,
  _record: () => _record2,
  _refine: () => _refine2,
  _regex: () => _regex2,
  _safeDecode: () => _safeDecode2,
  _safeDecodeAsync: () => _safeDecodeAsync2,
  _safeEncode: () => _safeEncode2,
  _safeEncodeAsync: () => _safeEncodeAsync2,
  _safeParse: () => _safeParse2,
  _safeParseAsync: () => _safeParseAsync2,
  _set: () => _set2,
  _size: () => _size2,
  _startsWith: () => _startsWith2,
  _string: () => _string2,
  _stringFormat: () => _stringFormat2,
  _stringbool: () => _stringbool2,
  _success: () => _success2,
  _superRefine: () => _superRefine2,
  _symbol: () => _symbol2,
  _templateLiteral: () => _templateLiteral2,
  _toLowerCase: () => _toLowerCase2,
  _toUpperCase: () => _toUpperCase2,
  _transform: () => _transform2,
  _trim: () => _trim2,
  _tuple: () => _tuple2,
  _uint32: () => _uint322,
  _uint64: () => _uint642,
  _ulid: () => _ulid2,
  _undefined: () => _undefined5,
  _union: () => _union2,
  _unknown: () => _unknown2,
  _uppercase: () => _uppercase2,
  _url: () => _url2,
  _uuid: () => _uuid2,
  _uuidv4: () => _uuidv42,
  _uuidv6: () => _uuidv62,
  _uuidv7: () => _uuidv72,
  _void: () => _void3,
  _xid: () => _xid2,
  clone: () => clone2,
  config: () => config2,
  decode: () => decode3,
  decodeAsync: () => decodeAsync3,
  encode: () => encode3,
  encodeAsync: () => encodeAsync3,
  flattenError: () => flattenError2,
  formatError: () => formatError2,
  globalConfig: () => globalConfig2,
  globalRegistry: () => globalRegistry2,
  isValidBase64: () => isValidBase642,
  isValidBase64URL: () => isValidBase64URL2,
  isValidJWT: () => isValidJWT2,
  locales: () => locales_exports2,
  parse: () => parse3,
  parseAsync: () => parseAsync3,
  prettifyError: () => prettifyError2,
  regexes: () => regexes_exports2,
  registry: () => registry2,
  safeDecode: () => safeDecode3,
  safeDecodeAsync: () => safeDecodeAsync3,
  safeEncode: () => safeEncode3,
  safeEncodeAsync: () => safeEncodeAsync3,
  safeParse: () => safeParse3,
  safeParseAsync: () => safeParseAsync3,
  toDotPath: () => toDotPath2,
  toJSONSchema: () => toJSONSchema2,
  treeifyError: () => treeifyError2,
  util: () => util_exports2,
  version: () => version2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/core.js
var NEVER2 = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor2(name, initializer5, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer5(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand2 = Symbol("zod_brand");
var $ZodAsyncError2 = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError2 = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig2 = {};
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/util.js
var util_exports2 = {};
__export(util_exports2, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2,
  Class: () => Class2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  aborted: () => aborted2,
  allowsEval: () => allowsEval2,
  assert: () => assert2,
  assertEqual: () => assertEqual2,
  assertIs: () => assertIs2,
  assertNever: () => assertNever2,
  assertNotEqual: () => assertNotEqual2,
  assignProp: () => assignProp2,
  base64ToUint8Array: () => base64ToUint8Array2,
  base64urlToUint8Array: () => base64urlToUint8Array2,
  cached: () => cached2,
  captureStackTrace: () => captureStackTrace2,
  cleanEnum: () => cleanEnum2,
  cleanRegex: () => cleanRegex2,
  clone: () => clone2,
  cloneDef: () => cloneDef2,
  createTransparentProxy: () => createTransparentProxy2,
  defineLazy: () => defineLazy2,
  esc: () => esc2,
  escapeRegex: () => escapeRegex2,
  extend: () => extend2,
  finalizeIssue: () => finalizeIssue2,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath2,
  getEnumValues: () => getEnumValues2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin2,
  hexToUint8Array: () => hexToUint8Array2,
  isObject: () => isObject3,
  isPlainObject: () => isPlainObject2,
  issue: () => issue2,
  joinValues: () => joinValues2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  merge: () => merge2,
  mergeDefs: () => mergeDefs2,
  normalizeParams: () => normalizeParams2,
  nullish: () => nullish3,
  numKeys: () => numKeys2,
  objectClone: () => objectClone2,
  omit: () => omit2,
  optionalKeys: () => optionalKeys2,
  partial: () => partial2,
  pick: () => pick2,
  prefixIssues: () => prefixIssues2,
  primitiveTypes: () => primitiveTypes2,
  promiseAllObject: () => promiseAllObject2,
  propertyKeyTypes: () => propertyKeyTypes2,
  randomString: () => randomString2,
  required: () => required2,
  safeExtend: () => safeExtend2,
  shallowClone: () => shallowClone2,
  stringifyPrimitive: () => stringifyPrimitive2,
  uint8ArrayToBase64: () => uint8ArrayToBase642,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url2,
  uint8ArrayToHex: () => uint8ArrayToHex2,
  unwrapMessage: () => unwrapMessage2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {
}
function assertNever2(_x) {
  throw new Error();
}
function assert2(_) {
}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === void 0;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING2 = Symbol("evaluating");
function defineLazy2(object3, key, getter) {
  let value = void 0;
  Object.defineProperty(object3, key, {
    get() {
      if (value === EVALUATING2) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING2;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone2(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs2(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef2(schema) {
  return mergeDefs2(schema._zod.def);
}
function getElementAtPath2(obj, path52) {
  if (!path52)
    return obj;
  return path52.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc2(str) {
  return JSON.stringify(str);
}
var captureStackTrace2 = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject3(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval2 = cached2(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject2(o) {
  if (isObject3(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject3(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone2(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes2 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes2 = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES2 = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function omit2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function safeExtend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone2(schema, def);
}
function merge2(a, b) {
  const def = mergeDefs2(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone2(a, def);
}
function partial2(Class3, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class3 ? new Class3({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function required2(Class3, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class3({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function aborted2(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues2(path52, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path52);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config3.customError?.(iss)) ?? unwrapMessage2(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array2(base645) {
  const binaryString = atob(base645);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase642(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array2(base64url5) {
  const base645 = base64url5.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base645.length % 4) % 4);
  return base64ToUint8Array2(base645 + padding);
}
function uint8ArrayToBase64url2(bytes) {
  return uint8ArrayToBase642(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array2(hex5) {
  const cleanHex = hex5.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex2(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class2 = class {
  constructor(..._args) {
  }
};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/errors.js
var initializer3 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError2 = $constructor2("$ZodError", initializer3);
var $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
function flattenError2(error92, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error92.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error92, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error93) => {
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error92);
  return fieldErrors;
}
function treeifyError2(error92, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = (error93, path52 = []) => {
    var _a2, _b;
    for (const issue3 of error93.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path52, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error92);
  return result;
}
function toDotPath2(_path) {
  const segs = [];
  const path52 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path52) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error92) {
  const lines = [];
  const issues = [...error92.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath2(issue3.path)}`);
  }
  return lines.join("\n");
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/parse.js
var _parse2 = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse3 = /* @__PURE__ */ _parse2($ZodRealError2);
var _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync3 = /* @__PURE__ */ _parseAsync2($ZodRealError2);
var _safeParse2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
var _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
var _encode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse2(_Err)(schema, value, ctx);
};
var encode3 = /* @__PURE__ */ _encode2($ZodRealError2);
var _decode2 = (_Err) => (schema, value, _ctx) => {
  return _parse2(_Err)(schema, value, _ctx);
};
var decode3 = /* @__PURE__ */ _decode2($ZodRealError2);
var _encodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync2(_Err)(schema, value, ctx);
};
var encodeAsync3 = /* @__PURE__ */ _encodeAsync2($ZodRealError2);
var _decodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync2(_Err)(schema, value, _ctx);
};
var decodeAsync3 = /* @__PURE__ */ _decodeAsync2($ZodRealError2);
var _safeEncode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse2(_Err)(schema, value, ctx);
};
var safeEncode3 = /* @__PURE__ */ _safeEncode2($ZodRealError2);
var _safeDecode2 = (_Err) => (schema, value, _ctx) => {
  return _safeParse2(_Err)(schema, value, _ctx);
};
var safeDecode3 = /* @__PURE__ */ _safeDecode2($ZodRealError2);
var _safeEncodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync2(_Err)(schema, value, ctx);
};
var safeEncodeAsync3 = /* @__PURE__ */ _safeEncodeAsync2($ZodRealError2);
var _safeDecodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync2(_Err)(schema, value, _ctx);
};
var safeDecodeAsync3 = /* @__PURE__ */ _safeDecodeAsync2($ZodRealError2);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/regexes.js
var regexes_exports2 = {};
__export(regexes_exports2, {
  base64: () => base643,
  base64url: () => base64url3,
  bigint: () => bigint4,
  boolean: () => boolean4,
  browserEmail: () => browserEmail2,
  cidrv4: () => cidrv43,
  cidrv6: () => cidrv63,
  cuid: () => cuid4,
  cuid2: () => cuid23,
  date: () => date5,
  datetime: () => datetime3,
  domain: () => domain2,
  duration: () => duration3,
  e164: () => e1643,
  email: () => email3,
  emoji: () => emoji3,
  extendedDuration: () => extendedDuration2,
  guid: () => guid3,
  hex: () => hex3,
  hostname: () => hostname3,
  html5Email: () => html5Email2,
  idnEmail: () => idnEmail2,
  integer: () => integer2,
  ipv4: () => ipv43,
  ipv6: () => ipv63,
  ksuid: () => ksuid3,
  lowercase: () => lowercase2,
  md5_base64: () => md5_base642,
  md5_base64url: () => md5_base64url2,
  md5_hex: () => md5_hex2,
  nanoid: () => nanoid3,
  null: () => _null4,
  number: () => number4,
  rfc5322Email: () => rfc5322Email2,
  sha1_base64: () => sha1_base642,
  sha1_base64url: () => sha1_base64url2,
  sha1_hex: () => sha1_hex2,
  sha256_base64: () => sha256_base642,
  sha256_base64url: () => sha256_base64url2,
  sha256_hex: () => sha256_hex2,
  sha384_base64: () => sha384_base642,
  sha384_base64url: () => sha384_base64url2,
  sha384_hex: () => sha384_hex2,
  sha512_base64: () => sha512_base642,
  sha512_base64url: () => sha512_base64url2,
  sha512_hex: () => sha512_hex2,
  string: () => string4,
  time: () => time3,
  ulid: () => ulid3,
  undefined: () => _undefined4,
  unicodeEmail: () => unicodeEmail2,
  uppercase: () => uppercase2,
  uuid: () => uuid3,
  uuid4: () => uuid42,
  uuid6: () => uuid62,
  uuid7: () => uuid72,
  xid: () => xid3
});
var cuid4 = /^[cC][^\s-]{8,}$/;
var cuid23 = /^[0-9a-z]+$/;
var ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid3 = /^[0-9a-vA-V]{20}$/;
var ksuid3 = /^[A-Za-z0-9]{27}$/;
var nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
var duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid3 = (version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid42 = /* @__PURE__ */ uuid3(4);
var uuid62 = /* @__PURE__ */ uuid3(6);
var uuid72 = /* @__PURE__ */ uuid3(7);
var email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail2 = unicodeEmail2;
var browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji3() {
  return new RegExp(_emoji3, "u");
}
var ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url3 = /^[A-Za-z0-9_-]*$/;
var hostname3 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e1643 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time5 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
var string4 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint4 = /^-?\d+n?$/;
var integer2 = /^-?\d+$/;
var number4 = /^-?\d+(?:\.\d+)?/;
var boolean4 = /^(?:true|false)$/i;
var _null4 = /^null$/i;
var _undefined4 = /^undefined$/i;
var lowercase2 = /^[^A-Z]*$/;
var uppercase2 = /^[^a-z]*$/;
var hex3 = /^[0-9a-fA-F]*$/;
function fixedBase642(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url2(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex2 = /^[0-9a-fA-F]{32}$/;
var md5_base642 = /* @__PURE__ */ fixedBase642(22, "==");
var md5_base64url2 = /* @__PURE__ */ fixedBase64url2(22);
var sha1_hex2 = /^[0-9a-fA-F]{40}$/;
var sha1_base642 = /* @__PURE__ */ fixedBase642(27, "=");
var sha1_base64url2 = /* @__PURE__ */ fixedBase64url2(27);
var sha256_hex2 = /^[0-9a-fA-F]{64}$/;
var sha256_base642 = /* @__PURE__ */ fixedBase642(43, "=");
var sha256_base64url2 = /* @__PURE__ */ fixedBase64url2(43);
var sha384_hex2 = /^[0-9a-fA-F]{96}$/;
var sha384_base642 = /* @__PURE__ */ fixedBase642(64, "");
var sha384_base64url2 = /* @__PURE__ */ fixedBase64url2(64);
var sha512_hex2 = /^[0-9a-fA-F]{128}$/;
var sha512_base642 = /* @__PURE__ */ fixedBase642(86, "==");
var sha512_base64url2 = /* @__PURE__ */ fixedBase64url2(86);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/checks.js
var $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap2 = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer2;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin2(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const escapedRegex = escapeRegex2(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
var $ZodCheckProperty2 = /* @__PURE__ */ $constructor2("$ZodCheckProperty", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
    }
    handleCheckPropertyResult2(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType2 = /* @__PURE__ */ $constructor2("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/doc.js
var Doc2 = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/versions.js
var version2 = {
  major: 4,
  minor: 1,
  patch: 8
};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/schemas.js
var $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted2(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError2();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted2(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted2(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted2(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse3(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  $ZodString2.init(inst, def);
});
var $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid3(v));
  } else
    def.pattern ?? (def.pattern = uuid3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url3 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url3.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname3.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url3.protocol.endsWith(":") ? url3.protocol.slice(0, -1) : url3.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url3.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid4);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid23);
  $ZodStringFormat2.init(inst, def);
});
var $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv43);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv43);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base643);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase642(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base645 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base645.padEnd(Math.ceil(base645.length / 4) * 4, "=");
  return isValidBase642(padded);
}
var $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url3);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL2(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e1643);
  $ZodStringFormat2.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat2.init(inst, def);
  $ZodNumber2.init(inst, def);
});
var $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = boolean4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = bigint4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat2.init(inst, def);
  $ZodBigInt2.init(inst, def);
});
var $ZodSymbol2 = /* @__PURE__ */ $constructor2("$ZodSymbol", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined2 = /* @__PURE__ */ $constructor2("$ZodUndefined", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _undefined4;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _null4;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny2 = /* @__PURE__ */ $constructor2("$ZodAny", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid2 = /* @__PURE__ */ $constructor2("$ZodVoid", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate2 = /* @__PURE__ */ $constructor2("$ZodDate", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
      } else {
        handleArrayResult2(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult2(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef2(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall2(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
    } else {
      handlePropertyResult2(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
  $ZodType2.init(inst, def);
  const _normalized = cached2(() => normalizeDef2(def));
  defineLazy2(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject4 = isObject3;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject4(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
      } else {
        handlePropertyResult2(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall2(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT2 = /* @__PURE__ */ $constructor2("$ZodObjectJIT", (inst, def) => {
  $ZodObject2.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached2(() => normalizeDef2(def));
  const generateFastpass = (shape) => {
    const doc = new Doc2(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc2(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc2(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject4 = isObject3;
  const jit = !globalConfig2.jitless;
  const allowsEval3 = allowsEval2;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject4(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall2([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted2(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
var $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy2(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy2(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults2(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults2(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy2(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached2(() => {
    const opts = def.options;
    const map3 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map3.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map3.set(v, o);
      }
    }
    return map3;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults2(payload, left2, right2);
      });
    }
    return handleIntersectionResults2(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple2 = /* @__PURE__ */ $constructor2("$ZodTuple", (inst, def) => {
  $ZodType2.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
      } else {
        handleTupleResult2(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
        } else {
          handleTupleResult2(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues2(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues2(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap2 = /* @__PURE__ */ $constructor2("$ZodMap", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet2 = /* @__PURE__ */ $constructor2("$ZodSet", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult2(result2, payload)));
      } else
        handleSetResult2(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
  $ZodType2.init(inst, def);
  const values = getEnumValues2(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile2 = /* @__PURE__ */ $constructor2("$ZodFile", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError2();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult2(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult2(r, payload.value));
      return handleOptionalResult2(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : void 0;
  });
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult2(result2, def));
    }
    return handleDefaultResult2(result, def);
  };
});
function handleDefaultResult2(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult2(result2, inst));
    }
    return handleNonOptionalResult2(result, inst);
  };
});
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess2 = /* @__PURE__ */ $constructor2("$ZodSuccess", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN2 = /* @__PURE__ */ $constructor2("$ZodNaN", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult2(right2, def.in, ctx));
      }
      return handlePipeResult2(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult2(left2, def.out, ctx));
    }
    return handlePipeResult2(left, def.out, ctx);
  };
});
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec2 = /* @__PURE__ */ $constructor2("$ZodCodec", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult2(left2, def, ctx));
      }
      return handleCodecAResult2(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult2(right2, def, ctx));
      }
      return handleCodecAResult2(right, def, ctx);
    }
  };
});
function handleCodecAResult2(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.out, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.in, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult2(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult2);
    }
    return handleReadonlyResult2(result);
  };
});
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("$ZodTemplateLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes2.has(typeof part)) {
      regexParts.push(escapeRegex2(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction2 = /* @__PURE__ */ $constructor2("$ZodFunction", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse3(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse3(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync3(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync3(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple2({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise2 = /* @__PURE__ */ $constructor2("$ZodPromise", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy2 = /* @__PURE__ */ $constructor2("$ZodLazy", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "innerType", () => def.getter());
  defineLazy2(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy2(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy2(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
  defineLazy2(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
  $ZodCheck2.init(inst, def);
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
    }
    handleRefineResult2(r, payload, input, inst);
    return;
  };
});
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/index.js
var locales_exports2 = {};
__export(locales_exports2, {
  ar: () => ar_default2,
  az: () => az_default2,
  be: () => be_default2,
  ca: () => ca_default2,
  cs: () => cs_default2,
  da: () => da_default2,
  de: () => de_default2,
  en: () => en_default2,
  eo: () => eo_default2,
  es: () => es_default2,
  fa: () => fa_default2,
  fi: () => fi_default2,
  fr: () => fr_default2,
  frCA: () => fr_CA_default2,
  he: () => he_default2,
  hu: () => hu_default2,
  id: () => id_default2,
  is: () => is_default2,
  it: () => it_default2,
  ja: () => ja_default2,
  ka: () => ka_default2,
  kh: () => kh_default2,
  km: () => km_default2,
  ko: () => ko_default2,
  lt: () => lt_default2,
  mk: () => mk_default2,
  ms: () => ms_default2,
  nl: () => nl_default2,
  no: () => no_default2,
  ota: () => ota_default2,
  pl: () => pl_default2,
  ps: () => ps_default2,
  pt: () => pt_default2,
  ru: () => ru_default2,
  sl: () => sl_default2,
  sv: () => sv_default2,
  ta: () => ta_default2,
  th: () => th_default2,
  tr: () => tr_default2,
  ua: () => ua_default2,
  uk: () => uk_default2,
  ur: () => ur_default2,
  vi: () => vi_default2,
  yo: () => yo_default2,
  zhCN: () => zh_CN_default2,
  zhTW: () => zh_TW_default2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ar.js
var error48 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default2() {
  return {
    localeError: error48()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/az.js
var error49 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue3.expected}, daxil olan ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive2(issue3.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default2() {
  return {
    localeError: error49()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/be.js
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error50 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default2() {
  return {
    localeError: error50()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ca.js
var error51 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType8(issue3.input)}`;
      // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue3.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default2() {
  return {
    localeError: error51()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/cs.js
var error52 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue3.expected}, obdr\u017Eeno ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue3.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default2() {
  return {
    localeError: error52()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/da.js
var error53 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue3.expected)}, fik ${getTypeName(parsedType8(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default2() {
  return {
    localeError: error53()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/de.js
var error54 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue3.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default2() {
  return {
    localeError: error54()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/en.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error55 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default2() {
  return {
    localeError: error55()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/eo.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error56 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue3.expected}, ricevi\u011Dis ${parsedType3(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default2() {
  return {
    localeError: error56()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/es.js
var error57 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue3.expected)}, recibido ${getTypeName(parsedType8(issue3.input))}`;
      // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue3.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue3.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default2() {
  return {
    localeError: error57()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fa.js
var error58 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType8(issue3.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive2(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues2(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default2() {
  return {
    localeError: error58()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fi.js
var error59 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default2() {
  return {
    localeError: error59()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr.js
var error60 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue3.expected} attendu, ${parsedType8(issue3.input)} re\xE7u`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default2() {
  return {
    localeError: error60()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr-CA.js
var error61 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue3.expected}, re\xE7u ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default2() {
  return {
    localeError: error61()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/he.js
var error62 = () => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType8(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default2() {
  return {
    localeError: error62()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/hu.js
var error63 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue3.expected}, a kapott \xE9rt\xE9k ${parsedType8(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default2() {
  return {
    localeError: error63()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/id.js
var error64 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default2() {
  return {
    localeError: error64()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/is.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error65 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue3.input)} \xFEar sem \xE1 a\xF0 vera ${issue3.expected}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default2() {
  return {
    localeError: error65()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/it.js
var error66 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType8(issue3.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default2() {
  return {
    localeError: error66()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ja.js
var error67 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType8(issue3.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive2(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues2(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default2() {
  return {
    localeError: error67()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ka.js
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
  };
  return typeMap[t] ?? t;
};
var error68 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues2(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default2() {
  return {
    localeError: error68()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/km.js
var error69 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default2() {
  return {
    localeError: error69()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/kh.js
function kh_default2() {
  return km_default2();
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ko.js
var error70 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType8(issue3.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive2(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues2(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default2() {
  return {
    localeError: error70()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/lt.js
var parsedType6 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
};
var parsedTypeFromType = (t, data = void 0) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === void 0)
        return "ne\u017Einomas objektas";
      if (data === null)
        return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    //Zod types below
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t;
};
var capitalizeFirstCharacter2 = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber2(number7) {
  const abs = Math.abs(number7);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error71 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue3.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue3.expected)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive2(issue3.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues2(issue3.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue3.origin);
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default2() {
  return {
    localeError: error71()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/mk.js
var error72 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType8(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default2() {
  return {
    localeError: error72()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ms.js
var error73 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default2() {
  return {
    localeError: error73()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/nl.js
var error74 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default2() {
  return {
    localeError: error74()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/no.js
var error75 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default2() {
  return {
    localeError: error75()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ota.js
var error76 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue3.expected}, al\u0131nan ${parsedType8(issue3.input)}`;
      // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default2() {
  return {
    localeError: error76()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ps.js
var error77 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType8(issue3.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive2(issue3.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues2(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default2() {
  return {
    localeError: error77()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pl.js
var error78 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default2() {
  return {
    localeError: error78()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pt.js
var error79 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue3.expected}, recebido ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue3.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default2() {
  return {
    localeError: error79()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ru.js
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error80 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default2() {
  return {
    localeError: error80()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sl.js
var error81 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue3.expected}, prejeto ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default2() {
  return {
    localeError: error81()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sv.js
var error82 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue3.expected}, fick ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default2() {
  return {
    localeError: error82()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ta.js
var error83 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues2(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default2() {
  return {
    localeError: error83()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/th.js
var error84 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default2() {
  return {
    localeError: error84()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/tr.js
var parsedType7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error85 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue3.expected}, al\u0131nan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default2() {
  return {
    localeError: error85()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/uk.js
var error86 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue3.input)}`;
      // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default2() {
  return {
    localeError: error86()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ua.js
function ua_default2() {
  return uk_default2();
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ur.js
var error87 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue3.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive2(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues2(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default2() {
  return {
    localeError: error87()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/vi.js
var error88 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive2(issue3.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default2() {
  return {
    localeError: error88()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-CN.js
var error89 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default2() {
  return {
    localeError: error89()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-TW.js
var error90 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default2() {
  return {
    localeError: error90()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/yo.js
var error91 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default2() {
  return {
    localeError: error91()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/registries.js
var $output2 = Symbol("ZodOutput");
var $input2 = Symbol("ZodInput");
var $ZodRegistry2 = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      if (this._idmap.has(meta3.id)) {
        throw new Error(`ID ${meta3.id} already exists in the registry`);
      }
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry2() {
  return new $ZodRegistry2();
}
var globalRegistry2 = /* @__PURE__ */ registry2();

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
var TimePrecision2 = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
function _undefined5(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _void3(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _positive2(params) {
  return _gt2(0, params);
}
function _negative2(params) {
  return _lt2(0, params);
}
function _nonpositive2(params) {
  return _lte2(0, params);
}
function _nonnegative2(params) {
  return _gte2(0, params);
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _property2(property, schema, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema,
    ...normalizeParams2(params)
  });
}
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams2(params)
  });
}
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone2(defaultValue);
    }
  });
}
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch3(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
function _superRefine2(fn) {
  const ch = _check2((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue2(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check2(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec2;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec3 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec3,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec3;
}
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator2 = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry2;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const formatMap2 = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json3 = _json;
            json3.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json3.minLength = minimum;
            if (typeof maximum === "number")
              json3.maxLength = maximum;
            if (format) {
              json3.format = formatMap2[format] ?? format;
              if (json3.format === "")
                delete json3.format;
            }
            if (contentEncoding)
              json3.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json3.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json3 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json3.type = "integer";
            else
              json3.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json3.minimum = exclusiveMinimum;
                json3.exclusiveMinimum = true;
              } else {
                json3.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json3.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json3.minimum;
                else
                  delete json3.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json3.maximum = exclusiveMaximum;
                json3.exclusiveMaximum = true;
              } else {
                json3.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json3.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json3.maximum;
                else
                  delete json3.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json3.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json3 = _json;
            json3.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json3 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json3.minItems = minimum;
            if (typeof maximum === "number")
              json3.maxItems = maximum;
            json3.type = "array";
            json3.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json3 = _json;
            json3.type = "object";
            json3.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json3.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json3.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json3.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json3.additionalProperties = false;
            } else if (def.catchall) {
              json3.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json3 = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json3.anyOf = options;
            break;
          }
          case "intersection": {
            const json3 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json3.allOf = allOf;
            break;
          }
          case "tuple": {
            const json3 = _json;
            json3.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json3.prefixItems = prefixItems;
              if (rest) {
                json3.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json3.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json3.items.anyOf.push(rest);
              }
              json3.minItems = prefixItems.length;
              if (!rest) {
                json3.maxItems = prefixItems.length;
              }
            } else {
              json3.items = prefixItems;
              if (rest) {
                json3.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json3.minItems = minimum;
            if (typeof maximum === "number")
              json3.maxItems = maximum;
            break;
          }
          case "record": {
            const json3 = _json;
            json3.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json3.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json3.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json3 = _json;
            const values = getEnumValues2(def.entries);
            if (values.every((v) => typeof v === "number"))
              json3.type = "number";
            if (values.every((v) => typeof v === "string"))
              json3.type = "string";
            json3.enum = values;
            break;
          }
          case "literal": {
            const json3 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json3.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json3.enum = [val];
              } else {
                json3.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json3.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json3.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json3.type = "string";
              if (vals.every((v) => v === null))
                json3.type = "null";
              json3.enum = vals;
            }
            break;
          }
          case "file": {
            const json3 = _json;
            const file3 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file3.minLength = minimum;
            if (maximum !== void 0)
              file3.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file3.contentMediaType = mime[0];
                Object.assign(json3, file3);
              } else {
                json3.anyOf = mime.map((m) => {
                  const mFile = { ...file3, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json3, file3);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json3 = _json;
            json3.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json3 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json3.type = "string";
            json3.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta3 = this.metadataRegistry.get(schema);
    if (meta3)
      Object.assign(result.schema, meta3);
    if (this.io === "input" && isTransforming2(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry2) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry2[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry2[1].defId ?? entry2[1].schema.id ?? `schema${this.counter++}`;
        entry2[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry2[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry2[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry2) => {
      if (entry2[1].schema.$ref) {
        return;
      }
      const seen = entry2[1];
      const { ref, defId } = makeURI(entry2);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry2 of this.seen.entries()) {
        const seen = entry2[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry2 of this.seen.entries()) {
      const seen = entry2[1];
      if (schema === entry2[0]) {
        extractToDef(entry2);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry2[0])?.id;
        if (schema !== entry2[0] && ext) {
          extractToDef(entry2);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry2[0])?.id;
      if (id) {
        extractToDef(entry2);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry2);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry2);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry2 of [...this.seen.entries()].reverse()) {
      flattenRef(entry2[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry2 of this.seen.entries()) {
      const seen = entry2[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema2(input, _params) {
  if (input instanceof $ZodRegistry2) {
    const gen2 = new JSONSchemaGenerator2(_params);
    const defs = {};
    for (const entry2 of input._idmap.entries()) {
      const [_, schema] = entry2;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry2 of input._idmap.entries()) {
      const [key, schema] = entry2;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator2(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming2(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming2(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming2(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming2(item, ctx))
          return true;
      }
      if (def.rest && isTransforming2(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "map": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "set": {
      return isTransforming2(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming2(def.innerType, ctx);
    case "lazy":
      return isTransforming2(def.getter(), ctx);
    case "default": {
      return isTransforming2(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming2(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/json-schema.js
var json_schema_exports2 = {};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISOTime: () => ZodISOTime2,
  date: () => date6,
  datetime: () => datetime4,
  duration: () => duration4,
  time: () => time4
});
var ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
  $ZodISODateTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
var ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
  $ZodISODate2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
var ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
  $ZodISOTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
var ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
  $ZodISODuration2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/errors.js
var initializer4 = (inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError2(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError2(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError2 = $constructor2("ZodError", initializer4);
var ZodRealError2 = $constructor2("ZodError", initializer4, {
  Parent: Error
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/parse.js
var parse4 = /* @__PURE__ */ _parse2(ZodRealError2);
var parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
var safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
var safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
var encode4 = /* @__PURE__ */ _encode2(ZodRealError2);
var decode4 = /* @__PURE__ */ _decode2(ZodRealError2);
var encodeAsync4 = /* @__PURE__ */ _encodeAsync2(ZodRealError2);
var decodeAsync4 = /* @__PURE__ */ _decodeAsync2(ZodRealError2);
var safeEncode4 = /* @__PURE__ */ _safeEncode2(ZodRealError2);
var safeDecode4 = /* @__PURE__ */ _safeDecode2(ZodRealError2);
var safeEncodeAsync4 = /* @__PURE__ */ _safeEncodeAsync2(ZodRealError2);
var safeDecodeAsync4 = /* @__PURE__ */ _safeDecodeAsync2(ZodRealError2);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
  $ZodType2.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse4(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse4(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode4(inst, data, params);
  inst.decode = (data, params) => decode4(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync4(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync4(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode4(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode4(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync4(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync4(inst, data, params);
  inst.refine = (check3, params) => inst.check(refine2(check3, params));
  inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite2(fn));
  inst.optional = () => optional2(inst);
  inst.nullable = () => nullable2(inst);
  inst.nullish = () => optional2(nullable2(inst));
  inst.nonoptional = (params) => nonoptional2(inst, params);
  inst.array = () => array2(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection2(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform2(tx));
  inst.default = (def2) => _default4(inst, def2);
  inst.prefault = (def2) => prefault2(inst, def2);
  inst.catch = (params) => _catch4(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly2(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry2.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry2.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry2.get(inst);
    }
    const cl = inst.clone();
    globalRegistry2.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  ZodType2.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex2(...args));
  inst.includes = (...args) => inst.check(_includes2(...args));
  inst.startsWith = (...args) => inst.check(_startsWith2(...args));
  inst.endsWith = (...args) => inst.check(_endsWith2(...args));
  inst.min = (...args) => inst.check(_minLength2(...args));
  inst.max = (...args) => inst.check(_maxLength2(...args));
  inst.length = (...args) => inst.check(_length2(...args));
  inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase2(params));
  inst.uppercase = (params) => inst.check(_uppercase2(params));
  inst.trim = () => inst.check(_trim2());
  inst.normalize = (...args) => inst.check(_normalize2(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase2());
  inst.toUpperCase = () => inst.check(_toUpperCase2());
});
var ZodString2 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  _ZodString2.init(inst, def);
  inst.email = (params) => inst.check(_email2(ZodEmail2, params));
  inst.url = (params) => inst.check(_url2(ZodURL2, params));
  inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
  inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
  inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
  inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
  inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
  inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
  inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
  inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
  inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
  inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
  inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
  inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
  inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
  inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
  inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
  inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
  inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
  inst.datetime = (params) => inst.check(datetime4(params));
  inst.date = (params) => inst.check(date6(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration4(params));
});
function string5(params) {
  return _string2(ZodString2, params);
}
var ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  _ZodString2.init(inst, def);
});
var ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
  $ZodEmail2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function email4(params) {
  return _email2(ZodEmail2, params);
}
var ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
  $ZodGUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function guid4(params) {
  return _guid2(ZodGUID2, params);
}
var ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
  $ZodUUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function uuid5(params) {
  return _uuid2(ZodUUID2, params);
}
function uuidv42(params) {
  return _uuidv42(ZodUUID2, params);
}
function uuidv62(params) {
  return _uuidv62(ZodUUID2, params);
}
function uuidv72(params) {
  return _uuidv72(ZodUUID2, params);
}
var ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
  $ZodURL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function url2(params) {
  return _url2(ZodURL2, params);
}
function httpUrl2(params) {
  return _url2(ZodURL2, {
    protocol: /^https?$/,
    hostname: regexes_exports2.domain,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
  $ZodEmoji2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function emoji4(params) {
  return _emoji4(ZodEmoji2, params);
}
var ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
  $ZodNanoID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function nanoid4(params) {
  return _nanoid2(ZodNanoID2, params);
}
var ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
  $ZodCUID3.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid5(params) {
  return _cuid3(ZodCUID3, params);
}
var ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
  $ZodCUID22.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid24(params) {
  return _cuid22(ZodCUID22, params);
}
var ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
  $ZodULID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ulid4(params) {
  return _ulid2(ZodULID2, params);
}
var ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
  $ZodXID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function xid4(params) {
  return _xid2(ZodXID2, params);
}
var ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
  $ZodKSUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ksuid4(params) {
  return _ksuid2(ZodKSUID2, params);
}
var ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
  $ZodIPv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv44(params) {
  return _ipv42(ZodIPv42, params);
}
var ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
  $ZodIPv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv64(params) {
  return _ipv62(ZodIPv62, params);
}
var ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv44(params) {
  return _cidrv42(ZodCIDRv42, params);
}
var ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv64(params) {
  return _cidrv62(ZodCIDRv62, params);
}
var ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
  $ZodBase642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base644(params) {
  return _base642(ZodBase642, params);
}
var ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
  $ZodBase64URL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base64url4(params) {
  return _base64url2(ZodBase64URL2, params);
}
var ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
  $ZodE1642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function e1644(params) {
  return _e1642(ZodE1642, params);
}
var ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
  $ZodJWT2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function jwt2(params) {
  return _jwt2(ZodJWT2, params);
}
var ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function stringFormat2(format, fnOrRegex, _params = {}) {
  return _stringFormat2(ZodCustomStringFormat2, format, fnOrRegex, _params);
}
function hostname4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hostname", regexes_exports2.hostname, _params);
}
function hex4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hex", regexes_exports2.hex, _params);
}
function hash2(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports2[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat2(ZodCustomStringFormat2, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
  $ZodNumber2.init(inst, def);
  ZodType2.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt2(0, params));
  inst.nonnegative = (params) => inst.check(_gte2(0, params));
  inst.negative = (params) => inst.check(_lt2(0, params));
  inst.nonpositive = (params) => inst.check(_lte2(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  inst.step = (value, params) => inst.check(_multipleOf2(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number5(params) {
  return _number2(ZodNumber2, params);
}
var ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat2.init(inst, def);
  ZodNumber2.init(inst, def);
});
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
function float322(params) {
  return _float322(ZodNumberFormat2, params);
}
function float642(params) {
  return _float642(ZodNumberFormat2, params);
}
function int322(params) {
  return _int322(ZodNumberFormat2, params);
}
function uint322(params) {
  return _uint322(ZodNumberFormat2, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
  $ZodBoolean2.init(inst, def);
  ZodType2.init(inst, def);
});
function boolean5(params) {
  return _boolean2(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor2("ZodBigInt", (inst, def) => {
  $ZodBigInt2.init(inst, def);
  ZodType2.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.positive = (params) => inst.check(_gt2(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt2(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte2(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte2(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint5(params) {
  return _bigint2(ZodBigInt2, params);
}
var ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat2.init(inst, def);
  ZodBigInt2.init(inst, def);
});
function int642(params) {
  return _int642(ZodBigIntFormat2, params);
}
function uint642(params) {
  return _uint642(ZodBigIntFormat2, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor2("ZodSymbol", (inst, def) => {
  $ZodSymbol2.init(inst, def);
  ZodType2.init(inst, def);
});
function symbol2(params) {
  return _symbol2(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor2("ZodUndefined", (inst, def) => {
  $ZodUndefined2.init(inst, def);
  ZodType2.init(inst, def);
});
function _undefined6(params) {
  return _undefined5(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
  $ZodNull2.init(inst, def);
  ZodType2.init(inst, def);
});
function _null6(params) {
  return _null5(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor2("ZodAny", (inst, def) => {
  $ZodAny2.init(inst, def);
  ZodType2.init(inst, def);
});
function any2() {
  return _any2(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
  $ZodUnknown2.init(inst, def);
  ZodType2.init(inst, def);
});
function unknown2() {
  return _unknown2(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
  $ZodNever2.init(inst, def);
  ZodType2.init(inst, def);
});
function never2(params) {
  return _never2(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor2("ZodVoid", (inst, def) => {
  $ZodVoid2.init(inst, def);
  ZodType2.init(inst, def);
});
function _void4(params) {
  return _void3(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor2("ZodDate", (inst, def) => {
  $ZodDate2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date7(params) {
  return _date2(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
  $ZodArray2.init(inst, def);
  ZodType2.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength2(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
  inst.length = (len, params) => inst.check(_length2(len, params));
  inst.unwrap = () => inst.element;
});
function array2(element, params) {
  return _array2(ZodArray2, element, params);
}
function keyof2(schema) {
  const shape = schema._zod.def.shape;
  return _enum4(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
  $ZodObjectJIT2.init(inst, def);
  ZodType2.init(inst, def);
  util_exports2.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum4(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports2.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports2.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports2.merge(inst, other);
  inst.pick = (mask) => util_exports2.pick(inst, mask);
  inst.omit = (mask) => util_exports2.omit(inst, mask);
  inst.partial = (...args) => util_exports2.partial(ZodOptional2, inst, args[0]);
  inst.required = (...args) => util_exports2.required(ZodNonOptional2, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", shape ? util_exports2.objectClone(shape) : {});
      return this.shape;
    },
    ...util_exports2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", util_exports2.objectClone(shape));
      return this.shape;
    },
    catchall: never2(),
    ...util_exports2.normalizeParams(params)
  });
}
function looseObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", util_exports2.objectClone(shape));
      return this.shape;
    },
    catchall: unknown2(),
    ...util_exports2.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  ZodType2.init(inst, def);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodDiscriminatedUnion2.init(inst, def);
});
function discriminatedUnion2(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
  $ZodIntersection2.init(inst, def);
  ZodType2.init(inst, def);
});
function intersection2(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor2("ZodTuple", (inst, def) => {
  $ZodTuple2.init(inst, def);
  ZodType2.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple2(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
  $ZodRecord2.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record2(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
function partialRecord2(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = void 0;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor2("ZodMap", (inst, def) => {
  $ZodMap2.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map2(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor2("ZodSet", (inst, def) => {
  $ZodSet2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (...args) => inst.check(_minSize2(...args));
  inst.nonempty = (params) => inst.check(_minSize2(1, params));
  inst.max = (...args) => inst.check(_maxSize2(...args));
  inst.size = (...args) => inst.check(_size2(...args));
});
function set2(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
  $ZodEnum2.init(inst, def);
  ZodType2.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
function nativeEnum2(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
  $ZodLiteral2.init(inst, def);
  ZodType2.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal2(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports2.normalizeParams(params)
  });
}
var ZodFile2 = /* @__PURE__ */ $constructor2("ZodFile", (inst, def) => {
  $ZodFile2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize2(size, params));
  inst.max = (size, params) => inst.check(_maxSize2(size, params));
  inst.mime = (types, params) => inst.check(_mime2(Array.isArray(types) ? types : [types], params));
});
function file2(params) {
  return _file2(ZodFile2, params);
}
var ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
  $ZodTransform2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(util_exports2.issue(issue3, payload.value, def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports2.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
  $ZodNullable2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable2(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish4(innerType) {
  return optional2(nullable2(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
  $ZodDefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default4(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
  $ZodPrefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
  $ZodNonOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodSuccess2 = /* @__PURE__ */ $constructor2("ZodSuccess", (inst, def) => {
  $ZodSuccess2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success2(innerType) {
  return new ZodSuccess2({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
  $ZodCatch2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch4(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor2("ZodNaN", (inst, def) => {
  $ZodNaN2.init(inst, def);
  ZodType2.init(inst, def);
});
function nan2(params) {
  return _nan2(ZodNaN2, params);
}
var ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
  $ZodPipe2.init(inst, def);
  ZodType2.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec2 = /* @__PURE__ */ $constructor2("ZodCodec", (inst, def) => {
  ZodPipe2.init(inst, def);
  $ZodCodec2.init(inst, def);
});
function codec2(in_, out, params) {
  return new ZodCodec2({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
  $ZodReadonly2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly2(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral2.init(inst, def);
  ZodType2.init(inst, def);
});
function templateLiteral2(parts, params) {
  return new ZodTemplateLiteral2({
    type: "template_literal",
    parts,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor2("ZodLazy", (inst, def) => {
  $ZodLazy2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy2(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor2("ZodPromise", (inst, def) => {
  $ZodPromise2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise2(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor2("ZodFunction", (inst, def) => {
  $ZodFunction2.init(inst, def);
  ZodType2.init(inst, def);
});
function _function2(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple2(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
var ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
  $ZodCustom2.init(inst, def);
  ZodType2.init(inst, def);
});
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  return _superRefine2(fn);
}
function _instanceof2(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom2({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool2 = (...args) => _stringbool2({
  Codec: ZodCodec2,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json2(params) {
  const jsonSchema = lazy2(() => {
    return union2([string5(params), number5(), boolean5(), _null6(), array2(jsonSchema), record2(string5(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess2(fn, schema) {
  return pipe2(transform2(fn), schema);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/compat.js
var ZodIssueCode2 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap2(map3) {
  config2({
    customError: map3
  });
}
function getErrorMap2() {
  return config2().customError;
}
var ZodFirstPartyTypeKind2;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/coerce.js
var coerce_exports2 = {};
__export(coerce_exports2, {
  bigint: () => bigint6,
  boolean: () => boolean6,
  date: () => date8,
  number: () => number6,
  string: () => string6
});
function string6(params) {
  return _coercedString2(ZodString2, params);
}
function number6(params) {
  return _coercedNumber2(ZodNumber2, params);
}
function boolean6(params) {
  return _coercedBoolean2(ZodBoolean2, params);
}
function bigint6(params) {
  return _coercedBigint2(ZodBigInt2, params);
}
function date8(params) {
  return _coercedDate2(ZodDate2, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
config2(en_default2());

// node_modules/@opencode-ai/plugin/dist/tool.js
function tool(input) {
  return input;
}
tool.schema = external_exports2;

// src/gateway/index.ts
import { spawnSync as spawnSync7 } from "node:child_process";
import { createHash as createHash15, randomUUID as randomUUID18 } from "node:crypto";
import * as fs47 from "node:fs";
import { createServer } from "node:http";
import * as os7 from "node:os";
import * as path48 from "node:path";
import WebSocket2, { WebSocketServer } from "ws";

// src/channels/service.ts
import * as fs16 from "node:fs";
import * as path16 from "node:path";
import { createHash as createHash5, randomUUID as randomUUID3 } from "node:crypto";

// src/channel/outbound/shared.ts
import { createHash, randomUUID } from "node:crypto";
import * as fs9 from "node:fs";
function safeValueFromSignal(signal, key) {
  const matched = new RegExp(`${key}=([^|]*)`).exec(signal)?.[1];
  if (matched == null) return void 0;
  const text = matched.trim();
  return text.length > 0 ? text : void 0;
}
function deriveDesktopFailureDetail(input) {
  return safeValueFromSignal(input.signal, "error") ?? (input.stderr.trim() || void 0) ?? (input.stdout.trim() || void 0) ?? (input.timedOut ? "timeout" : `exit_${input.exitCode}`);
}
function buildEvidenceDir(projectDir, channel) {
  const root = getMiyaVisionTempDir(projectDir, channel);
  fs9.mkdirSync(root, { recursive: true });
  return root;
}
async function sendDesktopOutbound(input) {
  const destination = input.destination.trim();
  const text = (input.text ?? "").trim();
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = createHash("sha256").update(`${text}||${mediaPath}`).digest("hex");
  const traceID = `desktop_${randomUUID()}`;
  const evidenceDir = buildEvidenceDir(input.projectDir, input.channel);
  if (process.platform !== "win32") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_windows_only",
      receiptStatus: "uncertain",
      failureStep: "preflight.platform",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (process.env.MIYA_UI_AUTOMATION_ENABLED !== "1") {
    return Promise.resolve({
      sent: false,
      message: "desktop_ui_disabled:set MIYA_UI_AUTOMATION_ENABLED=1",
      receiptStatus: "uncertain",
      failureStep: "preflight.runtime_switch",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  if (!destination || !text && !mediaPath) {
    return Promise.resolve({
      sent: false,
      message: "invalid_desktop_send_args",
      receiptStatus: "uncertain",
      failureStep: "preflight.args",
      payloadHash,
      recipientTextCheck: "uncertain"
    });
  }
  const script = `
$ErrorActionPreference = 'Stop'
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
Add-Type @"
using System;
using System.Runtime.InteropServices;
public static class MiyaInputProbe {
  [StructLayout(LayoutKind.Sequential)]
  public struct POINT { public int X; public int Y; }
  [DllImport("user32.dll")]
  public static extern bool GetCursorPos(out POINT point);
  [DllImport("user32.dll")]
  public static extern short GetAsyncKeyState(int vKey);
}
"@

$destination = $env:MIYA_DESTINATION
$payload = $env:MIYA_MESSAGE
$mediaPath = $env:MIYA_MEDIA_PATH
$appName = $env:MIYA_APP_NAME
$payloadHash = $env:MIYA_PAYLOAD_HASH
$traceId = $env:MIYA_TRACE_ID
$evidenceDir = $env:MIYA_EVIDENCE_DIR
$shell = New-Object -ComObject WScript.Shell

$step = "bootstrap"
$precheck = "unavailable"
$postcheck = "unavailable"
$receipt = "uncertain"
$recipientCheck = "uncertain"
$preShot = ""
$postShot = ""
$windowFingerprint = ""

function Save-Screenshot {
  param([string]$TargetPath)
  try {
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing
    $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
    $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
    $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
    $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)
    $bitmap.Save($TargetPath, [System.Drawing.Imaging.ImageFormat]::Png)
    $graphics.Dispose()
    $bitmap.Dispose()
  } catch {}
}

function Get-CursorPoint {
  $point = New-Object MiyaInputProbe+POINT
  [void][MiyaInputProbe]::GetCursorPos([ref]$point)
  return @{ X = [int]$point.X; Y = [int]$point.Y }
}

function Test-KeyboardActivity {
  $keys = @(0x08,0x09,0x0D,0x10,0x11,0x12,0x1B,0x20,0x25,0x26,0x27,0x28,0x2E,0x5B,0x5C)
  foreach ($vk in $keys) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  for ($vk = 0x30; $vk -le 0x5A; $vk++) {
    if (([MiyaInputProbe]::GetAsyncKeyState($vk) -band 0x8000) -ne 0) { return $true }
  }
  return $false
}

function Wait-UserInputIdle {
  param([int]$TimeoutMs = 1200, [int]$StableMs = 350, [int]$SampleMs = 60)
  $deadline = (Get-Date).AddMilliseconds($TimeoutMs)
  $idleSince = Get-Date
  $last = Get-CursorPoint
  while ((Get-Date) -lt $deadline) {
    Start-Sleep -Milliseconds $SampleMs
    $curr = Get-CursorPoint
    $moved = ([Math]::Abs($curr.X - $last.X) + [Math]::Abs($curr.Y - $last.Y)) -gt 2
    $typing = Test-KeyboardActivity
    if ($moved -or $typing) {
      $idleSince = Get-Date
      $last = $curr
      continue
    }
    if (((Get-Date) - $idleSince).TotalMilliseconds -ge $StableMs) {
      return $curr
    }
    $last = $curr
  }
  throw "input_mutex_timeout:user_active"
}

function Assert-NoUserInterference {
  param($LockPoint)
  $curr = Get-CursorPoint
  $moved = ([Math]::Abs($curr.X - $LockPoint.X) + [Math]::Abs($curr.Y - $LockPoint.Y)) -gt 6
  if ($moved -or (Test-KeyboardActivity)) {
    throw "input_mutex_timeout:user_interference"
  }
}

try {
  if (-not (Test-Path -LiteralPath $evidenceDir)) {
    New-Item -ItemType Directory -Path $evidenceDir -Force | Out-Null
  }

  $step = "bootstrap.process"
  $lockPoint = Wait-UserInputIdle
$proc = Get-Process -Name $appName -ErrorAction SilentlyContinue | Select-Object -First 1
if (-not $proc) {
  Start-Process -FilePath $appName | Out-Null
  Start-Sleep -Milliseconds 1200
}

$step = "precheck.activate_window"
$activated = $shell.AppActivate($destination)
if (-not $activated) {
  $activated = $shell.AppActivate($appName)
}
if (-not $activated) {
  throw "window_not_found:$destination"
}
$precheck = "window_activated"
Assert-NoUserInterference -LockPoint $lockPoint

$step = "precheck.capture"
$preShot = Join-Path $evidenceDir ($traceId + "_pre.png")
Save-Screenshot -TargetPath $preShot

$activeByDestination = $shell.AppActivate($destination)
if (-not $activeByDestination) {
  $activeByDestination = $false
}
$windowProc = Get-Process -Name $appName -ErrorAction SilentlyContinue | Select-Object -First 1
$windowTitle = ""
if ($windowProc -and $windowProc.MainWindowTitle) {
  $windowTitle = $windowProc.MainWindowTitle
}
$windowFingerprint = ($appName + ":" + [string]($windowProc.Id) + ":" + $windowTitle.Replace('|', '/'))
if ($windowTitle -like ("*" + $destination + "*")) {
  $recipientCheck = "matched"
} elseif ($activeByDestination) {
  $recipientCheck = "matched"
} else {
  $recipientCheck = "uncertain"
}

if ($mediaPath) {
  Assert-NoUserInterference -LockPoint $lockPoint
  $step = "send.media_prepare"
  if (-not (Test-Path -LiteralPath $mediaPath)) {
    throw "media_not_found:$mediaPath"
  }
  $list = New-Object System.Collections.Specialized.StringCollection
  $list.Add($mediaPath) | Out-Null
  $data = New-Object System.Windows.Forms.DataObject
  $data.SetFileDropList($list)
  [System.Windows.Forms.Clipboard]::SetDataObject($data, $true)
  Start-Sleep -Milliseconds 220
  [System.Windows.Forms.SendKeys]::SendWait('^v')
  $step = "send.media_commit"
  Start-Sleep -Milliseconds 220
  [System.Windows.Forms.SendKeys]::SendWait('{ENTER}')
  Start-Sleep -Milliseconds 240
}

if ($payload) {
  Assert-NoUserInterference -LockPoint $lockPoint
  $step = "send.text_prepare"
  Set-Clipboard -Value $payload
  Start-Sleep -Milliseconds 180
  [System.Windows.Forms.SendKeys]::SendWait('^v')
  $step = "send.text_commit"
  Start-Sleep -Milliseconds 120
  [System.Windows.Forms.SendKeys]::SendWait('{ENTER}')
}

$step = "postcheck.activate"
if (-not $shell.AppActivate($appName)) {
  throw "postcheck_window_not_active:$appName"
}
$postcheck = "window_active_after_send"
$receipt = "confirmed"
$step = "postcheck.capture"
$postShot = Join-Path $evidenceDir ($traceId + "_post.png")
Save-Screenshot -TargetPath $postShot

Write-Output ("desktop_send_ok|step=" + $step + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFingerprint.Replace('|', '/') + "|pre_shot=" + $preShot.Replace('|', '/') + "|post_shot=" + $postShot.Replace('|', '/') + "|payload=" + $payloadHash)
exit 0
} catch {
  $err = $_.Exception.Message.Replace('|', '/')
  Write-Output ("desktop_send_fail|step=" + $step + "|error=" + $err + "|pre=" + $precheck + "|post=" + $postcheck + "|receipt=" + $receipt + "|recipient=" + $recipientCheck + "|window_fp=" + $windowFingerprint.Replace('|', '/') + "|pre_shot=" + $preShot.Replace('|', '/') + "|post_shot=" + $postShot.Replace('|', '/') + "|payload=" + $payloadHash)
  exit 2
}
`.trim();
  const result = await runProcess(
    "powershell",
    [
      "-NoProfile",
      "-NonInteractive",
      "-ExecutionPolicy",
      "Bypass",
      "-Command",
      script
    ],
    {
      env: {
        ...process.env,
        MIYA_DESTINATION: destination,
        MIYA_MESSAGE: text,
        MIYA_MEDIA_PATH: mediaPath,
        MIYA_APP_NAME: input.appName,
        MIYA_PAYLOAD_HASH: payloadHash,
        MIYA_TRACE_ID: traceID,
        MIYA_EVIDENCE_DIR: evidenceDir
      },
      windowsHide: true,
      timeoutMs: 15e3
    }
  );
  const timedOut = result.timedOut;
  const exitCode = result.exitCode;
  const stdout = result.stdout.trim();
  const stderr = result.stderr.trim();
  const signal = stdout || stderr;
  const precheck = safeValueFromSignal(signal, "pre") ?? "failed";
  const postcheck = safeValueFromSignal(signal, "post") ?? "failed";
  const receipt = safeValueFromSignal(signal, "receipt") === "confirmed" ? "confirmed" : "uncertain";
  const failureStep = safeValueFromSignal(signal, "step") ?? "send.unknown";
  const windowFingerprint = safeValueFromSignal(signal, "window_fp");
  const recipientTextCheckRaw = safeValueFromSignal(signal, "recipient");
  const recipientTextCheck = recipientTextCheckRaw === "matched" || recipientTextCheckRaw === "mismatch" ? recipientTextCheckRaw : "uncertain";
  const preSendScreenshotPath = safeValueFromSignal(signal, "pre_shot");
  const postSendScreenshotPath = safeValueFromSignal(signal, "post_shot");
  const payloadFromSignal = safeValueFromSignal(signal, "payload") ?? payloadHash;
  if (exitCode === 0 && stdout.includes("desktop_send_ok") && !timedOut) {
    return {
      sent: true,
      message: `${input.channel}_desktop_sent`,
      visualPrecheck: precheck,
      visualPostcheck: postcheck,
      receiptStatus: receipt,
      payloadHash: payloadFromSignal,
      windowFingerprint,
      recipientTextCheck,
      preSendScreenshotPath,
      postSendScreenshotPath,
      failureStep
    };
  }
  const detail = deriveDesktopFailureDetail({
    signal,
    stdout,
    stderr,
    timedOut,
    exitCode
  });
  return {
    sent: false,
    message: `${input.channel}_desktop_send_failed:${detail}`,
    visualPrecheck: precheck,
    visualPostcheck: postcheck,
    receiptStatus: receipt,
    failureStep,
    payloadHash: payloadFromSignal,
    windowFingerprint,
    recipientTextCheck,
    preSendScreenshotPath,
    postSendScreenshotPath
  };
}

// src/channel/outbound/qq.ts
async function sendQqDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "QQ",
    channel: "qq",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath
  });
}

// src/channel/outbound/wechat.ts
async function sendWechatDesktopMessage(input) {
  return await sendDesktopOutbound({
    projectDir: input.projectDir,
    appName: "WeChat",
    channel: "wechat",
    destination: input.destination,
    text: input.text,
    mediaPath: input.mediaPath
  });
}

// src/multimodal/vision.ts
import * as fs13 from "node:fs";
import * as os4 from "node:os";

// src/media/store.ts
import * as fs11 from "node:fs";
import * as path12 from "node:path";
import { randomUUID as randomUUID2 } from "node:crypto";

// src/security/system-keyring.ts
import { createCipheriv, createDecipheriv, createHash as createHash2, randomBytes } from "node:crypto";
import { spawnSync as spawnSync3 } from "node:child_process";
import * as fs10 from "node:fs";
import * as path11 from "node:path";
function keyFile(projectDir) {
  return path11.join(getMiyaRuntimeDir(projectDir), "security", "master.key");
}
function ensureDir4(file3) {
  fs10.mkdirSync(path11.dirname(file3), { recursive: true });
}
function toBase64(text) {
  return Buffer.from(text, "utf-8").toString("base64");
}
function fromBase64(base645) {
  return Buffer.from(base645, "base64").toString("utf-8");
}
function hasPowerShell() {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const result = spawnSync3(shell, ["-NoProfile", "-NonInteractive", "-Command", "$PSVersionTable.PSVersion.ToString()"], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 1500
  });
  return result.status === 0;
}
function encryptWithDpapi(plainText) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const script = [
    `$plain = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('${toBase64(plainText)}'))`,
    "$secure = ConvertTo-SecureString -String $plain -AsPlainText -Force",
    "ConvertFrom-SecureString -SecureString $secure"
  ].join("; ");
  const result = spawnSync3(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2e3
  });
  if (result.status !== 0) return null;
  const out = result.stdout.trim();
  return out.length > 0 ? out : null;
}
function decryptWithDpapi(blob) {
  const shell = process.platform === "win32" ? "powershell" : "pwsh";
  const escaped = blob.replace(/'/g, "''");
  const script = [
    `$secure = ConvertTo-SecureString '${escaped}'`,
    "$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secure)",
    "$plain = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)",
    "[Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)",
    "[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($plain))"
  ].join("; ");
  const result = spawnSync3(shell, ["-NoProfile", "-NonInteractive", "-Command", script], {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8",
    timeout: 2e3
  });
  if (result.status !== 0) return null;
  const out = result.stdout.trim();
  if (!out) return null;
  try {
    return fromBase64(out);
  } catch {
    return null;
  }
}
function deriveFallbackKey(projectDir) {
  const file3 = keyFile(projectDir);
  if (fs10.existsSync(file3)) {
    return fs10.readFileSync(file3);
  }
  const entropy = randomBytes(32);
  ensureDir4(file3);
  fs10.writeFileSync(file3, entropy);
  return entropy;
}
function encryptFallback(projectDir, plainText) {
  const key = deriveFallbackKey(projectDir);
  const iv = randomBytes(12);
  const cipher = createCipheriv("aes-256-gcm", createHash2("sha256").update(key).digest(), iv);
  const payload = Buffer.concat([cipher.update(plainText, "utf-8"), cipher.final()]);
  return {
    version: 1,
    alg: "aes256gcm",
    payload: payload.toString("base64"),
    iv: iv.toString("base64"),
    tag: cipher.getAuthTag().toString("base64")
  };
}
function decryptFallback(projectDir, envelope) {
  if (!envelope.iv || !envelope.tag) return null;
  try {
    const key = deriveFallbackKey(projectDir);
    const decipher = createDecipheriv(
      "aes-256-gcm",
      createHash2("sha256").update(key).digest(),
      Buffer.from(envelope.iv, "base64")
    );
    decipher.setAuthTag(Buffer.from(envelope.tag, "base64"));
    const plain = Buffer.concat([
      decipher.update(Buffer.from(envelope.payload, "base64")),
      decipher.final()
    ]);
    return plain.toString("utf-8");
  } catch {
    return null;
  }
}
function encodeEnvelope(envelope) {
  return `miya-sec:${Buffer.from(JSON.stringify(envelope), "utf-8").toString("base64")}`;
}
function decodeEnvelope(raw) {
  if (!raw.startsWith("miya-sec:")) return null;
  const body = raw.slice("miya-sec:".length);
  try {
    const parsed = JSON.parse(Buffer.from(body, "base64").toString("utf-8"));
    if (!parsed || parsed.version !== 1) return null;
    return parsed;
  } catch {
    return null;
  }
}
function encryptSensitiveValue(projectDir, plainText) {
  const normalized = String(plainText ?? "");
  if (!normalized) return normalized;
  if (process.platform === "win32" && hasPowerShell()) {
    const dpapi = encryptWithDpapi(normalized);
    if (dpapi) {
      return encodeEnvelope({
        version: 1,
        alg: "dpapi",
        payload: dpapi
      });
    }
  }
  return encodeEnvelope(encryptFallback(projectDir, normalized));
}
function decryptSensitiveValue(projectDir, rawValue) {
  const raw = String(rawValue ?? "");
  if (!raw.startsWith("miya-sec:")) return raw;
  const envelope = decodeEnvelope(raw);
  if (!envelope) return raw;
  if (envelope.alg === "dpapi") {
    const decoded = decryptWithDpapi(envelope.payload);
    return decoded ?? raw;
  }
  const fallback = decryptFallback(projectDir, envelope);
  return fallback ?? raw;
}

// src/media/store.ts
var DEFAULT_TTL_HOURS = 24;
function nowIso3() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function mediaDir(projectDir) {
  return path12.join(getMiyaRuntimeDir(projectDir), "media");
}
function mediaIndexFile(projectDir) {
  return path12.join(mediaDir(projectDir), "index.json");
}
function ensureDir5(dirPath) {
  fs11.mkdirSync(dirPath, { recursive: true });
}
function decodeMetadata(projectDir, metadata) {
  if (!metadata || typeof metadata !== "object") return metadata;
  if (typeof metadata.secure === "string") {
    try {
      const plain = decryptSensitiveValue(projectDir, metadata.secure);
      const parsed = JSON.parse(plain);
      return parsed;
    } catch {
      return metadata;
    }
  }
  return metadata;
}
function readStore(projectDir) {
  const file3 = mediaIndexFile(projectDir);
  if (!fs11.existsSync(file3)) {
    return { items: {} };
  }
  try {
    const parsed = JSON.parse(fs11.readFileSync(file3, "utf-8"));
    const items = {};
    for (const [id, item] of Object.entries(parsed.items ?? {})) {
      items[id] = {
        ...item,
        source: decryptSensitiveValue(projectDir, String(item.source ?? "")),
        fileName: decryptSensitiveValue(projectDir, String(item.fileName ?? "")),
        localPath: typeof item.localPath === "string" ? decryptSensitiveValue(projectDir, item.localPath) : item.localPath,
        metadata: decodeMetadata(projectDir, item.metadata)
      };
    }
    return { items };
  } catch {
    return { items: {} };
  }
}
function writeStore(projectDir, store2) {
  ensureDir5(mediaDir(projectDir));
  const encrypted = { items: {} };
  for (const [id, item] of Object.entries(store2.items)) {
    encrypted.items[id] = {
      ...item,
      source: encryptSensitiveValue(projectDir, item.source),
      fileName: encryptSensitiveValue(projectDir, item.fileName),
      localPath: item.localPath ? encryptSensitiveValue(projectDir, item.localPath) : item.localPath,
      metadata: item.metadata ? {
        secure: encryptSensitiveValue(projectDir, JSON.stringify(item.metadata))
      } : item.metadata
    };
  }
  fs11.writeFileSync(
    mediaIndexFile(projectDir),
    `${JSON.stringify(encrypted, null, 2)}
`,
    "utf-8"
  );
}
function buildExpiration(ttlHours) {
  const expires = new Date(Date.now() + ttlHours * 3600 * 1e3);
  return expires.toISOString();
}
function ingestMedia(projectDir, input) {
  const ttlHours = Math.max(1, input.ttlHours ?? DEFAULT_TTL_HOURS);
  const store2 = readStore(projectDir);
  const id = `media_${randomUUID2()}`;
  let localPath;
  if (input.contentBase64) {
    const dir = mediaDir(projectDir);
    ensureDir5(dir);
    const ext = path12.extname(input.fileName) || ".bin";
    const filePath14 = path12.join(dir, `${id}${ext}`);
    fs11.writeFileSync(filePath14, Buffer.from(input.contentBase64, "base64"));
    localPath = filePath14;
  }
  const item = {
    id,
    source: input.source,
    kind: input.kind,
    mimeType: input.mimeType,
    fileName: input.fileName,
    localPath,
    sizeBytes: input.sizeBytes,
    createdAt: nowIso3(),
    expiresAt: buildExpiration(ttlHours),
    metadata: input.metadata
  };
  store2.items[id] = item;
  writeStore(projectDir, store2);
  return item;
}
function getMediaItem(projectDir, mediaID) {
  const store2 = readStore(projectDir);
  return store2.items[mediaID] ?? null;
}
function listMediaItems(projectDir, limit = 100) {
  const store2 = readStore(projectDir);
  return Object.values(store2.items).sort((a, b) => Date.parse(b.createdAt) - Date.parse(a.createdAt)).slice(0, Math.max(1, limit));
}
function runMediaGc(projectDir) {
  const store2 = readStore(projectDir);
  const now = Date.now();
  let removed = 0;
  for (const [id, item] of Object.entries(store2.items)) {
    const expired = Date.parse(item.expiresAt) <= now;
    if (!expired) continue;
    if (item.localPath && fs11.existsSync(item.localPath)) {
      try {
        fs11.unlinkSync(item.localPath);
      } catch {
      }
    }
    delete store2.items[id];
    removed += 1;
  }
  writeStore(projectDir, store2);
  return {
    removed,
    kept: Object.keys(store2.items).length
  };
}

// src/multimodal/ocr-cache.ts
import { createHash as createHash3 } from "node:crypto";
import * as fs12 from "node:fs";
import * as path13 from "node:path";
var MAX_CACHE_ITEMS = 500;
function nowIso4() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath2(projectDir) {
  return path13.join(getMiyaRuntimeDir(projectDir), "ocr-cache.json");
}
function ensureDir6(projectDir) {
  fs12.mkdirSync(path13.dirname(filePath2(projectDir)), { recursive: true });
}
function readStore2(projectDir) {
  const file3 = filePath2(projectDir);
  if (!fs12.existsSync(file3)) return { entries: [] };
  try {
    const parsed = JSON.parse(fs12.readFileSync(file3, "utf-8"));
    return {
      entries: Array.isArray(parsed.entries) ? parsed.entries : []
    };
  } catch {
    return { entries: [] };
  }
}
function writeStore2(projectDir, store2) {
  ensureDir6(projectDir);
  fs12.writeFileSync(filePath2(projectDir), `${JSON.stringify(store2, null, 2)}
`, "utf-8");
}
function toKey(mediaID, question) {
  return createHash3("sha1").update(`${mediaID}::${question.trim().toLowerCase()}`).digest("hex");
}
function readOcrCoordinateCache(projectDir, input) {
  const question = input.question?.trim() ?? "";
  const key = toKey(input.mediaID, question);
  const store2 = readStore2(projectDir);
  const hit = store2.entries.find((entry2) => entry2.key === key) ?? null;
  if (!hit) return null;
  hit.usedAt = nowIso4();
  writeStore2(projectDir, store2);
  return hit;
}
function writeOcrCoordinateCache(projectDir, input) {
  const question = input.question?.trim() ?? "";
  const key = toKey(input.mediaID, question);
  const store2 = readStore2(projectDir);
  const next = {
    key,
    mediaID: input.mediaID,
    question,
    boxes: input.boxes,
    summary: input.summary,
    createdAt: nowIso4(),
    usedAt: nowIso4()
  };
  const deduped = store2.entries.filter((entry2) => entry2.key !== key);
  store2.entries = [next, ...deduped].sort((a, b) => Date.parse(b.usedAt) - Date.parse(a.usedAt)).slice(0, MAX_CACHE_ITEMS);
  writeStore2(projectDir, store2);
}

// src/multimodal/vision.ts
function summarizeFromMetadata(metadata) {
  if (!metadata) return "No metadata available for vision summary.";
  const caption = typeof metadata.caption === "string" ? metadata.caption : typeof metadata.description === "string" ? metadata.description : "";
  const tags = Array.isArray(metadata.tags) ? metadata.tags.filter((item) => typeof item === "string").join(", ") : "";
  if (caption && tags) return `${caption} (tags: ${tags})`;
  if (caption) return caption;
  if (tags) return `tags: ${tags}`;
  return "Image metadata found but no caption/tags were provided.";
}
async function commandExists(command) {
  const probe = process.platform === "win32" ? ["where", command] : ["which", command];
  const result = await runProcess(probe[0], probe.slice(1), { timeoutMs: 3e3 });
  return !result.timedOut && result.exitCode === 0;
}
async function runTesseractOcr(imagePath) {
  if (!await commandExists("tesseract")) return "";
  const args = process.platform === "win32" ? ["tesseract", imagePath, "stdout", "--psm", "6"] : ["tesseract", imagePath, "stdout", "--psm", "6"];
  const result = await runProcess(args[0], args.slice(1), { timeoutMs: 8e3 });
  if (result.timedOut || result.exitCode !== 0) return "";
  return result.stdout.trim();
}
async function runRemoteVisionInference(imagePath, question) {
  const endpoint = process.env.MIYA_VISION_OCR_ENDPOINT?.trim();
  if (!endpoint) return { text: "" };
  if (!fs13.existsSync(imagePath)) return { text: "" };
  const image = fs13.readFileSync(imagePath);
  const mimeType = imagePath.endsWith(".png") ? "image/png" : imagePath.endsWith(".jpg") || imagePath.endsWith(".jpeg") ? "image/jpeg" : "application/octet-stream";
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        imageBase64: image.toString("base64"),
        mimeType,
        question: question ?? ""
      })
    });
    if (!response.ok) return { text: "" };
    const payload = await response.json();
    const text = String(payload.text ?? payload.ocr_text ?? "").trim();
    return {
      text,
      summary: payload.summary ? String(payload.summary) : void 0,
      boxes: Array.isArray(payload.boxes) ? payload.boxes : void 0
    };
  } catch {
    return { text: "" };
  }
}
async function readTextFromImage(imagePath, question) {
  const remote = await runRemoteVisionInference(imagePath, question);
  if (remote.text) {
    return {
      source: "remote_vlm",
      text: remote.text,
      summary: remote.summary,
      boxes: remote.boxes
    };
  }
  const tesseractText = await runTesseractOcr(imagePath);
  if (tesseractText) {
    return {
      source: "tesseract",
      text: tesseractText
    };
  }
  return {
    source: "none",
    text: ""
  };
}
var CAPTURE_PRIORITY = [
  "wgc_hwnd",
  "print_window",
  "dxgi_duplication",
  "uia_only"
];
function normalizeCaptureMethod(input) {
  const raw = String(input ?? "").trim().toLowerCase();
  if (!raw) return null;
  if (raw === "wgc" || raw === "wgc_hwnd") return "wgc_hwnd";
  if (raw === "printwindow" || raw === "print_window") return "print_window";
  if (raw === "dxgi" || raw === "dxgi_duplication") return "dxgi_duplication";
  if (raw === "uia" || raw === "uia_only") return "uia_only";
  if (raw === "unknown") return "unknown";
  return null;
}
function parseCaptureMethods(input) {
  const raw = String(input ?? "").trim();
  if (!raw) return [...CAPTURE_PRIORITY];
  const methods = raw.split(",").map((item) => normalizeCaptureMethod(item)).filter((item) => Boolean(item) && item !== "unknown");
  if (methods.length === 0) return [...CAPTURE_PRIORITY];
  return [...new Set(methods)];
}
function inferCaptureProbeLimitations(input) {
  const signal = `${input.visualPrecheck ?? ""}|${input.visualPostcheck ?? ""}`.toLowerCase();
  const result = [];
  if (!signal.trim()) return result;
  if (signal.includes("black")) result.push("capture_probe_black_screen");
  if (signal.includes("timeout")) result.push("capture_probe_timeout");
  if (signal.includes("error") || signal.includes("failed")) result.push("capture_probe_error");
  if (signal.includes("occluded")) result.push("capture_probe_occluded");
  return [...new Set(result)];
}
function compactOcrText(text) {
  return (text || "").replace(/\s+/g, "").toLowerCase();
}
function parseDesktopOcrSignals(ocrText, expectedRecipient) {
  const normalized = (ocrText || "").replace(/\s+/g, " ").trim();
  const recipient = expectedRecipient.trim();
  const lowered = normalized.toLowerCase();
  const compactNormalized = compactOcrText(normalized);
  const compactRecipient = compactOcrText(recipient);
  const recipientDetected = recipient && (normalized.includes(recipient) || lowered.includes(recipient.toLowerCase()) || compactRecipient.length > 0 && compactNormalized.includes(compactRecipient)) ? recipient : "";
  const sentHints = [
    "\u53D1\u9001\u6210\u529F",
    "\u5DF2\u53D1\u9001",
    "sent",
    "delivered",
    "\u53D1\u9001",
    "\u5DF2\u53D1\u51FA"
  ];
  const failHints = [
    "\u53D1\u9001\u5931\u8D25",
    "failed",
    "\u5931\u8D25",
    "retry",
    "\u91CD\u8BD5",
    "\u672A\u53D1\u9001"
  ];
  const hasSent = sentHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const hasFail = failHints.some((item) => {
    const loweredHint = item.toLowerCase();
    return lowered.includes(loweredHint) || compactNormalized.includes(compactOcrText(loweredHint));
  });
  const sendStatusDetected = hasFail ? "failed" : hasSent ? "sent" : "uncertain";
  let recipientMatch = "uncertain";
  if (recipientDetected) {
    recipientMatch = "matched";
  } else if (recipient && normalized.length > 0) {
    recipientMatch = "mismatch";
  }
  return {
    recipientDetected,
    recipientMatch,
    sendStatusDetected
  };
}
async function analyzeDesktopOutboundEvidence(input) {
  const capture = resolveCaptureCapability(input);
  const candidates = [
    input.postSendScreenshotPath,
    input.preSendScreenshotPath
  ].filter((item) => typeof item === "string" && fs13.existsSync(item));
  if (candidates.length === 0) {
    const recipientMatch = input.recipientTextCheck ?? "uncertain";
    const sendStatusDetected = input.receiptStatus === "confirmed" ? "sent" : "uncertain";
    return {
      recipientMatch,
      sendStatusDetected,
      ocrSource: "none",
      ocrPreview: "",
      uiStyleMismatch: true,
      retries: 0,
      capture: {
        method: capture.method,
        confidence: capture.confidence,
        limitations: mergeCaptureLimitations(capture.limitations, {
          uiStyleMismatch: true,
          recipientMatch,
          sendStatusDetected
        })
      }
    };
  }
  const isLowConfidenceText = (text) => {
    const trimmed = (text || "").replace(/\s+/g, "");
    if (trimmed.length < 8) return true;
    const meaningful = trimmed.replace(/[a-zA-Z0-9\u4e00-\u9fa5]/g, "");
    const noiseRatio = meaningful.length / Math.max(1, trimmed.length);
    return noiseRatio > 0.6;
  };
  let inferred = await readTextFromImage(candidates[0], "\u8BC6\u522B\u804A\u5929\u754C\u9762\u6536\u4EF6\u4EBA\u4E0E\u53D1\u9001\u72B6\u6001");
  let signals = parseDesktopOcrSignals(inferred.text, input.destination);
  let retries = 0;
  let uiStyleMismatch = inferred.source === "none" || signals.recipientMatch !== "matched" && isLowConfidenceText(inferred.text);
  if (candidates.length > 1 && (signals.recipientMatch === "mismatch" || uiStyleMismatch)) {
    const retryInferred = await readTextFromImage(
      candidates[1],
      "DPI\u6837\u5F0F\u517C\u5BB9\u91CD\u8BD5\uFF1A\u8BC6\u522B\u804A\u5929\u754C\u9762\u6536\u4EF6\u4EBA\u4E0E\u53D1\u9001\u72B6\u6001"
    );
    const retrySignals = parseDesktopOcrSignals(retryInferred.text, input.destination);
    retries = 1;
    const retryBetter = retrySignals.recipientMatch === "matched" || retrySignals.sendStatusDetected !== "uncertain" && signals.sendStatusDetected === "uncertain" || !isLowConfidenceText(retryInferred.text) && isLowConfidenceText(inferred.text);
    if (retryBetter) {
      inferred = retryInferred;
      signals = retrySignals;
    }
    uiStyleMismatch = (inferred.source === "none" || isLowConfidenceText(inferred.text)) && signals.recipientMatch !== "matched";
  }
  const mergedRecipient = signals.recipientMatch === "mismatch" && input.recipientTextCheck === "matched" ? "matched" : signals.recipientMatch === "uncertain" ? input.recipientTextCheck ?? "uncertain" : signals.recipientMatch;
  const mergedStatus = signals.sendStatusDetected === "uncertain" ? input.receiptStatus === "confirmed" ? "sent" : "uncertain" : signals.sendStatusDetected;
  const stableRecipient = uiStyleMismatch && mergedRecipient === "mismatch" ? "uncertain" : mergedRecipient;
  const confidence = estimateEvidenceConfidence({
    ocrSource: inferred.source,
    uiStyleMismatch,
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    retries
  });
  const mergedConfidence = Number(Math.min(confidence, capture.confidence).toFixed(2));
  if (mergedConfidence < 0.45) {
    uiStyleMismatch = true;
  }
  return {
    recipientMatch: stableRecipient,
    sendStatusDetected: mergedStatus,
    ocrSource: inferred.source,
    ocrPreview: inferred.text.slice(0, 300),
    uiStyleMismatch,
    retries,
    capture: {
      method: capture.method,
      confidence: mergedConfidence,
      limitations: mergeCaptureLimitations(capture.limitations, {
        uiStyleMismatch,
        recipientMatch: stableRecipient,
        sendStatusDetected: mergedStatus
      })
    }
  };
}
function resolveCaptureCapability(input) {
  const hasScreenshots = typeof input.preSendScreenshotPath === "string" && input.preSendScreenshotPath.length > 0 && fs13.existsSync(input.preSendScreenshotPath) || typeof input.postSendScreenshotPath === "string" && input.postSendScreenshotPath.length > 0 && fs13.existsSync(input.postSendScreenshotPath);
  const supported = parseCaptureMethods(process.env.MIYA_CAPTURE_CAPABILITIES);
  const preferred = CAPTURE_PRIORITY.find((item) => supported.includes(item));
  const requested = normalizeCaptureMethod(process.env.MIYA_CAPTURE_METHOD);
  let method = "unknown";
  if (hasScreenshots) {
    if (requested && supported.includes(requested)) {
      method = requested;
    } else if (preferred) {
      method = preferred;
    } else {
      method = "unknown";
    }
  } else {
    method = supported.includes("uia_only") ? "uia_only" : "unknown";
  }
  const limitations = [];
  limitations.push(...inferCaptureProbeLimitations(input));
  if (!hasScreenshots) {
    limitations.push("no_desktop_screenshot");
  }
  if (requested && requested !== "unknown" && !supported.includes(requested)) {
    limitations.push(`capture_method_not_supported:${requested}`);
  }
  if (hasScreenshots && preferred && method !== "unknown" && method !== preferred) {
    limitations.push(`capture_fallback:${preferred}->${method}`);
  }
  if (!hasScreenshots && preferred && preferred !== "uia_only") {
    limitations.push(`capture_tree_exhausted:${preferred}`);
  }
  if (method === "unknown") limitations.push("capture_method_unspecified");
  if (method === "uia_only") limitations.push("pixel_evidence_unavailable");
  const baseByMethod = {
    wgc_hwnd: 0.92,
    print_window: 0.84,
    dxgi_duplication: 0.76,
    uia_only: 0.4,
    unknown: 0.24
  };
  let confidence = baseByMethod[method];
  if (!hasScreenshots) {
    confidence = Math.min(confidence, method === "uia_only" ? 0.34 : 0.24);
  }
  if (limitations.includes("capture_probe_black_screen")) {
    confidence = Math.min(confidence, 0.28);
  }
  if (limitations.includes("capture_probe_timeout")) {
    confidence = Math.min(confidence, 0.3);
  }
  if (limitations.includes("capture_probe_error")) {
    confidence = Math.min(confidence, 0.3);
  }
  return {
    method,
    confidence: Number(confidence.toFixed(2)),
    limitations
  };
}
function estimateEvidenceConfidence(input) {
  let score = input.ocrSource === "remote_vlm" ? 0.86 : input.ocrSource === "tesseract" ? 0.72 : 0.35;
  if (input.uiStyleMismatch) score -= 0.32;
  if (input.recipientMatch === "matched") score += 0.08;
  if (input.sendStatusDetected === "sent" || input.sendStatusDetected === "failed") score += 0.04;
  if (input.retries > 0) score -= 0.05;
  if (score < 0) return 0;
  if (score > 1) return 1;
  return Number(score.toFixed(2));
}
function mergeCaptureLimitations(base, input) {
  const result = [...base];
  if (input.uiStyleMismatch) result.push("ui_style_mismatch");
  if (input.recipientMatch === "uncertain") result.push("recipient_unverified");
  if (input.sendStatusDetected === "uncertain") result.push("delivery_unverified");
  return [...new Set(result)];
}
async function analyzeVision(projectDir, input) {
  const cacheHit = readOcrCoordinateCache(projectDir, {
    mediaID: input.mediaID,
    question: input.question
  });
  if (cacheHit) {
    return {
      mediaID: cacheHit.mediaID,
      summary: cacheHit.summary,
      details: {
        cacheHit: true,
        ocrBoxes: cacheHit.boxes
      }
    };
  }
  const media = getMediaItem(projectDir, input.mediaID);
  if (!media) throw new Error("media_not_found");
  if (media.kind !== "image") throw new Error("invalid_vision_media_kind");
  const filePath14 = media.localPath && fs13.existsSync(media.localPath) ? media.localPath : "";
  const ocr = filePath14 ? await readTextFromImage(filePath14, input.question) : { source: "none", text: "" };
  const metadataSummary = summarizeFromMetadata(media.metadata);
  const summary = ocr.summary || ocr.text || metadataSummary;
  const ocrLines = ocr.text.split(/\r?\n/).map((line) => line.trim()).filter(Boolean).slice(0, 6);
  const remoteBoxes = Array.isArray(ocr.boxes) && ocr.boxes.length > 0 ? ocr.boxes.map((item) => ({
    x: Number(item.x ?? 0),
    y: Number(item.y ?? 0),
    width: Number(item.width ?? 0),
    height: Number(item.height ?? 0),
    text: String(item.text ?? "").trim()
  })).filter(
    (item) => Number.isFinite(item.x) && Number.isFinite(item.y) && Number.isFinite(item.width) && Number.isFinite(item.height) && item.text.length > 0
  ) : [];
  const ocrBoxes = remoteBoxes.length > 0 ? remoteBoxes : ocrLines.map((line, index) => ({
    x: 16,
    y: 24 + index * 24,
    width: Math.min(720, 80 + line.length * 8),
    height: 20,
    text: line.slice(0, 240)
  }));
  const finalSummary = input.question?.trim() ? `${summary} | question: ${input.question.trim()}` : summary;
  writeOcrCoordinateCache(projectDir, {
    mediaID: media.id,
    question: input.question,
    boxes: ocrBoxes,
    summary: finalSummary
  });
  return {
    mediaID: media.id,
    summary: finalSummary,
    details: {
      cacheHit: false,
      ocrBoxes,
      inferenceSource: ocr.source,
      ocrPreview: ocr.text.slice(0, 400),
      fileName: media.fileName,
      mimeType: media.mimeType,
      localPath: media.localPath,
      metadata: media.metadata ?? {},
      host: os4.hostname()
    }
  };
}

// src/channels/policy.ts
var OUTBOUND_ALLOWLIST_CHANNELS = /* @__PURE__ */ new Set(["qq", "wechat"]);
function getChannelDirection(channel) {
  return OUTBOUND_ALLOWLIST_CHANNELS.has(channel) ? "OUTBOUND_ALLOWLIST" : "INBOUND_ONLY";
}
function canChannelSend(channel) {
  return getChannelDirection(channel) === "OUTBOUND_ALLOWLIST";
}
function assertChannelCanSend(channel) {
  if (canChannelSend(channel)) return;
  throw new Error(
    `channel_send_blocked:${channel}:INBOUND_ONLY channels are receive-only`
  );
}

// src/channels/pairing-store.ts
import * as fs14 from "node:fs";
import * as path14 from "node:path";

// src/channels/types.ts
var CHANNEL_NAMES = [
  "qq",
  "wechat",
  "telegram",
  "slack",
  "discord",
  "whatsapp",
  "google_chat",
  "signal",
  "imessage",
  "teams",
  "webchat"
];
function isChannelName(value) {
  return typeof value === "string" && CHANNEL_NAMES.includes(value);
}

// src/channels/pairing-store.ts
function nowIso5() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath3(projectDir) {
  return path14.join(getMiyaRuntimeDir(projectDir), "channels.json");
}
function ensureDir7(file3) {
  fs14.mkdirSync(path14.dirname(file3), { recursive: true });
}
function defaultChannelState(name) {
  return {
    name,
    enabled: name === "webchat",
    connected: name === "webchat",
    updatedAt: nowIso5(),
    allowlist: [],
    contactTiers: {}
  };
}
function defaultStore() {
  const channels = {};
  for (const name of CHANNEL_NAMES) {
    channels[name] = defaultChannelState(name);
  }
  return { channels, pairs: [] };
}
function readChannelStore(projectDir) {
  const file3 = filePath3(projectDir);
  if (!fs14.existsSync(file3)) {
    return defaultStore();
  }
  try {
    const parsed = JSON.parse(fs14.readFileSync(file3, "utf-8"));
    const fallback = defaultStore();
    const mergedChannels = {};
    for (const name of CHANNEL_NAMES) {
      const channel = {
        ...fallback.channels[name],
        ...parsed.channels?.[name] ?? {}
      };
      const allowlist = Array.isArray(channel.allowlist) ? channel.allowlist.map((item) => decryptSensitiveValue(projectDir, String(item))) : [];
      const contactTiersRaw = channel.contactTiers && typeof channel.contactTiers === "object" ? channel.contactTiers : {};
      const contactTiers = {};
      for (const [senderID, tier] of Object.entries(contactTiersRaw)) {
        const decoded = decryptSensitiveValue(projectDir, senderID);
        if (tier === "owner" || tier === "friend") {
          contactTiers[decoded] = tier;
        }
      }
      mergedChannels[name] = {
        ...channel,
        allowlist,
        contactTiers
      };
    }
    const pairs = Array.isArray(parsed.pairs) ? parsed.pairs : [];
    return {
      channels: mergedChannels,
      pairs: pairs.map((pair) => ({
        ...pair,
        senderID: decryptSensitiveValue(projectDir, pair.senderID),
        displayName: pair.displayName ? decryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
        messagePreview: pair.messagePreview ? decryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
      }))
    };
  } catch {
    return defaultStore();
  }
}
function writeChannelStore(projectDir, store2) {
  const file3 = filePath3(projectDir);
  ensureDir7(file3);
  const encrypted = {
    channels: Object.fromEntries(
      Object.entries(store2.channels).map(([name, state2]) => {
        const contactTiers = {};
        for (const [senderID, tier] of Object.entries(state2.contactTiers ?? {})) {
          contactTiers[encryptSensitiveValue(projectDir, senderID)] = tier;
        }
        return [
          name,
          {
            ...state2,
            allowlist: state2.allowlist.map(
              (item) => encryptSensitiveValue(projectDir, item)
            ),
            contactTiers
          }
        ];
      })
    ),
    pairs: store2.pairs.map((pair) => ({
      ...pair,
      senderID: encryptSensitiveValue(projectDir, pair.senderID),
      displayName: pair.displayName ? encryptSensitiveValue(projectDir, pair.displayName) : pair.displayName,
      messagePreview: pair.messagePreview ? encryptSensitiveValue(projectDir, pair.messagePreview) : pair.messagePreview
    }))
  };
  fs14.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function listChannelStates(projectDir) {
  const store2 = readChannelStore(projectDir);
  return Object.values(store2.channels).sort((a, b) => a.name.localeCompare(b.name));
}
function upsertChannelState(projectDir, name, patch) {
  const store2 = readChannelStore(projectDir);
  const next = {
    ...store2.channels[name],
    ...patch,
    name,
    updatedAt: nowIso5()
  };
  store2.channels[name] = next;
  writeChannelStore(projectDir, store2);
  return next;
}
function ensurePairRequest(projectDir, input) {
  const store2 = readChannelStore(projectDir);
  const existing = store2.pairs.find(
    (item) => item.channel === input.channel && item.senderID === input.senderID && item.status === "pending"
  );
  if (existing) return existing;
  const next = {
    id: `pair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    channel: input.channel,
    senderID: input.senderID,
    displayName: input.displayName,
    messagePreview: input.messagePreview,
    status: "pending",
    requestedAt: nowIso5()
  };
  store2.pairs = [next, ...store2.pairs].slice(0, 1e3);
  writeChannelStore(projectDir, store2);
  return next;
}
function resolvePairRequest(projectDir, pairID, status) {
  const store2 = readChannelStore(projectDir);
  const pair = store2.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending") return null;
  pair.status = status;
  pair.resolvedAt = nowIso5();
  if (status === "approved") {
    const channel = store2.channels[pair.channel];
    const ownerByEnv = new Set(
      String(process.env.MIYA_OWNER_IDS ?? "").split(",").map((item) => item.trim()).filter(Boolean)
    );
    if (!channel.allowlist.includes(pair.senderID)) {
      channel.allowlist = [...channel.allowlist, pair.senderID].sort();
    }
    const currentTier = channel.contactTiers?.[pair.senderID];
    const resolvedTier = currentTier ?? (ownerByEnv.has(pair.senderID) ? "owner" : "friend");
    channel.contactTiers = {
      ...channel.contactTiers ?? {},
      [pair.senderID]: resolvedTier
    };
    channel.updatedAt = nowIso5();
  }
  writeChannelStore(projectDir, store2);
  return pair;
}
function listPairRequests(projectDir, status) {
  const store2 = readChannelStore(projectDir);
  const pairs = status ? store2.pairs.filter((item) => item.status === status) : store2.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function isSenderAllowed(projectDir, channel, senderID) {
  const store2 = readChannelStore(projectDir);
  const allowed = store2.channels[channel].allowlist;
  return allowed.includes(senderID);
}
function getContactTier(projectDir, channel, senderID) {
  const store2 = readChannelStore(projectDir);
  const state2 = store2.channels[channel];
  if (!state2.allowlist.includes(senderID)) return null;
  return state2.contactTiers?.[senderID] ?? "friend";
}
function setContactTier(projectDir, channel, senderID, tier) {
  const store2 = readChannelStore(projectDir);
  const state2 = store2.channels[channel];
  const allowlist = state2.allowlist.includes(senderID) ? state2.allowlist : [...state2.allowlist, senderID].sort();
  const next = {
    ...state2,
    allowlist,
    contactTiers: {
      ...state2.contactTiers ?? {},
      [senderID]: tier
    },
    updatedAt: nowIso5()
  };
  store2.channels[channel] = next;
  writeChannelStore(projectDir, store2);
  return next;
}
function listContactTiers(projectDir, channel) {
  const store2 = readChannelStore(projectDir);
  const channels = channel ? [channel] : [...CHANNEL_NAMES];
  const rows = [];
  for (const name of channels) {
    const state2 = store2.channels[name];
    const mapping = state2.contactTiers ?? {};
    for (const senderID of state2.allowlist) {
      rows.push({
        channel: name,
        senderID,
        tier: mapping[senderID] ?? "friend"
      });
    }
  }
  return rows.sort(
    (a, b) => `${a.channel}:${a.senderID}`.localeCompare(`${b.channel}:${b.senderID}`)
  );
}

// src/policy/index.ts
import { createHash as createHash4 } from "node:crypto";
import * as fs15 from "node:fs";
import * as path15 from "node:path";
var POLICY_DOMAINS = [
  "outbound_send",
  "desktop_control",
  "shell_exec",
  "fs_write",
  "memory_read",
  "memory_write",
  "memory_delete",
  "training",
  "media_generate",
  "read_only_research",
  "local_build"
];
function nowIso6() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function policyFile(projectDir) {
  return path15.join(getMiyaRuntimeDir(projectDir), "policy.json");
}
function defaultPolicy() {
  return {
    version: 1,
    updatedAt: nowIso6(),
    domains: {
      outbound_send: "running",
      desktop_control: "running",
      shell_exec: "running",
      fs_write: "running",
      memory_read: "running",
      memory_write: "running",
      memory_delete: "running",
      training: "running",
      media_generate: "running",
      read_only_research: "running",
      local_build: "running"
    },
    outbound: {
      allowedChannels: ["qq", "wechat"],
      requireArchAdvisorApproval: true,
      requireAllowlist: true,
      minIntervalMs: 4e3,
      burstWindowMs: 6e4,
      burstLimit: 3,
      duplicateWindowMs: 6e4
    }
  };
}
function readPolicy(projectDir) {
  const file3 = policyFile(projectDir);
  if (!fs15.existsSync(file3)) {
    const base = defaultPolicy();
    fs15.mkdirSync(path15.dirname(file3), { recursive: true });
    fs15.writeFileSync(file3, `${JSON.stringify(base, null, 2)}
`, "utf-8");
    return base;
  }
  try {
    const parsed = JSON.parse(fs15.readFileSync(file3, "utf-8"));
    const base = defaultPolicy();
    const parsedDomains = parsed.domains && typeof parsed.domains === "object" ? parsed.domains : {};
    return {
      ...base,
      ...parsed,
      domains: {
        ...base.domains,
        ...parsedDomains
      },
      outbound: {
        ...base.outbound,
        ...parsed.outbound ?? {}
      }
    };
  } catch {
    return defaultPolicy();
  }
}
function writePolicy(projectDir, patch) {
  const file3 = policyFile(projectDir);
  const current = readPolicy(projectDir);
  const next = {
    ...current,
    ...patch,
    outbound: {
      ...current.outbound,
      ...patch.outbound ?? {}
    },
    updatedAt: nowIso6()
  };
  fs15.mkdirSync(path15.dirname(file3), { recursive: true });
  fs15.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function hashPolicy(policy) {
  return createHash4("sha256").update(
    JSON.stringify({
      version: policy.version,
      domains: policy.domains,
      outbound: policy.outbound
    })
  ).digest("hex");
}
function currentPolicyHash(projectDir) {
  return hashPolicy(readPolicy(projectDir));
}
function assertPolicyHash(projectDir, providedHash) {
  const hash3 = currentPolicyHash(projectDir);
  if (!providedHash) {
    return { ok: false, hash: hash3, reason: "missing_policy_hash" };
  }
  if (providedHash !== hash3) {
    return { ok: false, hash: hash3, reason: "policy_hash_mismatch" };
  }
  return { ok: true, hash: hash3 };
}
function isDomainRunning(projectDir, domain3) {
  const policy = readPolicy(projectDir);
  return policy.domains[domain3] === "running";
}
function isPolicyDomain(value) {
  return typeof value === "string" && POLICY_DOMAINS.includes(value);
}

// src/policy/semantic-tags.ts
var SEMANTIC_TAGS = [
  "window_not_found",
  "window_occluded",
  "recipient_mismatch",
  "input_mutex_timeout",
  "receipt_uncertain",
  "privilege_barrier",
  "ui_style_mismatch"
];
function isSemanticTag(value) {
  return typeof value === "string" && SEMANTIC_TAGS.includes(value);
}
function normalizeSemanticTags(value) {
  if (!Array.isArray(value)) return [];
  return value.map((item) => String(item)).filter((item) => isSemanticTag(item));
}
function assertSemanticTags(value) {
  if (!Array.isArray(value)) return;
  for (const item of value) {
    if (!isSemanticTag(item)) {
      throw new Error(`invalid_semantic_tag:${String(item)}`);
    }
  }
}

// src/channels/service.ts
function parseEnvList(input) {
  if (!input) return [];
  return input.split(",").map((value) => value.trim()).filter(Boolean);
}
function outboundAuditFile(projectDir) {
  return path16.join(getMiyaRuntimeDir(projectDir), "channels-outbound.jsonl");
}
function appendOutboundAudit(projectDir, row) {
  const file3 = outboundAuditFile(projectDir);
  fs16.mkdirSync(path16.dirname(file3), { recursive: true });
  fs16.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
function semanticTagsForOutboundMessage(message) {
  if (message.includes("target_not_in_allowlist")) return ["recipient_mismatch"];
  if (message.includes("recipient_text_mismatch")) return ["recipient_mismatch"];
  if (message.includes("arch_advisor_denied")) return ["privilege_barrier"];
  if (message.includes("input_mutex_timeout")) return ["input_mutex_timeout"];
  if (message.includes("receipt_uncertain")) return ["receipt_uncertain"];
  if (message.includes("blocked_by_privilege") || message.includes("privilege")) {
    return ["privilege_barrier"];
  }
  if (message.includes("window_not_found")) return ["window_not_found"];
  if (message.includes("window_occluded")) return ["window_occluded"];
  if (message.includes("ui_style_mismatch")) return ["ui_style_mismatch"];
  return [];
}
function parsePositiveIntEnv(name, fallback) {
  const raw = process.env[name];
  if (!raw) return fallback;
  const parsed = Number(raw);
  if (!Number.isFinite(parsed) || parsed <= 0) return fallback;
  return Math.floor(parsed);
}
var INPUT_MUTEX_TIMEOUT_MS = parsePositiveIntEnv("MIYA_INPUT_MUTEX_TIMEOUT_MS", 2e4);
var INPUT_MUTEX_STRIKE_LIMIT = 3;
var INPUT_MUTEX_COOLDOWN_MS = 15 * 60 * 1e3;
var inputMutexOwner = null;
var inputMutexQueue = [];
function acquireInputMutex(sessionID2, timeoutMs = INPUT_MUTEX_TIMEOUT_MS) {
  return new Promise((resolve7, reject) => {
    let released = false;
    const makeLease = () => ({
      release: () => {
        if (released) return;
        released = true;
        if (inputMutexOwner === sessionID2) {
          inputMutexOwner = null;
        }
        while (inputMutexQueue.length > 0 && !inputMutexOwner) {
          const next = inputMutexQueue.shift();
          if (!next) break;
          if (!next.active) continue;
          next.grant();
        }
      }
    });
    const pending = {
      sessionID: sessionID2,
      active: true,
      grant: () => {
      }
    };
    const timer = setTimeout(() => {
      pending.active = false;
      const idx = inputMutexQueue.indexOf(pending);
      if (idx >= 0) inputMutexQueue.splice(idx, 1);
      reject(new Error("input_mutex_timeout"));
    }, timeoutMs);
    const grant = () => {
      if (!pending.active) return;
      pending.active = false;
      clearTimeout(timer);
      inputMutexOwner = sessionID2;
      resolve7(makeLease());
    };
    pending.grant = grant;
    if (!inputMutexOwner) {
      grant();
      return;
    }
    inputMutexQueue.push(pending);
  });
}
function buildSemanticSummary(row) {
  if (row.sent) {
    return {
      conclusion: "Outbound send completed with verifiable desktop evidence.",
      keyAssertion: `recipient_check=${row.recipientTextCheck ?? "uncertain"}, send_status=${row.sendStatusCheck ?? "uncertain"}`,
      recovery: "No recovery needed."
    };
  }
  if (row.message.includes("arch_advisor_denied")) {
    return {
      conclusion: "Outbound send blocked by Arch Advisor approval gate.",
      keyAssertion: "Arch Advisor approval flag was false, so outbound flow was denied before desktop execution.",
      recovery: "Re-issue approval ticket via Arch Advisor and retry only after policy checks pass."
    };
  }
  if (row.message.includes("input_mutex_timeout")) {
    return {
      conclusion: "Outbound send blocked by input mutex timeout.",
      keyAssertion: "Desktop control was denied because user input mutex could not be acquired in time.",
      recovery: "Wait for user idle state and retry with renewed approval tickets."
    };
  }
  if (row.message.includes("ui_style_mismatch")) {
    return {
      conclusion: "Outbound send degraded due to unstable UI/OCR style mismatch.",
      keyAssertion: "Visual confirmation confidence was too low after retry, so send was treated as failed.",
      recovery: "Adjust DPI/theme/window state, then retry with refreshed evidence."
    };
  }
  return {
    conclusion: row.sent ? "Outbound send completed." : "Outbound send blocked or uncertain.",
    keyAssertion: `message=${row.message}`,
    recovery: row.sent ? "No recovery needed." : "Review desktop evidence and retry only after policy/approval checks pass."
  };
}
function buildEvidenceBundle(row) {
  if (row.channel !== "qq" && row.channel !== "wechat") return void 0;
  const screenshots = [row.preSendScreenshotPath, row.postSendScreenshotPath].filter((item) => typeof item === "string" && item.length > 0);
  const ticketTraceIds = [
    row.ticketSummary?.outboundSendTraceId,
    row.ticketSummary?.desktopControlTraceId
  ].filter((item) => typeof item === "string" && item.length > 0);
  return {
    kind: "desktop_outbound",
    version: "v5",
    destination: row.destination,
    payloadHash: row.payloadHash,
    ticketTraceIds: ticketTraceIds.length > 0 ? ticketTraceIds : void 0,
    screenshots,
    checks: {
      recipientTextCheck: row.recipientTextCheck,
      sendStatusCheck: row.sendStatusCheck,
      receiptStatus: row.receiptStatus
    },
    diagnostics: {
      windowFingerprint: row.windowFingerprint,
      failureStep: row.failureStep,
      ocrSource: row.ocrSource,
      ocrPreview: row.ocrPreview
    },
    meta: {
      captureMethod: row.captureMethod ?? "unknown",
      confidence: Number.isFinite(row.evidenceConfidence) ? Number(row.evidenceConfidence) : 0,
      limitations: row.evidenceLimitations ?? [],
      policyHash: row.policyHash
    },
    simulation: screenshots.length > 0 ? {
      status: "captured",
      clickTargets: []
    } : {
      status: "not_available",
      reason: "desktop_screenshots_missing"
    }
  };
}
function listOutboundAudit(projectDir, limit = 50) {
  const file3 = outboundAuditFile(projectDir);
  if (!fs16.existsSync(file3)) return [];
  const rows = fs16.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}
var ChannelRuntime = class {
  projectDir;
  callbacks;
  sendQqDesktopMessageImpl;
  sendWechatDesktopMessageImpl;
  analyzeDesktopOutboundEvidenceImpl;
  telegramPolling = false;
  telegramOffset = 0;
  slackSocketModeRunning = false;
  slackSocket;
  slackReconnectTimer;
  outboundThrottle = /* @__PURE__ */ new Map();
  outboundPayloadHistory = /* @__PURE__ */ new Map();
  inputMutexStrike = /* @__PURE__ */ new Map();
  inputMutexCooldownUntil = /* @__PURE__ */ new Map();
  sendFingerprintHistory = /* @__PURE__ */ new Map();
  constructor(projectDir, callbacks, deps = {}) {
    this.projectDir = projectDir;
    this.callbacks = callbacks;
    this.sendQqDesktopMessageImpl = deps.sendQqDesktopMessage ?? sendQqDesktopMessage;
    this.sendWechatDesktopMessageImpl = deps.sendWechatDesktopMessage ?? sendWechatDesktopMessage;
    this.analyzeDesktopOutboundEvidenceImpl = deps.analyzeDesktopOutboundEvidence ?? analyzeDesktopOutboundEvidence;
  }
  listChannels() {
    return listChannelStates(this.projectDir);
  }
  listPairs(status) {
    return listPairRequests(this.projectDir, status);
  }
  approvePair(pairID) {
    return resolvePairRequest(this.projectDir, pairID, "approved");
  }
  rejectPair(pairID) {
    return resolvePairRequest(this.projectDir, pairID, "rejected");
  }
  markChannelEnabled(channel, enabled) {
    upsertChannelState(this.projectDir, channel, { enabled, connected: enabled });
  }
  async start() {
    upsertChannelState(this.projectDir, "webchat", { enabled: true, connected: true });
    await this.startTelegramPolling();
    this.syncPassiveChannelStates();
    await this.startSlackSocketMode();
  }
  syncPassiveChannelStates() {
    upsertChannelState(this.projectDir, "qq", {
      enabled: false,
      connected: false,
      lastError: "QQ outbound requires desktop UI automation runtime"
    });
    upsertChannelState(this.projectDir, "wechat", {
      enabled: false,
      connected: false,
      lastError: "WeChat outbound requires desktop UI automation runtime"
    });
    const hasSlack = !!process.env.MIYA_SLACK_BOT_TOKEN;
    upsertChannelState(this.projectDir, "slack", {
      enabled: hasSlack,
      connected: hasSlack,
      lastError: hasSlack ? void 0 : "Missing MIYA_SLACK_BOT_TOKEN"
    });
    const hasDiscord = !!process.env.MIYA_DISCORD_BOT_TOKEN;
    upsertChannelState(this.projectDir, "discord", {
      enabled: hasDiscord,
      connected: hasDiscord,
      lastError: hasDiscord ? void 0 : "Missing MIYA_DISCORD_BOT_TOKEN"
    });
    const hasWhatsApp = !!process.env.MIYA_WHATSAPP_TOKEN && !!process.env.MIYA_WHATSAPP_PHONE_NUMBER_ID;
    upsertChannelState(this.projectDir, "whatsapp", {
      enabled: hasWhatsApp,
      connected: hasWhatsApp,
      lastError: hasWhatsApp ? void 0 : "Missing MIYA_WHATSAPP_TOKEN or MIYA_WHATSAPP_PHONE_NUMBER_ID"
    });
    const hasGoogleChat = !!process.env.MIYA_GOOGLE_CHAT_WEBHOOK_URL;
    upsertChannelState(this.projectDir, "google_chat", {
      enabled: hasGoogleChat,
      connected: hasGoogleChat,
      lastError: hasGoogleChat ? void 0 : "Missing MIYA_GOOGLE_CHAT_WEBHOOK_URL"
    });
    const hasSignal = !!process.env.MIYA_SIGNAL_REST_URL;
    upsertChannelState(this.projectDir, "signal", {
      enabled: hasSignal,
      connected: hasSignal,
      lastError: hasSignal ? void 0 : "Missing MIYA_SIGNAL_REST_URL"
    });
    const hasIMessage = !!process.env.MIYA_BLUEBUBBLES_URL;
    upsertChannelState(this.projectDir, "imessage", {
      enabled: hasIMessage,
      connected: hasIMessage,
      lastError: hasIMessage ? void 0 : "Missing MIYA_BLUEBUBBLES_URL"
    });
    const hasTeams = !!process.env.MIYA_TEAMS_WEBHOOK_URL;
    upsertChannelState(this.projectDir, "teams", {
      enabled: hasTeams,
      connected: hasTeams,
      lastError: hasTeams ? void 0 : "Missing MIYA_TEAMS_WEBHOOK_URL"
    });
  }
  async startSlackSocketMode() {
    const appToken = process.env.MIYA_SLACK_APP_TOKEN;
    const botToken = process.env.MIYA_SLACK_BOT_TOKEN;
    if (!appToken || !botToken || this.slackSocketModeRunning) return;
    this.slackSocketModeRunning = true;
    const connect = async () => {
      if (!this.slackSocketModeRunning) return;
      try {
        const openRes = await fetch("https://slack.com/api/apps.connections.open", {
          method: "POST",
          headers: {
            authorization: `Bearer ${appToken}`,
            "content-type": "application/json"
          },
          body: "{}"
        });
        const openBody = await openRes.json();
        if (!openBody.ok || !openBody.url) {
          throw new Error(openBody.error ?? "slack_socket_open_failed");
        }
        const socket = new WebSocket(openBody.url);
        this.slackSocket = socket;
        socket.onopen = () => {
          upsertChannelState(this.projectDir, "slack", {
            enabled: true,
            connected: true,
            lastError: void 0
          });
        };
        socket.onmessage = (event) => {
          void this.handleSlackSocketMessage(String(event.data));
        };
        socket.onerror = () => {
          upsertChannelState(this.projectDir, "slack", {
            connected: false,
            lastError: "slack_socket_error"
          });
        };
        socket.onclose = () => {
          if (!this.slackSocketModeRunning) return;
          upsertChannelState(this.projectDir, "slack", {
            connected: false,
            lastError: "slack_socket_closed"
          });
          this.scheduleSlackReconnect(connect);
        };
      } catch (error92) {
        upsertChannelState(this.projectDir, "slack", {
          connected: false,
          lastError: error92 instanceof Error ? error92.message : String(error92)
        });
        this.scheduleSlackReconnect(connect);
      }
    };
    await connect();
  }
  scheduleSlackReconnect(connect) {
    if (!this.slackSocketModeRunning) return;
    if (this.slackReconnectTimer) clearTimeout(this.slackReconnectTimer);
    this.slackReconnectTimer = setTimeout(() => {
      void connect();
    }, 3e3);
  }
  async handleSlackSocketMessage(messageText) {
    if (!messageText.trim()) return;
    const payload = JSON.parse(messageText);
    if (payload.envelope_id && this.slackSocket?.readyState === WebSocket.OPEN) {
      this.slackSocket.send(JSON.stringify({ envelope_id: payload.envelope_id }));
    }
    if (payload.type !== "events_api") return;
    const event = payload.payload?.event;
    if (!event) return;
    if (event.type !== "message") return;
    if (!event.user || !event.text || !event.channel) return;
    if (event.bot_id) return;
    await this.handleInbound({
      channel: "slack",
      senderID: event.user,
      displayName: event.user,
      conversationID: event.channel,
      text: event.text,
      raw: payload
    });
  }
  async startTelegramPolling() {
    const token = process.env.MIYA_TELEGRAM_BOT_TOKEN;
    if (!token) {
      upsertChannelState(this.projectDir, "telegram", {
        enabled: false,
        connected: false,
        lastError: "Missing MIYA_TELEGRAM_BOT_TOKEN"
      });
      return;
    }
    if (this.telegramPolling) return;
    this.telegramPolling = true;
    upsertChannelState(this.projectDir, "telegram", {
      enabled: true,
      connected: true,
      lastError: void 0
    });
    const poll = async () => {
      if (!this.telegramPolling) return;
      try {
        const url3 = `https://api.telegram.org/bot${token}/getUpdates?timeout=20&offset=${this.telegramOffset}`;
        const response = await fetch(url3);
        const body = await response.json();
        if (!body.ok) {
          throw new Error(body.description ?? "telegram_get_updates_failed");
        }
        for (const update of body.result ?? []) {
          this.telegramOffset = Math.max(this.telegramOffset, Number(update.update_id) + 1);
          const message = update.message;
          if (!message?.text || !message.chat?.id || !message.from?.id) {
            continue;
          }
          await this.handleInbound({
            channel: "telegram",
            senderID: String(message.from.id),
            displayName: message.from.username ?? message.from.first_name ?? String(message.from.id),
            conversationID: String(message.chat.id),
            text: message.text,
            raw: update
          });
        }
        upsertChannelState(this.projectDir, "telegram", {
          connected: true,
          lastError: void 0
        });
      } catch (error92) {
        upsertChannelState(this.projectDir, "telegram", {
          connected: false,
          lastError: error92 instanceof Error ? error92.message : String(error92)
        });
      } finally {
        if (this.telegramPolling) {
          setTimeout(() => {
            void poll();
          }, 500);
        }
      }
    };
    void poll();
  }
  stop() {
    this.telegramPolling = false;
    this.slackSocketModeRunning = false;
    if (this.slackReconnectTimer) {
      clearTimeout(this.slackReconnectTimer);
      this.slackReconnectTimer = void 0;
    }
    if (this.slackSocket) {
      try {
        this.slackSocket.close();
      } catch {
      }
      this.slackSocket = void 0;
    }
  }
  async handleInbound(message) {
    const allowByEnv = parseEnvList(process.env.MIYA_ALLOWED_SENDERS);
    const isAllowed = allowByEnv.length > 0 ? allowByEnv.includes(message.senderID) : isSenderAllowed(this.projectDir, message.channel, message.senderID);
    if (!isAllowed) {
      const pair = ensurePairRequest(this.projectDir, {
        channel: message.channel,
        senderID: message.senderID,
        displayName: message.displayName,
        messagePreview: message.text.slice(0, 120)
      });
      await this.callbacks.onPairRequested(pair);
      await this.sendPairingMessage(message.channel, message.conversationID);
      return;
    }
    await this.callbacks.onInbound(message);
  }
  recordOutboundAttempt(row) {
    const semanticTags = normalizeSemanticTags(
      row.semanticTags ?? semanticTagsForOutboundMessage(row.message)
    );
    assertSemanticTags(semanticTags);
    const payload = {
      id: row.id ?? `out_${randomUUID3()}`,
      at: row.at ?? (/* @__PURE__ */ new Date()).toISOString(),
      channel: row.channel,
      destination: row.destination,
      textPreview: row.textPreview,
      sent: row.sent,
      message: row.message,
      mediaPath: row.mediaPath,
      reason: row.reason,
      riskLevel: row.riskLevel,
      archAdvisorApproved: row.archAdvisorApproved,
      targetInAllowlist: row.targetInAllowlist,
      contactTier: row.contactTier,
      intent: row.intent,
      containsSensitive: row.containsSensitive,
      policyHash: row.policyHash,
      sendFingerprint: row.sendFingerprint,
      ticketSummary: row.ticketSummary,
      visualPrecheck: row.visualPrecheck,
      visualPostcheck: row.visualPostcheck,
      receiptStatus: row.receiptStatus,
      payloadHash: row.payloadHash,
      windowFingerprint: row.windowFingerprint,
      recipientTextCheck: row.recipientTextCheck,
      sendStatusCheck: row.sendStatusCheck,
      preSendScreenshotPath: row.preSendScreenshotPath,
      postSendScreenshotPath: row.postSendScreenshotPath,
      failureStep: row.failureStep,
      ocrSource: row.ocrSource,
      ocrPreview: row.ocrPreview,
      captureMethod: row.captureMethod,
      evidenceConfidence: row.evidenceConfidence,
      evidenceLimitations: row.evidenceLimitations,
      evidenceBundle: buildEvidenceBundle(row),
      semanticSummary: buildSemanticSummary(row),
      semanticTags
    };
    appendOutboundAudit(this.projectDir, payload);
    return payload;
  }
  checkThrottle(channel, destination) {
    const now = Date.now();
    const key = `${channel}:${destination}`;
    const policy = readPolicy(this.projectDir);
    const windowMs = Math.max(1e3, Number(policy.outbound.burstWindowMs || 6e4));
    const minIntervalMs = Math.max(500, Number(policy.outbound.minIntervalMs || 4e3));
    const burstLimit = Math.max(1, Number(policy.outbound.burstLimit || 3));
    const list = (this.outboundThrottle.get(key) ?? []).filter(
      (ts) => now - ts <= windowMs
    );
    if (list.length > 0 && now - list[list.length - 1] < minIntervalMs) {
      this.outboundThrottle.set(key, list);
      return `throttled:min_interval_${minIntervalMs}ms`;
    }
    if (list.length >= burstLimit) {
      this.outboundThrottle.set(key, list);
      return `throttled:burst_limit_${burstLimit}_per_${windowMs}ms`;
    }
    list.push(now);
    this.outboundThrottle.set(key, list);
    return null;
  }
  checkDuplicatePayload(channel, destination, text) {
    const now = Date.now();
    const policy = readPolicy(this.projectDir);
    const duplicateWindowMs = Math.max(
      1e3,
      Number(policy.outbound.duplicateWindowMs || 6e4)
    );
    const key = `${channel}:${destination}`;
    const payloadHash = createHash5("sha256").update(text).digest("hex").slice(0, 24);
    const recent = (this.outboundPayloadHistory.get(key) ?? []).filter(
      (item) => now - item.at <= duplicateWindowMs
    );
    const duplicated = recent.some((item) => item.hash === payloadHash);
    if (!duplicated) {
      recent.push({ at: now, hash: payloadHash });
      this.outboundPayloadHistory.set(key, recent);
      return null;
    }
    this.outboundPayloadHistory.set(key, recent);
    return `duplicate_payload_within_${duplicateWindowMs}ms`;
  }
  isDesktopChannel(channel) {
    return channel === "qq" || channel === "wechat";
  }
  inMutexCooldown(sessionID2) {
    const until = this.inputMutexCooldownUntil.get(sessionID2) ?? 0;
    return until > Date.now();
  }
  markMutexTimeout(sessionID2) {
    const strikes = (this.inputMutexStrike.get(sessionID2) ?? 0) + 1;
    this.inputMutexStrike.set(sessionID2, strikes);
    if (strikes >= INPUT_MUTEX_STRIKE_LIMIT) {
      this.inputMutexCooldownUntil.set(sessionID2, Date.now() + INPUT_MUTEX_COOLDOWN_MS);
      this.inputMutexStrike.set(sessionID2, 0);
    }
  }
  clearMutexStrike(sessionID2) {
    this.inputMutexStrike.set(sessionID2, 0);
  }
  checkSendFingerprint(sendFingerprint) {
    const now = Date.now();
    const windowMs = 6e4;
    for (const [fingerprint, ts] of this.sendFingerprintHistory.entries()) {
      if (now - ts > windowMs) {
        this.sendFingerprintHistory.delete(fingerprint);
      }
    }
    if (this.sendFingerprintHistory.has(sendFingerprint)) {
      return "duplicate_send_fingerprint";
    }
    this.sendFingerprintHistory.set(sendFingerprint, now);
    return null;
  }
  normalizeDesktopRuntimeError(error92) {
    const raw = error92 instanceof Error ? error92.message : typeof error92 === "string" ? error92 : "unknown";
    return raw.trim().toLowerCase().replace(/[^a-z0-9:_-]+/g, "_").slice(0, 120) || "unknown";
  }
  recordDesktopRuntimeFailure(input) {
    const detail = this.normalizeDesktopRuntimeError(input.error);
    const audit = this.recordOutboundAttempt({
      channel: input.channel,
      destination: input.destination,
      textPreview: input.textPreview,
      sent: false,
      message: `outbound_degraded:desktop_runtime_exception:${detail}`,
      reason: "desktop_send_failed",
      archAdvisorApproved: input.archAdvisorApproved,
      targetInAllowlist: input.targetInAllowlist,
      contactTier: input.contactTier,
      intent: input.intent,
      containsSensitive: input.containsSensitive,
      riskLevel: input.riskLevel,
      policyHash: input.policyHash,
      sendFingerprint: input.sendFingerprint,
      ticketSummary: input.ticketSummary,
      payloadHash: input.payloadHash,
      failureStep: "desktop.runtime"
    });
    return { sent: false, message: audit.message, auditID: audit.id };
  }
  async sendMessage(input) {
    const text = (input.text ?? "").trim();
    const mediaPath = (input.mediaPath ?? "").trim();
    const payloadHash = (input.payloadHash ?? createHash5("sha256").update(`${text}||${mediaPath}`).digest("hex")).trim();
    if (!text && !mediaPath) {
      return { sent: false, message: "invalid_outbound_payload_empty" };
    }
    try {
      assertChannelCanSend(input.channel);
    } catch (error92) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: error92 instanceof Error ? error92.message : String(error92),
        reason: "channel_blocked",
        payloadHash
      });
      return {
        sent: false,
        message: audit.message,
        auditID: audit.id
      };
    }
    const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
    const riskLevel = input.outboundCheck?.riskLevel ?? "HIGH";
    const intent = input.outboundCheck?.intent ?? "initiate";
    const containsSensitive = Boolean(input.outboundCheck?.containsSensitive);
    const policyHash = input.outboundCheck?.policyHash;
    const sessionID2 = (input.sessionID ?? "main").trim() || "main";
    const ticketSummary = input.approvalTickets?.outboundSend && input.approvalTickets.desktopControl ? {
      outboundSendTraceId: input.approvalTickets.outboundSend.traceID,
      desktopControlTraceId: input.approvalTickets.desktopControl.traceID,
      expiresAt: Date.parse(input.approvalTickets.outboundSend.expiresAt) < Date.parse(input.approvalTickets.desktopControl.expiresAt) ? input.approvalTickets.outboundSend.expiresAt : input.approvalTickets.desktopControl.expiresAt
    } : void 0;
    if (!archAdvisorApproved) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: "outbound_blocked:arch_advisor_denied",
        reason: "arch_advisor_denied",
        archAdvisorApproved,
        riskLevel,
        intent,
        containsSensitive,
        policyHash,
        payloadHash
      });
      return { sent: false, message: audit.message, auditID: audit.id };
    }
    const targetInAllowlist = input.outboundCheck?.bypassAllowlist === true ? true : isSenderAllowed(this.projectDir, input.channel, input.destination);
    if (!targetInAllowlist) {
      const audit = this.recordOutboundAttempt({
        channel: input.channel,
        destination: input.destination,
        textPreview: text.slice(0, 200),
        sent: false,
        message: `outbound_blocked:target_not_in_allowlist:${input.channel}`,
        reason: "allowlist_denied",
        archAdvisorApproved,
        targetInAllowlist,
        riskLevel,
        intent,
        containsSensitive,
        policyHash,
        payloadHash
      });
      return { sent: false, message: audit.message, auditID: audit.id };
    }
    const tier = input.outboundCheck?.bypassAllowlist === true ? "owner" : getContactTier(this.projectDir, input.channel, input.destination);
    if (tier === "friend") {
      if (intent !== "reply") {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_blocked:friend_tier_can_only_reply",
          reason: "allowlist_denied",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
      if (containsSensitive) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_blocked:friend_tier_sensitive_content_denied",
          reason: "allowlist_denied",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.outboundCheck?.bypassThrottle !== true) {
      const throttle = this.checkThrottle(input.channel, input.destination);
      if (throttle) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${throttle}`,
          reason: "throttled",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.outboundCheck?.bypassDuplicateGuard !== true) {
      const duplicate = this.checkDuplicatePayload(
        input.channel,
        input.destination,
        `${text}||${mediaPath}`
      );
      if (duplicate) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${duplicate}`,
          reason: "duplicate_payload",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.sendFingerprint) {
      const fingerprintDup = this.checkSendFingerprint(input.sendFingerprint);
      if (fingerprintDup) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: `outbound_blocked:${fingerprintDup}`,
          reason: "duplicate_payload",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    let mutexLease = null;
    if (this.isDesktopChannel(input.channel)) {
      if (this.inMutexCooldown(sessionID2)) {
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_degraded:input_mutex_cooldown:draft_only",
          reason: "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
      try {
        mutexLease = await acquireInputMutex(sessionID2, INPUT_MUTEX_TIMEOUT_MS);
      } catch {
        this.markMutexTimeout(sessionID2);
        const audit = this.recordOutboundAttempt({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: false,
          message: "outbound_degraded:input_mutex_timeout:draft_only",
          reason: "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash
        });
        return { sent: false, message: audit.message, auditID: audit.id };
      }
    }
    if (input.channel === "qq" || input.channel === "wechat") {
      try {
        if (input.channel === "qq") {
          const result2 = await this.sendQqDesktopMessageImpl({
            projectDir: this.projectDir,
            destination: input.destination,
            text,
            mediaPath
          });
          const visionCheck2 = await this.analyzeDesktopOutboundEvidenceImpl({
            destination: input.destination,
            preSendScreenshotPath: result2.preSendScreenshotPath,
            postSendScreenshotPath: result2.postSendScreenshotPath,
            visualPrecheck: result2.visualPrecheck,
            visualPostcheck: result2.visualPostcheck,
            receiptStatus: result2.receiptStatus,
            recipientTextCheck: result2.recipientTextCheck
          });
          if (visionCheck2.recipientMatch === "mismatch") {
            result2.sent = false;
            result2.message = "outbound_blocked:recipient_text_mismatch";
          }
          if (visionCheck2.sendStatusDetected === "failed") {
            result2.sent = false;
            result2.message = "outbound_blocked:receipt_uncertain";
          }
          if (visionCheck2.uiStyleMismatch) {
            result2.sent = false;
            result2.message = "outbound_degraded:ui_style_mismatch:draft_only";
          }
          if (result2.sent && result2.receiptStatus !== "confirmed") {
            result2.sent = false;
            result2.message = "outbound_blocked:receipt_uncertain";
          }
          const audit2 = this.recordOutboundAttempt({
            channel: "qq",
            destination: input.destination,
            textPreview: text.slice(0, 200),
            sent: result2.sent,
            message: result2.message,
            mediaPath: mediaPath || void 0,
            reason: result2.sent ? "sent" : "desktop_send_failed",
            archAdvisorApproved,
            targetInAllowlist,
            contactTier: tier,
            intent,
            containsSensitive,
            riskLevel,
            policyHash,
            sendFingerprint: input.sendFingerprint,
            ticketSummary,
            payloadHash: result2.payloadHash ?? payloadHash,
            windowFingerprint: result2.windowFingerprint,
            recipientTextCheck: visionCheck2.recipientMatch === "matched" || visionCheck2.recipientMatch === "mismatch" ? visionCheck2.recipientMatch : result2.recipientTextCheck,
            sendStatusCheck: visionCheck2.sendStatusDetected,
            preSendScreenshotPath: result2.preSendScreenshotPath,
            postSendScreenshotPath: result2.postSendScreenshotPath,
            failureStep: result2.failureStep,
            ocrSource: visionCheck2.ocrSource,
            ocrPreview: visionCheck2.ocrPreview,
            captureMethod: visionCheck2.capture.method,
            evidenceConfidence: visionCheck2.capture.confidence,
            evidenceLimitations: visionCheck2.capture.limitations,
            visualPrecheck: result2.visualPrecheck,
            visualPostcheck: result2.visualPostcheck,
            receiptStatus: result2.receiptStatus
          });
          if (result2.sent) {
            this.clearMutexStrike(sessionID2);
          }
          if (!audit2.evidenceBundle || !audit2.semanticSummary) {
            return {
              sent: false,
              message: "outbound_blocked:missing_evidence_bundle",
              auditID: audit2.id
            };
          }
          return { ...result2, auditID: audit2.id };
        }
        const result = await this.sendWechatDesktopMessageImpl({
          projectDir: this.projectDir,
          destination: input.destination,
          text,
          mediaPath
        });
        const visionCheck = await this.analyzeDesktopOutboundEvidenceImpl({
          destination: input.destination,
          preSendScreenshotPath: result.preSendScreenshotPath,
          postSendScreenshotPath: result.postSendScreenshotPath,
          visualPrecheck: result.visualPrecheck,
          visualPostcheck: result.visualPostcheck,
          receiptStatus: result.receiptStatus,
          recipientTextCheck: result.recipientTextCheck
        });
        if (visionCheck.recipientMatch === "mismatch") {
          result.sent = false;
          result.message = "outbound_blocked:recipient_text_mismatch";
        }
        if (visionCheck.sendStatusDetected === "failed") {
          result.sent = false;
          result.message = "outbound_blocked:receipt_uncertain";
        }
        if (visionCheck.uiStyleMismatch) {
          result.sent = false;
          result.message = "outbound_degraded:ui_style_mismatch:draft_only";
        }
        if (result.sent && result.receiptStatus !== "confirmed") {
          result.sent = false;
          result.message = "outbound_blocked:receipt_uncertain";
        }
        const audit = this.recordOutboundAttempt({
          channel: "wechat",
          destination: input.destination,
          textPreview: text.slice(0, 200),
          sent: result.sent,
          message: result.message,
          mediaPath: mediaPath || void 0,
          reason: result.sent ? "sent" : "desktop_send_failed",
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash: result.payloadHash ?? payloadHash,
          windowFingerprint: result.windowFingerprint,
          recipientTextCheck: visionCheck.recipientMatch === "matched" || visionCheck.recipientMatch === "mismatch" ? visionCheck.recipientMatch : result.recipientTextCheck,
          sendStatusCheck: visionCheck.sendStatusDetected,
          preSendScreenshotPath: result.preSendScreenshotPath,
          postSendScreenshotPath: result.postSendScreenshotPath,
          failureStep: result.failureStep,
          ocrSource: visionCheck.ocrSource,
          ocrPreview: visionCheck.ocrPreview,
          captureMethod: visionCheck.capture.method,
          evidenceConfidence: visionCheck.capture.confidence,
          evidenceLimitations: visionCheck.capture.limitations,
          visualPrecheck: result.visualPrecheck,
          visualPostcheck: result.visualPostcheck,
          receiptStatus: result.receiptStatus
        });
        if (result.sent) {
          this.clearMutexStrike(sessionID2);
        }
        if (!audit.evidenceBundle || !audit.semanticSummary) {
          return {
            sent: false,
            message: "outbound_blocked:missing_evidence_bundle",
            auditID: audit.id
          };
        }
        return { ...result, auditID: audit.id };
      } catch (error92) {
        return this.recordDesktopRuntimeFailure({
          channel: input.channel,
          destination: input.destination,
          textPreview: text.slice(0, 200),
          archAdvisorApproved,
          targetInAllowlist,
          contactTier: tier,
          intent,
          containsSensitive,
          riskLevel,
          policyHash,
          sendFingerprint: input.sendFingerprint,
          ticketSummary,
          payloadHash,
          error: error92
        });
      } finally {
        mutexLease?.release();
      }
    }
    mutexLease?.release();
    return {
      sent: false,
      message: `channel_send_blocked:${input.channel}:INBOUND_ONLY channels are receive-only`
    };
  }
  async sendPairingMessage(channel, destination) {
    if (channel !== "qq" && channel !== "wechat") {
      return;
    }
    const pairingText = "Miya security: your account is not paired yet. Ask admin to approve pairing in Miya control panel.";
    await this.sendMessage({
      channel,
      destination,
      text: pairingText,
      outboundCheck: {
        archAdvisorApproved: true,
        riskLevel: "LOW",
        bypassAllowlist: true,
        bypassThrottle: true,
        bypassDuplicateGuard: true
      }
    });
  }
};

// src/safety/store.ts
import * as fs18 from "node:fs";
import * as path18 from "node:path";
import { randomUUID as randomUUID4 } from "node:crypto";

// src/safety/tier.ts
var SAFETY_RANK = {
  LIGHT: 1,
  STANDARD: 2,
  THOROUGH: 3
};
function normalizeTier(value) {
  const normalized = String(value ?? "STANDARD").trim().toUpperCase();
  if (normalized === "LIGHT") return "LIGHT";
  if (normalized === "THOROUGH") return "THOROUGH";
  return "STANDARD";
}
function tierAtLeast(current, required3) {
  return SAFETY_RANK[current] >= SAFETY_RANK[required3];
}

// src/safety/state-machine.ts
import * as fs17 from "node:fs";
import * as path17 from "node:path";
function nowIso7() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function stateFile(projectDir) {
  return path17.join(getMiyaRuntimeDir(projectDir), "safety-state.json");
}
function auditFile(projectDir) {
  return path17.join(getMiyaRuntimeDir(projectDir), "safety-state-audit.jsonl");
}
function ensureDir8(filePath14) {
  fs17.mkdirSync(path17.dirname(filePath14), { recursive: true });
}
function defaultState() {
  return {
    version: 1,
    updatedAt: nowIso7(),
    globalState: "running",
    domains: Object.fromEntries(
      POLICY_DOMAINS.map((domain3) => [domain3, "running"])
    )
  };
}
function writeState(projectDir, state2) {
  const file3 = stateFile(projectDir);
  const next = {
    ...state2,
    updatedAt: nowIso7()
  };
  ensureDir8(file3);
  fs17.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function readSafetyState(projectDir) {
  const file3 = stateFile(projectDir);
  if (!fs17.existsSync(file3)) {
    const created = defaultState();
    return writeState(projectDir, created);
  }
  try {
    const parsed = JSON.parse(fs17.readFileSync(file3, "utf-8"));
    const base = defaultState();
    const domains = {
      ...base.domains,
      ...parsed.domains ?? {}
    };
    return {
      ...base,
      ...parsed,
      domains
    };
  } catch {
    return defaultState();
  }
}
function appendAudit(projectDir, row) {
  const file3 = auditFile(projectDir);
  ensureDir8(file3);
  fs17.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}
function syncPolicyDomain(projectDir, domain3, state2) {
  const policy = readPolicy(projectDir);
  const mapped = state2 === "running" ? "running" : "paused";
  if (policy.domains[domain3] === mapped) return;
  writePolicy(projectDir, {
    domains: {
      ...policy.domains,
      [domain3]: mapped
    }
  });
}
function transitionSafetyState(projectDir, input) {
  const current = readSafetyState(projectDir);
  const next = {
    ...current,
    globalState: input.globalState ?? current.globalState,
    reason: input.reason,
    traceID: input.traceID ?? current.traceID,
    domains: {
      ...current.domains,
      ...input.domains ?? {}
    }
  };
  const written = writeState(projectDir, next);
  for (const domain3 of POLICY_DOMAINS) {
    syncPolicyDomain(projectDir, domain3, written.domains[domain3]);
  }
  appendAudit(projectDir, {
    id: `safety_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    at: nowIso7(),
    source: input.source,
    reason: input.reason,
    traceID: input.traceID,
    policyHash: input.policyHash,
    globalState: written.globalState,
    domains: input.domains ?? {}
  });
  return written;
}
function isDomainExecutionAllowed(projectDir, domain3) {
  const state2 = readSafetyState(projectDir);
  if (state2.globalState === "killed") return false;
  return state2.domains[domain3] === "running";
}

// src/safety/store.ts
var RECORD_LIMIT = 500;
var TOKEN_TTL_MS = 12e4;
var TOKEN_LIMIT_PER_SESSION = 200;
function runtimeFile(projectDir, name) {
  return path18.join(getMiyaRuntimeDir(projectDir), name);
}
function ensureDir9(file3) {
  fs18.mkdirSync(path18.dirname(file3), { recursive: true });
}
function readJson(file3, fallback) {
  if (!fs18.existsSync(file3)) return fallback;
  try {
    return JSON.parse(fs18.readFileSync(file3, "utf-8"));
  } catch {
    return fallback;
  }
}
function writeJson(file3, value) {
  ensureDir9(file3);
  fs18.writeFileSync(file3, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function nowIso8() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function syncGatewayStatus(projectDir, status) {
  const file3 = runtimeFile(projectDir, "gateway.json");
  if (!fs18.existsSync(file3)) return;
  const current = readJson(file3, {});
  if (!current || typeof current !== "object") return;
  writeJson(file3, { ...current, status });
}
function createTraceId() {
  return randomUUID4();
}
function writeSelfApprovalRecord(projectDir, record3) {
  const file3 = runtimeFile(projectDir, "self-approval.json");
  const current = readJson(file3, { records: [] });
  const next = {
    id: randomUUID4(),
    created_at: nowIso8(),
    ...record3
  };
  current.records = [next, ...current.records].slice(0, RECORD_LIMIT);
  writeJson(file3, current);
  return next;
}
function listRecentSelfApprovalRecords(projectDir, limit = 10) {
  const file3 = runtimeFile(projectDir, "self-approval.json");
  const current = readJson(file3, { records: [] });
  return current.records.slice(0, Math.max(1, limit));
}
function readTokenStore(projectDir) {
  const file3 = runtimeFile(projectDir, "approval-tokens.json");
  const store2 = readJson(file3, { tokens: {} });
  const decoded = { tokens: {} };
  for (const [sessionID2, tokens] of Object.entries(store2.tokens ?? {})) {
    const plainSession = decryptSensitiveValue(projectDir, sessionID2);
    decoded.tokens[plainSession] = {};
    for (const [hash3, token] of Object.entries(tokens ?? {})) {
      const plainHash = decryptSensitiveValue(projectDir, hash3);
      decoded.tokens[plainSession][plainHash] = {
        ...token,
        request_hash: decryptSensitiveValue(projectDir, token.request_hash),
        action: decryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  return decoded;
}
function writeTokenStore(projectDir, store2) {
  const file3 = runtimeFile(projectDir, "approval-tokens.json");
  const encoded = { tokens: {} };
  for (const [sessionID2, tokens] of Object.entries(store2.tokens ?? {})) {
    const safeSession = encryptSensitiveValue(projectDir, sessionID2);
    encoded.tokens[safeSession] = {};
    for (const [hash3, token] of Object.entries(tokens ?? {})) {
      const safeHash = encryptSensitiveValue(projectDir, hash3);
      encoded.tokens[safeSession][safeHash] = {
        ...token,
        request_hash: encryptSensitiveValue(projectDir, token.request_hash),
        action: encryptSensitiveValue(projectDir, token.action)
      };
    }
  }
  writeJson(file3, encoded);
}
function saveApprovalToken(projectDir, sessionID2, token, ttlMs = TOKEN_TTL_MS) {
  const store2 = readTokenStore(projectDir);
  const created = /* @__PURE__ */ new Date();
  const expires = new Date(created.getTime() + ttlMs);
  const next = {
    ...token,
    created_at: created.toISOString(),
    expires_at: expires.toISOString()
  };
  const sessionTokens = store2.tokens[sessionID2] ?? {};
  sessionTokens[token.request_hash] = next;
  const normalized = Object.values(sessionTokens).sort((a, b) => Date.parse(b.created_at) - Date.parse(a.created_at)).slice(0, TOKEN_LIMIT_PER_SESSION);
  store2.tokens[sessionID2] = Object.fromEntries(
    normalized.map((entry2) => [entry2.request_hash, entry2])
  );
  writeTokenStore(projectDir, store2);
  return next;
}
function findApprovalToken(projectDir, sessionID2, requestHashes, requiredTier) {
  const store2 = readTokenStore(projectDir);
  const sessionTokens = store2.tokens[sessionID2] ?? {};
  const now = Date.now();
  for (const hash3 of requestHashes) {
    const token = sessionTokens[hash3];
    if (!token) continue;
    const expiresAt = Date.parse(token.expires_at);
    if (!Number.isFinite(expiresAt) || expiresAt < now) continue;
    if (!tierAtLeast(token.tier, requiredTier)) continue;
    return token;
  }
  return null;
}
function readKillSwitch(projectDir) {
  return readJson(runtimeFile(projectDir, "kill-switch.json"), {
    active: false
  });
}
function activateKillSwitch(projectDir, reason, traceID) {
  const next = {
    active: true,
    reason,
    trace_id: traceID,
    activated_at: nowIso8()
  };
  writeJson(runtimeFile(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_activate",
    reason,
    traceID,
    globalState: "killed",
    domains: {}
  });
  syncGatewayStatus(projectDir, "killswitch");
  return next;
}
function releaseKillSwitch(projectDir) {
  const next = { active: false };
  writeJson(runtimeFile(projectDir, "kill-switch.json"), next);
  transitionSafetyState(projectDir, {
    source: "kill_switch_release",
    reason: "manual_release",
    globalState: "running",
    domains: {}
  });
  syncGatewayStatus(projectDir, "running");
  return next;
}

// src/safety/risk.ts
import { createHash as createHash6 } from "node:crypto";
var IRREVERSIBLE_BASH_PATTERNS = [
  /\bgit\s+push\b/i,
  /\bgit\s+remote\s+set-url\b/i,
  /\bgit\s+reset\s+--hard\b/i,
  /\bgit\s+clean\b[^\n]*\b-f\b/i,
  /\bgit\s+branch\b[^\n]*\b-D\b/i,
  /\brm\s+-[^\n]*\br\b/i,
  /\brm\s+-[^\n]*\bf\b/i,
  /\brm\s+(-rf|-fr)\b/i,
  /\bdel\s+\/[sfpq]/i,
  /\berase\s+\/[sfpq]/i,
  /\bRemove-Item\b[^\n]*\b(-Recurse|-Force)\b/i,
  /\btruncate\b/i,
  /\bcp\b[^\n]*\b-f\b/i,
  />\s*\.env(\.|$)/i,
  /\b(overwrite|truncate)\b/i
];
var SENSITIVE_PATH_PATTERNS = [
  /\.env(\.|$)/i,
  /\.pem$/i,
  /\.key$/i,
  /cookie/i,
  /credential/i,
  /secret/i,
  /token/i
];
function normalizePattern(pattern) {
  return pattern.trim().replaceAll("\\", "/");
}
function hasIrreversiblePattern(patterns) {
  return patterns.some(
    (pattern) => IRREVERSIBLE_BASH_PATTERNS.some((rule) => rule.test(pattern))
  );
}
function hasSensitivePath(patterns) {
  return patterns.some(
    (pattern) => SENSITIVE_PATH_PATTERNS.some((rule) => rule.test(pattern))
  );
}
function hasIrreversibleEditPattern(patterns) {
  return patterns.some(
    (pattern) => /\b(delete|remove|overwrite|truncate|destroy|wipe)\b/i.test(pattern) || pattern.endsWith(".env") || pattern.includes("/.env")
  );
}
function isSideEffectPermission(permission) {
  return permission === "edit" || permission === "bash" || permission === "external_directory" || permission === "external_message" || permission === "desktop_control" || permission === "node_invoke" || permission === "skills_install" || permission === "webhook_outbound";
}
function requiredTierForRequest(request) {
  const patterns = request.patterns.map(normalizePattern);
  if (request.permission === "external_directory") return "THOROUGH";
  if (request.permission === "external_message") return "THOROUGH";
  if (request.permission === "desktop_control") return "THOROUGH";
  if (request.permission === "node_invoke") {
    const patterns2 = request.patterns.map(normalizePattern).join(" ");
    if (/\b(system\.run|camera\.capture|canvas\.open|canvas\.render|voice\.)\b/i.test(
      patterns2
    )) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  if (request.permission === "skills_install") return "THOROUGH";
  if (request.permission === "webhook_outbound") return "THOROUGH";
  if (request.permission === "bash") {
    return hasIrreversiblePattern(patterns) ? "THOROUGH" : "STANDARD";
  }
  if (request.permission === "edit") {
    if (hasSensitivePath(patterns) || hasIrreversibleEditPattern(patterns)) {
      return "THOROUGH";
    }
    return "STANDARD";
  }
  return "STANDARD";
}
function buildRequestHash(request, includeMessageContext = true) {
  const payload = {
    permission: request.permission,
    patterns: [...request.patterns].map(normalizePattern).sort(),
    toolCallID: includeMessageContext ? request.toolCallID ?? "" : "",
    messageID: includeMessageContext ? request.messageID ?? "" : ""
  };
  return createHash6("sha256").update(JSON.stringify(payload)).digest("hex");
}

// src/policy/decision-fusion.ts
function normalizeConfidence(value) {
  if (!Number.isFinite(value)) return 0;
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
}
function normalizeTrustScore(value) {
  if (!Number.isFinite(value)) return 50;
  if (value < 0) return 0;
  if (value > 100) return 100;
  return Math.round(value);
}
function normalizeTrustMode(input) {
  let silentMin = Math.max(
    0,
    Math.min(100, Math.round(input?.silentMin ?? 90))
  );
  let modalMax = Math.max(
    0,
    Math.min(100, Math.round(input?.modalMax ?? 50))
  );
  if (silentMin <= modalMax) {
    const pivot = Math.round((silentMin + modalMax) / 2);
    silentMin = Math.min(100, pivot + 1);
    modalMax = Math.max(0, pivot - 1);
  }
  if (silentMin - modalMax < 2) {
    if (silentMin < 100) silentMin += 1;
    else if (modalMax > 0) modalMax -= 1;
  }
  if (silentMin <= modalMax) {
    return { silentMin: 90, modalMax: 50 };
  }
  return { silentMin, modalMax };
}
function resolveApprovalMode(input) {
  if (input.action !== "allow") return "modal_approval";
  const thresholds = normalizeTrustMode(input.trustMode);
  const silentMin = thresholds.silentMin;
  const modalMax = thresholds.modalMax;
  if (input.trustScore >= silentMin) return "silent_audit";
  if (input.trustScore <= modalMax) return "modal_approval";
  return "toast_gate";
}
function evaluateOutboundDecisionFusion(input) {
  const conf = normalizeConfidence(input.confidenceIntent);
  const evidenceConf = normalizeConfidence(input.evidenceConfidence ?? input.confidenceIntent);
  const trustScore = normalizeTrustScore(input.trustMinScore);
  const expressionMatched = input.factorTextSensitive && !input.factorRecipientIsMe || input.factorTextSensitive && input.factorIntentSuspicious;
  if (evidenceConf < 0.35) {
    const action2 = expressionMatched ? conf < 0.5 ? "hard_fuse" : "soft_fuse" : "allow";
    return {
      expressionMatched,
      zone: action2 === "hard_fuse" ? "danger" : "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: action2 === "hard_fuse" ? "decision_fusion_danger_low_evidence" : action2 === "soft_fuse" ? "decision_fusion_gray_low_evidence" : "decision_fusion_low_evidence_confirmation_required"
    };
  }
  if (!expressionMatched) {
    const action2 = "allow";
    return {
      expressionMatched: false,
      zone: "safe",
      action: action2,
      approvalMode: resolveApprovalMode({
        action: action2,
        trustScore,
        trustMode: input.trustMode
      }),
      reason: "decision_fusion_clear"
    };
  }
  if (conf < 0.5) {
    const action2 = "hard_fuse";
    return {
      expressionMatched: true,
      zone: "danger",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_danger"
    };
  }
  if (conf <= 0.85) {
    const action2 = "soft_fuse";
    return {
      expressionMatched: true,
      zone: "gray",
      action: action2,
      approvalMode: "modal_approval",
      reason: "decision_fusion_gray"
    };
  }
  const action = "allow";
  return {
    expressionMatched: true,
    zone: "safe",
    action,
    approvalMode: resolveApprovalMode({
      action,
      trustScore,
      trustMode: input.trustMode
    }),
    reason: "decision_fusion_safe_by_confidence"
  };
}

// src/policy/incident.ts
import * as fs19 from "node:fs";
import * as path19 from "node:path";
import { randomUUID as randomUUID5 } from "node:crypto";
function incidentFile(projectDir) {
  return path19.join(getMiyaRuntimeDir(projectDir), "policy-incidents.jsonl");
}
function appendPolicyIncident(projectDir, incident) {
  assertSemanticTags(incident.semanticTags);
  const semanticTags = normalizeSemanticTags(incident.semanticTags);
  const payload = {
    id: incident.id ?? `incident_${randomUUID5()}`,
    at: incident.at ?? (/* @__PURE__ */ new Date()).toISOString(),
    type: incident.type,
    reason: incident.reason,
    channel: incident.channel,
    destination: incident.destination,
    auditID: incident.auditID,
    policyHash: incident.policyHash,
    pausedDomains: incident.pausedDomains,
    statusByDomain: incident.statusByDomain,
    semanticSummary: incident.semanticSummary,
    semanticTags,
    details: incident.details
  };
  const file3 = incidentFile(projectDir);
  fs19.mkdirSync(path19.dirname(file3), { recursive: true });
  fs19.appendFileSync(file3, `${JSON.stringify(payload)}
`, "utf-8");
  return payload;
}
function listPolicyIncidents(projectDir, limit = 50) {
  const file3 = incidentFile(projectDir);
  if (!fs19.existsSync(file3)) return [];
  const rows = fs19.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((row) => Boolean(row));
  return rows.sort((a, b) => Date.parse(b.at) - Date.parse(a.at)).slice(0, Math.max(1, limit));
}

// src/nodes/index.ts
import * as fs20 from "node:fs";
import * as path20 from "node:path";
import { createHash as createHash7, randomBytes as randomBytes2, randomUUID as randomUUID6, timingSafeEqual } from "node:crypto";
var HEARTBEAT_STALE_MS = 2 * 60 * 1e3;
function nowIso9() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function hashToken(token) {
  return createHash7("sha256").update(token).digest("hex");
}
function defaultNodePermissions() {
  return {
    screenRecording: false,
    accessibility: false,
    filesystem: "none",
    network: false
  };
}
function inferPermissionsFromCapabilities(capabilities, base) {
  const inferred = defaultNodePermissions();
  for (const capability of capabilities) {
    if (capability === "perm.screenRecording") inferred.screenRecording = true;
    if (capability === "perm.accessibility") inferred.accessibility = true;
    if (capability === "perm.network") inferred.network = true;
    if (capability.startsWith("perm.filesystem.")) {
      const suffix = capability.slice("perm.filesystem.".length);
      if (suffix === "none" || suffix === "read" || suffix === "full") {
        inferred.filesystem = suffix;
      }
    }
  }
  return {
    ...inferred,
    ...base ?? {}
  };
}
function normalizeNodeRecord(partial3) {
  const capabilityList = Array.isArray(partial3.capabilities) ? partial3.capabilities.map((item) => String(item)).filter(Boolean).sort() : [];
  const fallbackHeartbeat = String(partial3.lastSeenAt ?? nowIso9());
  const permissions = inferPermissionsFromCapabilities(capabilityList, partial3.permissions);
  const status = partial3.connected ? "online" : "offline";
  return {
    nodeID: String(partial3.nodeID ?? ""),
    deviceID: String(partial3.deviceID ?? ""),
    type: partial3.type === "cli" || partial3.type === "desktop" || partial3.type === "mobile" || partial3.type === "browser" ? partial3.type : "cli",
    role: "node",
    platform: String(partial3.platform ?? process.platform),
    permissions,
    capabilities: capabilityList,
    connected: Boolean(partial3.connected),
    paired: Boolean(partial3.paired),
    status: partial3.status === "online" || partial3.status === "offline" || partial3.status === "error" ? partial3.status : status,
    tokenHash: typeof partial3.tokenHash === "string" ? partial3.tokenHash : void 0,
    tokenIssuedAt: typeof partial3.tokenIssuedAt === "string" ? partial3.tokenIssuedAt : void 0,
    tokenLastUsedAt: typeof partial3.tokenLastUsedAt === "string" ? partial3.tokenLastUsedAt : void 0,
    lastHeartbeatAt: typeof partial3.lastHeartbeatAt === "string" ? partial3.lastHeartbeatAt : fallbackHeartbeat,
    lastSeenAt: String(partial3.lastSeenAt ?? fallbackHeartbeat),
    createdAt: String(partial3.createdAt ?? nowIso9()),
    updatedAt: String(partial3.updatedAt ?? nowIso9())
  };
}
function applyHeartbeatHealth(store2) {
  const now = Date.now();
  let changed = false;
  for (const node of Object.values(store2.nodes)) {
    const heartbeatAt = Date.parse(node.lastHeartbeatAt || node.lastSeenAt);
    if (Number.isNaN(heartbeatAt)) continue;
    const stale = now - heartbeatAt > HEARTBEAT_STALE_MS;
    if (stale && (node.connected || node.status === "online")) {
      node.connected = false;
      node.status = "offline";
      node.updatedAt = nowIso9();
      changed = true;
    }
  }
  return changed;
}
function filePath4(projectDir) {
  return path20.join(getMiyaRuntimeDir(projectDir), "nodes.json");
}
function ensureDir10(file3) {
  fs20.mkdirSync(path20.dirname(file3), { recursive: true });
}
function readStore3(projectDir) {
  const file3 = filePath4(projectDir);
  if (!fs20.existsSync(file3)) {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
  try {
    const parsed = JSON.parse(fs20.readFileSync(file3, "utf-8"));
    const rawNodes = parsed.nodes ?? {};
    const nodes = {};
    for (const [nodeID, node] of Object.entries(rawNodes)) {
      const normalized = normalizeNodeRecord({
        ...node,
        nodeID: nodeID || node?.nodeID
      });
      if (!normalized.nodeID) continue;
      nodes[normalized.nodeID] = normalized;
    }
    return {
      nodes,
      devices: parsed.devices ?? {},
      pairs: Array.isArray(parsed.pairs) ? parsed.pairs : [],
      invokes: parsed.invokes ?? {}
    };
  } catch {
    return {
      nodes: {},
      devices: {},
      pairs: [],
      invokes: {}
    };
  }
}
function writeStore3(projectDir, store2) {
  const file3 = filePath4(projectDir);
  ensureDir10(file3);
  fs20.writeFileSync(file3, `${JSON.stringify(store2, null, 2)}
`, "utf-8");
}
function readStoreWithHealth(projectDir) {
  const store2 = readStore3(projectDir);
  if (applyHeartbeatHealth(store2)) {
    writeStore3(projectDir, store2);
  }
  return store2;
}
function verifyNodeToken(node, token) {
  if (!node.tokenHash) return true;
  if (!token) return false;
  const expected = Buffer.from(node.tokenHash, "hex");
  const actual = Buffer.from(hashToken(token), "hex");
  if (expected.length !== actual.length) return false;
  return timingSafeEqual(expected, actual);
}
function registerNode(projectDir, input) {
  const store2 = readStoreWithHealth(projectDir);
  const existing = store2.nodes[input.nodeID];
  if (existing && !verifyNodeToken(existing, input.token)) {
    throw new Error("node_token_invalid");
  }
  const nextCapabilities = [...new Set(input.capabilities)].sort();
  const now = nowIso9();
  const createdAt = store2.nodes[input.nodeID]?.createdAt ?? nowIso9();
  const lastHeartbeatAt = now;
  const tokenLastUsedAt = existing?.tokenHash ? now : existing?.tokenLastUsedAt;
  const node = {
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    type: input.type ?? existing?.type ?? "cli",
    role: "node",
    platform: input.platform,
    permissions: inferPermissionsFromCapabilities(nextCapabilities, {
      ...existing?.permissions,
      ...input.permissions ?? {}
    }),
    capabilities: nextCapabilities,
    connected: true,
    paired: existing?.paired ?? false,
    status: "online",
    tokenHash: existing?.tokenHash,
    tokenIssuedAt: existing?.tokenIssuedAt,
    tokenLastUsedAt,
    lastHeartbeatAt,
    lastSeenAt: now,
    createdAt,
    updatedAt: now
  };
  store2.nodes[input.nodeID] = node;
  const device = {
    deviceID: input.deviceID,
    label: store2.devices[input.deviceID]?.label,
    approved: store2.devices[input.deviceID]?.approved ?? false,
    createdAt: store2.devices[input.deviceID]?.createdAt ?? now,
    updatedAt: now
  };
  store2.devices[input.deviceID] = device;
  writeStore3(projectDir, store2);
  return node;
}
function touchNodeHeartbeat(projectDir, nodeID) {
  const store2 = readStore3(projectDir);
  const node = store2.nodes[nodeID];
  if (!node) return null;
  const now = nowIso9();
  node.connected = true;
  node.status = "online";
  node.lastHeartbeatAt = now;
  node.lastSeenAt = now;
  node.updatedAt = now;
  writeStore3(projectDir, store2);
  return node;
}
function markNodeDisconnected(projectDir, nodeID) {
  const store2 = readStore3(projectDir);
  const node = store2.nodes[nodeID];
  if (!node) return;
  node.connected = false;
  node.status = "offline";
  node.updatedAt = nowIso9();
  writeStore3(projectDir, store2);
}
function listNodes(projectDir) {
  const store2 = readStoreWithHealth(projectDir);
  return Object.values(store2.nodes).sort(
    (a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)
  );
}
function listDevices(projectDir) {
  const store2 = readStoreWithHealth(projectDir);
  return Object.values(store2.devices).sort(
    (a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)
  );
}
function describeNode(projectDir, nodeID) {
  const store2 = readStoreWithHealth(projectDir);
  return store2.nodes[nodeID] ?? null;
}
function issueNodeToken(projectDir, nodeID) {
  const store2 = readStoreWithHealth(projectDir);
  const node = store2.nodes[nodeID];
  if (!node) return null;
  const token = `nkt_${randomBytes2(24).toString("hex")}`;
  const issuedAt = nowIso9();
  node.tokenHash = hashToken(token);
  node.tokenIssuedAt = issuedAt;
  node.tokenLastUsedAt = issuedAt;
  node.updatedAt = issuedAt;
  store2.nodes[nodeID] = node;
  writeStore3(projectDir, store2);
  return { nodeID, token, issuedAt };
}
function createNodePairRequest(projectDir, input) {
  const store2 = readStore3(projectDir);
  const pending = store2.pairs.find(
    (item) => item.nodeID === input.nodeID && item.status === "pending"
  );
  if (pending) return pending;
  const pair = {
    id: `npair_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    nodeID: input.nodeID,
    deviceID: input.deviceID,
    status: "pending",
    requestedAt: nowIso9()
  };
  store2.pairs = [pair, ...store2.pairs].slice(0, 1e3);
  writeStore3(projectDir, store2);
  return pair;
}
function listNodePairs(projectDir, status) {
  const store2 = readStore3(projectDir);
  const pairs = status ? store2.pairs.filter((item) => item.status === status) : store2.pairs;
  return [...pairs].sort((a, b) => Date.parse(b.requestedAt) - Date.parse(a.requestedAt));
}
function resolveNodePair(projectDir, pairID, status) {
  const store2 = readStore3(projectDir);
  const pair = store2.pairs.find((item) => item.id === pairID);
  if (!pair || pair.status !== "pending") return null;
  pair.status = status;
  pair.resolvedAt = nowIso9();
  if (status === "approved") {
    const node = store2.nodes[pair.nodeID];
    if (node) {
      node.paired = true;
      node.updatedAt = nowIso9();
    }
    const device = store2.devices[pair.deviceID];
    if (device) {
      device.approved = true;
      device.updatedAt = nowIso9();
    }
  }
  writeStore3(projectDir, store2);
  return pair;
}
function createInvokeRequest(projectDir, input) {
  const store2 = readStore3(projectDir);
  const invoke = {
    id: `invoke_${randomUUID6()}`,
    nodeID: input.nodeID,
    capability: input.capability,
    args: input.args,
    status: "pending",
    createdAt: nowIso9(),
    updatedAt: nowIso9()
  };
  store2.invokes[invoke.id] = invoke;
  writeStore3(projectDir, store2);
  return invoke;
}
function markInvokeSent(projectDir, invokeID) {
  const store2 = readStore3(projectDir);
  const invoke = store2.invokes[invokeID];
  if (!invoke) return null;
  invoke.status = "sent";
  invoke.updatedAt = nowIso9();
  writeStore3(projectDir, store2);
  return invoke;
}
function resolveInvokeResult(projectDir, invokeID, input) {
  const store2 = readStore3(projectDir);
  const invoke = store2.invokes[invokeID];
  if (!invoke) return null;
  invoke.status = input.ok ? "completed" : "failed";
  invoke.result = input.result;
  invoke.error = input.error;
  invoke.updatedAt = nowIso9();
  writeStore3(projectDir, store2);
  return invoke;
}
function listInvokeRequests(projectDir, limit = 50) {
  const store2 = readStore3(projectDir);
  return Object.values(store2.invokes).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, limit));
}

// src/daemon/launcher.ts
import { randomUUID as randomUUID7 } from "node:crypto";
import * as fs23 from "node:fs";
import * as path23 from "node:path";
import { spawn as spawn4, spawnSync as spawnSync4 } from "node:child_process";
import { fileURLToPath } from "node:url";

// src/settings/registry.ts
function entry(input) {
  return {
    ...input,
    requiresEvidence: input.risk === "HIGH"
  };
}
function cloneValue(value) {
  return JSON.parse(JSON.stringify(value));
}
function keySegments(key) {
  return key.split(".").map((segment) => segment.trim()).filter((segment) => segment.length > 0);
}
function getNestedValue(root, key) {
  if (!root || typeof root !== "object") return void 0;
  const segments = keySegments(key);
  let current = root;
  for (const segment of segments) {
    if (!current || typeof current !== "object") return void 0;
    current = current[segment];
  }
  return current;
}
function setNestedValue(root, key, value) {
  const segments = keySegments(key);
  if (segments.length === 0) return;
  let current = root;
  for (let index = 0; index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const next = current[segment];
    if (!next || typeof next !== "object" || Array.isArray(next)) {
      current[segment] = {};
    }
    current = current[segment];
  }
  current[segments[segments.length - 1]] = value;
}
var SETTINGS_REGISTRY = [
  entry({
    key: "ui.language",
    type: "enum",
    enumValues: ["zh-CN"],
    defaultValue: "zh-CN",
    risk: "LOW",
    description: "\u63A7\u5236\u53F0\u8BED\u8A00\u3002"
  }),
  entry({
    key: "ui.theme",
    type: "enum",
    enumValues: ["dark", "light", "system"],
    defaultValue: "dark",
    risk: "LOW",
    description: "\u63A7\u5236\u53F0\u4E3B\u9898\u3002"
  }),
  entry({
    key: "ui.dashboard.openOnStart",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: "\u542F\u52A8\u65F6\u81EA\u52A8\u6253\u5F00\u63A7\u5236\u53F0\u3002"
  }),
  entry({
    key: "ui.dashboard.dockAutoLaunch",
    type: "boolean",
    defaultValue: false,
    risk: "LOW",
    description: "\u542F\u52A8\u65F6\u81EA\u52A8\u62C9\u8D77 Windows Dock\uFF08\u9ED8\u8BA4\u5173\u95ED\uFF0C\u907F\u514D\u53CD\u590D\u62C9\u8D77\uFF09\u3002"
  }),
  entry({
    key: "ui.dashboard.autoOpenCooldownMs",
    type: "integer",
    minimum: 1e4,
    maximum: 144e4,
    defaultValue: 12e4,
    risk: "LOW",
    description: "\u81EA\u52A8\u6253\u5F00\u63A7\u5236\u53F0\u7684\u8DE8\u8FDB\u7A0B\u51B7\u5374\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09\u3002"
  }),
  entry({
    key: "ui.dashboard.startPage",
    type: "enum",
    enumValues: [
      "overview",
      "autopilot",
      "approvals",
      "intake",
      "runtime",
      "jobs",
      "skills",
      "killswitch"
    ],
    defaultValue: "overview",
    risk: "LOW",
    description: "\u63A7\u5236\u53F0\u9ED8\u8BA4\u9996\u9875\u3002"
  }),
  entry({
    key: "ui.dashboard.refreshMs",
    type: "integer",
    minimum: 200,
    maximum: 5e3,
    defaultValue: 800,
    risk: "LOW",
    description: "\u63A7\u5236\u53F0\u81EA\u52A8\u5237\u65B0\u95F4\u9694\uFF08\u6BEB\u79D2\uFF09\u3002"
  }),
  entry({
    key: "autopilot.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u662F\u5426\u542F\u7528\u81EA\u52A8\u5FAA\u73AF\u6267\u884C\u3002"
  }),
  entry({
    key: "autopilot.maxCycles",
    type: "integer",
    minimum: 1,
    maximum: 20,
    defaultValue: 8,
    risk: "MED",
    description: "\u5355\u7A97\u53E3\u6700\u5927\u5FAA\u73AF\u8F6E\u6B21\uFF08\u8FDB\u5C55\u9A71\u52A8+\u4E0A\u9650\u7EA6\u675F\uFF09\u3002"
  }),
  entry({
    key: "autopilot.noInterruptChat",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u81EA\u52A8\u6267\u884C\u65F6\u5C3D\u91CF\u4E0D\u6253\u65AD\u4E3B\u5BF9\u8BDD\u3002"
  }),
  entry({
    key: "autopilot.stallDetection.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u542F\u7528\u505C\u6EDE\u68C0\u6D4B\u3002"
  }),
  entry({
    key: "autopilot.stallDetection.maxNoImprovementCycles",
    type: "integer",
    minimum: 1,
    maximum: 10,
    defaultValue: 3,
    risk: "MED",
    description: "\u8FDE\u7EED\u65E0\u6539\u8FDB\u8F6E\u6B21\u9608\u503C\u3002"
  }),
  entry({
    key: "autopilot.iterationDoneRequired",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u6BCF\u8F6E\u5FC5\u987B\u5199\u5165\u8FED\u4EE3\u5B8C\u6210\u8BB0\u5F55\u3002"
  }),
  entry({
    key: "approval.mode",
    type: "enum",
    enumValues: ["self"],
    defaultValue: "self",
    risk: "MED",
    description: "\u5BA1\u6279\u6A21\u5F0F\u3002"
  }),
  entry({
    key: "approval.requireEvidence",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u662F\u5426\u5F3A\u5236\u8BC1\u636E\u94FE\u3002"
  }),
  entry({
    key: "approval.signers",
    type: "object",
    defaultValue: {
      executor: true,
      verifier: true
    },
    risk: "MED",
    description: "\u5BA1\u6279\u7B7E\u5B57\u4EBA\u914D\u7F6E\u3002"
  }),
  entry({
    key: "approval.tier.default",
    type: "enum",
    enumValues: ["LIGHT", "STANDARD", "THOROUGH"],
    defaultValue: "STANDARD",
    risk: "MED",
    description: "\u9ED8\u8BA4\u9A8C\u8BC1\u7B49\u7EA7\u3002"
  }),
  entry({
    key: "approval.tier.irreversible",
    type: "enum",
    enumValues: ["THOROUGH"],
    defaultValue: "THOROUGH",
    risk: "HIGH",
    description: "\u4E0D\u53EF\u9006\u52A8\u4F5C\u5FC5\u987B\u9A8C\u8BC1\u7B49\u7EA7\u3002"
  }),
  entry({
    key: "approval.onDeny.activateKillSwitch",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u5BA1\u6279\u62D2\u7EDD\u540E\u662F\u5426\u89E6\u53D1\u6025\u505C\u3002"
  }),
  entry({
    key: "intake.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u4FE1\u606F\u95F8\u95E8\u603B\u5F00\u5173\u3002"
  }),
  entry({
    key: "intake.triggers.configChange",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u914D\u7F6E\u53D8\u66F4\u662F\u5426\u5F3A\u5236\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
  }),
  entry({
    key: "intake.triggers.skillOrToolchainChange",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u65B0\u589E/\u542F\u7528 skill \u6216\u5DE5\u5177\u94FE\u662F\u5426\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
  }),
  entry({
    key: "intake.triggers.highRiskAction",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u9AD8\u98CE\u9669\u52A8\u4F5C\u524D\u7F6E\u5B66\u4E60\u662F\u5426\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
  }),
  entry({
    key: "intake.triggers.directiveContent",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u7F51\u9875\u6307\u4EE4\u578B\u5185\u5BB9\u662F\u5426\u89E6\u53D1\u4FE1\u606F\u95F8\u95E8\u3002"
  }),
  entry({
    key: "intake.policy.autoWhitelistOnApprove",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u5BA1\u6279\u540C\u610F\u540E\u81EA\u52A8\u52A0\u5165\u767D\u540D\u5355\u3002"
  }),
  entry({
    key: "intake.policy.autoBlacklistOnReject",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u5BA1\u6279\u62D2\u7EDD\u540E\u81EA\u52A8\u52A0\u5165\u9ED1\u540D\u5355\u3002"
  }),
  entry({
    key: "intake.policy.defaultRejectScope",
    type: "enum",
    enumValues: ["CONTENT_FINGERPRINT", "PAGE", "PATH_PREFIX", "DOMAIN"],
    defaultValue: "CONTENT_FINGERPRINT",
    risk: "MED",
    description: "\u62D2\u7EDD\u65F6\u9ED8\u8BA4\u52A0\u5165\u9ED1\u540D\u5355\u7684\u7C92\u5EA6\u3002"
  }),
  entry({
    key: "intake.policy.allowTrialRunOption",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u5BA1\u6279\u9009\u9879\u4E2D\u5141\u8BB8\u201C\u4EC5\u8BD5\u8FD0\u884C\u4E00\u6B21\u201D\u3002"
  }),
  entry({
    key: "intake.stats.windowN",
    type: "integer",
    minimum: 3,
    maximum: 50,
    defaultValue: 10,
    risk: "MED",
    description: "\u6765\u6E90\u7EDF\u8BA1\u6ED1\u52A8\u7A97\u53E3\u5927\u5C0F N\uFF08\u6309\u5BA1\u6279\u4E8B\u4EF6\uFF09\u3002"
  }),
  entry({
    key: "intake.stats.hardDenyWhenUsefulLessThanRejected",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u5F53 U<R \u65F6\u9ED8\u8BA4\u5426\u51B3\u8BE5\u6765\u6E90\u3002"
  }),
  entry({
    key: "intake.stats.downrankThresholdRatioX100",
    type: "integer",
    minimum: 100,
    maximum: 500,
    defaultValue: 150,
    risk: "MED",
    description: "\u964D\u6743\u9608\u503C\u6BD4\u7387\uFF08X100\uFF0C\u9ED8\u8BA4 150 \u8868\u793A 1.5 \u500D\uFF09\u3002"
  }),
  entry({
    key: "intake.stats.downrankExplorePercent",
    type: "integer",
    minimum: 0,
    maximum: 100,
    defaultValue: 30,
    risk: "MED",
    description: "\u6765\u6E90\u964D\u6743\u540E\u63A2\u7D22\u6982\u7387\u767E\u5206\u6BD4\u3002"
  }),
  entry({
    key: "intake.stats.sourceUnit",
    type: "enum",
    enumValues: ["DOMAIN_PATH_PREFIX", "DOMAIN", "PATH_PREFIX"],
    defaultValue: "DOMAIN_PATH_PREFIX",
    risk: "MED",
    description: "\u6765\u6E90\u7EDF\u8BA1\u5355\u5143\u3002"
  }),
  entry({
    key: "killswitch.active",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: "\u6025\u505C\u603B\u5F00\u5173\u72B6\u6001\u3002"
  }),
  entry({
    key: "killswitch.lockdownOnHighRisk",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u9AD8\u98CE\u9669\u62D2\u7EDD\u540E\u8FDB\u5165\u9501\u5B9A\u3002"
  }),
  entry({
    key: "killswitch.unlockPolicy",
    type: "enum",
    enumValues: ["explicit"],
    defaultValue: "explicit",
    risk: "HIGH",
    description: "\u6025\u505C\u89E3\u9501\u7B56\u7565\u3002"
  }),
  entry({
    key: "killswitch.stopTargets",
    type: "object",
    defaultValue: {
      desktop: true,
      outbound: true,
      exec: true,
      browser: true,
      voice: false
    },
    risk: "HIGH",
    description: "\u6025\u505C\u9700\u8981\u505C\u6B62\u7684\u76EE\u6807\u6A21\u5757\u3002"
  }),
  entry({
    key: "gateway.bindHost",
    type: "string",
    defaultValue: "127.0.0.1",
    risk: "MED",
    description: "Gateway \u7ED1\u5B9A\u5730\u5740\u3002"
  }),
  entry({
    key: "gateway.port",
    type: "integer",
    minimum: 1024,
    maximum: 65535,
    defaultValue: 17321,
    risk: "MED",
    description: "Gateway \u76D1\u542C\u7AEF\u53E3\u3002"
  }),
  entry({
    key: "gateway.baseUrl",
    type: "string",
    defaultValue: "http://127.0.0.1:17321",
    risk: "MED",
    description: "Gateway \u57FA\u7840 URL\u3002"
  }),
  entry({
    key: "gateway.wsPath",
    type: "string",
    defaultValue: "/ws",
    risk: "MED",
    description: "Gateway WebSocket \u8DEF\u5F84\u3002"
  }),
  entry({
    key: "gateway.staticSpa.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u662F\u5426\u542F\u7528\u9759\u6001\u7F51\u9875\u63A7\u5236\u53F0\u3002"
  }),
  entry({
    key: "gateway.auth.mode",
    type: "enum",
    enumValues: ["localToken", "none"],
    defaultValue: "localToken",
    risk: "HIGH",
    description: "Gateway \u9274\u6743\u6A21\u5F0F\u3002"
  }),
  entry({
    key: "runtime.backpressure.max_in_flight",
    type: "integer",
    minimum: 1,
    maximum: 128,
    defaultValue: 8,
    risk: "MED",
    description: "Gateway \u6700\u5927\u5E76\u53D1\u6267\u884C\u6570\u3002"
  }),
  entry({
    key: "runtime.backpressure.max_queued",
    type: "integer",
    minimum: 1,
    maximum: 1024,
    defaultValue: 64,
    risk: "MED",
    description: "Gateway \u6700\u5927\u6392\u961F\u8BF7\u6C42\u6570\u3002"
  }),
  entry({
    key: "runtime.backpressure.queue_timeout_ms",
    type: "integer",
    minimum: 100,
    maximum: 12e4,
    defaultValue: 15e3,
    risk: "MED",
    description: "Gateway \u6392\u961F\u8D85\u65F6\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09\u3002"
  }),
  entry({
    key: "runtime.backpressure.daemon_max_pending_requests",
    type: "integer",
    minimum: 4,
    maximum: 1024,
    defaultValue: 64,
    risk: "MED",
    description: "Daemon Launcher \u6700\u5927\u6302\u8D77\u8BF7\u6C42\u6570\u3002"
  }),
  entry({
    key: "runtime.notifications.job_toast",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: "\u4EFB\u52A1\u5B8C\u6210/\u5931\u8D25\u65F6\u662F\u5426\u63A8\u9001 toast \u901A\u77E5\u3002"
  }),
  entry({
    key: "runtime.multimodal.test_mode",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: "\u591A\u6A21\u6001\u5355\u5143\u6D4B\u8BD5\u6A21\u5F0F\uFF08\u4F7F\u7528\u53EF\u8FFD\u6EAF\u964D\u7EA7\u8D44\u4EA7\uFF09\u3002"
  }),
  entry({
    key: "security.voiceprint.strict",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u58F0\u7EB9\u6821\u9A8C\u4E25\u683C\u6A21\u5F0F\u5F00\u5173\u3002"
  }),
  entry({
    key: "skills.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u662F\u5426\u542F\u7528\u6280\u80FD\u7CFB\u7EDF\u3002"
  }),
  entry({
    key: "skills.packages",
    type: "array",
    defaultValue: [],
    risk: "MED",
    description: "\u5DF2\u542F\u7528\u6280\u80FD\u5305\u5217\u8868\u3002"
  }),
  entry({
    key: "skills.versionLock.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u6280\u80FD\u5305\u7248\u672C\u9501\u5B9A\u3002"
  }),
  entry({
    key: "skills.compat.openCodeNative",
    type: "boolean",
    defaultValue: true,
    risk: "LOW",
    description: "\u517C\u5BB9 OpenCode \u539F\u751F\u6280\u80FD\u3002"
  }),
  entry({
    key: "desktop.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: "\u684C\u9762\u81EA\u52A8\u5316\u5F00\u5173\u3002"
  }),
  entry({
    key: "desktop.preferUia",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u4F18\u5148 UIA \u81EA\u52A8\u5316\u3002"
  }),
  entry({
    key: "desktop.requirePreSendScreenshotVerify",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u53D1\u9001\u524D\u622A\u56FE\u6838\u9A8C\u3002"
  }),
  entry({
    key: "desktop.requirePostActionVerify",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u52A8\u4F5C\u540E\u72B6\u6001\u6838\u9A8C\u3002"
  }),
  entry({
    key: "desktop.focusPolicy",
    type: "enum",
    enumValues: ["strict", "relaxed"],
    defaultValue: "strict",
    risk: "HIGH",
    description: "\u684C\u9762\u7126\u70B9\u7B56\u7565\u3002"
  }),
  entry({
    key: "outbound.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: "\u5916\u53D1\u6D88\u606F\u603B\u5F00\u5173\u3002"
  }),
  entry({
    key: "outbound.channels",
    type: "object",
    defaultValue: {
      qq: true,
      wechat: true
    },
    risk: "HIGH",
    description: "\u5916\u53D1\u6E20\u9053\u914D\u7F6E\uFF08\u4EC5 QQ/\u5FAE\u4FE1\uFF09\u3002"
  }),
  entry({
    key: "outbound.requireDraftInChat",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u5916\u53D1\u524D\u5148\u5728\u5BF9\u8BDD\u4E2D\u751F\u6210\u8349\u7A3F\u3002"
  }),
  entry({
    key: "outbound.requireVerifierSign",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u5916\u53D1\u524D\u5F3A\u5236 verifier \u7B7E\u5B57\u3002"
  }),
  entry({
    key: "voice.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "HIGH",
    description: "\u8BED\u97F3\u80FD\u529B\u603B\u5F00\u5173\u3002"
  }),
  entry({
    key: "voice.input.stt",
    type: "enum",
    enumValues: ["local", "off"],
    defaultValue: "local",
    risk: "MED",
    description: "\u8BED\u97F3\u8F93\u5165 STT \u6A21\u5F0F\u3002"
  }),
  entry({
    key: "voice.output.tts",
    type: "enum",
    enumValues: ["local", "off"],
    defaultValue: "local",
    risk: "MED",
    description: "\u8BED\u97F3\u8F93\u51FA TTS \u6A21\u5F0F\u3002"
  }),
  entry({
    key: "voice.wakeWord.enabled",
    type: "boolean",
    defaultValue: false,
    risk: "MED",
    description: "\u5524\u9192\u8BCD\u5F00\u5173\u3002"
  }),
  entry({
    key: "voice.oneShotMode",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u4E00\u53E5\u8BDD\u89E6\u53D1\u6A21\u5F0F\u3002"
  }),
  entry({
    key: "voice.routeToChat",
    type: "boolean",
    defaultValue: true,
    risk: "MED",
    description: "\u8BED\u97F3\u8F93\u5165\u7EDF\u4E00\u5199\u5165\u4F1A\u8BDD\u3002"
  }),
  entry({
    key: "git.autoPush.enabled",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u81EA\u52A8\u63A8\u9001\u5F00\u5173\u3002"
  }),
  entry({
    key: "git.autoPush.remote",
    type: "string",
    defaultValue: "https://github.com/mmy4shadow/miya-for-opencode.git",
    risk: "HIGH",
    description: "\u81EA\u52A8\u63A8\u9001\u8FDC\u7AEF\u4ED3\u5E93\u3002"
  }),
  entry({
    key: "git.autoPush.branchPattern",
    type: "string",
    defaultValue: "refs/heads/miya/<session-id>",
    risk: "HIGH",
    description: "\u81EA\u52A8\u63A8\u9001\u5206\u652F\u7B56\u7565\u3002"
  }),
  entry({
    key: "git.autoPush.maxFileSizeMB",
    type: "integer",
    minimum: 1,
    maximum: 50,
    defaultValue: 2,
    risk: "HIGH",
    description: "\u81EA\u52A8\u63A8\u9001\u5355\u6587\u4EF6\u5927\u5C0F\u4E0A\u9650\u3002"
  }),
  entry({
    key: "git.autoPush.blockWhenKillSwitchActive",
    type: "boolean",
    defaultValue: true,
    risk: "HIGH",
    description: "\u6025\u505C\u65F6\u963B\u65AD\u81EA\u52A8\u63A8\u9001\u3002"
  }),
  entry({
    key: "git.autoPush.excludeGlobs",
    type: "array",
    defaultValue: [
      ".opencode/**",
      ".venv/**",
      "node_modules/**",
      "**/*.pem",
      "**/*.key",
      "**/.env*"
    ],
    risk: "HIGH",
    description: "\u81EA\u52A8\u63A8\u9001\u6392\u9664\u5217\u8868\u3002"
  })
];
var REGISTRY_MAP = new Map(
  SETTINGS_REGISTRY.map((item) => [item.key, item])
);
function leafSchema(entryValue) {
  if (entryValue.type === "boolean") return { type: "boolean" };
  if (entryValue.type === "integer") {
    const schema = { type: "integer" };
    if (typeof entryValue.minimum === "number") schema.minimum = entryValue.minimum;
    if (typeof entryValue.maximum === "number") schema.maximum = entryValue.maximum;
    return schema;
  }
  if (entryValue.type === "string") return { type: "string" };
  if (entryValue.type === "enum") {
    return { type: "string", enum: [...entryValue.enumValues ?? []] };
  }
  if (entryValue.type === "array") return { type: "array" };
  return { type: "object" };
}
function setSchemaAtPath(root, key, schema) {
  const segments = keySegments(key);
  if (segments.length === 0) return;
  let current = root;
  for (let index = 0; index < segments.length - 1; index += 1) {
    const segment = segments[index];
    const existing = current[segment];
    if (!existing || typeof existing !== "object") {
      current[segment] = {
        type: "object",
        additionalProperties: true,
        properties: {}
      };
    }
    const node = current[segment];
    if (!node.properties || typeof node.properties !== "object") {
      node.properties = {};
    }
    current = node.properties;
  }
  current[segments[segments.length - 1]] = schema;
}
function getSettingEntry(key) {
  return REGISTRY_MAP.get(key);
}
function listSettingEntries() {
  return SETTINGS_REGISTRY.map((item) => cloneValue(item));
}
function buildDefaultConfig() {
  const config3 = {};
  for (const item of SETTINGS_REGISTRY) {
    setNestedValue(config3, item.key, cloneValue(item.defaultValue));
  }
  return config3;
}
function buildRegistryDocument() {
  return {
    version: 1,
    generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    settings: listSettingEntries()
  };
}
function buildSchemaDocument() {
  const rootProperties = {};
  for (const item of SETTINGS_REGISTRY) {
    setSchemaAtPath(rootProperties, item.key, leafSchema(item));
  }
  return {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    title: "Miya Config",
    type: "object",
    additionalProperties: true,
    properties: rootProperties
  };
}

// src/settings/store.ts
import * as fs21 from "node:fs";
import * as path21 from "node:path";
var EMPTY_PATCH = { set: {}, unset: [] };
function runtimeFile2(projectDir, fileName) {
  return path21.join(getMiyaRuntimeDir(projectDir), fileName);
}
function ensureDir11(file3) {
  fs21.mkdirSync(path21.dirname(file3), { recursive: true });
}
function cloneValue2(value) {
  return JSON.parse(JSON.stringify(value));
}
function writeJson2(file3, value) {
  ensureDir11(file3);
  fs21.writeFileSync(file3, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function readJsonObject(file3) {
  if (!fs21.existsSync(file3)) return {};
  try {
    const parsed = JSON.parse(fs21.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return {};
    }
    return parsed;
  } catch {
    return {};
  }
}
function riskRank(risk) {
  if (risk === "HIGH") return 3;
  if (risk === "MED") return 2;
  return 1;
}
function maxRisk(current, next) {
  return riskRank(next) > riskRank(current) ? next : current;
}
function deepEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}
function normalizePathToKey(input) {
  const trimmed = input.trim();
  if (!trimmed) return "";
  if (trimmed.startsWith("/")) {
    return trimmed.split("/").map((segment) => segment.trim()).filter((segment) => segment.length > 0).join(".");
  }
  return trimmed;
}
function normalizePatchObject(input) {
  if ("jsonPatch" in input && Array.isArray(input.jsonPatch)) {
    return normalizePatchInput(input.jsonPatch);
  }
  if ("patch" in input && input.patch !== void 0) {
    return normalizePatchInput(input.patch);
  }
  const setRaw = "set" in input && input.set && typeof input.set === "object" ? input.set : null;
  const unsetRaw = "unset" in input && Array.isArray(input.unset) ? input.unset : "reset" in input && Array.isArray(input.reset) ? input.reset : null;
  if (setRaw || unsetRaw) {
    const patch2 = {
      set: {},
      unset: []
    };
    const errors = [];
    if (setRaw) {
      for (const [key, value] of Object.entries(setRaw)) {
        const normalizedKey = normalizePathToKey(key);
        if (!normalizedKey) {
          errors.push(`Invalid set key: ${key}`);
          continue;
        }
        patch2.set[normalizedKey] = value;
      }
    }
    if (unsetRaw) {
      for (const key of unsetRaw) {
        const normalizedKey = normalizePathToKey(String(key));
        if (!normalizedKey) {
          errors.push(`Invalid unset key: ${String(key)}`);
          continue;
        }
        patch2.unset.push(normalizedKey);
      }
    }
    patch2.unset = [...new Set(patch2.unset)];
    return { patch: patch2, errors };
  }
  const patch = { set: {}, unset: [] };
  for (const [key, value] of Object.entries(input)) {
    const normalizedKey = normalizePathToKey(key);
    if (!normalizedKey) continue;
    patch.set[normalizedKey] = value;
  }
  return { patch, errors: [] };
}
function normalizeJsonPatchArray(input) {
  const patch = { set: {}, unset: [] };
  const errors = [];
  for (const item of input) {
    if (!item || typeof item !== "object" || Array.isArray(item)) {
      errors.push("JSON Patch item must be an object.");
      continue;
    }
    const op = String(item.op ?? "").toLowerCase();
    const pathValue = String(item.path ?? "");
    const key = normalizePathToKey(pathValue);
    if (!key) {
      errors.push(`JSON Patch path is invalid: ${pathValue}`);
      continue;
    }
    if (op === "remove") {
      patch.unset.push(key);
      continue;
    }
    if (op === "add" || op === "replace" || op === "set") {
      patch.set[key] = item.value;
      continue;
    }
    errors.push(`Unsupported JSON Patch operation: ${op}`);
  }
  patch.unset = [...new Set(patch.unset)];
  return { patch, errors };
}
function validateValueType(entryValue, value) {
  const valueType = entryValue.type;
  if (valueType === "boolean") {
    return typeof value === "boolean" ? null : `Expected boolean for ${entryValue.key}.`;
  }
  if (valueType === "integer") {
    if (typeof value !== "number" || !Number.isInteger(value)) {
      return `Expected integer for ${entryValue.key}.`;
    }
    if (typeof entryValue.minimum === "number" && value < entryValue.minimum) {
      return `${entryValue.key} must be >= ${entryValue.minimum}.`;
    }
    if (typeof entryValue.maximum === "number" && value > entryValue.maximum) {
      return `${entryValue.key} must be <= ${entryValue.maximum}.`;
    }
    return null;
  }
  if (valueType === "string") {
    return typeof value === "string" ? null : `Expected string for ${entryValue.key}.`;
  }
  if (valueType === "enum") {
    if (typeof value !== "string") {
      return `Expected enum string for ${entryValue.key}.`;
    }
    const options = entryValue.enumValues ?? [];
    if (!options.includes(value)) {
      return `${entryValue.key} must be one of: ${options.join(", ")}.`;
    }
    return null;
  }
  if (valueType === "object") {
    return value && typeof value === "object" && !Array.isArray(value) ? null : `Expected object for ${entryValue.key}.`;
  }
  if (valueType === "array") {
    return Array.isArray(value) ? null : `Expected array for ${entryValue.key}.`;
  }
  return `Unsupported type for ${entryValue.key}.`;
}
function mergeConfigWithDefaults(raw) {
  const merged = cloneValue2(raw);
  for (const item of listSettingEntries()) {
    const current = getNestedValue(merged, item.key);
    if (current === void 0) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
      continue;
    }
    const issue3 = validateValueType(item, current);
    if (issue3) {
      setNestedValue(merged, item.key, cloneValue2(item.defaultValue));
    }
  }
  return merged;
}
function ensureSettingsFiles(projectDir) {
  const registryPath = runtimeFile2(projectDir, "registry.json");
  const schemaPath = runtimeFile2(projectDir, "schema.json");
  const configPath = runtimeFile2(projectDir, "config.json");
  writeJson2(registryPath, buildRegistryDocument());
  writeJson2(schemaPath, buildSchemaDocument());
  if (!fs21.existsSync(configPath)) {
    writeJson2(configPath, buildDefaultConfig());
    return;
  }
  const raw = readJsonObject(configPath);
  const normalized = mergeConfigWithDefaults(raw);
  writeJson2(configPath, normalized);
}
function readConfig(projectDir) {
  ensureSettingsFiles(projectDir);
  const raw = readJsonObject(runtimeFile2(projectDir, "config.json"));
  return mergeConfigWithDefaults(raw);
}
function writeConfig(projectDir, config3) {
  ensureSettingsFiles(projectDir);
  writeJson2(runtimeFile2(projectDir, "config.json"), mergeConfigWithDefaults(config3));
}
function flattenConfig(config3) {
  const flat = {};
  for (const item of listSettingEntries()) {
    flat[item.key] = getNestedValue(config3, item.key);
  }
  return flat;
}
function normalizePatchInput(input) {
  if (!input) {
    return { patch: cloneValue2(EMPTY_PATCH), errors: ["Patch payload is empty."] };
  }
  if (Array.isArray(input)) {
    return normalizeJsonPatchArray(input);
  }
  if (typeof input !== "object") {
    return {
      patch: cloneValue2(EMPTY_PATCH),
      errors: ["Patch payload must be an object or JSON Patch array."]
    };
  }
  return normalizePatchObject(input);
}
function validateConfigPatch(projectDir, patchInput) {
  const currentConfig = readConfig(projectDir);
  const normalized = normalizePatchInput(patchInput);
  const errors = [...normalized.errors];
  const warnings = [];
  const changes = [];
  const keysToCheck = [
    ...Object.keys(normalized.patch.set),
    ...normalized.patch.unset
  ];
  const uniqueKeys = [...new Set(keysToCheck)];
  for (const key of uniqueKeys) {
    const setting = getSettingEntry(key);
    if (!setting) {
      errors.push(`Unknown setting key: ${key}`);
      continue;
    }
    const isReset = normalized.patch.unset.includes(key);
    const nextValue = isReset ? cloneValue2(setting.defaultValue) : normalized.patch.set[key];
    const previousValue = getNestedValue(currentConfig, key);
    const issue3 = validateValueType(setting, nextValue);
    if (issue3) {
      errors.push(issue3);
      continue;
    }
    if (deepEqual(previousValue, nextValue)) {
      warnings.push(`${key} is unchanged.`);
      continue;
    }
    changes.push({
      key,
      operation: isReset ? "reset" : "set",
      risk: setting.risk,
      description: setting.description,
      previousValue,
      nextValue,
      requiresEvidence: setting.requiresEvidence
    });
  }
  let highestRisk = "LOW";
  for (const change of changes) {
    highestRisk = maxRisk(highestRisk, change.risk);
  }
  if (normalized.patch.set["outbound.enabled"] === true && normalized.patch.set["desktop.requirePreSendScreenshotVerify"] === false) {
    errors.push(
      "outbound.enabled=true \u65F6\u4E0D\u5141\u8BB8\u5C06 desktop.requirePreSendScreenshotVerify \u8BBE\u4E3A false\u3002"
    );
  }
  if (changes.length === 0 && errors.length === 0) {
    warnings.push("Patch has no effective changes.");
  }
  const requiredSafetyTier = highestRisk === "HIGH" ? "THOROUGH" : highestRisk === "MED" ? "STANDARD" : "LIGHT";
  return {
    ok: errors.length === 0 && changes.length > 0,
    errors,
    warnings,
    normalizedPatch: normalized.patch,
    changes,
    maxRisk: highestRisk,
    requiresEvidence: changes.some((change) => change.requiresEvidence),
    requiredSafetyTier
  };
}
function applyConfigPatch(projectDir, validation) {
  const config3 = readConfig(projectDir);
  for (const change of validation.changes) {
    setNestedValue(config3, change.key, cloneValue2(change.nextValue));
  }
  writeConfig(projectDir, config3);
  return {
    updatedConfig: readConfig(projectDir),
    applied: validation.changes
  };
}
function getConfigValue(projectDir, key) {
  const config3 = readConfig(projectDir);
  if (!key) return flattenConfig(config3);
  return getNestedValue(config3, key);
}

// src/settings/tools.ts
import { spawn as spawn3 } from "node:child_process";

// src/safety/evidence.ts
import * as fs22 from "node:fs";
import * as path22 from "node:path";
var MAX_OUTPUT = 8e3;
var LARGE_FILE_LIMIT = 2 * 1024 * 1024;
var SECRET_RULES = [
  { name: "openai", pattern: /\bsk-[A-Za-z0-9_-]{20,}\b/ },
  { name: "github_pat", pattern: /\bgh[pousr]_[A-Za-z0-9]{20,}\b/ },
  { name: "slack_token", pattern: /\bxox[baprs]-[A-Za-z0-9-]{10,}\b/ },
  { name: "aws_key", pattern: /\bAKIA[0-9A-Z]{16}\b/ },
  { name: "private_key", pattern: /-----BEGIN [A-Z ]*PRIVATE KEY-----/ }
];
function truncate(text) {
  if (text.length <= MAX_OUTPUT) return text;
  return `${text.slice(0, MAX_OUTPUT)}
...[truncated]`;
}
async function runCommand2(projectDir, command, timeoutMs = 6e4) {
  const result = await runProcess(command[0], command.slice(1), {
    cwd: projectDir,
    timeoutMs
  });
  const stdout = truncate(result.stdout);
  const stderr = truncate(result.stderr);
  return {
    ok: result.exitCode === 0 && !result.timedOut,
    code: result.exitCode,
    stdout,
    stderr: result.timedOut ? `${stderr}
[timeout]` : stderr
  };
}
function scanSecrets(content) {
  const hits = [];
  for (const rule of SECRET_RULES) {
    if (rule.pattern.test(content)) {
      hits.push(rule.name);
    }
  }
  return hits;
}
async function collectSafetyEvidence(projectDir, tier) {
  const checks = [];
  const evidence = [];
  const issues = [];
  const status = await runCommand2(projectDir, ["git", "status", "--porcelain"]);
  checks.push("git status --porcelain");
  evidence.push(`git_status_exit=${status.code}`);
  if (status.stdout) evidence.push(`git_status:
${status.stdout}`);
  if (!status.ok) issues.push(`git status failed: ${status.stderr || status.code}`);
  const diffStat = await runCommand2(projectDir, ["git", "diff", "--stat"]);
  checks.push("git diff --stat");
  evidence.push(`git_diff_stat_exit=${diffStat.code}`);
  if (diffStat.stdout) evidence.push(`git_diff_stat:
${diffStat.stdout}`);
  if (!diffStat.ok) issues.push(`git diff --stat failed: ${diffStat.stderr || diffStat.code}`);
  const changed = await runCommand2(projectDir, ["git", "diff", "--name-only"]);
  const changedFiles = changed.stdout.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
  if (changedFiles.some((file3) => file3.startsWith("miya-src/"))) {
    const test = await runCommand2(
      projectDir,
      ["npm", "--prefix", "miya-src", "run", "typecheck"],
      12e4
    );
    checks.push("npm --prefix miya-src run typecheck");
    evidence.push(`miya_typecheck_exit=${test.code}`);
    if (test.stdout) evidence.push(`miya_typecheck_stdout:
${test.stdout}`);
    if (test.stderr) evidence.push(`miya_typecheck_stderr:
${test.stderr}`);
    if (!test.ok) issues.push("miya-src typecheck failed");
  }
  if (tier === "THOROUGH") {
    const diff = await runCommand2(projectDir, ["git", "diff"]);
    checks.push("git diff");
    evidence.push(`git_diff_exit=${diff.code}`);
    const diffText = [diff.stdout, diff.stderr].filter(Boolean).join("\n");
    if (diffText) evidence.push(`git_diff:
${diffText}`);
    if (!diff.ok) issues.push(`git diff failed: ${diff.stderr || diff.code}`);
    const secretHits = scanSecrets(diffText);
    if (secretHits.length > 0) {
      issues.push(`secret scan matched: ${secretHits.join(", ")}`);
    }
    checks.push("secret scan (workspace diff)");
    const oversized = changedFiles.map((file3) => {
      const full = path22.join(projectDir, file3);
      if (!fs22.existsSync(full)) return null;
      const stat = fs22.statSync(full);
      if (!stat.isFile()) return null;
      if (stat.size <= LARGE_FILE_LIMIT) return null;
      return `${file3} (${stat.size} bytes)`;
    }).filter((line) => line !== null);
    checks.push("large file scan (2MB)");
    if (oversized.length > 0) {
      issues.push(`large file threshold exceeded: ${oversized.join(", ")}`);
    }
  }
  return {
    pass: issues.length === 0,
    checks,
    evidence,
    issues
  };
}

// src/safety/verifier.ts
function extractText(parts) {
  return parts.filter((part) => typeof part.text === "string").map((part) => String(part.text)).join("\n").trim();
}
function parseVerdict(text) {
  const allow = /\bVERDICT:\s*ALLOW\b/i.test(text);
  const deny = /\bVERDICT:\s*DENY\b/i.test(text);
  const summaryMatch = /REASON:\s*([^\n]+)/i.exec(text);
  if (allow && !deny) {
    return {
      verdict: "allow",
      summary: summaryMatch?.[1]?.trim() ?? "Verifier allowed action.",
      raw: text
    };
  }
  return {
    verdict: "deny",
    summary: summaryMatch?.[1]?.trim() ?? "Verifier denied action.",
    raw: text
  };
}
async function runVerifier(ctx, input) {
  const prompt = [
    "You are the safety verifier.",
    "Do not call tools. Text response only.",
    "Reject if evidence is insufficient or issues are non-empty.",
    "",
    `trace_id=${input.traceID}`,
    `request_hash=${input.requestHash}`,
    `tier=${input.tier}`,
    `action=${input.action}`,
    "",
    "checks:",
    ...input.checks.map((check3) => `- ${check3}`),
    "",
    "issues:",
    ...input.issues.length > 0 ? input.issues.map((issue3) => `- ${issue3}`) : ["- none"],
    "",
    "evidence:",
    ...input.evidence.slice(0, 20).map((item) => `- ${item}`),
    "",
    "Respond in exact format:",
    "VERDICT: ALLOW|DENY",
    "REASON: <single sentence>"
  ].join("\n");
  try {
    const response = await ctx.client.session.prompt({
      path: { id: input.sessionID },
      body: {
        agent: "4-architecture-advisor",
        parts: [{ type: "text", text: prompt }]
      },
      query: { directory: ctx.directory }
    });
    const text = extractText(
      response.data?.parts ?? []
    );
    if (!text) {
      return {
        verdict: "deny",
        summary: "Verifier returned empty response.",
        raw: ""
      };
    }
    return parseVerdict(text);
  } catch (error92) {
    return {
      verdict: "deny",
      summary: error92 instanceof Error ? error92.message : String(error92),
      raw: ""
    };
  }
}

// src/settings/tools.ts
var z2 = tool.schema;
function formatValue(value) {
  if (value === void 0) return "undefined";
  if (typeof value === "string") return value;
  try {
    return JSON.stringify(value, null, 2);
  } catch {
    return String(value);
  }
}
function formatValidationResult(validation) {
  const lines = [
    `ok=${validation.ok}`,
    `risk=${validation.maxRisk}`,
    `required_tier=${validation.requiredSafetyTier}`,
    `requires_evidence=${validation.requiresEvidence}`,
    `changes=${validation.changes.length}`
  ];
  if (validation.errors.length > 0) {
    lines.push(`errors=${validation.errors.join(" | ")}`);
  }
  if (validation.warnings.length > 0) {
    lines.push(`warnings=${validation.warnings.join(" | ")}`);
  }
  if (validation.changes.length > 0) {
    lines.push(
      `changed_keys=${validation.changes.map((item) => item.key).join(", ")}`
    );
  }
  return lines.join("\n");
}
function openUrl(url3) {
  if (process.platform === "win32") {
    const child2 = spawn3("cmd", ["/c", "start", "", url3], {
      detached: true,
      stdio: "ignore"
    });
    child2.unref();
    return;
  }
  if (process.platform === "darwin") {
    const child2 = spawn3("open", [url3], { detached: true, stdio: "ignore" });
    child2.unref();
    return;
  }
  const child = spawn3("xdg-open", [url3], { detached: true, stdio: "ignore" });
  child.unref();
}
function stringifyPatch(input) {
  try {
    return JSON.stringify(input);
  } catch {
    return String(input);
  }
}
function safetyTierFromValidation(validation) {
  if (validation.requiredSafetyTier === "THOROUGH") return "THOROUGH";
  if (validation.requiredSafetyTier === "STANDARD") return "STANDARD";
  return "LIGHT";
}
function createConfigTools(ctx) {
  const miya_config_get = tool({
    description: "Read Miya runtime config by key (or all flattened keys).",
    args: {
      key: z2.string().optional().describe("Setting key, e.g. ui.language")
    },
    async execute(args) {
      const key = args.key ? String(args.key) : void 0;
      const value = getConfigValue(ctx.directory, key);
      if (key) {
        return `key=${key}
value=${formatValue(value)}`;
      }
      return formatValue(value);
    }
  });
  const miya_registry_list = tool({
    description: "List all writable Miya settings from registry with risk/type/default info.",
    args: {},
    async execute() {
      return formatValue({ settings: listSettingEntries() });
    }
  });
  const miya_config_validate = tool({
    description: "Validate config patch without writing (type/range/conflict/risk checks).",
    args: {
      patch: z2.any().describe("Patch payload: {set,unset} or JSON Patch array")
    },
    async execute(args) {
      return formatValidationResult(
        validateConfigPatch(ctx.directory, args.patch)
      );
    }
  });
  const miya_config_patch = tool({
    description: "Apply Miya config patch with self-approval audit. HIGH risk enforces THOROUGH verification.",
    args: {
      patch: z2.any().describe("Patch payload: {set,unset} or JSON Patch array"),
      reason: z2.string().optional().describe("Reason for this change")
    },
    async execute(args, toolContext) {
      const sessionID2 = toolContext && typeof toolContext === "object" && "sessionID" in toolContext ? String(toolContext.sessionID) : "main";
      const validation = validateConfigPatch(ctx.directory, args.patch);
      if (!validation.ok) {
        return formatValidationResult(validation);
      }
      const traceID = createTraceId();
      const reason = args.reason && String(args.reason).trim().length > 0 ? String(args.reason).trim() : "config_patch";
      const action = `miya.config.patch ${reason}`;
      const tier = safetyTierFromValidation(validation);
      let allow = true;
      let verifierSummary = "LOW/MED \u914D\u7F6E\u53D8\u66F4\u81EA\u52A8\u901A\u8FC7\u3002";
      let checks = ["config patch validation"];
      let evidence = [
        `patch=${stringifyPatch(args.patch)}`,
        `risk=${validation.maxRisk}`,
        `required_tier=${validation.requiredSafetyTier}`
      ];
      let issues = [];
      if (validation.maxRisk === "HIGH") {
        const kill = readKillSwitch(ctx.directory);
        if (kill.active) {
          allow = false;
          verifierSummary = "Kill switch \u5DF2\u6FC0\u6D3B\uFF0C\u62D2\u7EDD\u9AD8\u98CE\u9669\u914D\u7F6E\u53D8\u66F4\u3002";
          issues = ["kill_switch_active"];
        } else {
          const collected = await collectSafetyEvidence(ctx.directory, "THOROUGH");
          checks = [...checks, ...collected.checks];
          evidence = [...evidence, ...collected.evidence.slice(0, 20)];
          issues = [...collected.issues];
          const verifier = await runVerifier(ctx, {
            sessionID: sessionID2,
            traceID,
            requestHash: `config:${traceID}`,
            tier: "THOROUGH",
            action,
            checks,
            evidence,
            issues
          });
          verifierSummary = verifier.summary;
          allow = collected.pass && verifier.verdict === "allow";
        }
      }
      writeSelfApprovalRecord(ctx.directory, {
        trace_id: traceID,
        session_id: sessionID2,
        request_hash: `config:${traceID}`,
        action,
        tier,
        status: allow ? "allow" : "deny",
        reason: allow ? verifierSummary : `config_patch_denied:${verifierSummary}`,
        checks: checks.slice(0, 20),
        evidence: evidence.slice(0, 30),
        executor: {
          agent: "executor",
          plan: action
        },
        verifier: {
          agent: "4-architecture-advisor",
          verdict: allow ? "allow" : "deny",
          summary: verifierSummary
        },
        rollback: {
          strategy: "\u4F7F\u7528\u540C\u4E00\u5DE5\u5177\u63D0\u4EA4\u53CD\u5411 patch \u56DE\u6EDA\u3002"
        }
      });
      if (!allow) {
        activateKillSwitch(
          ctx.directory,
          `config_patch_denied:${verifierSummary}`,
          traceID
        );
        return [
          "VERDICT=DENY",
          `trace_id=${traceID}`,
          `risk=${validation.maxRisk}`,
          `reason=${verifierSummary}`,
          `changed_keys=${validation.changes.map((item) => item.key).join(", ")}`
        ].join("\n");
      }
      const applied = applyConfigPatch(ctx.directory, validation);
      return [
        "VERDICT=ALLOW",
        `trace_id=${traceID}`,
        `risk=${validation.maxRisk}`,
        `required_tier=${validation.requiredSafetyTier}`,
        `changed_keys=${applied.applied.map((item) => item.key).join(", ")}`
      ].join("\n");
    }
  });
  const miya_ui_open = tool({
    description: "Open Miya \u672C\u5730\u63A7\u5236\u53F0\u9875\u9762\uFF08\u9ED8\u8BA4\u6D4F\u89C8\u5668\uFF09\u3002",
    args: {},
    async execute() {
      let state2 = ensureGatewayRunning(ctx.directory);
      let healthy = await probeGatewayAlive(state2.url);
      if (!healthy) {
        stopGateway(ctx.directory);
        state2 = ensureGatewayRunning(ctx.directory);
        healthy = await probeGatewayAlive(state2.url, 1200);
      }
      if (!healthy) {
        return `opened=false
reason=gateway_unhealthy
url=${state2.url}`;
      }
      openUrl(state2.url);
      return `opened=${state2.url}`;
    }
  });
  return {
    miya_config_get,
    miya_config_validate,
    miya_config_patch,
    miya_registry_list,
    miya_ui_open
  };
}

// src/daemon/ws-protocol.ts
var JsonValue = external_exports.lazy(
  () => external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean(), external_exports.null(), external_exports.array(JsonValue), external_exports.record(external_exports.string(), JsonValue)])
);
var JsonObject = external_exports.record(external_exports.string(), JsonValue);
var DaemonHelloFrameSchema = external_exports.object({
  type: external_exports.literal("hello"),
  clientID: external_exports.string().min(1).max(120).optional(),
  role: external_exports.enum(["plugin", "ui", "unknown"]).default("plugin"),
  protocolVersion: external_exports.string().default("1.0"),
  auth: external_exports.object({
    token: external_exports.string().min(1)
  }).optional()
});
var DaemonRequestFrameSchema = external_exports.object({
  type: external_exports.literal("request"),
  id: external_exports.string().min(1),
  method: external_exports.string().min(1),
  params: JsonObject.default({})
});
var DaemonResponseFrameSchema = external_exports.object({
  type: external_exports.literal("response"),
  id: external_exports.string(),
  ok: external_exports.boolean(),
  result: JsonValue.optional(),
  error: external_exports.object({
    code: external_exports.string(),
    message: external_exports.string(),
    details: JsonValue.optional()
  }).optional()
});
var DaemonEventFrameSchema = external_exports.object({
  type: external_exports.literal("event"),
  event: external_exports.string().min(1),
  payload: JsonValue
});
var DaemonPingFrameSchema = external_exports.object({
  type: external_exports.literal("ping"),
  ts: external_exports.number().int().nonnegative()
});
var DaemonPongFrameSchema = external_exports.object({
  type: external_exports.literal("pong"),
  ts: external_exports.number().int().nonnegative()
});
var DaemonIncomingFrameSchema = external_exports.union([
  DaemonHelloFrameSchema,
  DaemonRequestFrameSchema,
  DaemonPingFrameSchema
]);
var DaemonOutgoingFrameSchema = external_exports.union([
  DaemonResponseFrameSchema,
  DaemonEventFrameSchema,
  DaemonPongFrameSchema
]);
function parseDaemonOutgoingFrame(input) {
  try {
    const value = typeof input === "string" ? JSON.parse(input) : input;
    const frame = DaemonOutgoingFrameSchema.parse(value);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}

// src/daemon/launcher.ts
var runtimes = /* @__PURE__ */ new Map();
var resolvedNodeBinaryCache;
function emitLauncherEvent(runtime, type, payload) {
  if (runtime.listeners.size === 0) return;
  const event = {
    type,
    at: nowIso10(),
    payload,
    snapshot: { ...runtime.snapshot }
  };
  for (const listener of runtime.listeners) {
    try {
      listener(event);
    } catch {
    }
  }
}
function syncBackpressureSnapshot(runtime) {
  runtime.snapshot.pendingRequests = runtime.pending.size;
  runtime.snapshot.rejectedRequests = runtime.rejectedRequests;
  runtime.snapshot.lastRejectReason = runtime.lastRejectReason;
}
function nowIso10() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function daemonDir(projectDir) {
  return path23.join(getMiyaRuntimeDir(projectDir), "daemon");
}
function daemonPidFile(projectDir) {
  return path23.join(daemonDir(projectDir), "daemon.pid");
}
function ensureDaemonDir(projectDir) {
  fs23.mkdirSync(daemonDir(projectDir), { recursive: true });
}
function safeWriteJson(filePath14, payload) {
  fs23.mkdirSync(path23.dirname(filePath14), { recursive: true });
  fs23.writeFileSync(filePath14, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
}
function safeReadJson(filePath14) {
  if (!fs23.existsSync(filePath14)) return null;
  try {
    const parsed = JSON.parse(fs23.readFileSync(filePath14, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return null;
    return parsed;
  } catch {
    return null;
  }
}
function toDaemonLock(raw) {
  if (!raw) return null;
  const pid = Number(raw.pid);
  const wsPort = Number(raw.wsPort);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  if (!Number.isFinite(pid) || !Number.isFinite(wsPort) || !token || !updatedAt) return null;
  return { pid, wsPort, token, updatedAt };
}
function resolveHostScriptPath(projectDir) {
  const here = path23.dirname(fileURLToPath(import.meta.url));
  const candidates = [
    path23.join(here, "host.ts"),
    path23.join(here, "host.js"),
    path23.join(projectDir, "src", "daemon", "host.ts"),
    path23.join(projectDir, "dist", "daemon", "host.js"),
    path23.join(projectDir, "miya-src", "src", "daemon", "host.ts"),
    path23.join(projectDir, "miya-src", "dist", "daemon", "host.js")
  ];
  for (const candidate of candidates) {
    if (fs23.existsSync(candidate)) return candidate;
  }
  return path23.join(here, "host.js");
}
function noteLaunchFailure(runtime, reason) {
  runtime.consecutiveLaunchFailures += 1;
  runtime.lastRejectReason = reason;
  if (runtime.consecutiveLaunchFailures >= runtime.maxConsecutiveLaunchFailures) {
    runtime.retryHalted = true;
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = `Miya Daemon Retry Halted (${reason})`;
  }
  syncBackpressureSnapshot(runtime);
}
function resetLaunchFailureState(runtime) {
  runtime.consecutiveLaunchFailures = 0;
  runtime.retryHalted = false;
  runtime.lastRejectReason = void 0;
  syncBackpressureSnapshot(runtime);
}
function resolveNodeBinary() {
  if (resolvedNodeBinaryCache !== void 0) return resolvedNodeBinaryCache;
  const configured = process.env.MIYA_NODE_BIN?.trim();
  const windowsNodeCandidates = process.platform === "win32" ? [
    path23.join(process.env.ProgramFiles ?? "C:\\Program Files", "nodejs", "node.exe"),
    path23.join(
      process.env["ProgramFiles(x86)"] ?? "C:\\Program Files (x86)",
      "nodejs",
      "node.exe"
    ),
    path23.join(process.env.LOCALAPPDATA ?? "", "Programs", "nodejs", "node.exe")
  ] : [];
  const candidates = [
    configured || null,
    (() => {
      const execBase = path23.basename(process.execPath).toLowerCase();
      return execBase === "node" || execBase === "node.exe" ? process.execPath : null;
    })(),
    ...windowsNodeCandidates,
    process.platform === "win32" ? "node.exe" : "node"
  ].filter((item) => Boolean(item));
  for (const candidate of candidates) {
    try {
      const probe = spawnSync4(candidate, ["--version"], {
        stdio: ["ignore", "ignore", "ignore"],
        timeout: 2e3,
        windowsHide: true
      });
      if (probe.status === 0) {
        resolvedNodeBinaryCache = candidate;
        return candidate;
      }
    } catch {
    }
  }
  return null;
}
function resolveLifecycleMode(projectDir) {
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "service") return "service_experimental";
  if (process.env.MIYA_DAEMON_LIFECYCLE_MODE === "coupled") return "coupled";
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime ?? {};
  return runtime.service_mode_experimental === true ? "service_experimental" : "coupled";
}
function spawnDaemon(runtime) {
  if (runtime.retryHalted) {
    return false;
  }
  if (runtime.lifecycleMode === "service_experimental") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Service Mode (attach only)";
    return false;
  }
  const now = Date.now();
  if (now - runtime.lastSpawnAttemptAtMs < 3e3) {
    return false;
  }
  runtime.lastSpawnAttemptAtMs = now;
  cleanupExistingDaemon(runtime.projectDir);
  const nodeBinary = resolveNodeBinary();
  if (!nodeBinary) {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (node_not_found)";
    noteLaunchFailure(runtime, "node_not_found");
    return false;
  }
  const binaryBase = path23.basename(nodeBinary).toLowerCase();
  if (binaryBase.includes("powershell") || binaryBase === "pwsh.exe") {
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disabled (invalid_runtime_binary)";
    noteLaunchFailure(runtime, "invalid_runtime_binary");
    return false;
  }
  const hostScript = resolveHostScriptPath(runtime.projectDir);
  const nodeArgs = [
    ...hostScript.endsWith(".ts") ? ["--import", "tsx"] : [],
    hostScript,
    "--project-dir",
    runtime.projectDir,
    "--parent-lock-file",
    runtime.parentLockFile,
    "--token",
    runtime.daemonToken
  ];
  spawn4(
    nodeBinary,
    nodeArgs,
    {
      cwd: path23.dirname(hostScript),
      detached: true,
      stdio: "ignore",
      windowsHide: true
    }
  ).unref();
  return true;
}
function readPidFile(projectDir) {
  const file3 = daemonPidFile(projectDir);
  if (!fs23.existsSync(file3)) return null;
  const raw = fs23.readFileSync(file3, "utf-8").trim();
  const pid = Number(raw);
  if (!Number.isFinite(pid) || pid <= 0) return null;
  return pid;
}
function isPidAlive(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function cleanupExistingDaemon(projectDir) {
  const stalePid = readPidFile(projectDir);
  if (!stalePid || !isPidAlive(stalePid)) return;
  try {
    process.kill(stalePid);
  } catch {
  }
}
function writeParentLock(runtime) {
  safeWriteJson(runtime.parentLockFile, {
    pid: process.pid,
    plugin: "miya",
    updatedAt: nowIso10()
  });
}
function connectWebSocket(runtime, lock) {
  const url3 = `ws://127.0.0.1:${lock.wsPort}/ws?token=${encodeURIComponent(runtime.daemonToken)}`;
  const ws = new WebSocket(url3);
  runtime.ws = ws;
  ws.onopen = () => {
    resetLaunchFailureState(runtime);
    runtime.connected = true;
    runtime.reconnectBackoffMs = 1e3;
    runtime.snapshot.statusText = "Miya Daemon Connected";
    runtime.snapshot.connected = true;
    runtime.snapshot.port = lock.wsPort;
    runtime.snapshot.pid = lock.pid;
    const hello = DaemonHelloFrameSchema.parse({
      type: "hello",
      clientID: `plugin-${process.pid}`,
      role: "plugin",
      protocolVersion: "1.0",
      auth: { token: runtime.daemonToken }
    });
    ws.send(JSON.stringify(hello));
    startHeartbeat(runtime);
    startStatusPoll(runtime);
  };
  ws.onmessage = (event) => {
    const parsed = parseDaemonOutgoingFrame(event.data);
    if (!parsed.frame) return;
    const frame = parsed.frame;
    if (frame.type === "pong") {
      runtime.lastPongAt = Date.now();
      if (runtime.pingWatchdog) clearTimeout(runtime.pingWatchdog);
      return;
    }
    if (frame.type === "response") {
      if (frame.id === "hello" && frame.ok) return;
      const pending = runtime.pending.get(frame.id);
      if (pending) {
        runtime.pending.delete(frame.id);
        clearTimeout(pending.timeout);
        syncBackpressureSnapshot(runtime);
        if (frame.ok) {
          pending.resolve(frame.result);
        } else {
          pending.reject(new Error(frame.error?.message ?? "daemon_request_failed"));
        }
      }
      return;
    }
    if (frame.type === "event" && frame.event === "daemon.ready") {
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.connected = true;
      emitLauncherEvent(runtime, "daemon.ready");
      return;
    }
    if (frame.type === "event" && frame.event === "job.progress") {
      const payload = frame.payload && typeof frame.payload === "object" && !Array.isArray(frame.payload) ? frame.payload : {};
      runtime.snapshot.activeJobID = typeof payload.jobID === "string" ? payload.jobID : runtime.snapshot.activeJobID;
      runtime.snapshot.activeJobProgress = typeof payload.progress === "number" ? Math.floor(payload.progress) : runtime.snapshot.activeJobProgress;
      runtime.snapshot.statusText = typeof payload.status === "string" && payload.status ? payload.status : runtime.snapshot.statusText;
      emitLauncherEvent(runtime, "job.progress", payload);
    }
  };
  ws.onerror = () => {
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Reconnecting";
  };
  ws.onclose = () => {
    noteLaunchFailure(runtime, "ws_closed");
    runtime.connected = false;
    runtime.snapshot.connected = false;
    runtime.snapshot.statusText = "Miya Daemon Disconnected";
    emitLauncherEvent(runtime, "daemon.disconnected");
    stopHeartbeat(runtime);
    stopStatusPoll(runtime);
    scheduleReconnect(runtime);
  };
}
function daemonRequest(runtime, method, params, timeoutMs = 8e3) {
  if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN) {
    runtime.lastRejectReason = "ws_not_open";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(new Error("daemon_ws_not_open"));
  }
  if (runtime.pending.size >= runtime.maxPendingRequests) {
    runtime.lastRejectReason = "overloaded";
    runtime.rejectedRequests += 1;
    syncBackpressureSnapshot(runtime);
    return Promise.reject(
      new Error(
        `daemon_backpressure_overloaded:pending=${runtime.pending.size}:max=${runtime.maxPendingRequests}`
      )
    );
  }
  runtime.reqSeq += 1;
  const id = `req-${runtime.reqSeq}`;
  const frame = DaemonRequestFrameSchema.parse({
    type: "request",
    id,
    method,
    params
  });
  return new Promise((resolve7, reject) => {
    const timeout = setTimeout(() => {
      runtime.pending.delete(id);
      runtime.lastRejectReason = "timeout";
      runtime.rejectedRequests += 1;
      syncBackpressureSnapshot(runtime);
      reject(new Error("daemon_request_timeout"));
    }, Math.max(1e3, timeoutMs));
    runtime.pending.set(id, { resolve: resolve7, reject, timeout });
    syncBackpressureSnapshot(runtime);
    runtime.ws?.send(JSON.stringify(frame));
  });
}
function startHeartbeat(runtime) {
  stopHeartbeat(runtime);
  runtime.pingTimer = setInterval(() => {
    if (!runtime.ws || runtime.ws.readyState !== WebSocket.OPEN) return;
    const ping = DaemonPingFrameSchema.parse({
      type: "ping",
      ts: Date.now()
    });
    runtime.ws.send(JSON.stringify(ping));
    if (runtime.pingWatchdog) clearTimeout(runtime.pingWatchdog);
    runtime.pingWatchdog = setTimeout(() => {
      if (runtime.ws && runtime.ws.readyState === WebSocket.OPEN) {
        runtime.ws.close();
      }
    }, 3e4);
  }, 1e4);
}
function stopHeartbeat(runtime) {
  if (runtime.pingTimer) clearInterval(runtime.pingTimer);
  runtime.pingTimer = void 0;
  if (runtime.pingWatchdog) clearTimeout(runtime.pingWatchdog);
  runtime.pingWatchdog = void 0;
}
function startStatusPoll(runtime) {
  stopStatusPoll(runtime);
  runtime.statusTimer = setInterval(async () => {
    try {
      const data = await daemonRequest(runtime, "daemon.status.get", {});
      if (!data || typeof data !== "object") return;
      runtime.snapshot.connected = true;
      runtime.snapshot.statusText = "Miya Daemon Connected";
      runtime.snapshot.uptimeSec = typeof data.uptimeSec === "number" ? data.uptimeSec : runtime.snapshot.uptimeSec;
      runtime.snapshot.cpuPercent = typeof data.cpuPercent === "number" ? data.cpuPercent : runtime.snapshot.cpuPercent;
      runtime.snapshot.vramUsedMB = typeof data.vramUsedMB === "number" ? data.vramUsedMB : runtime.snapshot.vramUsedMB;
      runtime.snapshot.vramTotalMB = typeof data.vramTotalMB === "number" ? data.vramTotalMB : runtime.snapshot.vramTotalMB;
      runtime.snapshot.lastSeenAt = typeof data.lastSeenAt === "string" ? data.lastSeenAt : runtime.snapshot.lastSeenAt;
    } catch {
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Reconnecting";
    }
  }, 3e3);
}
function stopStatusPoll(runtime) {
  if (runtime.statusTimer) clearInterval(runtime.statusTimer);
  runtime.statusTimer = void 0;
}
function scheduleReconnect(runtime) {
  if (runtime.retryHalted) return;
  if (runtime.reconnectTimer) return;
  const wait = runtime.reconnectBackoffMs;
  runtime.reconnectBackoffMs = Math.min(runtime.reconnectBackoffMs * 2, 3e4);
  runtime.reconnectTimer = setTimeout(() => {
    runtime.reconnectTimer = void 0;
    ensureDaemonLaunched(runtime);
  }, wait);
}
function ensureDaemonLaunched(runtime) {
  if (runtime.retryHalted) {
    return;
  }
  writeParentLock(runtime);
  if (Date.now() < runtime.launchCooldownUntilMs) {
    return;
  }
  const lock = toDaemonLock(safeReadJson(runtime.daemonLockFile));
  const lockFresh = lock && Number.isFinite(Date.parse(lock.updatedAt)) && Date.now() - Date.parse(lock.updatedAt) < 3e4;
  const lockOwnedByLauncher = runtime.lifecycleMode === "service_experimental" ? Boolean(lock) && (runtime.daemonToken ? lock?.token === runtime.daemonToken : true) : Boolean(lock) && lock?.token === runtime.daemonToken;
  if (!lockFresh || !lockOwnedByLauncher) {
    if (runtime.lifecycleMode === "service_experimental") {
      runtime.snapshot.connected = false;
      runtime.snapshot.statusText = "Miya Daemon Service Mode (waiting for daemon lock)";
      scheduleReconnect(runtime);
      return;
    }
    if (runtime.reconnectTimer) {
      return;
    }
    const spawned = spawnDaemon(runtime);
    if (!spawned) {
      runtime.reconnectBackoffMs = Math.max(runtime.reconnectBackoffMs, 15e3);
      runtime.launchCooldownUntilMs = Date.now() + 15e3;
      if (!runtime.retryHalted) {
        noteLaunchFailure(runtime, "spawn_skipped_or_failed");
      }
    }
    scheduleReconnect(runtime);
    return;
  }
  if (!runtime.ws || runtime.ws.readyState >= WebSocket.CLOSING) {
    connectWebSocket(runtime, lock);
  }
}
function cleanupRuntime(runtime) {
  if (runtime.parentBeatTimer) clearInterval(runtime.parentBeatTimer);
  runtime.parentBeatTimer = void 0;
  if (runtime.reconnectTimer) clearTimeout(runtime.reconnectTimer);
  runtime.reconnectTimer = void 0;
  stopHeartbeat(runtime);
  stopStatusPoll(runtime);
  for (const pending of runtime.pending.values()) {
    clearTimeout(pending.timeout);
    pending.reject(new Error("launcher_shutdown"));
  }
  runtime.pending.clear();
  syncBackpressureSnapshot(runtime);
  runtime.listeners.clear();
  try {
    runtime.ws?.close();
  } catch {
  }
  runtime.ws = void 0;
}
function ensureMiyaLauncher(projectDir) {
  const existing = runtimes.get(projectDir);
  if (existing) return { ...existing.snapshot };
  ensureDaemonDir(projectDir);
  const lifecycleMode = resolveLifecycleMode(projectDir);
  const config3 = readConfig(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const configuredMaxPending = typeof backpressure?.daemon_max_pending_requests === "number" ? Number(backpressure.daemon_max_pending_requests) : Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64);
  const configuredMaxFailures = typeof backpressure?.daemon_max_consecutive_failures === "number" ? Number(backpressure.daemon_max_consecutive_failures) : Number(process.env.MIYA_DAEMON_MAX_CONSECUTIVE_FAILURES ?? 5);
  const daemonToken = lifecycleMode === "service_experimental" ? String(process.env.MIYA_DAEMON_SERVICE_TOKEN ?? process.env.MIYA_DAEMON_TOKEN ?? "") : randomUUID7();
  const runtime = {
    projectDir,
    lifecycleMode,
    daemonToken,
    parentLockFile: path23.join(daemonDir(projectDir), "parent.lock.json"),
    daemonLockFile: path23.join(daemonDir(projectDir), "daemon.lock.json"),
    reconnectBackoffMs: 1e3,
    connected: false,
    reqSeq: 0,
    pending: /* @__PURE__ */ new Map(),
    maxPendingRequests: Math.max(
      4,
      Math.floor(configuredMaxPending)
    ),
    rejectedRequests: 0,
    lastRejectReason: void 0,
    listeners: /* @__PURE__ */ new Set(),
    lastSpawnAttemptAtMs: 0,
    launchCooldownUntilMs: 0,
    consecutiveLaunchFailures: 0,
    retryHalted: false,
    maxConsecutiveLaunchFailures: Math.max(1, Math.floor(configuredMaxFailures)),
    snapshot: {
      connected: false,
      statusText: lifecycleMode === "service_experimental" ? daemonToken ? "Miya Daemon Service Mode (attach only)" : "Miya Daemon Service Mode (token missing)" : "Miya Daemon Booting",
      lifecycleMode,
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso10()
    }
  };
  syncBackpressureSnapshot(runtime);
  runtimes.set(projectDir, runtime);
  writeParentLock(runtime);
  runtime.parentBeatTimer = setInterval(() => {
    writeParentLock(runtime);
  }, 1e4);
  ensureDaemonLaunched(runtime);
  return { ...runtime.snapshot };
}
function getLauncherDaemonSnapshot(projectDir) {
  const runtime = runtimes.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      statusText: "Miya Daemon Not Started",
      pendingRequests: 0,
      rejectedRequests: 0,
      startedAt: nowIso10()
    };
  }
  syncBackpressureSnapshot(runtime);
  return { ...runtime.snapshot };
}
function getLauncherBackpressureStats(projectDir) {
  const runtime = runtimes.get(projectDir);
  if (!runtime) {
    return {
      connected: false,
      maxPendingRequests: Math.max(
        4,
        Math.floor(Number(process.env.MIYA_DAEMON_MAX_PENDING_REQUESTS ?? 64))
      ),
      pendingRequests: 0,
      rejectedRequests: 0
    };
  }
  syncBackpressureSnapshot(runtime);
  return {
    connected: runtime.connected,
    maxPendingRequests: runtime.maxPendingRequests,
    pendingRequests: runtime.snapshot.pendingRequests,
    rejectedRequests: runtime.snapshot.rejectedRequests,
    lastRejectReason: runtime.snapshot.lastRejectReason
  };
}
function subscribeLauncherEvents(projectDir, listener) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes.get(projectDir);
  if (!runtime) return () => {
  };
  runtime.listeners.add(listener);
  return () => {
    const current = runtimes.get(projectDir);
    current?.listeners.delete(listener);
  };
}
async function waitForDaemonConnection(runtime, timeoutMs) {
  if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected) return;
  const startedAt = Date.now();
  while (Date.now() - startedAt < timeoutMs) {
    ensureDaemonLaunched(runtime);
    if (runtime.ws?.readyState === WebSocket.OPEN && runtime.connected) return;
    await new Promise((resolve7) => setTimeout(resolve7, 150));
  }
  throw new Error("daemon_connect_timeout");
}
async function daemonInvoke(projectDir, method, params, timeoutMs = 6e4) {
  ensureMiyaLauncher(projectDir);
  const runtime = runtimes.get(projectDir);
  if (!runtime) throw new Error("daemon_runtime_missing");
  await waitForDaemonConnection(runtime, Math.min(timeoutMs, 15e3));
  return daemonRequest(runtime, method, params, timeoutMs);
}
process.on("exit", () => {
  for (const runtime of runtimes.values()) {
    cleanupRuntime(runtime);
    try {
      fs23.rmSync(runtime.parentLockFile, { force: true });
    } catch {
    }
  }
});

// src/daemon/client.ts
var MiyaClient = class {
  constructor(projectDir) {
    this.projectDir = projectDir;
    ensureMiyaLauncher(projectDir);
  }
  async runFluxImageGenerate(input) {
    return daemonInvoke(
      this.projectDir,
      "daemon.flux.generate",
      input,
      24e4
    );
  }
  async runSovitsTts(input) {
    return daemonInvoke(
      this.projectDir,
      "daemon.sovits.tts",
      input,
      18e4
    );
  }
  async runFluxTraining(input) {
    return daemonInvoke(
      this.projectDir,
      "daemon.training.flux",
      input,
      35 * 6e4
    );
  }
  async runSovitsTraining(input) {
    return daemonInvoke(
      this.projectDir,
      "daemon.training.sovits",
      input,
      35 * 6e4
    );
  }
  async requestTrainingCancel(jobID) {
    await daemonInvoke(this.projectDir, "daemon.training.cancel", { jobID }, 15e3);
  }
  async getPythonRuntimeStatus() {
    return daemonInvoke(this.projectDir, "daemon.python.env.get", {}, 15e3);
  }
  async getModelLockStatus() {
    return daemonInvoke(this.projectDir, "daemon.model.locks.get", {}, 15e3);
  }
  async getModelUpdatePlan(target) {
    return daemonInvoke(
      this.projectDir,
      "daemon.model.update.plan",
      target ? { target } : {},
      2e4
    );
  }
  async applyModelUpdate(target) {
    return daemonInvoke(
      this.projectDir,
      "daemon.model.update.apply",
      target ? { target } : {},
      3e4
    );
  }
  async runIsolatedProcess(input) {
    return daemonInvoke(
      this.projectDir,
      "daemon.process.run_isolated",
      input,
      Math.max(3e4, input.timeoutMs ?? 12e4) + 1e4
    );
  }
  async psycheConsult(input) {
    const timeoutMs = Math.max(
      1e3,
      Math.floor(Number(process.env.MIYA_PSYCHE_CONSULT_TIMEOUT_MS ?? 3e3))
    );
    return daemonInvoke(
      this.projectDir,
      "daemon.psyche.consult",
      input,
      timeoutMs
    );
  }
  async psycheOutcome(input) {
    return daemonInvoke(
      this.projectDir,
      "daemon.psyche.outcome",
      input,
      15e3
    );
  }
};
var clients = /* @__PURE__ */ new Map();
function getMiyaClient(projectDir) {
  const existing = clients.get(projectDir);
  if (existing) return existing;
  const created = new MiyaClient(projectDir);
  clients.set(projectDir, created);
  return created;
}

// src/security/owner-identity.ts
import { createHash as createHash8, randomUUID as randomUUID8 } from "node:crypto";
import * as fs24 from "node:fs";
import * as path24 from "node:path";
function nowIso11() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath5(projectDir) {
  return path24.join(getMiyaRuntimeDir(projectDir), "security", "owner-identity.json");
}
function guestAuditPath(projectDir) {
  return path24.join(getMiyaRuntimeDir(projectDir), "security", "guest-conversations.jsonl");
}
function clamp(input, min, max) {
  if (!Number.isFinite(input)) return min;
  return Math.min(max, Math.max(min, input));
}
function defaultVoiceprintThresholds() {
  return {
    ownerMinScore: 0.78,
    guestMaxScore: 0.62,
    ownerMinLiveness: 0.65,
    guestMaxLiveness: 0.55,
    ownerMinDiarizationRatio: 0.7,
    minSampleDurationSec: 2,
    farTarget: 0.01,
    frrTarget: 0.03
  };
}
function normalizeVoiceprintThresholds(input) {
  const base = defaultVoiceprintThresholds();
  const normalized = {
    ownerMinScore: typeof input?.ownerMinScore === "number" ? clamp(input.ownerMinScore, 0.5, 0.99) : base.ownerMinScore,
    guestMaxScore: typeof input?.guestMaxScore === "number" ? clamp(input.guestMaxScore, 0.01, 0.9) : base.guestMaxScore,
    ownerMinLiveness: typeof input?.ownerMinLiveness === "number" ? clamp(input.ownerMinLiveness, 0.1, 0.99) : base.ownerMinLiveness,
    guestMaxLiveness: typeof input?.guestMaxLiveness === "number" ? clamp(input.guestMaxLiveness, 0.01, 0.9) : base.guestMaxLiveness,
    ownerMinDiarizationRatio: typeof input?.ownerMinDiarizationRatio === "number" ? clamp(input.ownerMinDiarizationRatio, 0.1, 1) : base.ownerMinDiarizationRatio,
    minSampleDurationSec: typeof input?.minSampleDurationSec === "number" ? clamp(input.minSampleDurationSec, 0.5, 20) : base.minSampleDurationSec,
    farTarget: typeof input?.farTarget === "number" ? clamp(input.farTarget, 1e-4, 0.5) : base.farTarget,
    frrTarget: typeof input?.frrTarget === "number" ? clamp(input.frrTarget, 1e-4, 0.5) : base.frrTarget
  };
  if (normalized.guestMaxScore >= normalized.ownerMinScore) {
    normalized.guestMaxScore = Math.max(0.01, normalized.ownerMinScore - 0.05);
  }
  return normalized;
}
function defaultState2() {
  return {
    initialized: false,
    mode: "unknown",
    voiceprintModelPath: "",
    voiceprintSampleDir: "",
    voiceprintThresholds: defaultVoiceprintThresholds(),
    updatedAt: nowIso11()
  };
}
function hashSecret(input) {
  return createHash8("sha256").update(input).digest("hex");
}
function defaultVoiceprintModelPath(projectDir) {
  return process.env.MIYA_VOICEPRINT_MODEL_PATH || getMiyaVoiceprintModelDir(projectDir);
}
function defaultVoiceprintSampleDir(projectDir) {
  return process.env.MIYA_VOICEPRINT_SAMPLE_DIR || getMiyaVoiceprintSampleDir(projectDir);
}
function readOwnerIdentityState(projectDir) {
  const file3 = filePath5(projectDir);
  if (!fs24.existsSync(file3)) {
    return {
      ...defaultState2(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
  try {
    const parsed = JSON.parse(fs24.readFileSync(file3, "utf-8"));
    return {
      ...defaultState2(),
      ...parsed,
      voiceprintModelPath: typeof parsed.voiceprintModelPath === "string" ? parsed.voiceprintModelPath : defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: typeof parsed.voiceprintSampleDir === "string" ? parsed.voiceprintSampleDir : defaultVoiceprintSampleDir(projectDir),
      voiceprintThresholds: normalizeVoiceprintThresholds(parsed.voiceprintThresholds),
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso11()
    };
  } catch {
    return {
      ...defaultState2(),
      voiceprintModelPath: defaultVoiceprintModelPath(projectDir),
      voiceprintSampleDir: defaultVoiceprintSampleDir(projectDir)
    };
  }
}
function writeOwnerIdentityState(projectDir, state2) {
  const file3 = filePath5(projectDir);
  fs24.mkdirSync(path24.dirname(file3), { recursive: true });
  const next = {
    ...state2,
    voiceprintThresholds: normalizeVoiceprintThresholds(state2.voiceprintThresholds),
    updatedAt: nowIso11()
  };
  fs24.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function initOwnerIdentity(projectDir, input) {
  const current = readOwnerIdentityState(projectDir);
  const next = {
    ...current,
    initialized: true,
    passwordHash: hashSecret(input.password),
    passphraseHash: hashSecret(input.passphrase),
    voiceprintEmbeddingID: input.voiceprintEmbeddingID || current.voiceprintEmbeddingID || `owner_${randomUUID8()}`,
    voiceprintModelPath: input.voiceprintModelPath || current.voiceprintModelPath || defaultVoiceprintModelPath(projectDir),
    voiceprintSampleDir: input.voiceprintSampleDir || current.voiceprintSampleDir || defaultVoiceprintSampleDir(projectDir),
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...input.voiceprintThresholds ?? {}
    }),
    mode: "owner",
    lastSpeakerAt: nowIso11(),
    updatedAt: nowIso11()
  };
  return writeOwnerIdentityState(projectDir, next);
}
function verifyOwnerSecrets(projectDir, input) {
  const state2 = readOwnerIdentityState(projectDir);
  if (!state2.initialized || !state2.passwordHash || !state2.passphraseHash) return false;
  const passOk = typeof input.password === "string" && hashSecret(input.password) === state2.passwordHash;
  const phraseOk = typeof input.passphrase === "string" && hashSecret(input.passphrase) === state2.passphraseHash;
  return passOk || phraseOk;
}
function verifyOwnerPasswordOnly(projectDir, password) {
  const state2 = readOwnerIdentityState(projectDir);
  if (!state2.initialized || !state2.passwordHash) return false;
  if (typeof password !== "string" || !password) return false;
  return hashSecret(password) === state2.passwordHash;
}
function rotateOwnerSecrets(projectDir, input) {
  if (!verifyOwnerSecrets(projectDir, {
    password: input.currentPassword,
    passphrase: input.currentPassphrase
  })) {
    throw new Error("owner_secret_verification_failed");
  }
  const state2 = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...state2,
    initialized: true,
    passwordHash: hashSecret(input.newPassword),
    passphraseHash: hashSecret(input.newPassphrase),
    mode: "owner",
    lastSpeakerAt: nowIso11(),
    updatedAt: nowIso11()
  });
}
function updateVoiceprintThresholds(projectDir, patch) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    voiceprintThresholds: normalizeVoiceprintThresholds({
      ...current.voiceprintThresholds,
      ...patch
    }),
    updatedAt: nowIso11()
  });
}
function resolveInteractionMode(projectDir, input) {
  const hint = (input.speakerHint || "").trim().toLowerCase();
  if (hint === "owner" || hint === "guest" || hint === "unknown") {
    return hint;
  }
  const state2 = readOwnerIdentityState(projectDir);
  if (!state2.initialized) return "unknown";
  if (typeof input.speakerScore === "number") {
    if (input.speakerScore >= state2.voiceprintThresholds.ownerMinScore) return "owner";
    if (input.speakerScore < state2.voiceprintThresholds.guestMaxScore) return "guest";
  }
  return state2.mode === "owner" ? "owner" : "unknown";
}
function setInteractionMode(projectDir, mode) {
  const current = readOwnerIdentityState(projectDir);
  return writeOwnerIdentityState(projectDir, {
    ...current,
    mode,
    lastSpeakerAt: nowIso11(),
    updatedAt: nowIso11()
  });
}
function appendGuestConversation(projectDir, input) {
  const file3 = guestAuditPath(projectDir);
  fs24.mkdirSync(path24.dirname(file3), { recursive: true });
  const row = {
    id: `guest_${randomUUID8()}`,
    at: nowIso11(),
    source: input.source,
    sessionID: input.sessionID,
    text: input.text
  };
  fs24.appendFileSync(file3, `${JSON.stringify(row)}
`, "utf-8");
}

// src/security/owner-sync.ts
import { randomUUID as randomUUID9 } from "node:crypto";
import * as fs25 from "node:fs";
import * as path25 from "node:path";
function nowIso12() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function storeFile(projectDir) {
  return path25.join(getMiyaRuntimeDir(projectDir), "security", "owner-sync.json");
}
function readStore4(projectDir) {
  const file3 = storeFile(projectDir);
  if (!fs25.existsSync(file3)) return { tokens: [] };
  try {
    const parsed = JSON.parse(fs25.readFileSync(file3, "utf-8"));
    return Array.isArray(parsed.tokens) ? parsed : { tokens: [] };
  } catch {
    return { tokens: [] };
  }
}
function writeStore4(projectDir, store2) {
  const file3 = storeFile(projectDir);
  fs25.mkdirSync(path25.dirname(file3), { recursive: true });
  fs25.writeFileSync(file3, `${JSON.stringify(store2, null, 2)}
`, "utf-8");
}
function purgeExpired(tokens) {
  const now = Date.now();
  return tokens.filter((item) => {
    const expiresAt = Date.parse(item.expiresAt);
    if (!Number.isFinite(expiresAt)) return false;
    if (expiresAt < now && item.status === "pending") return false;
    return true;
  });
}
function normalizeToken(input) {
  return input.trim().toUpperCase();
}
function createToken() {
  return `OS${randomUUID9().replaceAll("-", "").slice(0, 10).toUpperCase()}`;
}
function issueOwnerSyncToken(projectDir, input) {
  const ttlMs = Math.max(6e4, Number(input.ttlMs ?? 10 * 6e4));
  const store2 = readStore4(projectDir);
  store2.tokens = purgeExpired(store2.tokens);
  const now = Date.now();
  const existing = store2.tokens.find(
    (item) => item.status === "pending" && item.action === input.action && item.payloadHash === input.payloadHash && Date.parse(item.expiresAt) > now
  );
  if (existing) {
    writeStore4(projectDir, store2);
    return existing;
  }
  const createdAt = nowIso12();
  const record3 = {
    token: createToken(),
    action: input.action,
    payloadHash: input.payloadHash,
    status: "pending",
    createdAt,
    expiresAt: new Date(now + ttlMs).toISOString()
  };
  store2.tokens.unshift(record3);
  store2.tokens = store2.tokens.slice(0, 500);
  writeStore4(projectDir, store2);
  return record3;
}
function approveOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token) return { ok: false, reason: "owner_sync_token_empty" };
  const store2 = readStore4(projectDir);
  store2.tokens = purgeExpired(store2.tokens);
  const found = store2.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore4(projectDir, store2);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "pending") {
    writeStore4(projectDir, store2);
    return { ok: false, reason: `owner_sync_token_not_pending:${found.status}` };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore4(projectDir, store2);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  found.status = "approved";
  found.approvedAt = nowIso12();
  found.approvedBy = { channel: input.channel, senderID: input.senderID };
  writeStore4(projectDir, store2);
  return { ok: true, record: found };
}
function verifyOwnerSyncToken(projectDir, input) {
  const token = normalizeToken(input.token);
  if (!token) return { ok: false, reason: "owner_sync_token_empty" };
  const store2 = readStore4(projectDir);
  store2.tokens = purgeExpired(store2.tokens);
  const found = store2.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore4(projectDir, store2);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore4(projectDir, store2);
    return { ok: false, reason: `owner_sync_token_not_approved:${found.status}` };
  }
  if (found.action !== input.action) {
    writeStore4(projectDir, store2);
    return { ok: false, reason: "owner_sync_token_action_mismatch" };
  }
  if (found.payloadHash !== input.payloadHash) {
    writeStore4(projectDir, store2);
    return { ok: false, reason: "owner_sync_token_payload_mismatch" };
  }
  if (Date.parse(found.expiresAt) <= Date.now()) {
    writeStore4(projectDir, store2);
    return { ok: false, reason: "owner_sync_token_expired" };
  }
  writeStore4(projectDir, store2);
  return { ok: true, record: found };
}
function consumeOwnerSyncToken(projectDir, tokenInput) {
  const token = normalizeToken(tokenInput);
  if (!token) return { ok: false, reason: "owner_sync_token_empty" };
  const store2 = readStore4(projectDir);
  store2.tokens = purgeExpired(store2.tokens);
  const found = store2.tokens.find((item) => item.token === token);
  if (!found) {
    writeStore4(projectDir, store2);
    return { ok: false, reason: "owner_sync_token_not_found" };
  }
  if (found.status !== "approved") {
    writeStore4(projectDir, store2);
    return { ok: false, reason: `owner_sync_token_not_approved:${found.status}` };
  }
  found.status = "consumed";
  found.consumedAt = nowIso12();
  writeStore4(projectDir, store2);
  return { ok: true };
}
function detectOwnerSyncTokenFromText(text) {
  const normalized = text.trim();
  if (!normalized) return null;
  const matched = /(?:||approve|confirm|ok)\s*[:#]?\s*([a-z0-9_-]{6,64})/i.exec(normalized) ?? /(?:\/miya\s+confirm)\s+([a-z0-9_-]{6,64})/i.exec(normalized);
  if (!matched?.[1]) return null;
  return normalizeToken(matched[1]);
}

// src/voice/state.ts
import * as fs26 from "node:fs";
import * as path26 from "node:path";
import { randomUUID as randomUUID10 } from "node:crypto";
function nowIso13() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath6(projectDir) {
  return path26.join(getMiyaRuntimeDir(projectDir), "voice.json");
}
function ensureDir12(file3) {
  fs26.mkdirSync(path26.dirname(file3), { recursive: true });
}
function defaultState3() {
  return {
    enabled: false,
    wakeWordEnabled: false,
    talkMode: false,
    routeSessionID: "main",
    sttProvider: "local",
    ttsProvider: "local",
    history: []
  };
}
function readVoiceState(projectDir) {
  const file3 = filePath6(projectDir);
  if (!fs26.existsSync(file3)) return defaultState3();
  try {
    const parsed = JSON.parse(fs26.readFileSync(file3, "utf-8"));
    return {
      ...defaultState3(),
      ...parsed,
      history: Array.isArray(parsed.history) ? parsed.history : []
    };
  } catch {
    return defaultState3();
  }
}
function writeVoiceState(projectDir, state2) {
  const file3 = filePath6(projectDir);
  ensureDir12(file3);
  fs26.writeFileSync(file3, `${JSON.stringify(state2, null, 2)}
`, "utf-8");
  return state2;
}
function patchVoiceState(projectDir, patch) {
  const current = readVoiceState(projectDir);
  const next = {
    ...current,
    ...patch
  };
  return writeVoiceState(projectDir, next);
}
function appendVoiceHistory(projectDir, input) {
  const state2 = readVoiceState(projectDir);
  const item = {
    id: `voice_${randomUUID10()}`,
    text: input.text,
    source: input.source,
    language: input.language,
    mediaID: input.mediaID,
    createdAt: nowIso13()
  };
  const next = {
    ...state2,
    lastInputAt: item.createdAt,
    lastTranscript: item.text,
    history: [item, ...state2.history].slice(0, 200)
  };
  writeVoiceState(projectDir, next);
  return item;
}
function clearVoiceHistory(projectDir) {
  const state2 = readVoiceState(projectDir);
  return writeVoiceState(projectDir, {
    ...state2,
    history: [],
    lastInputAt: void 0,
    lastTranscript: void 0
  });
}

// src/config/provider-override-audit.ts
import * as fs27 from "node:fs";
import * as path27 from "node:path";
function providerOverrideAuditFile(projectDir) {
  return path27.join(getMiyaRuntimeDir(projectDir), "audit", "provider-overrides.jsonl");
}
function appendProviderOverrideAudit(projectDir, input) {
  const entry2 = {
    at: (/* @__PURE__ */ new Date()).toISOString(),
    source: input.source,
    agentName: input.agentName,
    model: input.model,
    providerID: input.providerID,
    activeAgentId: input.activeAgentId,
    hasApiKey: input.hasApiKey,
    hasBaseURL: input.hasBaseURL,
    optionKeys: [...input.optionKeys].sort()
  };
  const file3 = providerOverrideAuditFile(projectDir);
  fs27.mkdirSync(path27.dirname(file3), { recursive: true });
  fs27.appendFileSync(file3, `${JSON.stringify(entry2)}
`, "utf-8");
  return entry2;
}
function listProviderOverrideAudits(projectDir, limit = 50) {
  const file3 = providerOverrideAuditFile(projectDir);
  if (!fs27.existsSync(file3)) return [];
  const safeLimit = Math.max(1, Math.min(500, Math.floor(limit)));
  const lines = fs27.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean);
  return lines.slice(-safeLimit).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => item !== null).reverse();
}

// src/gateway/agent-model-api.ts
var AgentModelRuntimeApi = class {
  constructor(projectDir) {
    this.projectDir = projectDir;
  }
  list() {
    const runtime = readPersistedAgentRuntime(this.projectDir);
    const agents = [];
    for (const agentName of ALL_AGENT_NAMES) {
      const entry2 = runtime.agents[agentName];
      const model = entry2?.model ?? DEFAULT_MODELS[agentName];
      const source = entry2?.model ? "runtime" : "default";
      agents.push({
        agentName,
        model,
        providerID: entry2?.providerID,
        variant: entry2?.variant,
        updatedAt: entry2?.updatedAt ?? "",
        source,
        active: runtime.activeAgentId === agentName,
        healthStatus: this.resolveHealthStatus(model)
      });
    }
    return {
      activeAgentId: runtime.activeAgentId,
      revision: runtime.revision,
      agents
    };
  }
  set(input) {
    const agentName = normalizeAgentName(input.agentName);
    if (!agentName) {
      throw new Error("invalid_agent_name");
    }
    if (!normalizeModelRef(input.model)) {
      throw new Error("invalid_model_ref");
    }
    const changed = persistAgentRuntimeSelection(this.projectDir, {
      agentName,
      model: input.model,
      variant: input.variant,
      providerID: input.providerID,
      options: input.options,
      apiKey: input.apiKey,
      baseURL: input.baseURL,
      activeAgentId: input.activate === false ? void 0 : agentName
    });
    return { changed };
  }
  reset(input) {
    const changed = removePersistedAgentRuntimeSelection(
      this.projectDir,
      input.agentName,
      {
        clearActive: input.clearActive ?? true,
        activeAgentId: input.activeAgentId
      }
    );
    return { changed };
  }
  resolveHealthStatus(model) {
    if (!model) return "unavailable";
    return isModelLikelyAvailable(model) ? "healthy" : "degraded";
  }
};

// src/canvas/state.ts
import { randomUUID as randomUUID11 } from "node:crypto";
import * as fs28 from "node:fs";
import * as path28 from "node:path";
function nowIso14() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath7(projectDir) {
  return path28.join(getMiyaRuntimeDir(projectDir), "canvas.json");
}
function ensureDir13(file3) {
  fs28.mkdirSync(path28.dirname(file3), { recursive: true });
}
function defaultState4() {
  return {
    activeDocID: void 0,
    docs: {},
    events: []
  };
}
function readCanvasState(projectDir) {
  const file3 = filePath7(projectDir);
  if (!fs28.existsSync(file3)) return defaultState4();
  try {
    const parsed = JSON.parse(fs28.readFileSync(file3, "utf-8"));
    return {
      activeDocID: parsed.activeDocID,
      docs: parsed.docs ?? {},
      events: Array.isArray(parsed.events) ? parsed.events : []
    };
  } catch {
    return defaultState4();
  }
}
function writeCanvasState(projectDir, state2) {
  const file3 = filePath7(projectDir);
  ensureDir13(file3);
  fs28.writeFileSync(file3, `${JSON.stringify(state2, null, 2)}
`, "utf-8");
  return state2;
}
function pushEvent(state2, input) {
  state2.events = [
    {
      id: `canvas_evt_${randomUUID11()}`,
      kind: input.kind,
      docID: input.docID,
      at: nowIso14(),
      actor: input.actor
    },
    ...state2.events
  ].slice(0, 400);
}
function openCanvasDoc(projectDir, input) {
  const state2 = readCanvasState(projectDir);
  const id = `canvas_${randomUUID11()}`;
  const now = nowIso14();
  const doc = {
    id,
    title: input.title,
    type: input.type ?? "markdown",
    content: input.content ?? "",
    createdAt: now,
    updatedAt: now
  };
  state2.docs[id] = doc;
  state2.activeDocID = id;
  pushEvent(state2, { kind: "open", docID: id, actor: input.actor ?? "gateway" });
  writeCanvasState(projectDir, state2);
  return doc;
}
function renderCanvasDoc(projectDir, input) {
  const state2 = readCanvasState(projectDir);
  const doc = state2.docs[input.docID];
  if (!doc) return null;
  doc.content = input.merge ? `${doc.content}
${input.content}` : input.content;
  doc.updatedAt = nowIso14();
  state2.activeDocID = doc.id;
  pushEvent(state2, { kind: "render", docID: doc.id, actor: input.actor ?? "gateway" });
  writeCanvasState(projectDir, state2);
  return doc;
}
function closeCanvasDoc(projectDir, docID, actor = "gateway") {
  const state2 = readCanvasState(projectDir);
  const doc = state2.docs[docID];
  if (!doc) return null;
  if (state2.activeDocID === docID) {
    state2.activeDocID = void 0;
  }
  pushEvent(state2, { kind: "close", docID, actor });
  writeCanvasState(projectDir, state2);
  return doc;
}
function listCanvasDocs(projectDir) {
  const state2 = readCanvasState(projectDir);
  return Object.values(state2.docs).sort(
    (a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)
  );
}
function getCanvasDoc(projectDir, docID) {
  const state2 = readCanvasState(projectDir);
  return state2.docs[docID] ?? null;
}

// src/companion/store.ts
import { randomUUID as randomUUID13 } from "node:crypto";
import * as fs30 from "node:fs";
import * as path30 from "node:path";

// src/companion/memory-vector.ts
import { createHash as createHash9, randomUUID as randomUUID12 } from "node:crypto";

// src/companion/memory-sqlite.ts
import * as fs29 from "node:fs";
import { createRequire } from "node:module";
import * as path29 from "node:path";
var require2 = createRequire(import.meta.url);
function createSqlDatabase(file3) {
  try {
    const nodeSqlite = require2("node:sqlite");
    const nodeDb = new nodeSqlite.DatabaseSync(file3);
    const tx = (fn) => ((...args) => {
      nodeDb.exec("BEGIN");
      try {
        const result = fn(...args);
        nodeDb.exec("COMMIT");
        return result;
      } catch (error92) {
        try {
          nodeDb.exec("ROLLBACK");
        } catch {
        }
        throw error92;
      }
    });
    return {
      exec: (sql) => nodeDb.exec(sql),
      query: (sql) => {
        const stmt = nodeDb.prepare(sql);
        return {
          run: (...params) => stmt.run(...params),
          get: (...params) => stmt.get(...params),
          all: (...params) => stmt.all(...params)
        };
      },
      transaction: tx,
      close: () => nodeDb.close()
    };
  } catch {
  }
  throw new Error("sqlite_runtime_unavailable:requires_node_sqlite");
}
function nowIso15() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function normalizeText(text) {
  return text.trim().replace(/\s+/g, " ");
}
function textToEmbeddingLite(text, dims = 96) {
  const vec = new Array(dims).fill(0);
  const parts = normalizeText(text).toLowerCase().split(/[^\p{L}\p{N}]+/u).filter(Boolean);
  if (parts.length === 0) return vec;
  for (const part of parts) {
    let hash3 = 0;
    for (let i = 0; i < part.length; i += 1) {
      hash3 = hash3 * 31 + part.charCodeAt(i) >>> 0;
    }
    for (let i = 0; i < 8; i += 1) {
      const idx = (hash3 + i * 17) % dims;
      vec[idx] += 1 + (hash3 >>> i % 16 & 3);
    }
  }
  const norm = Math.sqrt(vec.reduce((sum, value) => sum + value * value, 0));
  if (norm <= 0) return vec;
  return vec.map((value) => value / norm);
}
function memoryDir(projectDir) {
  return path29.join(getMiyaRuntimeDir(projectDir), "memory");
}
function sqlitePath(projectDir) {
  return path29.join(memoryDir(projectDir), "memories.sqlite");
}
function safeJsonParse(value, fallback) {
  if (typeof value !== "string" || !value.trim()) return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}
function ensureSchema(db) {
  db.exec("PRAGMA journal_mode=WAL;");
  db.exec("PRAGMA synchronous=NORMAL;");
  db.exec("PRAGMA foreign_keys=ON;");
  db.exec("PRAGMA busy_timeout=5000;");
  db.exec(`
    CREATE TABLE IF NOT EXISTS mem_cells (
      id TEXT PRIMARY KEY,
      domain TEXT NOT NULL DEFAULT 'work',
      kind TEXT NOT NULL DEFAULT 'Fact',
      subject TEXT NOT NULL DEFAULT 'User',
      predicate TEXT NOT NULL DEFAULT 'fact',
      object TEXT NOT NULL DEFAULT '',
      text TEXT NOT NULL,
      polarity TEXT NOT NULL DEFAULT 'neutral',
      confidence REAL NOT NULL DEFAULT 0.5,
      tier TEXT NOT NULL DEFAULT 'L1',
      status TEXT NOT NULL DEFAULT 'candidate',
      conflict_key TEXT,
      source TEXT NOT NULL DEFAULT 'manual',
      source_type TEXT NOT NULL DEFAULT 'manual',
      source_message_id TEXT,
      evidence_ref_json TEXT,
      score REAL NOT NULL DEFAULT 1,
      embedding_json TEXT NOT NULL,
      access_count INTEGER NOT NULL DEFAULT 0,
      is_archived INTEGER NOT NULL DEFAULT 0,
      conflict_wizard_id TEXT,
      superseded_by TEXT,
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL,
      last_accessed_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memory_corrections (
      id TEXT PRIMARY KEY,
      conflict_key TEXT NOT NULL,
      candidate_memory_id TEXT NOT NULL,
      existing_memory_ids_json TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS raw_logs (
      id TEXT PRIMARY KEY,
      session_id TEXT NOT NULL,
      sender TEXT NOT NULL,
      text TEXT NOT NULL,
      at TEXT NOT NULL,
      message_hash TEXT NOT NULL UNIQUE,
      processed_at TEXT,
      processed_job_id TEXT
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS evidence_packs (
      audit_id TEXT PRIMARY KEY,
      meta_json TEXT NOT NULL,
      payload_json TEXT NOT NULL,
      created_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memory_events (
      seq INTEGER PRIMARY KEY AUTOINCREMENT,
      event_id TEXT NOT NULL UNIQUE,
      event_type TEXT NOT NULL,
      entity_type TEXT NOT NULL,
      entity_id TEXT NOT NULL,
      payload_json TEXT NOT NULL,
      policy_hash TEXT,
      created_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS mem_scenes (
      scene_id TEXT PRIMARY KEY,
      domain TEXT NOT NULL DEFAULT 'work',
      title TEXT NOT NULL,
      summary_l0 TEXT NOT NULL DEFAULT '[]',
      summary_l1 TEXT NOT NULL DEFAULT '',
      vec_json TEXT NOT NULL DEFAULT '[]',
      updated_at TEXT NOT NULL
    );
  `);
  db.exec(`
    CREATE TABLE IF NOT EXISTS memscene_cells (
      scene_id TEXT NOT NULL,
      cell_id TEXT NOT NULL,
      weight REAL NOT NULL DEFAULT 1,
      PRIMARY KEY(scene_id, cell_id),
      FOREIGN KEY(scene_id) REFERENCES mem_scenes(scene_id) ON DELETE CASCADE,
      FOREIGN KEY(cell_id) REFERENCES mem_cells(id) ON DELETE CASCADE
    );
  `);
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_mem_cells_status_domain ON mem_cells(status, domain);"
  );
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_mem_cells_conflict_key ON mem_cells(conflict_key);"
  );
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_raw_logs_processed ON raw_logs(processed_at, at);"
  );
  db.exec(
    "CREATE INDEX IF NOT EXISTS idx_memory_events_created ON memory_events(created_at);"
  );
  try {
    db.exec(`
      CREATE VIRTUAL TABLE IF NOT EXISTS mem_cells_fts USING fts5(
        text,
        content='mem_cells',
        content_rowid='rowid'
      );
    `);
    db.exec(`
      CREATE TRIGGER IF NOT EXISTS mem_cells_ai AFTER INSERT ON mem_cells BEGIN
        INSERT INTO mem_cells_fts(rowid, text) VALUES (new.rowid, new.text);
      END;
    `);
    db.exec(`
      CREATE TRIGGER IF NOT EXISTS mem_cells_ad AFTER DELETE ON mem_cells BEGIN
        INSERT INTO mem_cells_fts(mem_cells_fts, rowid, text) VALUES('delete', old.rowid, old.text);
      END;
    `);
    db.exec(`
      CREATE TRIGGER IF NOT EXISTS mem_cells_au AFTER UPDATE ON mem_cells BEGIN
        INSERT INTO mem_cells_fts(mem_cells_fts, rowid, text) VALUES('delete', old.rowid, old.text);
        INSERT INTO mem_cells_fts(rowid, text) VALUES (new.rowid, new.text);
      END;
    `);
  } catch {
  }
}
function openDatabase(projectDir) {
  fs29.mkdirSync(memoryDir(projectDir), { recursive: true });
  const db = createSqlDatabase(sqlitePath(projectDir));
  ensureSchema(db);
  return db;
}
function rowToMemory(row) {
  return {
    id: String(row.id ?? ""),
    text: String(row.text ?? ""),
    memoryKind: row.kind === "Fact" || row.kind === "Insight" || row.kind === "UserPreference" ? row.kind : void 0,
    source: String(row.source ?? "manual"),
    embedding: safeJsonParse(row.embedding_json, []),
    score: Number(row.score ?? 1),
    confidence: Number(row.confidence ?? 0.5),
    tier: String(row.tier ?? "L1"),
    domain: row.domain === "work" || row.domain === "relationship" || row.domain === "personal" || row.domain === "system" ? row.domain : "work",
    subject: String(row.subject ?? "User"),
    predicate: String(row.predicate ?? "fact"),
    object: String(row.object ?? ""),
    polarity: row.polarity === "positive" || row.polarity === "negative" || row.polarity === "neutral" ? row.polarity : "neutral",
    sourceMessageID: typeof row.source_message_id === "string" && row.source_message_id.trim() ? String(row.source_message_id) : void 0,
    sourceType: row.source_type === "manual" || row.source_type === "conversation" || row.source_type === "reflect" || row.source_type === "direct_correction" ? row.source_type : "manual",
    status: String(
      row.status ?? "candidate"
    ),
    conflictKey: typeof row.conflict_key === "string" && row.conflict_key.trim() ? String(row.conflict_key) : void 0,
    conflictWizardID: typeof row.conflict_wizard_id === "string" && row.conflict_wizard_id.trim() ? String(row.conflict_wizard_id) : void 0,
    supersededBy: typeof row.superseded_by === "string" && row.superseded_by.trim() ? String(row.superseded_by) : void 0,
    evidenceRef: safeJsonParse(
      row.evidence_ref_json,
      void 0
    ),
    accessCount: Number(row.access_count ?? 0),
    isArchived: Number(row.is_archived ?? 0) === 1,
    createdAt: String(row.created_at ?? nowIso15()),
    updatedAt: String(row.updated_at ?? nowIso15()),
    lastAccessedAt: String(row.last_accessed_at ?? nowIso15())
  };
}
function rowToCorrection(row) {
  return {
    id: String(row.id ?? ""),
    conflictKey: String(row.conflict_key ?? ""),
    candidateMemoryID: String(row.candidate_memory_id ?? ""),
    existingMemoryIDs: safeJsonParse(
      row.existing_memory_ids_json,
      []
    ),
    status: row.status === "resolved" || row.status === "rejected" ? row.status : "pending",
    createdAt: String(row.created_at ?? nowIso15()),
    updatedAt: String(row.updated_at ?? nowIso15())
  };
}
function withMemoryDb(projectDir, fn) {
  let db = null;
  try {
    db = openDatabase(projectDir);
    return fn(db);
  } finally {
    try {
      db?.close();
    } catch {
    }
  }
}
function listMemoryCells(projectDir) {
  return withMemoryDb(projectDir, (db) => {
    const rows = db.query(
      "SELECT * FROM mem_cells ORDER BY datetime(updated_at) DESC, id DESC"
    ).all();
    return rows.map(rowToMemory);
  });
}
function getMemoryCell(projectDir, id) {
  return withMemoryDb(projectDir, (db) => {
    const row = db.query("SELECT * FROM mem_cells WHERE id = ?").get(id);
    return row ? rowToMemory(row) : null;
  });
}
function upsertMemoryCell(projectDir, item) {
  return withMemoryDb(projectDir, (db) => {
    db.query(`
      INSERT INTO mem_cells (
        id, domain, kind, subject, predicate, object, text, polarity, confidence, tier, status,
        conflict_key, source, source_type, source_message_id, evidence_ref_json, score, embedding_json,
        access_count, is_archived, conflict_wizard_id, superseded_by, created_at, updated_at, last_accessed_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(id) DO UPDATE SET
        domain=excluded.domain,
        kind=excluded.kind,
        subject=excluded.subject,
        predicate=excluded.predicate,
        object=excluded.object,
        text=excluded.text,
        polarity=excluded.polarity,
        confidence=excluded.confidence,
        tier=excluded.tier,
        status=excluded.status,
        conflict_key=excluded.conflict_key,
        source=excluded.source,
        source_type=excluded.source_type,
        source_message_id=excluded.source_message_id,
        evidence_ref_json=excluded.evidence_ref_json,
        score=excluded.score,
        embedding_json=excluded.embedding_json,
        access_count=excluded.access_count,
        is_archived=excluded.is_archived,
        conflict_wizard_id=excluded.conflict_wizard_id,
        superseded_by=excluded.superseded_by,
        created_at=excluded.created_at,
        updated_at=excluded.updated_at,
        last_accessed_at=excluded.last_accessed_at
    `).run(
      item.id,
      item.domain ?? "work",
      item.memoryKind ?? "Fact",
      item.subject ?? "User",
      item.predicate ?? "fact",
      item.object ?? "",
      item.text,
      item.polarity ?? "neutral",
      item.confidence,
      item.tier,
      item.status,
      item.conflictKey ?? null,
      item.source,
      item.sourceType ?? "manual",
      item.sourceMessageID ?? null,
      item.evidenceRef ? JSON.stringify(item.evidenceRef) : null,
      item.score,
      JSON.stringify(item.embedding),
      item.accessCount,
      item.isArchived ? 1 : 0,
      item.conflictWizardID ?? null,
      item.supersededBy ?? null,
      item.createdAt,
      item.updatedAt,
      item.lastAccessedAt
    );
    return getMemoryCell(projectDir, item.id) ?? item;
  });
}
function upsertMemoryCells(projectDir, items) {
  withMemoryDb(projectDir, (db) => {
    const run = db.transaction(() => {
      const stmt = db.query(`
        INSERT INTO mem_cells (
          id, domain, kind, subject, predicate, object, text, polarity, confidence, tier, status,
          conflict_key, source, source_type, source_message_id, evidence_ref_json, score, embedding_json,
          access_count, is_archived, conflict_wizard_id, superseded_by, created_at, updated_at, last_accessed_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(id) DO UPDATE SET
          domain=excluded.domain,
          kind=excluded.kind,
          subject=excluded.subject,
          predicate=excluded.predicate,
          object=excluded.object,
          text=excluded.text,
          polarity=excluded.polarity,
          confidence=excluded.confidence,
          tier=excluded.tier,
          status=excluded.status,
          conflict_key=excluded.conflict_key,
          source=excluded.source,
          source_type=excluded.source_type,
          source_message_id=excluded.source_message_id,
          evidence_ref_json=excluded.evidence_ref_json,
          score=excluded.score,
          embedding_json=excluded.embedding_json,
          access_count=excluded.access_count,
          is_archived=excluded.is_archived,
          conflict_wizard_id=excluded.conflict_wizard_id,
          superseded_by=excluded.superseded_by,
          created_at=excluded.created_at,
          updated_at=excluded.updated_at,
          last_accessed_at=excluded.last_accessed_at
      `);
      for (const item of items) {
        stmt.run(
          item.id,
          item.domain ?? "work",
          item.memoryKind ?? "Fact",
          item.subject ?? "User",
          item.predicate ?? "fact",
          item.object ?? "",
          item.text,
          item.polarity ?? "neutral",
          item.confidence,
          item.tier,
          item.status,
          item.conflictKey ?? null,
          item.source,
          item.sourceType ?? "manual",
          item.sourceMessageID ?? null,
          item.evidenceRef ? JSON.stringify(item.evidenceRef) : null,
          item.score,
          JSON.stringify(item.embedding),
          item.accessCount,
          item.isArchived ? 1 : 0,
          item.conflictWizardID ?? null,
          item.supersededBy ?? null,
          item.createdAt,
          item.updatedAt,
          item.lastAccessedAt
        );
      }
    });
    run();
  });
}
function listMemoryCorrections(projectDir) {
  return withMemoryDb(projectDir, (db) => {
    const rows = db.query(
      "SELECT * FROM memory_corrections ORDER BY datetime(updated_at) DESC, id DESC"
    ).all();
    return rows.map(rowToCorrection);
  });
}
function upsertMemoryCorrection(projectDir, correction) {
  return withMemoryDb(projectDir, (db) => {
    db.query(`
      INSERT INTO memory_corrections (
        id, conflict_key, candidate_memory_id, existing_memory_ids_json, status, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(id) DO UPDATE SET
        conflict_key=excluded.conflict_key,
        candidate_memory_id=excluded.candidate_memory_id,
        existing_memory_ids_json=excluded.existing_memory_ids_json,
        status=excluded.status,
        created_at=excluded.created_at,
        updated_at=excluded.updated_at
    `).run(
      correction.id,
      correction.conflictKey,
      correction.candidateMemoryID,
      JSON.stringify(correction.existingMemoryIDs),
      correction.status,
      correction.createdAt,
      correction.updatedAt
    );
    const row = db.query("SELECT * FROM memory_corrections WHERE id = ?").get(correction.id);
    return row ? rowToCorrection(row) : correction;
  });
}
function appendRawMemoryLog(projectDir, row) {
  return withMemoryDb(projectDir, (db) => {
    try {
      db.query(`
        INSERT INTO raw_logs (id, session_id, sender, text, at, message_hash, processed_at, processed_job_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        row.id,
        row.sessionID,
        row.sender,
        row.text,
        row.at,
        row.messageHash,
        row.processedAt ?? null,
        null
      );
      return row;
    } catch {
      const existing = db.query("SELECT * FROM raw_logs WHERE message_hash = ? LIMIT 1").get(row.messageHash);
      if (!existing) return null;
      return null;
    }
  });
}
function listRawMemoryLogs(projectDir, options) {
  return withMemoryDb(projectDir, (db) => {
    const limit = Math.max(1, Math.min(1e3, options?.limit ?? 200));
    const sql = options?.pendingOnly ? "SELECT * FROM raw_logs WHERE processed_at IS NULL ORDER BY datetime(at) ASC LIMIT ?" : "SELECT * FROM raw_logs ORDER BY datetime(at) DESC LIMIT ?";
    const rows = db.query(sql).all(limit);
    return rows.map((row) => ({
      id: String(row.id ?? ""),
      sessionID: String(row.session_id ?? "main"),
      sender: row.sender === "assistant" || row.sender === "system" ? row.sender : "user",
      text: String(row.text ?? ""),
      at: String(row.at ?? nowIso15()),
      messageHash: String(row.message_hash ?? ""),
      processedAt: typeof row.processed_at === "string" && row.processed_at.trim() ? String(row.processed_at) : void 0
    }));
  });
}
function appendMemoryEvent(projectDir, input) {
  withMemoryDb(projectDir, (db) => {
    db.query(`
      INSERT OR IGNORE INTO memory_events (
        event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(
      input.eventID,
      input.eventType,
      input.entityType,
      input.entityID,
      JSON.stringify(input.payload ?? {}),
      input.policyHash ?? null,
      input.createdAt ?? nowIso15()
    );
  });
}
function listMemoryEvents(projectDir, options) {
  return withMemoryDb(projectDir, (db) => {
    const limit = Math.max(1, Math.min(2e3, options?.limit ?? 200));
    let rows;
    if (options?.since) {
      rows = db.query(
        `SELECT event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
           FROM memory_events
           WHERE datetime(created_at) >= datetime(?)
           ORDER BY seq ASC
           LIMIT ?`
      ).all(options.since, limit);
    } else {
      rows = db.query(
        `SELECT event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
           FROM memory_events
           ORDER BY seq DESC
           LIMIT ?`
      ).all(limit);
      rows.reverse();
    }
    return rows.map((row) => ({
      eventID: String(row.event_id ?? ""),
      eventType: String(row.event_type ?? ""),
      entityType: String(row.entity_type ?? ""),
      entityID: String(row.entity_id ?? ""),
      payload: safeJsonParse(row.payload_json, {}),
      policyHash: typeof row.policy_hash === "string" && row.policy_hash.trim() ? String(row.policy_hash) : void 0,
      createdAt: String(row.created_at ?? nowIso15())
    }));
  });
}
function constructReflectBatch(projectDir, input) {
  return withMemoryDb(projectDir, (db) => {
    const createdMemories = [];
    const tx = db.transaction(() => {
      db.query(`
        INSERT INTO evidence_packs (audit_id, meta_json, payload_json, created_at)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(audit_id) DO UPDATE SET
          meta_json=excluded.meta_json,
          payload_json=excluded.payload_json,
          created_at=excluded.created_at
      `).run(
        input.auditID,
        JSON.stringify(input.evidenceMeta ?? {}),
        JSON.stringify(input.evidencePayload ?? {}),
        input.processedAt
      );
      const memoryInsert = db.query(`
        INSERT INTO mem_cells (
          id, domain, kind, subject, predicate, object, text, polarity, confidence, tier, status,
          conflict_key, source, source_type, source_message_id, evidence_ref_json, score, embedding_json,
          access_count, is_archived, conflict_wizard_id, superseded_by, created_at, updated_at, last_accessed_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
      const eventInsert = db.query(`
        INSERT OR IGNORE INTO memory_events (
          event_id, event_type, entity_type, entity_id, payload_json, policy_hash, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
      `);
      for (const triplet of input.triplets) {
        const id = `mem_${Math.random().toString(36).slice(2, 10)}_${Math.random().toString(36).slice(2, 10)}`;
        const text = `${triplet.subject} ${triplet.predicate} ${triplet.object}`.trim();
        const embedding = textToEmbeddingLite(text);
        const evidenceRef = {
          auditID: input.auditID,
          sourceLogIDs: [triplet.sourceLogID],
          quoteSpans: triplet.quotes
        };
        const record3 = {
          id,
          text,
          memoryKind: triplet.kind,
          source: "reflect",
          embedding,
          score: 1,
          confidence: triplet.confidence,
          tier: triplet.tier,
          domain: triplet.domain,
          subject: triplet.subject,
          predicate: triplet.predicate,
          object: triplet.object,
          polarity: "neutral",
          sourceMessageID: triplet.sourceLogID,
          sourceType: "reflect",
          status: "candidate",
          conflictKey: void 0,
          conflictWizardID: void 0,
          supersededBy: void 0,
          evidenceRef,
          accessCount: 0,
          isArchived: false,
          createdAt: input.processedAt,
          updatedAt: input.processedAt,
          lastAccessedAt: input.processedAt
        };
        memoryInsert.run(
          record3.id,
          record3.domain ?? "work",
          record3.memoryKind ?? "Fact",
          record3.subject ?? "User",
          record3.predicate ?? "fact",
          record3.object ?? "",
          record3.text,
          record3.polarity ?? "neutral",
          record3.confidence,
          record3.tier,
          record3.status,
          null,
          record3.source,
          record3.sourceType ?? "reflect",
          record3.sourceMessageID ?? null,
          JSON.stringify(record3.evidenceRef),
          record3.score,
          JSON.stringify(record3.embedding),
          record3.accessCount,
          record3.isArchived ? 1 : 0,
          null,
          null,
          record3.createdAt,
          record3.updatedAt,
          record3.lastAccessedAt
        );
        eventInsert.run(
          `evt_${record3.id}`,
          "memory_candidate_created",
          "mem_cell",
          record3.id,
          JSON.stringify({
            status: record3.status,
            sourceType: record3.sourceType,
            source: "reflect",
            hasEvidence: true
          }),
          input.policyHash ?? null,
          input.processedAt
        );
        createdMemories.push(record3);
      }
      const markStmt = db.query(
        "UPDATE raw_logs SET processed_at = ?, processed_job_id = ? WHERE id = ?"
      );
      for (const row of input.pickedLogs) {
        markStmt.run(input.processedAt, input.jobID, row.id);
      }
      eventInsert.run(
        `evt_${input.jobID}`,
        "reflect_completed",
        "reflect_job",
        input.jobID,
        JSON.stringify({
          auditID: input.auditID,
          processedLogs: input.pickedLogs.length,
          generatedTriplets: input.triplets.length,
          generatedFacts: input.reflectStats?.generatedFacts ?? 0,
          generatedInsights: input.reflectStats?.generatedInsights ?? 0,
          generatedPreferences: input.reflectStats?.generatedPreferences ?? 0
        }),
        input.policyHash ?? null,
        input.processedAt
      );
    });
    tx();
    return {
      createdMemories,
      processedLogs: input.pickedLogs.length
    };
  });
}
function getEvidencePack(projectDir, auditID) {
  return withMemoryDb(projectDir, (db) => {
    const row = db.query(
      "SELECT audit_id, meta_json, payload_json, created_at FROM evidence_packs WHERE audit_id = ?"
    ).get(auditID);
    if (!row) return null;
    return {
      auditID: String(row.audit_id ?? ""),
      meta: safeJsonParse(row.meta_json, {}),
      payload: safeJsonParse(row.payload_json, {}),
      createdAt: String(row.created_at ?? nowIso15())
    };
  });
}
function buildMemoryPack(projectDir, input) {
  const domain3 = input.domain ?? "work";
  const mode = input.mode ?? "execution";
  const l0Limit = Math.max(1, Math.min(20, input.l0Limit ?? 10));
  const l1Limit = Math.max(1, Math.min(30, input.l1Limit ?? 12));
  return withMemoryDb(projectDir, (db) => {
    const queryText = input.query.trim();
    const candidates = db.query(
      `SELECT id, text, confidence, tier, updated_at, evidence_ref_json
         FROM mem_cells
         WHERE status = 'active' AND is_archived = 0 AND domain = ?
         ORDER BY datetime(last_accessed_at) DESC, score DESC
         LIMIT 100`
    ).all(domain3);
    const filtered = queryText ? candidates.filter(
      (row) => String(row.text ?? "").toLowerCase().includes(queryText.toLowerCase())
    ) : candidates;
    const base = (filtered.length > 0 ? filtered : candidates).slice(0, 100);
    const l0 = base.filter((row) => String(row.tier ?? "L1") === "L0").slice(0, l0Limit).map((row) => String(row.text ?? ""));
    const l1 = base.filter((row) => String(row.tier ?? "L1") !== "L0").slice(0, l1Limit).map((row) => ({
      text: String(row.text ?? ""),
      confidence: Number(row.confidence ?? 0.5),
      at: String(row.updated_at ?? nowIso15())
    }));
    const l2 = base.map(
      (row) => safeJsonParse(
        row.evidence_ref_json,
        void 0
      )
    ).filter((item) => Boolean(item?.auditID)).map((item) => `miya://audit/evidence/${item.auditID}`);
    const uniqueL2 = Array.from(new Set(l2));
    if (mode === "execution") {
      return { l0, l1: [], l2: [] };
    }
    if (mode === "response") {
      return { l0, l1, l2: uniqueL2.slice(0, 6) };
    }
    return { l0, l1, l2: uniqueL2 };
  });
}
function buildMemoryProfile(projectDir, domain3) {
  const rows = listMemoryCells(projectDir).filter(
    (row) => domain3 ? row.domain === domain3 : true
  );
  const active = rows.filter(
    (row) => row.status === "active" && !row.isArchived
  );
  const candidates = rows.filter(
    (row) => row.status === "candidate" || row.status === "pending"
  );
  const topConstraints = active.filter((row) => row.tier === "L0").slice(0, 12).map((row) => row.text);
  return {
    activeCount: active.length,
    candidateCount: candidates.length,
    topConstraints
  };
}
function resolveContextFsUri(projectDir, uri) {
  const target = String(uri || "").trim();
  if (!target.startsWith("miya://")) return null;
  if (target.startsWith("miya://mem/cell/")) {
    const id = target.slice("miya://mem/cell/".length);
    const cell = getMemoryCell(projectDir, id);
    return cell ? { uri: target, data: cell } : null;
  }
  if (target.startsWith("miya://audit/evidence/")) {
    const auditID = target.slice("miya://audit/evidence/".length);
    const pack = getEvidencePack(projectDir, auditID);
    return pack ? { uri: target, data: pack } : null;
  }
  if (target.startsWith("miya://audit/events")) {
    const question = target.split("?")[1] ?? "";
    const params = new URLSearchParams(question);
    const since = params.get("since") || void 0;
    const limitValue = Number(params.get("limit") ?? "200");
    const limit = Number.isFinite(limitValue) ? Math.max(1, Math.min(2e3, limitValue)) : 200;
    return {
      uri: target,
      data: listMemoryEvents(projectDir, { since, limit })
    };
  }
  if (target.startsWith("miya://mem/query")) {
    const question = target.split("?")[1] ?? "";
    const params = new URLSearchParams(question);
    const domain3 = params.get("domain") || void 0;
    const status = params.get("status") || void 0;
    const tier = params.get("tier") || void 0;
    const rows = listMemoryCells(projectDir).filter((item) => {
      if (domain3 && item.domain !== domain3) return false;
      if (status && item.status !== status) return false;
      if (tier && item.tier !== tier) return false;
      return true;
    });
    return { uri: target, data: rows };
  }
  if (target.startsWith("miya://mem/profile")) {
    const question = target.split("?")[1] ?? "";
    const params = new URLSearchParams(question);
    const domainRaw = params.get("domain");
    const domain3 = domainRaw === "work" || domainRaw === "relationship" || domainRaw === "personal" || domainRaw === "system" ? domainRaw : void 0;
    return {
      uri: target,
      data: buildMemoryProfile(projectDir, domain3)
    };
  }
  if (target.startsWith("miya://mem/scenes/")) {
    const sceneID = target.slice("miya://mem/scenes/".length).trim();
    if (!sceneID) return null;
    return withMemoryDb(projectDir, (db) => {
      const scene = db.query(
        "SELECT scene_id, domain, title, summary_l0, summary_l1, updated_at FROM mem_scenes WHERE scene_id = ?"
      ).get(sceneID);
      if (!scene) return null;
      const cells = db.query(
        `SELECT c.* FROM memscene_cells mc
           JOIN mem_cells c ON c.id = mc.cell_id
           WHERE mc.scene_id = ?
           ORDER BY mc.weight DESC, datetime(c.updated_at) DESC`
      ).all(sceneID);
      return {
        uri: target,
        data: {
          sceneID: String(scene.scene_id ?? ""),
          domain: String(scene.domain ?? "work"),
          title: String(scene.title ?? ""),
          summaryL0: safeJsonParse(scene.summary_l0, []),
          summaryL1: String(scene.summary_l1 ?? ""),
          updatedAt: String(scene.updated_at ?? nowIso15()),
          cells: cells.map(rowToMemory)
        }
      };
    });
  }
  return null;
}
function getCompanionMemorySqliteStats(projectDir) {
  const dbPath = sqlitePath(projectDir);
  return withMemoryDb(projectDir, (db) => {
    const memoryCount = Number(
      db.query("SELECT COUNT(1) AS c FROM mem_cells").get()?.c ?? 0
    );
    const candidateCount = Number(
      db.query(
        "SELECT COUNT(1) AS c FROM mem_cells WHERE status IN ('candidate','pending')"
      ).get()?.c ?? 0
    );
    const activeCount = Number(
      db.query("SELECT COUNT(1) AS c FROM mem_cells WHERE status = 'active'").get()?.c ?? 0
    );
    const rawLogCount = Number(
      db.query("SELECT COUNT(1) AS c FROM raw_logs").get()?.c ?? 0
    );
    const pendingRawLogCount = Number(
      db.query(
        "SELECT COUNT(1) AS c FROM raw_logs WHERE processed_at IS NULL"
      ).get()?.c ?? 0
    );
    const evidenceCount = Number(
      db.query("SELECT COUNT(1) AS c FROM evidence_packs").get()?.c ?? 0
    );
    const eventCount = Number(
      db.query("SELECT COUNT(1) AS c FROM memory_events").get()?.c ?? 0
    );
    return {
      sqlitePath: dbPath,
      memoryCount,
      candidateCount,
      activeCount,
      vectorCount: memoryCount,
      graphCount: memoryCount,
      rawLogCount,
      pendingRawLogCount,
      evidenceCount,
      eventCount
    };
  });
}

// src/companion/memory-vector.ts
function nowIso16() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function normalizeText2(text) {
  return text.trim().replace(/\s+/g, " ");
}
function textToEmbedding(text, dims = 96) {
  const vec = new Array(dims).fill(0);
  const parts = normalizeText2(text).toLowerCase().split(/[^\p{L}\p{N}]+/u).filter(Boolean);
  if (parts.length === 0) return vec;
  for (const part of parts) {
    const hash3 = createHash9("sha256").update(part).digest();
    for (let i = 0; i < 12; i += 1) {
      const idx = hash3[i] % dims;
      vec[idx] += 1 + hash3[i + 12] % 3;
    }
  }
  const norm = Math.sqrt(vec.reduce((sum, value) => sum + value * value, 0));
  if (norm <= 0) return vec;
  return vec.map((value) => value / norm);
}
function cosine(a, b) {
  if (a.length !== b.length || a.length === 0) return 0;
  let sum = 0;
  for (let i = 0; i < a.length; i += 1) sum += a[i] * b[i];
  return sum;
}
function extractConflictKey(text) {
  const negative = text.match(
    /(?:||||)\s*([^!?]+)/
  );
  if (negative?.[1])
    return { key: normalizeText2(negative[1]), polarity: "negative" };
  const positive = text.match(/(?:||||)\s*([^!?]+)/);
  if (positive?.[1])
    return { key: normalizeText2(positive[1]), polarity: "positive" };
  return { polarity: "neutral" };
}
function parseTriplet(text) {
  const parts = normalizeText2(text).split(/\s+/).filter(Boolean);
  if (parts.length >= 3) {
    return {
      subject: parts[0] ?? "User",
      predicate: parts[1] ?? "fact",
      object: parts.slice(2).join(" ")
    };
  }
  return {
    subject: "User",
    predicate: "stated",
    object: normalizeText2(text)
  };
}
function asPending(status) {
  return status === "pending" || status === "candidate";
}
function lexicalScore(query, text) {
  const q = normalizeText2(query).toLowerCase();
  const t = normalizeText2(text).toLowerCase();
  if (!q || !t) return 0;
  if (t.includes(q)) return 1;
  const qTokens = q.split(/[^\p{L}\p{N}]+/u).filter(Boolean);
  if (qTokens.length === 0) return 0;
  let hit = 0;
  for (const token of qTokens) if (t.includes(token)) hit += 1;
  return hit / qTokens.length;
}
function graphRelationScore(query, item) {
  const triplet = parseTriplet(query);
  const subjectHit = lexicalScore(triplet.subject, item.subject ?? "");
  const predicateHit = lexicalScore(triplet.predicate, item.predicate ?? "");
  const objectHit = lexicalScore(triplet.object, item.object ?? item.text);
  const directTripletHit = lexicalScore(
    query,
    `${item.subject ?? ""} ${item.predicate ?? ""} ${item.object ?? ""}`
  );
  return Math.max(
    directTripletHit,
    subjectHit * 0.2 + predicateHit * 0.4 + objectHit * 0.4
  );
}
function rrfScore(rank, k = 60) {
  return 1 / (k + rank + 1);
}
function qualityScore(item) {
  const tierWeight = item.tier === "L0" ? 1 : item.tier === "L1" ? 0.8 : item.tier === "L2" ? 0.55 : 0.35;
  const evidenceBoost = item.evidenceRef?.auditID ? 0.08 : 0;
  const archivedPenalty = item.isArchived || item.status === "archived" ? 0.5 : 1;
  const statusPenalty = item.status === "active" ? 1 : asPending(item.status) ? 0.75 : 0.4;
  return Math.max(
    0,
    Math.min(
      1.5,
      (item.confidence * 0.45 + item.score * 0.35 + tierWeight * 0.2 + evidenceBoost) * archivedPenalty * statusPenalty
    )
  );
}
function appendMutationEvent(projectDir, eventType, memoryID, payload) {
  appendMemoryEvent(projectDir, {
    eventID: `evt_${randomUUID12()}`,
    eventType,
    entityType: "mem_cell",
    entityID: memoryID,
    payload
  });
}
function decayCompanionMemoryVectors(projectDir, halfLifeDays = 30) {
  const items = listMemoryCells(projectDir);
  const safeHalfLife = Math.max(1, halfLifeDays);
  const lambda = Math.log(2) / safeHalfLife;
  const nowMs = Date.now();
  let updated = 0;
  const touched = [];
  for (const item of items) {
    if (item.status !== "active") continue;
    const ageDays = Math.max(
      0,
      (nowMs - Date.parse(item.updatedAt)) / (24 * 3600 * 1e3)
    );
    const nextScore = Math.max(0.05, item.score * Math.exp(-lambda * ageDays));
    if (Math.abs(nextScore - item.score) <= 1e-4) continue;
    item.score = Number(nextScore.toFixed(4));
    if (item.score < 0.08) item.isArchived = true;
    item.updatedAt = nowIso16();
    touched.push(item);
    updated += 1;
  }
  if (touched.length > 0) {
    upsertMemoryCells(projectDir, touched);
  }
  autoCleanupCompanionMemoryVectors(projectDir);
  return { updated, items: listMemoryCells(projectDir) };
}
function autoCleanupCompanionMemoryVectors(projectDir, input) {
  const maxActive = Math.max(100, Math.floor(input?.maxActive ?? 600));
  const maxPendingAgeDays = Math.max(
    1,
    Math.floor(input?.maxPendingAgeDays ?? 45)
  );
  const minQualityToKeep = Math.max(
    0.05,
    Math.min(1.5, Number(input?.minQualityToKeep ?? 0.18))
  );
  const nowMs = Date.now();
  const cells = listMemoryCells(projectDir);
  const touched = [];
  let archived = 0;
  let superseded = 0;
  for (const cell of cells) {
    const ageDays = Math.max(
      0,
      (nowMs - Date.parse(cell.updatedAt)) / (24 * 3600 * 1e3)
    );
    if (asPending(cell.status) && ageDays > maxPendingAgeDays) {
      cell.status = "superseded";
      cell.updatedAt = nowIso16();
      touched.push(cell);
      superseded += 1;
      appendMutationEvent(
        projectDir,
        "memory_auto_cleanup_pending_expired",
        cell.id,
        {
          ageDays: Number(ageDays.toFixed(2))
        }
      );
      continue;
    }
    if (cell.status === "active" && qualityScore(cell) < minQualityToKeep && ageDays > 14) {
      cell.isArchived = true;
      cell.status = "archived";
      cell.updatedAt = nowIso16();
      touched.push(cell);
      archived += 1;
      appendMutationEvent(
        projectDir,
        "memory_auto_cleanup_low_quality",
        cell.id,
        {
          quality: Number(qualityScore(cell).toFixed(4)),
          ageDays: Number(ageDays.toFixed(2))
        }
      );
    }
  }
  const active = cells.filter(
    (item) => item.status === "active" && !item.isArchived
  );
  if (active.length > maxActive) {
    const overflow = active.map((item) => ({
      item,
      q: qualityScore(item),
      age: Date.parse(item.updatedAt)
    })).sort((a, b) => a.q - b.q || a.age - b.age).slice(0, active.length - maxActive);
    for (const row of overflow) {
      row.item.isArchived = true;
      row.item.status = "archived";
      row.item.updatedAt = nowIso16();
      touched.push(row.item);
      archived += 1;
      appendMutationEvent(
        projectDir,
        "memory_auto_cleanup_capacity",
        row.item.id,
        {
          quality: Number(row.q.toFixed(4))
        }
      );
    }
  }
  if (touched.length > 0) {
    upsertMemoryCells(projectDir, touched);
  }
  const retained = listMemoryCells(projectDir).filter(
    (item) => item.status === "active" && !item.isArchived
  ).length;
  return { archived, superseded, retained };
}
function upsertCompanionMemoryVector(projectDir, input) {
  const text = normalizeText2(input.text);
  if (!text) throw new Error("invalid_memory_text");
  decayCompanionMemoryVectors(projectDir);
  const items = listMemoryCells(projectDir);
  const embedding = textToEmbedding(text);
  const now = nowIso16();
  const near = items.filter((item) => item.status === "active").map((item) => ({ item, sim: cosine(item.embedding, embedding) })).sort((a, b) => b.sim - a.sim)[0];
  if (near && near.sim >= 0.95) {
    near.item.score = Math.min(1.5, near.item.score + 0.15);
    near.item.accessCount += 1;
    near.item.isArchived = false;
    near.item.lastAccessedAt = now;
    near.item.updatedAt = now;
    upsertMemoryCell(projectDir, near.item);
    appendMutationEvent(projectDir, "memory_reinforced", near.item.id, {
      similarity: near.sim,
      sourceType: input.sourceType ?? "manual"
    });
    return near.item;
  }
  const preference = extractConflictKey(text);
  const confidenceInput = typeof input.confidence === "number" && Number.isFinite(input.confidence) ? input.confidence : input.tier === "L0" ? 1 : input.tier === "L3" ? 0.4 : 0.7;
  const confidence = Math.max(0, Math.min(1, confidenceInput));
  const tier = input.tier ?? (confidence >= 0.95 ? "L0" : confidence >= 0.6 ? "L1" : "L2");
  const triplet = parseTriplet(text);
  const created = {
    id: `mem_${randomUUID12()}`,
    text,
    source: input.source?.trim() || "manual",
    embedding,
    score: 1,
    confidence,
    tier,
    domain: input.domain ?? "work",
    subject: triplet.subject,
    predicate: triplet.predicate,
    object: triplet.object,
    polarity: preference.polarity,
    sourceMessageID: input.sourceMessageID,
    sourceType: input.sourceType ?? "manual",
    memoryKind: input.memoryKind,
    status: input.activate ? "active" : "pending",
    conflictKey: preference.key,
    evidenceRef: input.evidenceRef,
    accessCount: 0,
    isArchived: false,
    createdAt: now,
    updatedAt: now,
    lastAccessedAt: now
  };
  if (preference.key && preference.polarity !== "neutral") {
    const conflicting = [];
    for (const item of items) {
      if (item.status === "superseded" || item.status === "archived") continue;
      const other = extractConflictKey(item.text);
      if (!other.key || other.key !== preference.key || other.polarity === "neutral")
        continue;
      if (other.polarity !== preference.polarity) conflicting.push(item);
    }
    if (conflicting.length > 0) {
      const lambda = Math.log(2) / 30;
      const newScore = created.confidence;
      const scored = conflicting.map((item) => {
        const ageDays = Math.max(
          0,
          (Date.now() - Date.parse(item.lastAccessedAt)) / (24 * 3600 * 1e3)
        );
        const score = item.confidence * Math.exp(-lambda * ageDays);
        return { item, score };
      });
      const strongestOld = scored.sort((a, b) => b.score - a.score)[0];
      const threshold = 0.1;
      const forceOverride = created.sourceType === "direct_correction";
      const shouldOverwrite = forceOverride || (strongestOld ? newScore > strongestOld.score + threshold : false);
      if (shouldOverwrite) {
        created.status = "active";
        for (const other of conflicting) {
          other.status = "superseded";
          other.supersededBy = created.id;
          other.updatedAt = now;
        }
        upsertMemoryCells(projectDir, conflicting);
      } else {
        const wizard = {
          id: `mcw_${randomUUID12()}`,
          conflictKey: preference.key,
          candidateMemoryID: created.id,
          existingMemoryIDs: conflicting.map((item) => item.id),
          status: "pending",
          createdAt: now,
          updatedAt: now
        };
        upsertMemoryCorrection(projectDir, wizard);
        created.conflictWizardID = wizard.id;
        created.status = "pending";
      }
    }
  }
  const saved = upsertMemoryCell(projectDir, created);
  appendMutationEvent(projectDir, "memory_candidate_created", saved.id, {
    status: saved.status,
    sourceType: saved.sourceType,
    conflictKey: saved.conflictKey ?? null,
    hasEvidence: Boolean(saved.evidenceRef?.auditID)
  });
  return saved;
}
function searchCompanionMemoryVectors(projectDir, query, limit = 5, options) {
  const q = normalizeText2(query);
  if (!q) return [];
  const qEmb = textToEmbedding(q);
  const items = listMemoryCells(projectDir).filter(
    (item) => item.status === "active" && !item.isArchived && (!options?.domain || (item.domain ?? "work") === options.domain)
  );
  if (items.length === 0) return [];
  const nowMs = Date.now();
  const recencyHalfLifeDays = Math.max(1, options?.recencyHalfLifeDays ?? 30);
  const alpha = options?.alpha ?? 0.6;
  const beta = options?.beta ?? 0.2;
  const gamma = options?.gamma ?? 0.2;
  const threshold = Math.max(0, options?.threshold ?? 0.15);
  const importanceFromTier = (tier) => tier === "L0" ? 1 : tier === "L1" ? 0.7 : 0.4;
  const recency = (at) => {
    const deltaDays = Math.max(
      0,
      (nowMs - Date.parse(at)) / (24 * 3600 * 1e3)
    );
    const lambda = Math.log(2) / recencyHalfLifeDays;
    return Math.exp(-lambda * deltaDays);
  };
  const vectorRanked = items.map((item) => ({ item, score: cosine(item.embedding, qEmb) })).sort((a, b) => b.score - a.score);
  const lexicalRanked = items.map((item) => ({ item, score: lexicalScore(q, item.text) })).sort((a, b) => b.score - a.score);
  const relationRanked = items.map((item) => ({ item, score: graphRelationScore(q, item) })).sort((a, b) => b.score - a.score);
  const vectorIndex = /* @__PURE__ */ new Map();
  const lexicalIndex = /* @__PURE__ */ new Map();
  const relationIndex = /* @__PURE__ */ new Map();
  vectorRanked.forEach((entry2, index) => vectorIndex.set(entry2.item.id, index));
  lexicalRanked.forEach(
    (entry2, index) => lexicalIndex.set(entry2.item.id, index)
  );
  relationRanked.forEach(
    (entry2, index) => relationIndex.set(entry2.item.id, index)
  );
  const ranked = items.map((item) => {
    const similarity2 = cosine(item.embedding, qEmb);
    const lexical = lexicalScore(q, item.text);
    const relation = graphRelationScore(q, item);
    const quality = qualityScore(item);
    const importance = importanceFromTier(item.tier) * quality;
    const vectorRrf = rrfScore(vectorIndex.get(item.id) ?? 999);
    const lexicalRrf = rrfScore(lexicalIndex.get(item.id) ?? 999);
    const relationRrf = rrfScore(relationIndex.get(item.id) ?? 999);
    const mode = options?.mode ?? "hybrid";
    const fusedRecall = mode === "vector" ? vectorRrf : mode === "keyword" ? lexicalRrf + relationRrf * 0.5 : vectorRrf + lexicalRrf + relationRrf;
    const rankScore = alpha * fusedRecall + beta * recency(item.lastAccessedAt) + gamma * importance;
    return {
      ...item,
      similarity: similarity2,
      rankScore,
      quality,
      vectorScore: similarity2,
      lexicalScore: lexical,
      relationScore: relation
    };
  }).filter((item) => item.rankScore >= threshold).sort((a, b) => b.rankScore - a.rankScore).slice(0, Math.max(1, limit));
  if (ranked.length > 0) {
    const touched = /* @__PURE__ */ new Map();
    for (const item of ranked) {
      item.accessCount += 1;
      item.lastAccessedAt = nowIso16();
      touched.set(item.id, item);
    }
    upsertMemoryCells(projectDir, Array.from(touched.values()));
  }
  autoCleanupCompanionMemoryVectors(projectDir);
  return ranked;
}
function listCompanionMemoryVectors(projectDir) {
  return listMemoryCells(projectDir);
}
function listPendingCompanionMemoryVectors(projectDir) {
  return listMemoryCells(projectDir).filter((item) => asPending(item.status));
}
function listCompanionMemoryCorrections(projectDir) {
  return listMemoryCorrections(projectDir);
}
function updateCompanionMemoryVector(projectDir, input) {
  const target = listMemoryCells(projectDir).find(
    (item) => item.id === input.memoryID
  );
  if (!target) return null;
  const nextText = typeof input.text === "string" && input.text.trim() ? normalizeText2(input.text) : target.text;
  const confidenceInput = typeof input.confidence === "number" && Number.isFinite(input.confidence) ? Math.max(0, Math.min(1, Number(input.confidence))) : target.confidence;
  target.text = nextText;
  target.embedding = textToEmbedding(nextText);
  const conflict = extractConflictKey(nextText);
  target.conflictKey = conflict.key;
  target.polarity = conflict.polarity;
  target.confidence = confidenceInput;
  target.tier = input.tier ?? (confidenceInput >= 0.95 ? "L0" : confidenceInput >= 0.6 ? "L1" : "L2");
  target.memoryKind = input.memoryKind === "Fact" || input.memoryKind === "Insight" || input.memoryKind === "UserPreference" ? input.memoryKind : target.memoryKind;
  if (input.status) target.status = input.status;
  target.updatedAt = nowIso16();
  if (target.status === "active") target.lastAccessedAt = target.updatedAt;
  const saved = upsertMemoryCell(projectDir, target);
  appendMutationEvent(projectDir, "memory_updated", saved.id, {
    status: saved.status,
    tier: saved.tier
  });
  return saved;
}
function archiveCompanionMemoryVector(projectDir, input) {
  const target = listMemoryCells(projectDir).find(
    (item) => item.id === input.memoryID
  );
  if (!target) return null;
  target.isArchived = Boolean(input.archived);
  target.status = target.isArchived ? "archived" : target.status === "archived" ? "active" : target.status;
  target.updatedAt = nowIso16();
  const saved = upsertMemoryCell(projectDir, target);
  appendMutationEvent(projectDir, "memory_archive_toggled", saved.id, {
    archived: saved.isArchived
  });
  return saved;
}
function confirmCompanionMemoryVector(projectDir, input) {
  const all = listMemoryCells(projectDir);
  const target = all.find((item) => item.id === input.memoryID);
  if (!target) return null;
  const now = nowIso16();
  if (!input.confirm) {
    target.status = "superseded";
    target.updatedAt = now;
  } else {
    target.status = "active";
    target.updatedAt = now;
    target.lastAccessedAt = now;
    if (input.supersedeConflicts && target.conflictKey) {
      const sourcePolarity = extractConflictKey(target.text).polarity;
      const touched = [];
      for (const item of all) {
        if (item.id === target.id || item.status === "superseded") continue;
        if (item.conflictKey !== target.conflictKey) continue;
        const itemPolarity = extractConflictKey(item.text).polarity;
        if (sourcePolarity !== "neutral" && itemPolarity !== "neutral" && sourcePolarity !== itemPolarity) {
          item.status = "superseded";
          item.supersededBy = target.id;
          item.updatedAt = now;
          touched.push(item);
        }
      }
      if (touched.length > 0) upsertMemoryCells(projectDir, touched);
    }
  }
  const saved = upsertMemoryCell(projectDir, target);
  if (target.conflictWizardID) {
    const correction = listMemoryCorrections(projectDir).find(
      (item) => item.id === target.conflictWizardID
    );
    if (correction) {
      correction.status = input.confirm ? "resolved" : "rejected";
      correction.updatedAt = now;
      upsertMemoryCorrection(projectDir, correction);
    }
  }
  appendMutationEvent(projectDir, "memory_confirmed", saved.id, {
    confirm: input.confirm,
    supersedeConflicts: Boolean(input.supersedeConflicts)
  });
  return saved;
}

// src/companion/store.ts
function nowIso17() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath8(projectDir) {
  return path30.join(getMiyaRuntimeDir(projectDir), "companion.json");
}
function ensureDir14(file3) {
  fs30.mkdirSync(path30.dirname(file3), { recursive: true });
}
function defaultProfile() {
  return {
    enabled: false,
    onboardingCompleted: false,
    name: "Miya",
    persona: "calm, supportive, and proactive",
    relationship: "companion",
    style: "warm and concise",
    memoryFacts: [],
    assets: [],
    updatedAt: nowIso17()
  };
}
function deriveActiveMemoryFacts(projectDir) {
  return listCompanionMemoryVectors(projectDir).filter((item) => item.status === "active" && !item.isArchived).map((item) => item.text).slice(0, 300);
}
function readCompanionProfile(projectDir) {
  const file3 = filePath8(projectDir);
  if (!fs30.existsSync(file3)) {
    return {
      ...defaultProfile(),
      memoryFacts: deriveActiveMemoryFacts(projectDir)
    };
  }
  try {
    const parsed = JSON.parse(fs30.readFileSync(file3, "utf-8"));
    return {
      ...defaultProfile(),
      ...parsed,
      // Runtime memory truth source is SQLite (mem_cells), not JSON profile blobs.
      memoryFacts: deriveActiveMemoryFacts(projectDir),
      assets: Array.isArray(parsed.assets) ? parsed.assets : [],
      updatedAt: parsed.updatedAt ?? nowIso17()
    };
  } catch {
    return {
      ...defaultProfile(),
      memoryFacts: deriveActiveMemoryFacts(projectDir)
    };
  }
}
function writeCompanionProfile(projectDir, profile) {
  const file3 = filePath8(projectDir);
  ensureDir14(file3);
  const next = {
    ...profile,
    memoryFacts: deriveActiveMemoryFacts(projectDir),
    updatedAt: nowIso17()
  };
  fs30.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function patchCompanionProfile(projectDir, patch) {
  const current = readCompanionProfile(projectDir);
  return writeCompanionProfile(projectDir, {
    ...current,
    ...patch
  });
}
function addCompanionAsset(projectDir, input) {
  const current = readCompanionProfile(projectDir);
  const asset = {
    id: `asset_${randomUUID13()}`,
    type: input.type,
    pathOrUrl: input.pathOrUrl,
    label: input.label,
    createdAt: nowIso17()
  };
  return writeCompanionProfile(projectDir, {
    ...current,
    assets: [asset, ...current.assets].slice(0, 200)
  });
}
function resetCompanionProfile(projectDir) {
  const allMemories = listCompanionMemoryVectors(projectDir);
  for (const item of allMemories) {
    if (item.isArchived) continue;
    archiveCompanionMemoryVector(projectDir, {
      memoryID: item.id,
      archived: true
    });
  }
  return writeCompanionProfile(projectDir, defaultProfile());
}
function syncCompanionProfileMemoryFacts(projectDir) {
  const current = readCompanionProfile(projectDir);
  return writeCompanionProfile(projectDir, {
    ...current,
    memoryFacts: deriveActiveMemoryFacts(projectDir)
  });
}

// src/companion/memory-reflect.ts
import { createHash as createHash11, randomUUID as randomUUID15 } from "node:crypto";
import * as fs32 from "node:fs";
import * as path32 from "node:path";

// src/learning/skill-drafts.ts
import { createHash as createHash10, randomUUID as randomUUID14 } from "node:crypto";
import * as fs31 from "node:fs";
import * as path31 from "node:path";
function nowIso18() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath9(projectDir) {
  return path31.join(getMiyaRuntimeDir(projectDir), "learning-skill-drafts.json");
}
function normalizeText3(text) {
  return String(text ?? "").replace(/\s+/g, " ").trim();
}
function tokenize(text) {
  return Array.from(
    new Set(
      normalizeText3(text).toLowerCase().split(/[^a-z0-9_\-\u4e00-\u9fff]+/i).map((item) => item.trim()).filter((item) => item.length >= 2)
    )
  );
}
function hashText(text) {
  return createHash10("sha256").update(text).digest("hex").slice(0, 16);
}
function ensureDir15(projectDir) {
  fs31.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp2(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeDraft(raw) {
  const now = nowIso18();
  return {
    id: String(raw.id ?? `draft_${randomUUID14()}`),
    source: raw.source === "reflect" ? "reflect" : "ralph",
    status: raw.status === "accepted" || raw.status === "rejected" || raw.status === "recommended" || raw.status === "draft" ? raw.status : "draft",
    title: normalizeText3(String(raw.title ?? "")),
    problemPattern: normalizeText3(String(raw.problemPattern ?? "")),
    solutionPattern: normalizeText3(String(raw.solutionPattern ?? "")),
    commands: Array.isArray(raw.commands) ? raw.commands.map(String).map(normalizeText3).filter(Boolean) : [],
    tags: Array.isArray(raw.tags) ? raw.tags.map(String).map((item) => item.trim().toLowerCase()).filter(Boolean) : [],
    confidence: clamp2(Number(raw.confidence ?? 0.5), 0.1, 0.99),
    uses: clamp2(Number(raw.uses ?? 0), 0, 1e6),
    hits: clamp2(Number(raw.hits ?? 0), 0, 1e6),
    misses: clamp2(Number(raw.misses ?? 0), 0, 1e6),
    createdAt: raw.createdAt ? String(raw.createdAt) : now,
    updatedAt: raw.updatedAt ? String(raw.updatedAt) : now
  };
}
function readStore5(projectDir) {
  const file3 = filePath9(projectDir);
  if (!fs31.existsSync(file3)) return { drafts: [] };
  try {
    const parsed = JSON.parse(fs31.readFileSync(file3, "utf-8"));
    const drafts = Array.isArray(parsed?.drafts) ? parsed.drafts.map((item) => normalizeDraft(item)) : [];
    return { drafts };
  } catch {
    return { drafts: [] };
  }
}
function writeStore5(projectDir, store2) {
  ensureDir15(projectDir);
  fs31.writeFileSync(filePath9(projectDir), `${JSON.stringify(store2, null, 2)}
`, "utf-8");
}
function findSimilarDraftIndex(drafts, candidate) {
  const signature = hashText(
    `${candidate.source}|${candidate.problemPattern}|${candidate.solutionPattern}|${candidate.commands.join("|")}`
  );
  return drafts.findIndex((item) => {
    const current = hashText(
      `${item.source}|${item.problemPattern}|${item.solutionPattern}|${item.commands.join("|")}`
    );
    return current === signature;
  });
}
function upsertDraft(projectDir, draft) {
  const store2 = readStore5(projectDir);
  const index = findSimilarDraftIndex(store2.drafts, draft);
  if (index >= 0) {
    const current = store2.drafts[index];
    const merged = normalizeDraft({
      ...current,
      ...draft,
      id: current.id,
      createdAt: current.createdAt,
      confidence: current.confidence * 0.7 + draft.confidence * 0.3,
      status: current.status === "accepted" || current.status === "rejected" ? current.status : draft.status,
      tags: Array.from(/* @__PURE__ */ new Set([...current.tags, ...draft.tags])).slice(0, 12),
      updatedAt: nowIso18()
    });
    store2.drafts[index] = merged;
    writeStore5(projectDir, store2);
    return merged;
  }
  const next = normalizeDraft(draft);
  store2.drafts = [next, ...store2.drafts].slice(0, 500);
  writeStore5(projectDir, store2);
  return next;
}
function draftScoreForQuery(draft, query) {
  const queryTokens = tokenize(query);
  if (queryTokens.length === 0) return 0;
  const targetTokens = new Set(
    tokenize(`${draft.title} ${draft.problemPattern} ${draft.solutionPattern} ${draft.tags.join(" ")}`)
  );
  let overlap = 0;
  for (const token of queryTokens) {
    if (targetTokens.has(token)) overlap += 1;
  }
  const overlapScore = overlap / queryTokens.length;
  const quality = draft.confidence;
  const statusBoost = draft.status === "accepted" ? 0.12 : draft.status === "recommended" ? 0.06 : 0;
  return clamp2(overlapScore * 0.75 + quality * 0.25 + statusBoost, 0, 1);
}
function matchDrafts(projectDir, query, threshold, limit) {
  const store2 = readStore5(projectDir);
  return store2.drafts.filter((draft) => draft.status !== "rejected").map((draft) => ({ draft, score: draftScoreForQuery(draft, query) })).filter((item) => item.score >= threshold).sort((a, b) => b.score - a.score).slice(0, Math.max(1, limit));
}
function listSkillDrafts(projectDir, input) {
  const limit = Math.max(1, Math.min(200, Math.floor(Number(input?.limit ?? 50))));
  const store2 = readStore5(projectDir);
  return store2.drafts.filter((draft) => input?.status ? draft.status === input.status : true).slice(0, limit);
}
function setSkillDraftStatus(projectDir, draftID, status, usage) {
  const store2 = readStore5(projectDir);
  const index = store2.drafts.findIndex((item) => item.id === draftID);
  if (index < 0) return null;
  const current = store2.drafts[index];
  const next = normalizeDraft({
    ...current,
    status: status ?? current.status,
    uses: usage ? current.uses + 1 : current.uses,
    hits: usage ? current.hits + (usage.hit ? 1 : 0) : current.hits,
    misses: usage ? current.misses + (usage.hit ? 0 : 1) : current.misses,
    updatedAt: nowIso18()
  });
  store2.drafts[index] = next;
  writeStore5(projectDir, store2);
  return next;
}
function getLearningStats(projectDir) {
  const drafts = readStore5(projectDir).drafts;
  const byStatus = {
    draft: 0,
    recommended: 0,
    accepted: 0,
    rejected: 0
  };
  let totalUses = 0;
  let totalHits = 0;
  for (const draft of drafts) {
    byStatus[draft.status] += 1;
    totalUses += draft.uses;
    totalHits += draft.hits;
  }
  return {
    total: drafts.length,
    byStatus,
    totalUses,
    hitRate: totalUses > 0 ? Number((totalHits / totalUses).toFixed(4)) : 0
  };
}
function buildLearningInjection(projectDir, query, input) {
  const threshold = clamp2(Number(input?.threshold ?? 0.64), 0.3, 0.98);
  const limit = Math.max(1, Math.min(3, Math.floor(Number(input?.limit ?? 2))));
  const matches = matchDrafts(projectDir, query, threshold, limit);
  if (matches.length === 0) return { snippet: void 0, matchedDraftIDs: [] };
  const lines = [
    "[MIYA_LEARNING_DRAFT_REUSE]",
    "Matched historical patterns (use as guidance, then verify):"
  ];
  for (const item of matches) {
    lines.push(`- draft=${item.draft.id} score=${item.score.toFixed(2)} title=${item.draft.title}`);
    lines.push(`  pattern=${item.draft.problemPattern}`);
    lines.push(`  fix=${item.draft.solutionPattern}`);
    if (item.draft.commands.length > 0) {
      lines.push(`  commands=${item.draft.commands.join(" ; ")}`);
    }
  }
  return {
    snippet: lines.join("\n"),
    matchedDraftIDs: matches.map((item) => item.draft.id)
  };
}
function createSkillDraftFromRalph(projectDir, input) {
  const fixCommands = input.result.attempts.filter((item) => item.type === "fix").map((item) => normalizeText3(item.result.command)).filter(Boolean);
  if (fixCommands.length === 0) return null;
  const latestVerify = [...input.result.attempts].reverse().find((item) => item.type === "verify");
  const problemSummary = normalizeText3(latestVerify?.failureSummary ?? input.result.summary);
  const confidence = input.result.success ? 0.82 : 0.58;
  return upsertDraft(projectDir, {
    id: `draft_${randomUUID14()}`,
    source: "ralph",
    status: input.result.success ? "recommended" : "draft",
    title: `Ralph \u4FEE\u590D\u6A21\u5F0F: ${normalizeText3(input.taskDescription).slice(0, 48)}`,
    problemPattern: problemSummary || "verification_failed_pattern",
    solutionPattern: input.result.summary,
    commands: fixCommands.slice(0, 4),
    tags: ["ralph", input.result.reason ?? "unknown"],
    confidence,
    uses: 0,
    hits: 0,
    misses: 0,
    createdAt: nowIso18(),
    updatedAt: nowIso18()
  });
}
function createSkillDraftsFromReflect(projectDir, input) {
  const memories = Array.isArray(input.createdMemories) ? input.createdMemories : [];
  if (memories.length === 0) return [];
  const preferenceMemories = memories.filter((item) => item.memoryKind === "UserPreference").slice(0, 6);
  if (preferenceMemories.length === 0) return [];
  const pattern = preferenceMemories.map((item) => item.text).join(" | ");
  const draft = upsertDraft(projectDir, {
    id: `draft_${randomUUID14()}`,
    source: "reflect",
    status: "draft",
    title: "Reflect \u504F\u597D\u6267\u884C\u8349\u6848",
    problemPattern: "\u4EFB\u52A1\u6267\u884C\u6D89\u53CA\u7528\u6237\u4E60\u60EF\u6216\u504F\u597D\u5224\u65AD",
    solutionPattern: `\u4F18\u5148\u9075\u5FAA\u8FD1\u671F\u504F\u597D\u8BB0\u5FC6\uFF1A${pattern}`,
    commands: [],
    tags: ["reflect", "preference"],
    confidence: 0.62,
    uses: 0,
    hits: 0,
    misses: 0,
    createdAt: nowIso18(),
    updatedAt: nowIso18()
  });
  return [draft];
}

// src/companion/memory-reflect.ts
function nowIso19() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function memoryDir2(projectDir) {
  return path32.join(getMiyaRuntimeDir(projectDir), "memory");
}
function reflectJobPath(projectDir) {
  return path32.join(memoryDir2(projectDir), "reflect-jobs.jsonl");
}
function reflectStatePath(projectDir) {
  return path32.join(memoryDir2(projectDir), "reflect-state.json");
}
function ensureDir16(projectDir) {
  fs32.mkdirSync(memoryDir2(projectDir), { recursive: true });
}
function normalizeText4(input) {
  return input.trim().replace(/\s+/g, " ");
}
function hashMessage(input) {
  return createHash11("sha256").update(`${input.sender}
${input.at}
${normalizeText4(input.text)}`).digest("hex");
}
function readReflectState(projectDir) {
  const file3 = reflectStatePath(projectDir);
  if (!fs32.existsSync(file3)) return {};
  try {
    const parsed = JSON.parse(fs32.readFileSync(file3, "utf-8"));
    return parsed ?? {};
  } catch {
    return {};
  }
}
function writeReflectState(projectDir, patch) {
  ensureDir16(projectDir);
  const file3 = reflectStatePath(projectDir);
  const next = {
    ...readReflectState(projectDir),
    ...patch
  };
  fs32.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function quoteSpan(log2, raw) {
  const value = normalizeText4(raw);
  if (!value) return null;
  const start = log2.text.indexOf(value);
  if (start < 0) return null;
  return {
    logID: log2.id,
    exactText: value,
    charStart: start,
    charEnd: start + value.length
  };
}
function extractTriplets(log2) {
  if (log2.sender === "system") return [];
  const text = normalizeText4(log2.text);
  if (!text) return [];
  const triplets = [];
  const add = (kind, subject, predicate, object3, confidence, tier, quoteRaw) => {
    const value = normalizeText4(object3);
    const q = quoteSpan(log2, quoteRaw);
    if (!value || !q) return;
    triplets.push({
      kind,
      subject,
      predicate,
      object: value,
      confidence,
      tier,
      sourceLogID: log2.id,
      domain: "work",
      quotes: [q]
    });
  };
  const likes = text.match(/(?:)?([^!?.]+)/);
  if (likes?.[1])
    add("UserPreference", "User", "likes", likes[1], 0.86, "L1", likes[0]);
  const dislikes = text.match(/(?:|)?([^!?.]+)/);
  if (dislikes?.[1])
    add(
      "UserPreference",
      "User",
      "dislikes",
      dislikes[1],
      0.86,
      "L1",
      dislikes[0]
    );
  const prefers = text.match(
    /(?:||)?(?:|||)\s*([^!?.]+)/
  );
  if (prefers?.[1])
    add("UserPreference", "User", "prefers", prefers[1], 0.9, "L1", prefers[0]);
  const avoids = text.match(/(?:||)\s*([^!?.]+)/);
  if (avoids?.[1])
    add("UserPreference", "User", "avoids", avoids[1], 0.88, "L1", avoids[0]);
  const needs = text.match(/(?:||)([^!?.]+)/);
  if (needs?.[1])
    add("Fact", "User", "requires", needs[1], 0.7, "L1", needs[0]);
  const blocks = text.match(
    /(?:||)([^!?.]+)(?:|||)/
  );
  if (blocks?.[1])
    add(
      "Insight",
      "User",
      "is_blocking",
      `${blocks[1]}\u95EE\u9898`,
      0.75,
      "L2",
      blocks[0]
    );
  const anxiety = text.match(
    /(?:||||)([^!?.]*)/
  );
  if (anxiety)
    add(
      "Insight",
      "User",
      "emotion_signal",
      `\u8FDB\u5EA6\u538B\u529B ${anxiety[0]}`.trim(),
      0.72,
      "L2",
      anxiety[0]
    );
  const project = text.match(
    /(?:||repo|)\s*[:]?\s*([^!?.]+)/i
  );
  if (project?.[1])
    add("Fact", "User", "project", project[1], 0.68, "L1", project[0]);
  if (triplets.length === 0 && text.length <= 120) {
    add(
      "Fact",
      log2.sender === "assistant" ? "Miya" : "User",
      "stated",
      text,
      0.55,
      "L2",
      text
    );
  }
  return triplets;
}
function validateTripletQuotes(triplet, logsByID) {
  for (const quote of triplet.quotes) {
    const source = logsByID.get(quote.logID);
    if (!source) return false;
    if (quote.charStart < 0 || quote.charEnd <= quote.charStart) return false;
    const picked = source.text.slice(quote.charStart, quote.charEnd);
    if (normalizeText4(picked) !== normalizeText4(quote.exactText)) return false;
  }
  return true;
}
function appendShortTermMemoryLog(projectDir, input) {
  const text = normalizeText4(input.text);
  if (!text) return null;
  const at = input.at ?? nowIso19();
  const messageHash = input.messageID || hashMessage({ text, sender: input.sender, at });
  ensureDir16(projectDir);
  const row = {
    id: `st_${randomUUID15()}`,
    sessionID: input.sessionID?.trim() || "main",
    sender: input.sender,
    text,
    at,
    messageHash
  };
  const saved = appendRawMemoryLog(projectDir, row);
  if (!saved) return null;
  appendMemoryEvent(projectDir, {
    eventID: `evt_${randomUUID15()}`,
    eventType: "raw_log_appended",
    entityType: "raw_log",
    entityID: saved.id,
    payload: {
      sessionID: saved.sessionID,
      sender: saved.sender,
      at: saved.at
    }
  });
  writeReflectState(projectDir, { lastLogAt: at });
  return saved;
}
function getMemoryReflectStatus(projectDir) {
  const pendingLogs = listRawMemoryLogs(projectDir, {
    pendingOnly: true,
    limit: 5e3
  }).length;
  const state2 = readReflectState(projectDir);
  return {
    pendingLogs,
    lastLogAt: state2.lastLogAt,
    lastReflectAt: state2.lastReflectAt
  };
}
function reflectCompanionMemory(projectDir, input) {
  ensureDir16(projectDir);
  const state2 = readReflectState(projectDir);
  const now = nowIso19();
  if (input?.idempotencyKey && state2.lastReflectIdempotencyKey === input.idempotencyKey) {
    if (state2.lastReflectResult) return state2.lastReflectResult;
  }
  const cooldownMinutes = Math.max(0, input?.cooldownMinutes ?? 0);
  if (cooldownMinutes > 0 && state2.lastReflectAt) {
    const deltaMs = Date.now() - Date.parse(state2.lastReflectAt);
    if (Number.isFinite(deltaMs) && deltaMs < cooldownMinutes * 60 * 1e3) {
      const blocked = {
        jobID: `reflect_${randomUUID15()}`,
        processedLogs: 0,
        generatedTriplets: 0,
        generatedFacts: 0,
        generatedInsights: 0,
        generatedPreferences: 0,
        createdMemories: [],
        archivedLogs: 0,
        auditID: `audit_${randomUUID15()}`
      };
      writeReflectState(projectDir, {
        lastReflectReason: `cooldown_blocked_${cooldownMinutes}m`
      });
      return blocked;
    }
  }
  const pending = listRawMemoryLogs(projectDir, {
    pendingOnly: true,
    limit: 2e3
  });
  const minLogs = Math.max(1, input?.minLogs ?? 1);
  if (!input?.force && pending.length < minLogs) {
    return {
      jobID: `reflect_${randomUUID15()}`,
      processedLogs: 0,
      generatedTriplets: 0,
      generatedFacts: 0,
      generatedInsights: 0,
      generatedPreferences: 0,
      createdMemories: [],
      archivedLogs: 0,
      auditID: `audit_${randomUUID15()}`
    };
  }
  const maxLogs = Math.max(1, input?.maxLogs ?? 50);
  const picked = pending.slice(0, maxLogs);
  const logsByID = new Map(picked.map((row) => [row.id, row]));
  const extracted = picked.flatMap((row) => extractTriplets(row));
  const triplets = extracted.filter(
    (item) => validateTripletQuotes(item, logsByID)
  );
  const generatedFacts = triplets.filter((item) => item.kind === "Fact").length;
  const generatedInsights = triplets.filter(
    (item) => item.kind === "Insight"
  ).length;
  const generatedPreferences = triplets.filter(
    (item) => item.kind === "UserPreference"
  ).length;
  const processedAt = nowIso19();
  const jobID = `reflect_${randomUUID15()}`;
  const auditID = `audit_${randomUUID15()}`;
  const constructed = constructReflectBatch(projectDir, {
    jobID,
    auditID,
    processedAt,
    policyHash: input?.policyHash,
    pickedLogs: picked,
    triplets,
    evidenceMeta: {
      schema_version: "EvidencePackV5",
      generated_at: processedAt,
      policy_hash: input?.policyHash ?? null,
      tool: "miya.memory.reflect",
      job_id: jobID,
      source: "memory_reflect"
    },
    evidencePayload: {
      logs: picked,
      extracted_triplets: triplets,
      dropped_triplets: extracted.length - triplets.length
    },
    reflectStats: {
      generatedFacts,
      generatedInsights,
      generatedPreferences
    }
  });
  const createdMemories = constructed.createdMemories;
  const result = {
    jobID,
    processedLogs: picked.length,
    generatedTriplets: triplets.length,
    generatedFacts,
    generatedInsights,
    generatedPreferences,
    createdMemories,
    archivedLogs: constructed.processedLogs,
    auditID
  };
  createSkillDraftsFromReflect(projectDir, {
    createdMemories
  });
  fs32.appendFileSync(
    reflectJobPath(projectDir),
    `${JSON.stringify({ ...result, at: processedAt })}
`,
    "utf-8"
  );
  writeReflectState(projectDir, {
    lastReflectAt: now,
    lastReflectIdempotencyKey: input?.idempotencyKey,
    lastReflectResult: result,
    lastReflectReason: "ok"
  });
  return result;
}
function maybeAutoReflectCompanionMemory(projectDir, input) {
  const idleMinutes = Math.max(1, input?.idleMinutes ?? 5);
  const minPendingLogs = Math.max(1, input?.minPendingLogs ?? 1);
  const cooldownMinutes = Math.max(1, input?.cooldownMinutes ?? 3);
  const status = getMemoryReflectStatus(projectDir);
  if (status.pendingLogs < minPendingLogs) return null;
  if (!status.lastLogAt) return null;
  const nowMs = Date.now();
  const idleMs = nowMs - Date.parse(status.lastLogAt);
  if (!Number.isFinite(idleMs) || idleMs < idleMinutes * 60 * 1e3) return null;
  if (status.lastReflectAt) {
    const cooldownMs = nowMs - Date.parse(status.lastReflectAt);
    if (Number.isFinite(cooldownMs) && cooldownMs < cooldownMinutes * 60 * 1e3)
      return null;
  }
  return reflectCompanionMemory(projectDir, {
    force: true,
    minLogs: minPendingLogs,
    maxLogs: input?.maxLogs ?? 50
  });
}
function maybeReflectOnSessionEnd(projectDir, input) {
  const minPendingLogs = Math.max(1, input?.minPendingLogs ?? 50);
  const status = getMemoryReflectStatus(projectDir);
  if (status.pendingLogs < minPendingLogs) return null;
  return reflectCompanionMemory(projectDir, {
    force: true,
    minLogs: minPendingLogs,
    maxLogs: input?.maxLogs ?? 100
  });
}

// src/companion/wizard.ts
import { createHash as createHash12, randomUUID as randomUUID16 } from "node:crypto";
import * as fs33 from "node:fs";
import * as path33 from "node:path";
function nowIso20() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function normalizeSessionId(sessionId) {
  const normalized = sessionId.trim().replace(/[^a-zA-Z0-9_-]+/g, "_");
  return normalized || "main";
}
function profilesRoot(projectDir) {
  return path33.join(getMiyaRuntimeDir(projectDir), "profiles", "companion");
}
function sessionRoot(projectDir, sessionId) {
  return path33.join(profilesRoot(projectDir), "sessions", normalizeSessionId(sessionId));
}
function currentProfileDir(projectDir, sessionId) {
  return path33.join(sessionRoot(projectDir, sessionId), "current");
}
function wizardFilePath(projectDir, sessionId) {
  return path33.join(currentProfileDir(projectDir, sessionId), "wizard-state.json");
}
function metadataPath(projectDir, sessionId) {
  return path33.join(currentProfileDir(projectDir, sessionId), "metadata.json");
}
function ensureProfileLayout(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  fs33.mkdirSync(path33.join(current, "photos"), { recursive: true });
  fs33.mkdirSync(path33.join(current, "embeddings"), { recursive: true });
  fs33.mkdirSync(path33.join(current, "lora"), { recursive: true });
  fs33.mkdirSync(path33.join(current, "voice"), { recursive: true });
  fs33.mkdirSync(path33.join(sessionRoot(projectDir, sessionId), "history"), { recursive: true });
}
function safeReadJson2(filePath14) {
  if (!fs33.existsSync(filePath14)) return null;
  try {
    return JSON.parse(fs33.readFileSync(filePath14, "utf-8"));
  } catch {
    return null;
  }
}
function safeWriteJson2(filePath14, value) {
  fs33.mkdirSync(path33.dirname(filePath14), { recursive: true });
  fs33.writeFileSync(filePath14, `${JSON.stringify(value, null, 2)}
`, "utf-8");
}
function checksumFile(filePath14) {
  try {
    const data = fs33.readFileSync(filePath14);
    return `sha256:${createHash12("sha256").update(data).digest("hex")}`;
  } catch {
    return "sha256:unknown";
  }
}
function extensionForMime(mimeType, fallback = ".bin") {
  if (mimeType.includes("png")) return ".png";
  if (mimeType.includes("jpeg") || mimeType.includes("jpg")) return ".jpg";
  if (mimeType.includes("webp")) return ".webp";
  if (mimeType.includes("wav")) return ".wav";
  if (mimeType.includes("mpeg") || mimeType.includes("mp3")) return ".mp3";
  if (mimeType.includes("ogg")) return ".ogg";
  return fallback;
}
function defaultMetadata(sessionId) {
  const now = nowIso20();
  return {
    profileId: `companion-${now.replace(/[:.]/g, "-")}`,
    createdAt: now,
    updatedAt: now,
    version: "v1",
    assets: {
      photos: {
        count: 0,
        paths: [],
        checksums: []
      },
      voice: {
        hasSample: false,
        duration: 0,
        modelType: "gpt_sovits_v2"
      },
      persona: {
        sourceText: "",
        generatedPrompt: ""
      }
    },
    trainingStatus: {
      image: "pending",
      voice: "pending"
    },
    sessionBinding: {
      opencodeSessionId: sessionId,
      daemonSessionId: `daemon-${sessionId}`
    }
  };
}
function defaultState5(sessionId) {
  const now = nowIso20();
  return {
    sessionId: `wizard:companion:${normalizeSessionId(sessionId)}`,
    boundSessionId: sessionId || "main",
    state: "idle",
    startedAt: now,
    updatedAt: now,
    assets: {
      photos: [],
      voiceSample: "",
      personalityText: ""
    },
    trainingJobs: {},
    jobs: []
  };
}
function writeMetadata(projectDir, sessionId, metadata) {
  const next = { ...metadata, updatedAt: nowIso20() };
  safeWriteJson2(metadataPath(projectDir, sessionId), next);
  return next;
}
function readMetadata(projectDir, sessionId) {
  ensureProfileLayout(projectDir, sessionId);
  const existing = safeReadJson2(metadataPath(projectDir, sessionId));
  if (existing) return existing;
  const created = defaultMetadata(sessionId);
  writeMetadata(projectDir, sessionId, created);
  return created;
}
function writeState2(projectDir, sessionId, state2) {
  ensureProfileLayout(projectDir, sessionId);
  const next = { ...state2, updatedAt: nowIso20() };
  safeWriteJson2(wizardFilePath(projectDir, sessionId), next);
  return next;
}
function moveCurrentToHistory(projectDir, sessionId) {
  const current = currentProfileDir(projectDir, sessionId);
  if (!fs33.existsSync(current)) return;
  const historyDir = path33.join(
    sessionRoot(projectDir, sessionId),
    "history",
    (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-")
  );
  fs33.mkdirSync(path33.dirname(historyDir), { recursive: true });
  fs33.cpSync(current, historyDir, { recursive: true });
  fs33.rmSync(current, { recursive: true, force: true });
}
function listSessionDirs(projectDir) {
  const root = path33.join(profilesRoot(projectDir), "sessions");
  if (!fs33.existsSync(root)) return [];
  return fs33.readdirSync(root, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => entry2.name);
}
function sessionHasWizardFile(projectDir, sessionDirName) {
  const file3 = path33.join(
    profilesRoot(projectDir),
    "sessions",
    sessionDirName,
    "current",
    "wizard-state.json"
  );
  return fs33.existsSync(file3);
}
function stateHasAssets(state2) {
  return state2.assets.photos.length > 0 || Boolean(state2.assets.voiceSample) || Boolean(state2.assets.personalityText);
}
function findSessionByJobId(projectDir, jobID) {
  for (const sid2 of listCompanionWizardSessions(projectDir)) {
    const state2 = readCompanionWizardState(projectDir, sid2);
    if (state2.jobs.some((job) => job.id === jobID)) return sid2;
  }
  return null;
}
function resolveSessionForWrite(projectDir, requestedSessionId) {
  if (requestedSessionId?.trim()) {
    return normalizeSessionId(requestedSessionId);
  }
  const sessions = listCompanionWizardSessions(projectDir);
  if (sessions.length === 0) return "main";
  const active = sessions.filter((sid2) => {
    const state2 = readCompanionWizardState(projectDir, sid2);
    return state2.state !== "idle" || stateHasAssets(state2) || state2.jobs.length > 0;
  });
  if (active.length === 1) return active[0];
  if (active.includes("main")) return "main";
  return active[0] ?? sessions[0] ?? "main";
}
function listCompanionWizardSessions(projectDir) {
  return listSessionDirs(projectDir).filter((name) => sessionHasWizardFile(projectDir, name)).map((name) => name || "main");
}
function readCompanionWizardState(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  const existing = safeReadJson2(
    wizardFilePath(projectDir, effectiveSessionId)
  );
  if (existing) return existing;
  const created = defaultState5(effectiveSessionId);
  return writeState2(projectDir, effectiveSessionId, created);
}
function isCompanionWizardEmpty(projectDir, sessionId = "main") {
  const state2 = readCompanionWizardState(projectDir, sessionId);
  if (stateHasAssets(state2)) return false;
  if (state2.jobs.length > 0) return false;
  return state2.state === "idle";
}
function startCompanionWizard(projectDir, input) {
  const sessionId = normalizeSessionId(input?.sessionId ?? "main");
  ensureProfileLayout(projectDir, sessionId);
  if (input?.forceReset) {
    moveCurrentToHistory(projectDir, sessionId);
    ensureProfileLayout(projectDir, sessionId);
  }
  const existing = readCompanionWizardState(projectDir, sessionId);
  if (!input?.forceReset && (stateHasAssets(existing) || existing.state !== "idle")) {
    return existing;
  }
  const state2 = writeState2(projectDir, sessionId, {
    ...defaultState5(sessionId),
    state: "awaiting_photos",
    startedAt: nowIso20()
  });
  writeMetadata(projectDir, sessionId, defaultMetadata(sessionId));
  return state2;
}
function resetCompanionWizard(projectDir, sessionId = "main") {
  const effectiveSessionId = normalizeSessionId(sessionId);
  moveCurrentToHistory(projectDir, effectiveSessionId);
  ensureProfileLayout(projectDir, effectiveSessionId);
  writeMetadata(projectDir, effectiveSessionId, defaultMetadata(effectiveSessionId));
  return writeState2(projectDir, effectiveSessionId, {
    ...defaultState5(effectiveSessionId),
    state: "idle"
  });
}
function copyMediaToProfile(projectDir, mediaIDs, targetDir) {
  const output = [];
  fs33.mkdirSync(targetDir, { recursive: true });
  for (const mediaID of mediaIDs) {
    const item = getMediaItem(projectDir, mediaID);
    if (!item?.localPath || !fs33.existsSync(item.localPath)) {
      throw new Error(`media_asset_not_found:${mediaID}`);
    }
    const ext = path33.extname(item.fileName) || extensionForMime(item.mimeType);
    const fileName = `${String(output.length + 1).padStart(2, "0")}_original${ext}`;
    const filePath14 = path33.join(targetDir, fileName);
    fs33.copyFileSync(item.localPath, filePath14);
    output.push(filePath14);
  }
  return output;
}
function enqueueJob(state2, input) {
  const job = {
    id: `wjob_${randomUUID16()}`,
    type: input.type,
    status: "queued",
    progress: 0,
    estimatedTime: input.estimatedTime,
    fallbackStrategy: input.fallbackStrategy,
    createdAt: nowIso20(),
    updatedAt: nowIso20(),
    attempts: 0
  };
  return {
    ...state2,
    jobs: [...state2.jobs, job],
    trainingJobs: {
      ...state2.trainingJobs,
      imageJobId: input.type === "training.image" ? job.id : state2.trainingJobs.imageJobId,
      voiceJobId: input.type === "training.voice" ? job.id : state2.trainingJobs.voiceJobId
    }
  };
}
function submitWizardPhotos(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_photos") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  if (input.mediaIDs.length < 1 || input.mediaIDs.length > 5) {
    throw new Error("wizard_photo_count_invalid:must_be_1_to_5");
  }
  const photosDir = path33.join(currentProfileDir(projectDir, sessionId), "photos");
  fs33.rmSync(photosDir, { recursive: true, force: true });
  const copied = copyMediaToProfile(projectDir, input.mediaIDs, photosDir);
  if (copied.length < 1 || copied.length > 5 || copied.length !== input.mediaIDs.length) {
    throw new Error("wizard_photo_copy_invalid:must_be_1_to_5");
  }
  const withJob = enqueueJob(
    {
      ...current,
      state: "training_image",
      assets: {
        ...current.assets,
        photos: copied
      }
    },
    {
      type: "training.image",
      estimatedTime: "\u7EA65-10\u5206\u949F",
      fallbackStrategy: "\u82E5\u663E\u5B58\u4E0D\u8DB3\u5C06\u81EA\u52A8\u964D\u7EA7\u5230embedding\u65B9\u6848"
    }
  );
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      photos: {
        count: copied.length,
        paths: copied.map((item) => path33.relative(currentProfileDir(projectDir, sessionId), item)),
        checksums: copied.map((item) => checksumFile(item))
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      image: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.imageJobId);
  if (!job) throw new Error("image_job_not_created");
  return { state: written, job };
}
function submitWizardVoice(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_voice") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const voiceDir = path33.join(currentProfileDir(projectDir, sessionId), "voice");
  fs33.mkdirSync(voiceDir, { recursive: true });
  const copied = copyMediaToProfile(projectDir, [input.mediaID], voiceDir);
  if (copied.length !== 1) throw new Error("voice_asset_not_found");
  const voicePath = path33.join(voiceDir, "original_sample.wav");
  fs33.copyFileSync(copied[0], voicePath);
  const withJob = enqueueJob(
    {
      ...current,
      state: "training_voice",
      assets: {
        ...current.assets,
        voiceSample: voicePath
      }
    },
    {
      type: "training.voice",
      estimatedTime: "\u7EA63-8\u5206\u949F",
      fallbackStrategy: "\u82E5\u663E\u5B58\u4E0D\u8DB3\u5C06\u81EA\u52A8\u964D\u7EA7\u5230embedding\u65B9\u6848"
    }
  );
  const written = writeState2(projectDir, sessionId, withJob);
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      voice: {
        hasSample: true,
        duration: 0,
        modelType: "gpt_sovits_v2"
      }
    },
    trainingStatus: {
      ...metadata.trainingStatus,
      voice: "pending"
    }
  });
  const job = written.jobs.find((item) => item.id === written.trainingJobs.voiceJobId);
  if (!job) throw new Error("voice_job_not_created");
  return { state: written, job };
}
function submitWizardPersonality(projectDir, input) {
  const sessionId = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sessionId);
  if (current.state !== "awaiting_personality") {
    throw new Error(`wizard_state_invalid:${current.state}`);
  }
  const text = input.personalityText.trim();
  if (!text) throw new Error("invalid_personality_text");
  const personaPath = path33.join(currentProfileDir(projectDir, sessionId), "persona.json");
  const persona = {
    sourceText: text,
    generatedPrompt: `system: ${text}`,
    updatedAt: nowIso20()
  };
  safeWriteJson2(personaPath, persona);
  const next = writeState2(projectDir, sessionId, {
    ...current,
    state: "completed",
    assets: {
      ...current.assets,
      personalityText: text
    }
  });
  const metadata = readMetadata(projectDir, sessionId);
  writeMetadata(projectDir, sessionId, {
    ...metadata,
    assets: {
      ...metadata.assets,
      persona: {
        sourceText: text,
        generatedPrompt: persona.generatedPrompt
      }
    }
  });
  return next;
}
function pickQueuedTrainingJob(projectDir, sessionId) {
  const targetSessions = sessionId ? [normalizeSessionId(sessionId)] : listCompanionWizardSessions(projectDir);
  for (const sid2 of targetSessions) {
    const state2 = readCompanionWizardState(projectDir, sid2);
    if (state2.jobs.some((item) => item.status === "training")) continue;
    const queued = state2.jobs.find((item) => item.status === "queued");
    if (queued) return { sessionId: sid2, job: queued };
  }
  return null;
}
function markTrainingJobRunning(projectDir, jobID, sessionId = "main") {
  const sid2 = normalizeSessionId(sessionId);
  const resolvedSession = sessionId === "main" ? findSessionByJobId(projectDir, jobID) ?? sid2 : sid2;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    jobs: current.jobs.map(
      (job2) => job2.id === jobID ? {
        ...job2,
        status: "training",
        progress: Math.max(5, job2.progress),
        attempts: job2.attempts + 1,
        updatedAt: nowIso20()
      } : job2
    )
  });
  const job = updated.jobs.find((item) => item.id === jobID);
  if (!job) return updated;
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, image: "training" }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: { ...metadata.trainingStatus, voice: "training" }
    });
  }
  return updated;
}
function requeueTrainingJob(projectDir, input) {
  const sid2 = resolveSessionForWrite(projectDir, input.sessionId);
  const current = readCompanionWizardState(projectDir, sid2);
  return writeState2(projectDir, sid2, {
    ...current,
    jobs: current.jobs.map(
      (job) => job.id === input.jobID ? {
        ...job,
        status: "queued",
        progress: Math.max(10, job.progress),
        checkpointPath: input.checkpointPath,
        message: input.message,
        updatedAt: nowIso20()
      } : job
    )
  });
}
function markTrainingJobFinished(projectDir, input) {
  const sid2 = normalizeSessionId(input.sessionId ?? "main");
  const resolvedSession = input.sessionId == null ? findSessionByJobId(projectDir, input.jobID) ?? sid2 : sid2;
  const current = readCompanionWizardState(projectDir, resolvedSession);
  const job = current.jobs.find((item) => item.id === input.jobID);
  if (!job) return current;
  const nextState = job.type === "training.image" ? input.status === "failed" || input.status === "canceled" ? "training_image" : "awaiting_voice" : input.status === "failed" || input.status === "canceled" ? "training_voice" : "awaiting_personality";
  const updated = writeState2(projectDir, resolvedSession, {
    ...current,
    state: nextState,
    jobs: current.jobs.map(
      (item) => item.id === input.jobID ? {
        ...item,
        status: input.status,
        message: input.message,
        progress: input.status === "failed" ? item.progress : 100,
        currentTier: input.tier,
        checkpointPath: input.checkpointPath ?? item.checkpointPath,
        updatedAt: nowIso20()
      } : item
    )
  });
  const metadata = readMetadata(projectDir, resolvedSession);
  if (job.type === "training.image") {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        image: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  } else {
    writeMetadata(projectDir, resolvedSession, {
      ...metadata,
      trainingStatus: {
        ...metadata.trainingStatus,
        voice: input.status === "completed" ? "completed" : input.status === "degraded" ? "degraded" : input.status === "canceled" ? "canceled" : "failed"
      }
    });
  }
  return updated;
}
function cancelCompanionWizardTraining(projectDir, sessionId = "main") {
  const sid2 = resolveSessionForWrite(projectDir, sessionId);
  const current = readCompanionWizardState(projectDir, sid2);
  let hasCanceled = false;
  const nextJobs = current.jobs.map((job) => {
    if (job.status !== "queued" && job.status !== "training") return job;
    hasCanceled = true;
    return {
      ...job,
      status: "canceled",
      message: "\u8BAD\u7EC3\u5DF2\u53D6\u6D88/\u53EF\u91CD\u8BD5",
      updatedAt: nowIso20()
    };
  });
  if (!hasCanceled) return current;
  const nextState = current.assets.voiceSample ? "awaiting_personality" : current.assets.photos.length > 0 ? "awaiting_voice" : "awaiting_photos";
  return writeState2(projectDir, sid2, {
    ...current,
    state: nextState,
    jobs: nextJobs
  });
}
function getCompanionProfileCurrentDir(projectDir, sessionId = "main") {
  const sid2 = normalizeSessionId(sessionId);
  ensureProfileLayout(projectDir, sid2);
  return currentProfileDir(projectDir, sid2);
}
function getWizardJobById(projectDir, jobID) {
  for (const sid2 of listCompanionWizardSessions(projectDir)) {
    const state2 = readCompanionWizardState(projectDir, sid2);
    const match = state2.jobs.find((job) => job.id === jobID);
    if (match) return { ...match, sessionId: sid2 };
  }
  return null;
}
function wizardChecklist(state2) {
  return [
    state2.assets.photos.length > 0 ? "visual:done" : "visual:pending",
    state2.assets.voiceSample ? "voice:done" : "voice:pending",
    state2.assets.personalityText ? "persona:done" : "persona:pending"
  ];
}

// src/multimodal/image.ts
import * as fs34 from "node:fs";
import * as path34 from "node:path";
var DEFAULT_IMAGE_MODEL = "local:flux.1-schnell";
var DEFAULT_IMAGE_SIZE = "1024x1024";
var BLANK_PNG_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO6sYz0AAAAASUVORK5CYII=";
function sanitizePrompt(prompt) {
  return prompt.trim().slice(0, 2e3);
}
function toBase64FromFile(filePath14) {
  try {
    if (!fs34.existsSync(filePath14)) return null;
    return fs34.readFileSync(filePath14).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:")) return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode(projectDir) {
  if (process.env.MIYA_MULTIMODAL_TEST_MODE === "1") return true;
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime;
  const multimodal = runtime?.multimodal;
  return multimodal?.test_mode === true;
}
async function generateImage(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const prompt = sanitizePrompt(input.prompt);
  if (!prompt) throw new Error("invalid_prompt");
  const model = input.model?.trim() || DEFAULT_IMAGE_MODEL;
  const size = input.size?.trim() || DEFAULT_IMAGE_SIZE;
  const referenceMediaIDs = (input.referenceMediaIDs ?? []).filter(Boolean);
  const references = referenceMediaIDs.map((id) => getMediaItem(projectDir, id)).filter((item) => Boolean(item)).map((item) => ({
    id: item.id,
    fileName: item.fileName,
    mimeType: item.mimeType,
    localPath: item.localPath
  }));
  const outputDir = getMiyaImageTempDir(projectDir);
  const outputPath = path34.join(outputDir, `flux-${Date.now()}.png`);
  const profileDir = path34.join(
    getMiyaRuntimeDir(projectDir),
    "profiles",
    "companion",
    "current"
  );
  let inference;
  if (useMultimodalTestMode(projectDir)) {
    inference = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      inference = await daemon.runFluxImageGenerate({
        prompt,
        outputPath,
        profileDir,
        references: references.map((item) => item.localPath).filter((item) => Boolean(item)),
        size
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number") pending = String(plan.pending);
        } catch {
        }
        throw new Error(
          `model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`
        );
      }
      if (!isRuntimeNotReadyError(error92)) throw error92;
      inference = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const payloadBase64 = toBase64FromFile(inference.outputPath) ?? BLANK_PNG_BASE64;
  const media = ingestMedia(projectDir, {
    source: "multimodal.image.generate",
    kind: "image",
    mimeType: "image/png",
    fileName: `generated-${Date.now()}.png`,
    contentBase64: payloadBase64,
    sizeBytes: Math.floor(payloadBase64.length * 3 / 4),
    metadata: {
      status: inference.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      prompt,
      model,
      size,
      tier: inference.tier,
      degraded: inference.degraded,
      engineMessage: inference.message,
      runtimeError: inference.message.startsWith("python_runtime_not_ready:") ? inference.message : void 0,
      references,
      createdBy: "miya_generate_image"
    }
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "image",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `generated:${model}`
    });
  }
  return {
    media,
    model,
    size,
    prompt
  };
}

// src/multimodal/vision-regression.ts
import * as path35 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
var FIXTURE_FILE = path35.join(
  path35.dirname(fileURLToPath2(import.meta.url)),
  "fixtures",
  "desktop-outbound-ocr-regression.json"
);

// src/multimodal/voice.ts
import * as fs35 from "node:fs";
import * as path36 from "node:path";
var DEFAULT_VOICE = "default";
var DEFAULT_TTS_MODEL = "local:gpt-sovits-v2pro";
function resolveVoiceInputText(projectDir, input) {
  const explicit = input.text?.trim();
  if (explicit) return explicit;
  if (!input.mediaID) return "";
  const media = getMediaItem(projectDir, input.mediaID);
  if (!media) return "";
  const transcript = typeof media.metadata?.transcript === "string" ? String(media.metadata.transcript) : "";
  if (transcript.trim()) return transcript.trim();
  return `[media:${media.id}]`;
}
function ingestVoiceInput(projectDir, input) {
  const source = input.source ?? (input.mediaID ? "media" : "manual");
  const text = resolveVoiceInputText(projectDir, input);
  if (!text) throw new Error("invalid_voice_input");
  appendVoiceHistory(projectDir, {
    text,
    source,
    language: input.language,
    mediaID: input.mediaID
  });
  return {
    text,
    source,
    mediaID: input.mediaID
  };
}
function normalizeFormat(format) {
  if (format === "mp3" || format === "ogg") return format;
  return "wav";
}
function buildSilentWavBase64(durationMs) {
  const sampleRate = 16e3;
  const channels = 1;
  const bitsPerSample = 16;
  const bytesPerSample = bitsPerSample / 8;
  const frameCount = Math.max(1, Math.floor(sampleRate * durationMs / 1e3));
  const dataSize = frameCount * channels * bytesPerSample;
  const buffer = Buffer.alloc(44 + dataSize);
  buffer.write("RIFF", 0);
  buffer.writeUInt32LE(36 + dataSize, 4);
  buffer.write("WAVE", 8);
  buffer.write("fmt ", 12);
  buffer.writeUInt32LE(16, 16);
  buffer.writeUInt16LE(1, 20);
  buffer.writeUInt16LE(channels, 22);
  buffer.writeUInt32LE(sampleRate, 24);
  buffer.writeUInt32LE(sampleRate * channels * bytesPerSample, 28);
  buffer.writeUInt16LE(channels * bytesPerSample, 32);
  buffer.writeUInt16LE(bitsPerSample, 34);
  buffer.write("data", 36);
  buffer.writeUInt32LE(dataSize, 40);
  return buffer.toString("base64");
}
function toBase64FromFile2(filePath14) {
  try {
    if (!fs35.existsSync(filePath14)) return null;
    return fs35.readFileSync(filePath14).toString("base64");
  } catch {
    return null;
  }
}
function isRuntimeNotReadyError2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  return message.startsWith("python_runtime_not_ready:");
}
function parseModelUpdateTarget2(error92) {
  const message = error92 instanceof Error ? error92.message : String(error92 ?? "");
  if (!message.startsWith("model_update_required:")) return null;
  const [, target] = message.split(":");
  const normalized = String(target ?? "").trim();
  return normalized || null;
}
function useMultimodalTestMode2(projectDir) {
  if (process.env.MIYA_MULTIMODAL_TEST_MODE === "1") return true;
  const config3 = readConfig(projectDir);
  const runtime = config3.runtime;
  const multimodal = runtime?.multimodal;
  return multimodal?.test_mode === true;
}
async function synthesizeVoiceOutput(projectDir, input) {
  const daemon = getMiyaClient(projectDir);
  const text = input.text.trim();
  if (!text) throw new Error("invalid_tts_text");
  const voice = input.voice?.trim() || DEFAULT_VOICE;
  const model = input.model?.trim() || DEFAULT_TTS_MODEL;
  const format = normalizeFormat(input.format);
  const mimeType = format === "mp3" ? "audio/mpeg" : format === "ogg" ? "audio/ogg" : "audio/wav";
  const estDurationMs = Math.max(600, Math.min(7e3, text.length * 55));
  const outputDir = getMiyaVoiceTempDir(projectDir);
  const outputPath = path36.join(outputDir, `tts-${Date.now()}.${format}`);
  const profileDir = path36.join(
    getMiyaRuntimeDir(projectDir),
    "profiles",
    "companion",
    "current"
  );
  let tts;
  if (useMultimodalTestMode2(projectDir)) {
    tts = {
      outputPath,
      tier: "reference",
      degraded: true,
      message: "python_runtime_not_ready:test_mode"
    };
  } else {
    try {
      tts = await daemon.runSovitsTts({
        text,
        outputPath,
        profileDir,
        voice,
        format
      });
    } catch (error92) {
      const updateTarget = parseModelUpdateTarget2(error92);
      if (updateTarget) {
        let pending = "unknown";
        try {
          const plan = await daemon.getModelUpdatePlan(updateTarget);
          if (typeof plan?.pending === "number") pending = String(plan.pending);
        } catch {
        }
        throw new Error(
          `model_metadata_mismatch_blocked:${updateTarget}:run daemon.model.update.plan + daemon.model.update.apply:pending=${pending}`
        );
      }
      if (!isRuntimeNotReadyError2(error92)) throw error92;
      tts = {
        outputPath,
        tier: "reference",
        degraded: true,
        message: error92 instanceof Error ? error92.message : String(error92)
      };
    }
  }
  const wavBase64 = toBase64FromFile2(tts.outputPath) ?? buildSilentWavBase64(estDurationMs);
  const media = ingestMedia(projectDir, {
    source: "multimodal.voice.output",
    kind: "audio",
    mimeType,
    fileName: `tts-${Date.now()}.${format}`,
    contentBase64: wavBase64,
    sizeBytes: Math.floor(wavBase64.length * 3 / 4),
    metadata: {
      status: tts.message.startsWith("python_runtime_not_ready:") ? "degraded_runtime_not_ready" : "generated_local",
      text,
      voice,
      model,
      format,
      tier: tts.tier,
      degraded: tts.degraded,
      engineMessage: tts.message,
      payloadCodec: "pcm_s16le",
      estimatedDurationMs: estDurationMs,
      runtimeError: tts.message.startsWith("python_runtime_not_ready:") ? tts.message : void 0,
      createdBy: "miya_voice_output"
    }
  });
  appendVoiceHistory(projectDir, {
    text,
    source: "talk",
    mediaID: media.id
  });
  if (input.registerAsCompanionAsset) {
    addCompanionAsset(projectDir, {
      type: "audio",
      pathOrUrl: media.localPath ?? media.fileName,
      label: `voice:${voice}`
    });
  }
  return {
    media,
    voice,
    model,
    format
  };
}

// src/multimodal/intent.ts
function extractFriend(text) {
  const bracket = text.match(/\s*\[([^\]]+)\]/);
  if (bracket?.[1]) return bracket[1].trim();
  const plain = text.match(/\s*([^\s!?]+)/);
  if (plain?.[1]) return plain[1].trim();
  return "";
}
function detectMultimodalIntent(text) {
  const normalized = text.trim();
  if (!normalized) return { type: "unknown" };
  if (/(|||)/.test(normalized)) {
    return {
      type: "selfie",
      prompt: "a natural selfie portrait, indoor soft light, realistic phone camera shot"
    };
  }
  if (/(||)/.test(normalized)) {
    const friend = extractFriend(normalized);
    return {
      type: "voice_to_friend",
      text: normalized,
      friend
    };
  }
  return { type: "unknown" };
}

// src/resource-scheduler/scheduler.ts
import { randomUUID as randomUUID17 } from "node:crypto";

// src/resource-scheduler/store.ts
import * as fs36 from "node:fs";
import * as path37 from "node:path";
function schedulerDir(projectDir) {
  return path37.join(getMiyaRuntimeDir(projectDir), "resource-scheduler");
}
function snapshotPath(projectDir) {
  return path37.join(schedulerDir(projectDir), "state.json");
}
function eventsPath(projectDir) {
  return path37.join(schedulerDir(projectDir), "events.jsonl");
}
function ensureDir17(projectDir) {
  fs36.mkdirSync(schedulerDir(projectDir), { recursive: true });
}
function writeSchedulerSnapshot(projectDir, snapshot) {
  ensureDir17(projectDir);
  fs36.writeFileSync(
    snapshotPath(projectDir),
    `${JSON.stringify(snapshot, null, 2)}
`,
    "utf-8"
  );
}
function appendSchedulerEvent(projectDir, event) {
  ensureDir17(projectDir);
  fs36.appendFileSync(eventsPath(projectDir), `${JSON.stringify(event)}
`, "utf-8");
}

// src/resource-scheduler/vram.ts
function clampNonNegative(value) {
  if (!Number.isFinite(value) || value <= 0) return 0;
  return Math.floor(value);
}
function calculateVramBudget(input) {
  const availableMB = Math.max(
    0,
    clampNonNegative(input.snapshot.totalVramMB) - clampNonNegative(input.snapshot.safetyMarginMB) - clampNonNegative(input.snapshot.usedVramMB)
  );
  const loaded = new Map(
    input.snapshot.loadedModels.map((model) => [model.modelID, clampNonNegative(model.vramMB)])
  );
  const keepLoaded = /* @__PURE__ */ new Set();
  let modelsNeedLoadMB = 0;
  for (const model of input.models) {
    if (!model.required) continue;
    const need = clampNonNegative(model.vramMB);
    const loadedMB = loaded.get(model.modelID) ?? 0;
    if (loadedMB >= need) {
      keepLoaded.add(model.modelID);
      continue;
    }
    modelsNeedLoadMB += need;
  }
  const requiredMB = clampNonNegative(input.task.taskVramMB) + modelsNeedLoadMB;
  const overflowMB = Math.max(0, requiredMB - availableMB);
  const fit = overflowMB <= 0;
  const suggestedTaskVramMB = fit ? clampNonNegative(input.task.taskVramMB) : Math.max(256, clampNonNegative(input.task.taskVramMB) - overflowMB);
  const unloadFirst = input.snapshot.loadedModels.filter((model) => model.pins <= 0 && !keepLoaded.has(model.modelID)).sort((a, b) => Date.parse(a.lastUsedAt) - Date.parse(b.lastUsedAt)).map((model) => model.modelID);
  return {
    fit,
    availableMB,
    requiredMB,
    overflowMB,
    suggestedTaskVramMB,
    canUseReferenceOnly: suggestedTaskVramMB < 512,
    modelPlan: {
      keepLoaded: [...keepLoaded],
      unloadFirst
    }
  };
}
function decideModelSwapAction(input) {
  const current = (input.currentModelID ?? "").trim();
  const target = (input.targetModelID ?? "").trim();
  if (!target) return "reuse";
  if (current && current === target) return "reuse";
  if (input.budget.fit) return current ? "hot_load" : "reuse";
  if (input.budget.modelPlan.unloadFirst.length > 0) return "evict_then_load";
  return "degraded_reference";
}

// src/resource-scheduler/scheduler.ts
function nowIso21() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function toNumber(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) return fallback;
  return Math.floor(parsed);
}
function toStringList(value) {
  if (!value) return [];
  return value.split(",").map((item) => item.trim()).filter(Boolean);
}
var ResourceScheduler = class {
  projectDir;
  totalVramMB;
  safetyMarginMB;
  maxConcurrentTasks;
  hotsetModelIDs = /* @__PURE__ */ new Set();
  warmPool = /* @__PURE__ */ new Map();
  warmPoolLimit;
  isolateTrainingLane;
  queue = [];
  active = /* @__PURE__ */ new Map();
  loadedModels = /* @__PURE__ */ new Map();
  currentModelByKind = /* @__PURE__ */ new Map();
  usedVramMB = 0;
  draining = false;
  constructor(projectDir, options = {}) {
    this.projectDir = projectDir;
    this.totalVramMB = Math.min(
      8192,
      options.totalVramMB ?? toNumber(process.env.MIYA_RESOURCE_TOTAL_VRAM_MB, 8192)
    );
    this.safetyMarginMB = options.safetyMarginMB ?? toNumber(process.env.MIYA_RESOURCE_SAFETY_MARGIN_MB, 768);
    this.maxConcurrentTasks = options.maxConcurrentTasks ?? toNumber(process.env.MIYA_RESOURCE_MAX_CONCURRENT, 2);
    this.warmPoolLimit = options.warmPoolLimit ?? toNumber(process.env.MIYA_RESOURCE_WARM_POOL_LIMIT, 8);
    this.isolateTrainingLane = options.isolateTrainingLane ?? process.env.MIYA_RESOURCE_ISOLATE_TRAINING_LANE !== "0";
    const hotset = /* @__PURE__ */ new Set([
      ...Array.isArray(options.hotsetModelIDs) ? options.hotsetModelIDs : [],
      ...toStringList(process.env.MIYA_RESOURCE_HOTSET_MODELS)
    ]);
    for (const modelID of hotset) {
      if (modelID) this.hotsetModelIDs.add(modelID);
    }
    this.recordSnapshot();
  }
  async acquire(request) {
    const pendingID = `lease_${randomUUID17()}`;
    return new Promise((resolve7, reject) => {
      const timeoutMs = typeof request.timeoutMs === "number" && request.timeoutMs > 0 ? request.timeoutMs : void 0;
      const timeoutAtMs = timeoutMs ? Date.now() + timeoutMs : void 0;
      const pending = {
        id: pendingID,
        request,
        createdAtMs: Date.now(),
        timeoutAtMs,
        resolve: resolve7,
        reject
      };
      this.queue.push(pending);
      this.queue.sort((a, b) => {
        const priorityA = a.request.priority ?? 0;
        const priorityB = b.request.priority ?? 0;
        if (priorityA !== priorityB) return priorityB - priorityA;
        return a.createdAtMs - b.createdAtMs;
      });
      appendSchedulerEvent(this.projectDir, {
        at: nowIso21(),
        type: "queued",
        leaseID: pendingID,
        kind: request.kind,
        priority: request.priority ?? 0,
        requestedVramMB: request.vramMB ?? 0,
        modelID: request.modelID
      });
      this.recordSnapshot();
      this.scheduleDrain();
    });
  }
  async withLease(request, run) {
    const lease = await this.acquire(request);
    try {
      return await run();
    } finally {
      lease.release();
    }
  }
  snapshot() {
    return {
      timestamp: nowIso21(),
      totalVramMB: this.totalVramMB,
      safetyMarginMB: this.safetyMarginMB,
      usedVramMB: this.usedVramMB,
      activeTasks: this.active.size,
      queueDepth: this.queue.length,
      loadedModels: [...this.loadedModels.values()].sort((a, b) => b.lastUsedAtMs - a.lastUsedAtMs).map((model) => ({
        modelID: model.modelID,
        vramMB: model.vramMB,
        pins: model.pins,
        lastUsedAt: new Date(model.lastUsedAtMs).toISOString()
      })),
      hotsetModelIDs: [...this.hotsetModelIDs.values()],
      warmPoolModels: [...this.warmPool.values()].sort((a, b) => b.cachedAtMs - a.cachedAtMs).map((model) => ({
        modelID: model.modelID,
        cachedAt: new Date(model.cachedAtMs).toISOString()
      }))
    };
  }
  planVramBudget(request) {
    return calculateVramBudget({
      snapshot: this.snapshot(),
      task: {
        taskID: request.kind,
        taskVramMB: Math.max(0, Math.floor(request.vramMB ?? 0)),
        priority: request.priority
      },
      models: request.modelID ? [
        {
          modelID: request.modelID,
          vramMB: Math.max(
            0,
            Math.floor(request.modelVramMB ?? request.vramMB ?? 0)
          ),
          required: true
        }
      ] : []
    });
  }
  scheduleDrain() {
    if (this.draining) return;
    this.draining = true;
    queueMicrotask(() => {
      this.draining = false;
      this.drainQueue();
    });
  }
  drainQueue() {
    let progressed = true;
    while (progressed) {
      progressed = false;
      this.removeExpiredPending();
      if (this.active.size >= this.maxConcurrentTasks) return;
      const pending = this.queue[0];
      if (!pending) return;
      if (!this.canGrant(pending.request)) return;
      this.queue.shift();
      const grantedAt = nowIso21();
      const requestVramMB = Math.max(0, Math.floor(pending.request.vramMB ?? 0));
      const lease = {
        id: pending.id,
        kind: pending.request.kind,
        grantedAt,
        requestVramMB,
        modelID: pending.request.modelID
      };
      this.active.set(lease.id, lease);
      if (requestVramMB > 0) this.usedVramMB += requestVramMB;
      if (pending.request.modelID) {
        const modelVramMB = Math.max(
          0,
          Math.floor(pending.request.modelVramMB ?? requestVramMB)
        );
        const swapAction = this.selectModelSwapAction(
          pending.request.kind,
          pending.request.modelID,
          pending.request
        );
        if (swapAction === "evict_then_load") {
          this.evictModelsIfNeeded(modelVramMB);
        }
        this.ensureModelLoaded(pending.request.modelID, modelVramMB);
        this.pinModel(pending.request.modelID);
        this.currentModelByKind.set(pending.request.kind, pending.request.modelID);
        appendSchedulerEvent(this.projectDir, {
          at: nowIso21(),
          type: "model_swap",
          kind: pending.request.kind,
          action: swapAction,
          modelID: pending.request.modelID,
          vramMB: modelVramMB
        });
      }
      appendSchedulerEvent(this.projectDir, {
        at: grantedAt,
        type: "granted",
        leaseID: lease.id,
        kind: lease.kind,
        requestedVramMB: requestVramMB,
        modelID: lease.modelID
      });
      this.recordSnapshot();
      pending.resolve({
        id: lease.id,
        kind: lease.kind,
        grantedAt,
        vramMB: requestVramMB,
        release: () => this.release(lease.id)
      });
      progressed = true;
    }
  }
  release(leaseID) {
    const lease = this.active.get(leaseID);
    if (!lease) return;
    this.active.delete(leaseID);
    if (lease.requestVramMB > 0) {
      this.usedVramMB = Math.max(0, this.usedVramMB - lease.requestVramMB);
    }
    if (lease.modelID) {
      this.unpinModel(lease.modelID);
      this.touchModel(lease.modelID);
    }
    appendSchedulerEvent(this.projectDir, {
      at: nowIso21(),
      type: "released",
      leaseID,
      kind: lease.kind,
      releasedVramMB: lease.requestVramMB,
      modelID: lease.modelID
    });
    this.recordSnapshot();
    this.scheduleDrain();
  }
  canGrant(request) {
    if (this.active.size >= this.maxConcurrentTasks) return false;
    if (this.isolateTrainingLane) {
      if (this.isTrainingKind(request.kind) && this.hasActiveInferenceTask()) return false;
      if (!this.isTrainingKind(request.kind) && this.hasActiveTrainingTask()) return false;
    }
    const neededVramMB = Math.max(0, Math.floor(request.vramMB ?? 0));
    if (neededVramMB === 0) return true;
    const modelVramMB = request.modelID ? Math.max(
      0,
      Math.floor(request.modelVramMB ?? request.vramMB ?? 0)
    ) : 0;
    this.evictModelsIfNeeded(neededVramMB + modelVramMB);
    return this.availableVramMB() >= neededVramMB + modelVramMB;
  }
  selectModelSwapAction(kind, targetModelID, request) {
    const budget = this.planVramBudget(request);
    return decideModelSwapAction({
      currentModelID: this.currentModelByKind.get(kind),
      targetModelID,
      budget
    });
  }
  availableVramMB() {
    return Math.max(
      0,
      this.totalVramMB - this.safetyMarginMB - this.usedVramMB - this.loadedModelsVramMB()
    );
  }
  loadedModelsVramMB() {
    let sum = 0;
    for (const model of this.loadedModels.values()) sum += model.vramMB;
    return sum;
  }
  removeExpiredPending() {
    const now = Date.now();
    const keep = [];
    for (const pending of this.queue) {
      if (pending.timeoutAtMs && pending.timeoutAtMs <= now) {
        appendSchedulerEvent(this.projectDir, {
          at: nowIso21(),
          type: "timeout",
          leaseID: pending.id,
          kind: pending.request.kind
        });
        pending.reject(new Error("resource_acquire_timeout"));
      } else {
        keep.push(pending);
      }
    }
    if (keep.length !== this.queue.length) {
      this.queue.length = 0;
      this.queue.push(...keep);
      this.recordSnapshot();
    }
  }
  ensureModelLoaded(modelID, vramMB) {
    if (!modelID || vramMB <= 0) return;
    const existing = this.loadedModels.get(modelID);
    if (existing) {
      existing.lastUsedAtMs = Date.now();
      return;
    }
    const warmEntry = this.warmPool.get(modelID);
    if (warmEntry) {
      this.warmPool.delete(modelID);
      appendSchedulerEvent(this.projectDir, {
        at: nowIso21(),
        type: "model_restored_from_warm_pool",
        modelID
      });
    }
    this.evictModelsIfNeeded(vramMB);
    this.loadedModels.set(modelID, {
      modelID,
      vramMB,
      pins: 0,
      lastUsedAtMs: Date.now()
    });
    appendSchedulerEvent(this.projectDir, {
      at: nowIso21(),
      type: "model_loaded",
      modelID,
      vramMB
    });
  }
  evictModelsIfNeeded(requiredVramMB) {
    if (requiredVramMB <= 0) return;
    if (this.availableVramMB() >= requiredVramMB) return;
    const candidates = [...this.loadedModels.values()].filter((item) => item.pins <= 0).sort((a, b) => {
      const hotA = this.hotsetModelIDs.has(a.modelID) ? 1 : 0;
      const hotB = this.hotsetModelIDs.has(b.modelID) ? 1 : 0;
      if (hotA !== hotB) return hotA - hotB;
      return a.lastUsedAtMs - b.lastUsedAtMs;
    });
    for (const candidate of candidates) {
      this.loadedModels.delete(candidate.modelID);
      this.addToWarmPool(candidate.modelID);
      appendSchedulerEvent(this.projectDir, {
        at: nowIso21(),
        type: "model_unloaded",
        modelID: candidate.modelID,
        vramMB: candidate.vramMB,
        reason: "lru_evict"
      });
      if (this.availableVramMB() >= requiredVramMB) break;
    }
  }
  pinModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model) return;
    model.pins += 1;
    model.lastUsedAtMs = Date.now();
  }
  unpinModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model) return;
    model.pins = Math.max(0, model.pins - 1);
    model.lastUsedAtMs = Date.now();
  }
  touchModel(modelID) {
    const model = this.loadedModels.get(modelID);
    if (!model) return;
    model.lastUsedAtMs = Date.now();
  }
  isTrainingKind(kind) {
    return kind === "training.image" || kind === "training.voice";
  }
  hasActiveTrainingTask() {
    for (const lease of this.active.values()) {
      if (this.isTrainingKind(lease.kind)) return true;
    }
    return false;
  }
  hasActiveInferenceTask() {
    for (const lease of this.active.values()) {
      if (!this.isTrainingKind(lease.kind)) return true;
    }
    return false;
  }
  addToWarmPool(modelID) {
    if (!modelID || this.hotsetModelIDs.has(modelID) || this.warmPoolLimit <= 0) return;
    this.warmPool.set(modelID, {
      modelID,
      cachedAtMs: Date.now()
    });
    this.pruneWarmPool();
  }
  pruneWarmPool() {
    if (this.warmPool.size <= this.warmPoolLimit) return;
    const entries = [...this.warmPool.values()].sort((a, b) => a.cachedAtMs - b.cachedAtMs);
    while (this.warmPool.size > this.warmPoolLimit) {
      const candidate = entries.shift();
      if (!candidate) break;
      this.warmPool.delete(candidate.modelID);
    }
  }
  recordSnapshot() {
    writeSchedulerSnapshot(this.projectDir, this.snapshot());
  }
};

// src/resource-scheduler/index.ts
var schedulers = /* @__PURE__ */ new Map();
function getResourceScheduler(projectDir, options) {
  const existing = schedulers.get(projectDir);
  if (existing) return existing;
  const created = new ResourceScheduler(projectDir, options);
  schedulers.set(projectDir, created);
  return created;
}

// src/sessions/index.ts
import * as fs37 from "node:fs";
import * as path38 from "node:path";
var DEFAULT_POLICY = {
  activation: "active",
  reply: "auto",
  queueStrategy: "fifo"
};
function nowIso22() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath10(projectDir) {
  return path38.join(getMiyaRuntimeDir(projectDir), "sessions.json");
}
function ensureDir18(file3) {
  fs37.mkdirSync(path38.dirname(file3), { recursive: true });
}
function readStore6(projectDir) {
  const file3 = filePath10(projectDir);
  if (!fs37.existsSync(file3)) {
    return { sessions: {} };
  }
  try {
    const parsed = JSON.parse(fs37.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const normalized = { sessions: {} };
    for (const [id, session] of Object.entries(parsed.sessions ?? {})) {
      normalized.sessions[id] = {
        ...session,
        groupId: decryptSensitiveValue(
          projectDir,
          String(session.groupId ?? "")
        ),
        title: typeof session.title === "string" ? decryptSensitiveValue(projectDir, session.title) : session.title,
        routing: {
          ...session.routing ?? {
            opencodeSessionID: "main",
            agent: "1-task-manager"
          },
          opencodeSessionID: decryptSensitiveValue(
            projectDir,
            String(session.routing?.opencodeSessionID ?? "main")
          )
        },
        queue: Array.isArray(session.queue) ? session.queue.map((item) => ({
          ...item,
          text: decryptSensitiveValue(projectDir, String(item.text ?? "")),
          source: decryptSensitiveValue(
            projectDir,
            String(item.source ?? "")
          )
        })) : []
      };
    }
    return normalized;
  } catch {
    return { sessions: {} };
  }
}
function writeStore6(projectDir, store2) {
  const file3 = filePath10(projectDir);
  ensureDir18(file3);
  const encrypted = { sessions: {} };
  for (const [id, session] of Object.entries(store2.sessions)) {
    encrypted.sessions[id] = {
      ...session,
      groupId: encryptSensitiveValue(projectDir, session.groupId),
      title: session.title ? encryptSensitiveValue(projectDir, session.title) : session.title,
      routing: {
        ...session.routing,
        opencodeSessionID: encryptSensitiveValue(
          projectDir,
          session.routing.opencodeSessionID
        )
      },
      queue: session.queue.map((item) => ({
        ...item,
        text: encryptSensitiveValue(projectDir, item.text),
        source: encryptSensitiveValue(projectDir, item.source)
      }))
    };
  }
  fs37.writeFileSync(file3, `${JSON.stringify(encrypted, null, 2)}
`, "utf-8");
}
function sanitizeSession(value) {
  return {
    ...value,
    policy: {
      activation: value.policy?.activation ?? DEFAULT_POLICY.activation,
      reply: value.policy?.reply ?? DEFAULT_POLICY.reply,
      queueStrategy: value.policy?.queueStrategy ?? DEFAULT_POLICY.queueStrategy
    },
    routing: {
      opencodeSessionID: value.routing?.opencodeSessionID ?? "main",
      agent: value.routing?.agent ?? "1-task-manager"
    },
    recovery: value.recovery ? {
      recoverable: value.recovery.recoverable !== false,
      reasonCode: typeof value.recovery.reasonCode === "string" ? value.recovery.reasonCode : void 0,
      from: value.recovery.from === "autoflow" || value.recovery.from === "daemon" || value.recovery.from === "session" ? value.recovery.from : "session",
      updatedAt: value.recovery.updatedAt || nowIso22()
    } : void 0,
    queue: Array.isArray(value.queue) ? value.queue : []
  };
}
function listSessions(projectDir) {
  const store2 = readStore6(projectDir);
  return Object.values(store2.sessions).map(sanitizeSession).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt));
}
function getSession(projectDir, sessionID2) {
  const store2 = readStore6(projectDir);
  const session = store2.sessions[sessionID2];
  return session ? sanitizeSession(session) : null;
}
function upsertSession(projectDir, input) {
  const store2 = readStore6(projectDir);
  const existing = store2.sessions[input.id];
  const createdAt = existing?.createdAt ?? nowIso22();
  const session = sanitizeSession({
    id: input.id,
    kind: input.kind ?? existing?.kind ?? "channel",
    groupId: input.groupId ?? existing?.groupId ?? input.id,
    title: input.title ?? existing?.title,
    policy: existing?.policy ?? DEFAULT_POLICY,
    routing: {
      opencodeSessionID: input.routingSessionID ?? existing?.routing?.opencodeSessionID ?? "main",
      agent: input.agent ?? existing?.routing?.agent ?? "1-task-manager"
    },
    queue: existing?.queue ?? [],
    createdAt,
    updatedAt: nowIso22()
  });
  store2.sessions[input.id] = session;
  writeStore6(projectDir, store2);
  return session;
}
function setSessionPolicy(projectDir, sessionID2, patch) {
  const store2 = readStore6(projectDir);
  const existing = store2.sessions[sessionID2];
  if (!existing) return null;
  const next = sanitizeSession({
    ...existing,
    policy: {
      ...existing.policy,
      ...patch
    },
    updatedAt: nowIso22()
  });
  store2.sessions[sessionID2] = next;
  writeStore6(projectDir, store2);
  return next;
}
function enqueueSessionMessage(projectDir, sessionID2, input) {
  const store2 = readStore6(projectDir);
  const existing = sanitizeSession(
    store2.sessions[sessionID2] ?? upsertSession(projectDir, {
      id: sessionID2
    })
  );
  const message = {
    id: `queue_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    text: input.text,
    source: input.source,
    createdAt: nowIso22()
  };
  const nextQueue = [...existing.queue, message];
  const next = {
    ...existing,
    queue: nextQueue,
    updatedAt: nowIso22()
  };
  store2.sessions[sessionID2] = next;
  writeStore6(projectDir, store2);
  return message;
}
function dequeueSessionMessage(projectDir, sessionID2) {
  const store2 = readStore6(projectDir);
  const existing = store2.sessions[sessionID2];
  if (!existing || existing.queue.length === 0) {
    return null;
  }
  const [first, ...rest] = existing.queue;
  store2.sessions[sessionID2] = {
    ...existing,
    queue: rest,
    updatedAt: nowIso22()
  };
  writeStore6(projectDir, store2);
  return first;
}
function setSessionRecoveryReason(projectDir, input) {
  const existing = getSession(projectDir, input.sessionID) ?? upsertSession(projectDir, {
    id: input.sessionID,
    kind: input.sessionID.startsWith("opencode:") ? "opencode" : "channel",
    groupId: input.sessionID
  });
  const store2 = readStore6(projectDir);
  const next = sanitizeSession({
    ...existing,
    recovery: {
      recoverable: Boolean(input.recoverable),
      reasonCode: input.reasonCode.trim(),
      from: input.from ?? "session",
      updatedAt: nowIso22()
    },
    updatedAt: nowIso22()
  });
  store2.sessions[input.sessionID] = next;
  writeStore6(projectDir, store2);
  return next;
}

// src/router/classifier.ts
function classifyIntent(text) {
  const lower = text.toLowerCase();
  if (/(||bug||test fail|failing|compile)/i.test(lower)) {
    return "code_fix";
  }
  if (/(||where|find|grep|search)/i.test(lower)) {
    return "code_search";
  }
  if (/(|api|docs|reference|)/i.test(lower)) {
    return "docs_research";
  }
  if (/(||tradeoff|risk|)/i.test(lower)) {
    return "architecture";
  }
  if (/(ui|||||)/i.test(lower)) {
    return "ui_design";
  }
  return "general";
}
function recommendedAgent(intent) {
  if (intent === "code_fix") return "5-code-fixer";
  if (intent === "code_search") return "2-code-search";
  if (intent === "docs_research") return "3-docs-helper";
  if (intent === "architecture") return "4-architecture-advisor";
  if (intent === "ui_design") return "6-ui-designer";
  return "1-task-manager";
}

// src/router/fallback.ts
function resolveFallbackAgent(intent, availableAgents) {
  const primary = recommendedAgent(intent);
  if (availableAgents.includes(primary)) return primary;
  if (availableAgents.includes("1-task-manager")) return "1-task-manager";
  return availableAgents[0] ?? primary;
}
function resolveAgentWithFeedback(intent, availableAgents, ranked) {
  const base = resolveFallbackAgent(intent, availableAgents);
  if (ranked.length === 0) return base;
  const preferred = ranked.find(
    (item) => availableAgents.includes(item.agent) && item.score >= 0.55
  );
  return preferred?.agent ?? base;
}

// src/router/learner.ts
import * as fs38 from "node:fs";
import * as path39 from "node:path";
function filePath11(projectDir) {
  return path39.join(getMiyaRuntimeDir(projectDir), "router-history.json");
}
function readStore7(projectDir) {
  const file3 = filePath11(projectDir);
  if (!fs38.existsSync(file3)) return { records: [] };
  try {
    const parsed = JSON.parse(fs38.readFileSync(file3, "utf-8"));
    return { records: Array.isArray(parsed.records) ? parsed.records : [] };
  } catch {
    return { records: [] };
  }
}
function writeStore7(projectDir, store2) {
  const file3 = filePath11(projectDir);
  fs38.mkdirSync(path39.dirname(file3), { recursive: true });
  fs38.writeFileSync(file3, `${JSON.stringify(store2, null, 2)}
`, "utf-8");
}
function addRouteFeedback(projectDir, record3) {
  const store2 = readStore7(projectDir);
  const next = {
    ...record3,
    at: (/* @__PURE__ */ new Date()).toISOString()
  };
  store2.records = [next, ...store2.records].slice(0, 1e3);
  writeStore7(projectDir, store2);
  return next;
}
function summarizeRouteHistory(projectDir) {
  const records = readStore7(projectDir).records.slice(0, 50);
  if (records.length === 0) return "route_history=empty";
  const accepted = records.filter((item) => item.accepted).length;
  return [
    `route_history_total=${records.length}`,
    `route_history_accept_rate=${Math.round(accepted / records.length * 100)}%`
  ].join("\n");
}
function rankAgentsByFeedback(projectDir, intent, availableAgents) {
  const records = readStore7(projectDir).records.filter((item) => item.intent === intent).slice(0, 300);
  const scored = availableAgents.map((agent) => {
    const matched = records.filter((item) => item.suggestedAgent === agent);
    const accepted = matched.filter((item) => item.accepted).length;
    const samples = matched.length;
    const acceptRate = samples > 0 ? accepted / samples : 0;
    const score = Number((acceptRate * 0.8 + Math.min(0.2, samples / 50)).toFixed(4));
    return {
      agent,
      score,
      samples,
      acceptRate: Number(acceptRate.toFixed(4))
    };
  });
  return scored.sort((a, b) => b.score - a.score);
}

// src/router/runtime.ts
import * as fs39 from "node:fs";
import * as path40 from "node:path";
var DEFAULT_MODE = {
  ecoMode: true,
  stageTokenMultiplier: {
    low: 0.62,
    medium: 1,
    high: 1.45
  },
  stageCostUsdPer1k: {
    low: 9e-4,
    medium: 18e-4,
    high: 32e-4
  }
};
var ORCHESTRATION_ORDER = [
  "1-task-manager",
  "2-code-search",
  "3-docs-helper",
  "4-architecture-advisor",
  "5-code-fixer",
  "6-ui-designer",
  "7-code-simplicity-reviewer"
];
function getComplexityProfile(complexity) {
  if (complexity === "low") {
    return { maxAgents: 1, contextStrategy: "minimal", enableEarlyExit: true };
  }
  if (complexity === "medium") {
    return { maxAgents: 3, contextStrategy: "summary", enableEarlyExit: true };
  }
  return { maxAgents: 7, contextStrategy: "full", enableEarlyExit: false };
}
function primaryAgentForIntent(intent) {
  if (intent === "code_fix") return "5-code-fixer";
  if (intent === "code_search") return "2-code-search";
  if (intent === "docs_research") return "3-docs-helper";
  if (intent === "architecture") return "4-architecture-advisor";
  if (intent === "ui_design") return "6-ui-designer";
  return "1-task-manager";
}
function buildAgentPlan(input) {
  const profile = getComplexityProfile(input.complexity);
  const include = (target, list) => {
    if (!target || !input.availableAgents.includes(target) || list.includes(target)) return list;
    return [...list, target];
  };
  if (input.pinnedAgent) {
    return {
      plannedAgents: [input.selectedAgent],
      maxAgents: 1,
      contextStrategy: "minimal",
      requiresMultipleSteps: false,
      enableEarlyExit: true
    };
  }
  if (input.complexity === "low") {
    return {
      plannedAgents: [input.selectedAgent],
      maxAgents: profile.maxAgents,
      contextStrategy: profile.contextStrategy,
      requiresMultipleSteps: false,
      enableEarlyExit: profile.enableEarlyExit
    };
  }
  if (input.complexity === "medium") {
    let plan = [];
    plan = include("1-task-manager", plan);
    plan = include(input.selectedAgent, plan);
    plan = include(primaryAgentForIntent(input.intent), plan);
    plan = include("5-code-fixer", plan);
    return {
      plannedAgents: plan.slice(0, profile.maxAgents),
      maxAgents: profile.maxAgents,
      contextStrategy: profile.contextStrategy,
      requiresMultipleSteps: true,
      enableEarlyExit: profile.enableEarlyExit
    };
  }
  const highPlan = [
    "1-task-manager",
    input.selectedAgent,
    primaryAgentForIntent(input.intent),
    ...ORCHESTRATION_ORDER
  ].filter((agent, index, arr) => arr.indexOf(agent) === index).filter((agent) => input.availableAgents.includes(agent)).slice(0, profile.maxAgents);
  return {
    plannedAgents: highPlan,
    maxAgents: profile.maxAgents,
    contextStrategy: profile.contextStrategy,
    requiresMultipleSteps: true,
    enableEarlyExit: profile.enableEarlyExit
  };
}
function modeFile(projectDir) {
  return path40.join(getMiyaRuntimeDir(projectDir), "router-mode.json");
}
function costFile(projectDir) {
  return path40.join(getMiyaRuntimeDir(projectDir), "router-cost.jsonl");
}
function sessionStateFile(projectDir) {
  return path40.join(getMiyaRuntimeDir(projectDir), "router-session-state.json");
}
function ensureDir19(projectDir) {
  fs39.mkdirSync(getMiyaRuntimeDir(projectDir), { recursive: true });
}
function clamp3(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function nowIso23() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function parseMode(raw) {
  const input = raw && typeof raw === "object" ? raw : {};
  const forcedStage = input.forcedStage === "low" || input.forcedStage === "medium" || input.forcedStage === "high" ? input.forcedStage : void 0;
  const stageTokenMultiplierInput = input.stageTokenMultiplier && typeof input.stageTokenMultiplier === "object" ? input.stageTokenMultiplier : {};
  const stageCostInput = input.stageCostUsdPer1k && typeof input.stageCostUsdPer1k === "object" ? input.stageCostUsdPer1k : {};
  return {
    ecoMode: input.ecoMode !== false,
    forcedStage,
    stageTokenMultiplier: {
      low: clamp3(Number(stageTokenMultiplierInput.low ?? DEFAULT_MODE.stageTokenMultiplier.low), 0.2, 2.5),
      medium: clamp3(
        Number(stageTokenMultiplierInput.medium ?? DEFAULT_MODE.stageTokenMultiplier.medium),
        0.3,
        3
      ),
      high: clamp3(Number(stageTokenMultiplierInput.high ?? DEFAULT_MODE.stageTokenMultiplier.high), 0.4, 4)
    },
    stageCostUsdPer1k: {
      low: clamp3(Number(stageCostInput.low ?? DEFAULT_MODE.stageCostUsdPer1k.low), 1e-4, 0.1),
      medium: clamp3(Number(stageCostInput.medium ?? DEFAULT_MODE.stageCostUsdPer1k.medium), 1e-4, 0.2),
      high: clamp3(Number(stageCostInput.high ?? DEFAULT_MODE.stageCostUsdPer1k.high), 1e-4, 0.3)
    }
  };
}
function readRouterModeConfig(projectDir) {
  const file3 = modeFile(projectDir);
  if (!fs39.existsSync(file3)) return DEFAULT_MODE;
  try {
    const parsed = JSON.parse(fs39.readFileSync(file3, "utf-8"));
    return parseMode(parsed);
  } catch {
    return DEFAULT_MODE;
  }
}
function writeRouterModeConfig(projectDir, patch) {
  ensureDir19(projectDir);
  const current = readRouterModeConfig(projectDir);
  const next = parseMode({
    ...current,
    ...patch,
    stageTokenMultiplier: {
      ...current.stageTokenMultiplier,
      ...patch.stageTokenMultiplier ?? {}
    },
    stageCostUsdPer1k: {
      ...current.stageCostUsdPer1k,
      ...patch.stageCostUsdPer1k ?? {}
    }
  });
  fs39.writeFileSync(modeFile(projectDir), `${JSON.stringify(next, null, 2)}
`, "utf-8");
  return next;
}
function readSessionStore(projectDir) {
  const file3 = sessionStateFile(projectDir);
  if (!fs39.existsSync(file3)) return { sessions: {} };
  try {
    const parsed = JSON.parse(fs39.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) return { sessions: {} };
    return {
      sessions: Object.fromEntries(
        Object.entries(parsed.sessions).map(([sessionID2, state2]) => [
          sessionID2,
          {
            sessionID: sessionID2,
            consecutiveFailures: clamp3(Number(state2?.consecutiveFailures ?? 0), 0, 10),
            lastStage: state2?.lastStage === "low" || state2?.lastStage === "medium" || state2?.lastStage === "high" ? state2.lastStage : "medium",
            updatedAt: String(state2?.updatedAt ?? nowIso23())
          }
        ])
      )
    };
  } catch {
    return { sessions: {} };
  }
}
function writeSessionStore(projectDir, store2) {
  ensureDir19(projectDir);
  fs39.writeFileSync(sessionStateFile(projectDir), `${JSON.stringify(store2, null, 2)}
`, "utf-8");
}
function getSessionState2(projectDir, sessionID2) {
  const store2 = readSessionStore(projectDir);
  return store2.sessions[sessionID2] ?? {
    sessionID: sessionID2,
    consecutiveFailures: 0,
    lastStage: "medium",
    updatedAt: nowIso23()
  };
}
function stageLevel(stage) {
  if (stage === "low") return 0;
  if (stage === "medium") return 1;
  return 2;
}
function levelToStage(level) {
  if (level <= 0) return "low";
  if (level === 1) return "medium";
  return "high";
}
function readCostRows(projectDir, limit = 500) {
  const file3 = costFile(projectDir);
  if (!fs39.existsSync(file3)) return [];
  const rows = fs39.readFileSync(file3, "utf-8").split(/\r?\n/).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((item) => Boolean(item));
  return rows.slice(-Math.max(1, limit));
}
function appendCostRow(projectDir, row) {
  ensureDir19(projectDir);
  fs39.appendFileSync(costFile(projectDir), `${JSON.stringify(row)}
`, "utf-8");
}
function analyzeRouteComplexity(text) {
  const normalized = String(text ?? "").trim();
  const reasons = [];
  let score = 0;
  if (normalized.length > 1600) {
    score += 2;
    reasons.push("long_request");
  } else if (normalized.length > 700) {
    score += 1;
    reasons.push("medium_length");
  }
  if (/```[\s\S]*```/.test(normalized)) {
    score += 2;
    reasons.push("contains_code_block");
  }
  if (/(|tradeoff||risk|migration||performance||security|)/i.test(normalized)) {
    score += 1;
    reasons.push("architecture_or_risk");
  }
  if (/(||pipeline|workflow||verify||fix|loop)/i.test(normalized)) {
    score += 1;
    reasons.push("multi_step_execution");
  }
  if (/(|||critical|p0|severe)/i.test(normalized)) {
    score += 1;
    reasons.push("urgency_signal");
  }
  const complexity = score >= 4 ? "high" : score >= 2 ? "medium" : "low";
  return { complexity, score, reasons };
}
function stageFromComplexity(complexity) {
  if (complexity === "high") return "high";
  if (complexity === "medium") return "medium";
  return "low";
}
function compressTextByStage(text, stage) {
  const normalized = String(text ?? "").trim();
  if (!normalized) return { text: "", compressed: false };
  if (stage === "high") return { text: normalized, compressed: false };
  if (stage === "medium" && normalized.length <= 4200) return { text: normalized, compressed: false };
  if (stage === "low" && normalized.length <= 1600) return { text: normalized, compressed: false };
  if (stage === "medium") {
    const head2 = normalized.slice(0, 2600);
    const tail2 = normalized.slice(-1200);
    return {
      text: `${head2}

[MIYA_ROUTER_COMPRESSION stage=medium]
...
${tail2}`,
      compressed: true
    };
  }
  const head = normalized.slice(0, 900);
  const bulletLines = normalized.split(/\r?\n/).map((line) => line.trim()).filter((line) => /^[-*0-9.]/.test(line)).slice(0, 8).join("\n");
  const tail = normalized.slice(-480);
  const merged = [head, bulletLines, tail].filter(Boolean).join("\n");
  return {
    text: `${merged}

[MIYA_ROUTER_COMPRESSION stage=low reason=eco_mode]`,
    compressed: true
  };
}
function estimateInputTokens(text) {
  const length = String(text ?? "").length;
  return Math.max(20, Math.ceil(length / 3.6));
}
function estimateOutputTokens(inputTokens, stage) {
  if (stage === "low") return Math.max(60, Math.ceil(inputTokens * 0.35));
  if (stage === "medium") return Math.max(100, Math.ceil(inputTokens * 0.55));
  return Math.max(140, Math.ceil(inputTokens * 0.9));
}
function buildRouteExecutionPlan(input) {
  const intent = classifyIntent(input.text);
  const complexity = analyzeRouteComplexity(input.text);
  const mode = readRouterModeConfig(input.projectDir);
  const session = getSessionState2(input.projectDir, input.sessionID);
  const ranked = rankAgentsByFeedback(input.projectDir, intent, input.availableAgents);
  const preferredAgent = resolveFallbackAgent(intent, input.availableAgents);
  const fallbackAgent = resolveFallbackAgent(intent, input.availableAgents);
  const selectedByFeedback = resolveAgentWithFeedback(intent, input.availableAgents, ranked);
  const pinnedAgent = input.pinnedAgent?.trim();
  const selectedAgent = pinnedAgent && input.availableAgents.includes(pinnedAgent) ? pinnedAgent : selectedByFeedback;
  const feedbackScore = ranked.find((item) => item.agent === selectedAgent)?.score ?? 0;
  const feedbackSamples = ranked.find((item) => item.agent === selectedAgent)?.samples ?? 0;
  let stage = stageFromComplexity(complexity.complexity);
  const reasons = [...complexity.reasons];
  if (mode.forcedStage) {
    stage = mode.forcedStage;
    reasons.push("forced_stage");
  } else {
    if (mode.ecoMode) {
      stage = levelToStage(stageLevel(stage) - 1);
      reasons.push("eco_mode_downshift");
    }
    if (session.consecutiveFailures >= 1) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_1");
    }
    if (session.consecutiveFailures >= 2) {
      stage = levelToStage(stageLevel(stage) + 1);
      reasons.push("failure_escalation_2");
    }
  }
  const agentPlan = buildAgentPlan({
    complexity: complexity.complexity,
    intent,
    selectedAgent,
    availableAgents: input.availableAgents,
    pinnedAgent: pinnedAgent && input.availableAgents.includes(pinnedAgent) ? pinnedAgent : void 0
  });
  if (agentPlan.plannedAgents.length > 1) {
    reasons.push("multi_agent_plan");
  }
  if (pinnedAgent && input.availableAgents.includes(pinnedAgent)) {
    reasons.push("pinned_agent_lock");
  }
  return {
    intent,
    complexity: complexity.complexity,
    complexityScore: complexity.score,
    stage,
    agent: selectedAgent,
    plannedAgents: agentPlan.plannedAgents,
    maxAgents: agentPlan.maxAgents,
    contextStrategy: agentPlan.contextStrategy,
    requiresMultipleSteps: agentPlan.requiresMultipleSteps,
    enableEarlyExit: agentPlan.enableEarlyExit,
    preferredAgent,
    fallbackAgent,
    feedbackScore,
    feedbackSamples,
    ecoMode: mode.ecoMode,
    reasons
  };
}
function prepareRoutePayload(projectDir, input) {
  const mode = readRouterModeConfig(projectDir);
  const compressed = compressTextByStage(input.text, input.stage);
  const inputTokens = estimateInputTokens(compressed.text);
  const outputTokensEstimate = estimateOutputTokens(inputTokens, input.stage);
  const totalTokensEstimate = Math.ceil(
    (inputTokens + outputTokensEstimate) * mode.stageTokenMultiplier[input.stage]
  );
  const baselineHighTokensEstimate = Math.ceil(
    (inputTokens + estimateOutputTokens(inputTokens, "high")) * mode.stageTokenMultiplier.high
  );
  const costUsdEstimate = Number(
    (totalTokensEstimate / 1e3 * mode.stageCostUsdPer1k[input.stage]).toFixed(6)
  );
  return {
    text: compressed.text,
    compressed: compressed.compressed,
    inputTokens,
    outputTokensEstimate,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    costUsdEstimate
  };
}
function recordRouteExecutionOutcome(input) {
  const row = {
    at: nowIso23(),
    sessionID: input.sessionID,
    intent: input.intent,
    complexity: input.complexity,
    stage: input.stage,
    agent: input.agent,
    success: input.success,
    inputTokens: input.inputTokens,
    outputTokensEstimate: input.outputTokensEstimate,
    totalTokensEstimate: input.totalTokensEstimate,
    baselineHighTokensEstimate: input.baselineHighTokensEstimate,
    costUsdEstimate: input.costUsdEstimate
  };
  appendCostRow(input.projectDir, row);
  const store2 = readSessionStore(input.projectDir);
  const current = store2.sessions[input.sessionID] ?? {
    sessionID: input.sessionID,
    consecutiveFailures: 0,
    lastStage: input.stage,
    updatedAt: nowIso23()
  };
  const next = {
    sessionID: input.sessionID,
    consecutiveFailures: input.success ? 0 : clamp3(current.consecutiveFailures + 1, 0, 10),
    lastStage: input.stage,
    updatedAt: nowIso23()
  };
  store2.sessions[input.sessionID] = next;
  writeSessionStore(input.projectDir, store2);
  return row;
}
function getRouteCostSummary(projectDir, limit = 300) {
  const rows = readCostRows(projectDir, limit);
  const byStage = {
    low: { records: 0, tokens: 0, costUsd: 0 },
    medium: { records: 0, tokens: 0, costUsd: 0 },
    high: { records: 0, tokens: 0, costUsd: 0 }
  };
  let totalTokensEstimate = 0;
  let baselineHighTokensEstimate = 0;
  let totalCostUsdEstimate = 0;
  for (const row of rows) {
    byStage[row.stage].records += 1;
    byStage[row.stage].tokens += row.totalTokensEstimate;
    byStage[row.stage].costUsd += row.costUsdEstimate;
    totalTokensEstimate += row.totalTokensEstimate;
    baselineHighTokensEstimate += row.baselineHighTokensEstimate;
    totalCostUsdEstimate += row.costUsdEstimate;
  }
  const savingsTokensEstimate = Math.max(0, baselineHighTokensEstimate - totalTokensEstimate);
  const savingsPercentEstimate = baselineHighTokensEstimate > 0 ? Number((savingsTokensEstimate / baselineHighTokensEstimate * 100).toFixed(2)) : 0;
  return {
    totalRecords: rows.length,
    totalTokensEstimate,
    baselineHighTokensEstimate,
    savingsTokensEstimate,
    savingsPercentEstimate,
    totalCostUsdEstimate: Number(totalCostUsdEstimate.toFixed(6)),
    byStage: {
      low: {
        ...byStage.low,
        costUsd: Number(byStage.low.costUsd.toFixed(6))
      },
      medium: {
        ...byStage.medium,
        costUsd: Number(byStage.medium.costUsd.toFixed(6))
      },
      high: {
        ...byStage.high,
        costUsd: Number(byStage.high.costUsd.toFixed(6))
      }
    }
  };
}
function listRouteCostRecords(projectDir, limit = 40) {
  return readCostRows(projectDir, limit);
}
function getRouterSessionState(projectDir, sessionID2) {
  return getSessionState2(projectDir, sessionID2);
}

// src/skills/loader.ts
import * as fs40 from "node:fs";
import * as os5 from "node:os";
import * as path41 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";

// src/skills/frontmatter.ts
var LIST_KEYS = /* @__PURE__ */ new Set(["bins", "env", "platforms", "permissions"]);
function normalizeScalar(value) {
  const trimmed = value.trim();
  if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
    return trimmed.slice(1, -1).trim();
  }
  return trimmed;
}
function normalizeList(value) {
  const trimmed = value.trim();
  if (!trimmed) return [];
  const body = trimmed.startsWith("[") && trimmed.endsWith("]") ? trimmed.slice(1, -1) : trimmed;
  return body.split(",").map((item) => normalizeScalar(item)).filter(Boolean);
}
function parseSkillFrontmatter(markdown) {
  const trimmed = markdown.trimStart();
  if (!trimmed.startsWith("---")) {
    return {};
  }
  const lines = trimmed.split(/\r?\n/);
  if (lines.length < 3 || lines[0].trim() !== "---") {
    return {};
  }
  const endIndex = lines.findIndex((line, index) => index > 0 && line.trim() === "---");
  if (endIndex === -1) {
    return {};
  }
  const result = {};
  let activeListKey;
  for (const rawLine of lines.slice(1, endIndex)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#")) continue;
    if (activeListKey && line.startsWith("- ")) {
      const value2 = normalizeScalar(line.slice(2));
      if (value2) {
        const existing = result[activeListKey] ?? [];
        result[activeListKey] = [...existing, value2];
      }
      continue;
    }
    activeListKey = void 0;
    const colon = line.indexOf(":");
    if (colon <= 0) continue;
    const key = line.slice(0, colon).trim();
    const value = line.slice(colon + 1).trim();
    if (key === "name") result.name = value;
    else if (key === "version") result.version = value;
    else if (key === "description") result.description = value;
    else if (LIST_KEYS.has(key)) {
      const listKey = key;
      const parsed = normalizeList(value);
      if (parsed.length > 0) {
        result[listKey] = parsed;
      } else {
        result[listKey] = [];
        activeListKey = listKey;
      }
    }
  }
  return result;
}

// src/skills/gating.ts
import { spawnSync as spawnSync5 } from "node:child_process";
function hasBinary(bin) {
  const checker = process.platform === "win32" ? "where" : "which";
  const result = spawnSync5(checker, [bin], { stdio: "ignore" });
  return result.status === 0;
}
function evaluateSkillGate(frontmatter) {
  const reasons = [];
  if (Array.isArray(frontmatter.platforms) && frontmatter.platforms.length > 0) {
    if (!frontmatter.platforms.includes(process.platform)) {
      reasons.push(`platform_not_supported:${process.platform}`);
    }
  }
  for (const envName of frontmatter.env ?? []) {
    if (!process.env[envName]) {
      reasons.push(`missing_env:${envName}`);
    }
  }
  for (const bin of frontmatter.bins ?? []) {
    if (!hasBinary(bin)) {
      reasons.push(`missing_bin:${bin}`);
    }
  }
  return {
    loadable: reasons.length === 0,
    reasons
  };
}

// src/skills/loader.ts
function isSkillDir(dir) {
  const skillFile = path41.join(dir, "SKILL.md");
  return fs40.existsSync(skillFile);
}
function listSkillDirs(rootDir) {
  if (!fs40.existsSync(rootDir)) return [];
  const entries = fs40.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path41.join(rootDir, entry2.name));
  return entries.filter(isSkillDir);
}
function builtinSkillRoots(projectDir) {
  const roots = /* @__PURE__ */ new Set();
  const localBuiltinRoot = path41.dirname(fileURLToPath3(import.meta.url));
  roots.add(path41.join(projectDir, "miya-src", "src", "skills"));
  roots.add(localBuiltinRoot);
  return [...roots];
}
function enforcePermissionMetadataGate(source, frontmatter, gate) {
  if (source === "builtin") return gate;
  if ((frontmatter.permissions?.length ?? 0) > 0) return gate;
  const reasons = [...gate.reasons, "missing_permission_metadata"];
  return {
    loadable: false,
    reasons: [...new Set(reasons)]
  };
}
function discoverSkills(projectDir, extraDirs = []) {
  const workspaceRoot = path41.join(projectDir, "skills");
  const globalRoot = path41.join(os5.homedir(), ".config", "opencode", "miya", "skills");
  const scopedDirs = [
    { source: "workspace", dirs: listSkillDirs(workspaceRoot) },
    { source: "global", dirs: listSkillDirs(globalRoot) },
    {
      source: "builtin",
      dirs: builtinSkillRoots(projectDir).flatMap((root) => listSkillDirs(root))
    },
    {
      source: "extra",
      dirs: extraDirs.flatMap((root) => listSkillDirs(path41.resolve(projectDir, root)))
    }
  ];
  const precedence = {
    workspace: 4,
    global: 3,
    extra: 2,
    builtin: 1
  };
  const byName = /* @__PURE__ */ new Map();
  for (const scope of scopedDirs) {
    for (const dir of scope.dirs) {
      const skillFile = path41.join(dir, "SKILL.md");
      let content = "";
      try {
        content = fs40.readFileSync(skillFile, "utf-8");
      } catch {
        continue;
      }
      const frontmatter = parseSkillFrontmatter(content);
      const name = frontmatter.name ?? path41.basename(dir);
      const gate = enforcePermissionMetadataGate(
        scope.source,
        frontmatter,
        evaluateSkillGate(frontmatter)
      );
      const descriptor = {
        id: name,
        name,
        source: scope.source,
        dir,
        skillFile,
        frontmatter,
        gate
      };
      const existing = byName.get(name);
      if (!existing || precedence[scope.source] >= precedence[existing.source]) {
        byName.set(name, descriptor);
      }
    }
  }
  return [...byName.values()].sort((a, b) => a.name.localeCompare(b.name));
}

// src/skills/state.ts
import * as fs41 from "node:fs";
import * as path42 from "node:path";
function nowIso24() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function filePath12(projectDir) {
  return path42.join(getMiyaRuntimeDir(projectDir), "skills.json");
}
function ensureDir20(file3) {
  fs41.mkdirSync(path42.dirname(file3), { recursive: true });
}
function readState(projectDir) {
  const file3 = filePath12(projectDir);
  if (!fs41.existsSync(file3)) {
    return { enabled: [], updatedAt: nowIso24() };
  }
  try {
    const parsed = JSON.parse(fs41.readFileSync(file3, "utf-8"));
    return {
      enabled: Array.isArray(parsed.enabled) ? parsed.enabled.map(String) : [],
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : nowIso24()
    };
  } catch {
    return { enabled: [], updatedAt: nowIso24() };
  }
}
function writeState3(projectDir, state2) {
  const file3 = filePath12(projectDir);
  ensureDir20(file3);
  fs41.writeFileSync(file3, `${JSON.stringify(state2, null, 2)}
`, "utf-8");
}
function listEnabledSkills(projectDir) {
  return readState(projectDir).enabled;
}
function setSkillEnabled(projectDir, skillID, enabled) {
  const state2 = readState(projectDir);
  const normalized = new Set(state2.enabled);
  if (enabled) normalized.add(skillID);
  else normalized.delete(skillID);
  const next = {
    enabled: [...normalized].sort(),
    updatedAt: nowIso24()
  };
  writeState3(projectDir, next);
  return next.enabled;
}

// src/skills/sync.ts
import { createHash as createHash13 } from "node:crypto";
import * as fs42 from "node:fs";
import * as os6 from "node:os";
import * as path43 from "node:path";
var DEFAULT_STATE3 = {
  version: 1,
  updatedAt: (/* @__PURE__ */ new Date(0)).toISOString(),
  sourcePacks: {},
  importPlans: {},
  pinnedReleases: {}
};
var TRUSTED_SOURCE_ALLOWLIST = [
  /^https?:\/\/github\.com\/(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i,
  /^git@github\.com:(openclaw|openclaw-girl-agent|Yeachan-Heo|code-yeongyu|SumeLabs|MemTensor|mmy4shadow)\//i
];
function nowIso25(options) {
  return options?.now?.() ?? (/* @__PURE__ */ new Date()).toISOString();
}
function stateFile2(projectDir) {
  return path43.join(getMiyaRuntimeDir(projectDir), "ecosystem-bridge.json");
}
function readState2(projectDir) {
  const file3 = stateFile2(projectDir);
  if (!fs42.existsSync(file3)) return { ...DEFAULT_STATE3 };
  try {
    const parsed = JSON.parse(fs42.readFileSync(file3, "utf-8"));
    return {
      version: 1,
      updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : (/* @__PURE__ */ new Date(0)).toISOString(),
      sourcePacks: parsed.sourcePacks && typeof parsed.sourcePacks === "object" ? parsed.sourcePacks : {},
      importPlans: parsed.importPlans && typeof parsed.importPlans === "object" ? parsed.importPlans : {},
      pinnedReleases: parsed.pinnedReleases && typeof parsed.pinnedReleases === "object" ? parsed.pinnedReleases : {}
    };
  } catch {
    return { ...DEFAULT_STATE3 };
  }
}
function writeState4(projectDir, state2, options) {
  const file3 = stateFile2(projectDir);
  fs42.mkdirSync(path43.dirname(file3), { recursive: true });
  const next = {
    ...state2,
    version: 1,
    updatedAt: nowIso25(options)
  };
  fs42.writeFileSync(file3, `${JSON.stringify(next, null, 2)}
`, "utf-8");
}
function runGit(args, cwd) {
  const proc = runProcessSync("git", args, {
    cwd
  });
  return {
    exitCode: proc.exitCode,
    stdout: proc.stdout.trim(),
    stderr: proc.stderr.trim()
  };
}
function git(options, args, cwd) {
  return (options?.gitRunner ?? runGit)(args, cwd);
}
function normalizeText5(value) {
  const trimmed = value?.trim();
  if (!trimmed) return void 0;
  return trimmed;
}
function defaultSourceRoots(projectDir) {
  return [
    path43.join(projectDir, "skills"),
    path43.join(os6.homedir(), ".config", "opencode", "miya", "skills")
  ];
}
function listSkillReposFromRoot(rootDir) {
  if (!fs42.existsSync(rootDir)) return [];
  return fs42.readdirSync(rootDir, { withFileTypes: true }).filter((entry2) => entry2.isDirectory()).map((entry2) => path43.join(rootDir, entry2.name)).filter((dir) => {
    return fs42.existsSync(path43.join(dir, "SKILL.md")) && fs42.existsSync(path43.join(dir, ".git"));
  });
}
function sanitizeIdSegment(input) {
  return input.replace(/[^a-zA-Z0-9_-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
}
function buildSourcePackID(repo, localDir) {
  const base = sanitizeIdSegment(path43.basename(localDir) || "source-pack") || "source-pack";
  const fingerprint = createHash13("sha256").update(`${repo ?? ""}|${path43.resolve(localDir)}`).digest("hex").slice(0, 12);
  return `${base}-${fingerprint}`;
}
function trustLevelForRepo(repo) {
  if (!repo) return "unknown";
  return TRUSTED_SOURCE_ALLOWLIST.some((rule) => rule.test(repo)) ? "allowlisted" : "untrusted";
}
function resolveSkillName(localDir) {
  const manifest = path43.join(localDir, "SKILL.md");
  if (!fs42.existsSync(manifest)) return path43.basename(localDir);
  try {
    const raw = fs42.readFileSync(manifest, "utf-8");
    const heading = /^#\s+(.+)$/m.exec(raw)?.[1]?.trim();
    if (heading) return heading;
  } catch {
  }
  return path43.basename(localDir);
}
function readGitValue(options, cwd, args) {
  const result = git(options, args, cwd);
  if (result.exitCode !== 0) return void 0;
  return normalizeText5(result.stdout);
}
function resolveUpstreamRef(localDir, branch, options) {
  const upstream = readGitValue(options, localDir, [
    "rev-parse",
    "--abbrev-ref",
    "--symbolic-full-name",
    "@{upstream}"
  ]);
  if (upstream) return upstream;
  if (branch && branch !== "HEAD") return `origin/${branch}`;
  return "origin/HEAD";
}
function resolveRevision(localDir, ref, options) {
  const resolved = readGitValue(options, localDir, ["rev-parse", `${ref}^{commit}`]);
  if (!resolved) {
    throw new Error(`source_pack_revision_unresolved:${ref}`);
  }
  return resolved;
}
function requireCleanWorkingTree(localDir, options) {
  const status = git(options, ["status", "--porcelain"], localDir);
  if (status.exitCode !== 0) {
    throw new Error(status.stderr || "source_pack_status_failed");
  }
  if (status.stdout.trim()) {
    throw new Error("source_pack_dirty_worktree");
  }
}
function discoverSourcePacks(projectDir, state2, options) {
  const roots = options?.sourceRoots?.length ? options.sourceRoots : defaultSourceRoots(projectDir);
  const dirs = /* @__PURE__ */ new Set();
  for (const root of roots) {
    for (const repoDir of listSkillReposFromRoot(root)) {
      dirs.add(path43.resolve(repoDir));
    }
  }
  const packs = [];
  for (const localDir of [...dirs]) {
    const headRevision = readGitValue(options, localDir, ["rev-parse", "HEAD"]);
    if (!headRevision) continue;
    const repo = readGitValue(options, localDir, ["config", "--get", "remote.origin.url"]);
    const branch = readGitValue(options, localDir, ["rev-parse", "--abbrev-ref", "HEAD"]) ?? "HEAD";
    const sourcePackID = buildSourcePackID(repo, localDir);
    const sourceState = state2.sourcePacks[sourcePackID];
    const importPlan = state2.importPlans[sourcePackID];
    const pinnedRelease = state2.pinnedReleases[sourcePackID];
    packs.push({
      sourcePackID,
      name: path43.basename(localDir),
      skillName: resolveSkillName(localDir),
      repo,
      localDir,
      branch,
      headRevision,
      latestRevision: sourceState?.latestRevision,
      lastPulledAt: sourceState?.lastPulledAt,
      trustLevel: trustLevelForRepo(repo),
      importPlan,
      pinnedRelease
    });
  }
  return packs.sort((a, b) => {
    const byName = a.name.localeCompare(b.name);
    if (byName !== 0) return byName;
    return a.sourcePackID.localeCompare(b.sourcePackID);
  });
}
function requireSourcePack(projectDir, sourcePackID, options) {
  const state2 = readState2(projectDir);
  const packs = discoverSourcePacks(projectDir, state2, options);
  const sourcePack = packs.find((item) => item.sourcePackID === sourcePackID);
  if (!sourcePack) throw new Error(`unknown_source_pack:${sourcePackID}`);
  return { state: state2, sourcePack };
}
function ensureImportPlan(state2, sourcePack, options) {
  const existing = state2.importPlans[sourcePack.sourcePackID];
  if (existing) {
    const refreshed = {
      ...existing,
      sourcePackID: sourcePack.sourcePackID,
      localDir: sourcePack.localDir,
      updatedAt: nowIso25(options)
    };
    state2.importPlans[sourcePack.sourcePackID] = refreshed;
    return refreshed;
  }
  const created = {
    sourcePackID: sourcePack.sourcePackID,
    localDir: sourcePack.localDir,
    importMode: "skills_only",
    permissionMode: "sandbox_read_only",
    createdAt: nowIso25(options),
    updatedAt: nowIso25(options)
  };
  state2.importPlans[sourcePack.sourcePackID] = created;
  return created;
}
function updateSourcePackState(state2, sourcePack, patch) {
  const current = state2.sourcePacks[sourcePack.sourcePackID];
  state2.sourcePacks[sourcePack.sourcePackID] = {
    sourcePackID: sourcePack.sourcePackID,
    repo: sourcePack.repo,
    localDir: sourcePack.localDir,
    latestRevision: current?.latestRevision,
    lastPulledAt: current?.lastPulledAt,
    lastError: current?.lastError,
    ...patch
  };
}
function listEcosystemBridge(projectDir, options) {
  const state2 = readState2(projectDir);
  const sourcePacks = discoverSourcePacks(projectDir, state2, options);
  const bySkillName = /* @__PURE__ */ new Map();
  for (const pack of sourcePacks) {
    const key = pack.skillName.toLowerCase();
    const list = bySkillName.get(key) ?? [];
    list.push(pack);
    bySkillName.set(key, list);
  }
  const conflicts = [];
  for (const [, list] of bySkillName.entries()) {
    if (list.length <= 1) continue;
    conflicts.push({
      type: "skill_name_collision",
      skillName: list[0].skillName,
      sourcePackIDs: list.map((item) => item.sourcePackID).sort()
    });
  }
  const importPlans = Object.values(state2.importPlans).sort(
    (a, b) => a.sourcePackID.localeCompare(b.sourcePackID)
  );
  const pinnedReleases = Object.values(state2.pinnedReleases).sort(
    (a, b) => a.sourcePackID.localeCompare(b.sourcePackID)
  );
  return {
    sourcePacks,
    importPlans,
    pinnedReleases,
    conflicts: conflicts.sort((a, b) => a.skillName.localeCompare(b.skillName))
  };
}
function pullSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pull = git(options, ["fetch", "--prune", "origin"], resolved.sourcePack.localDir);
  if (pull.exitCode !== 0) {
    updateSourcePackState(resolved.state, resolved.sourcePack, {
      lastError: pull.stderr || "source_pack_fetch_failed"
    });
    writeState4(projectDir, resolved.state, options);
    throw new Error(pull.stderr || "source_pack_fetch_failed");
  }
  const compareRef = resolveUpstreamRef(
    resolved.sourcePack.localDir,
    resolved.sourcePack.branch,
    options
  );
  const latestRevision = resolveRevision(resolved.sourcePack.localDir, compareRef, options);
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision,
    lastPulledAt: nowIso25(options),
    lastError: void 0
  });
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    latestRevision,
    compareRef,
    pulledAt: nowIso25(options)
  };
}
function diffSourcePack(projectDir, sourcePackID, options) {
  const { state: state2, sourcePack } = requireSourcePack(projectDir, sourcePackID, options);
  const compareRef = state2.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(sourcePack.localDir, sourcePack.branch, options);
  const compareRevision = resolveRevision(sourcePack.localDir, compareRef, options);
  const count = git(
    options,
    ["rev-list", "--left-right", "--count", `HEAD...${compareRevision}`],
    sourcePack.localDir
  );
  if (count.exitCode !== 0) {
    throw new Error(count.stderr || "source_pack_diff_failed");
  }
  const [aheadRaw, behindRaw] = count.stdout.split(/\s+/);
  const ahead = Number.parseInt(aheadRaw ?? "0", 10) || 0;
  const behind = Number.parseInt(behindRaw ?? "0", 10) || 0;
  const logResult = git(
    options,
    ["log", "--oneline", "--max-count", "20", `HEAD..${compareRevision}`],
    sourcePack.localDir
  );
  const pendingCommits = logResult.exitCode === 0 && logResult.stdout ? logResult.stdout.split("\n").map((line) => line.trim()).filter(Boolean) : [];
  return {
    sourcePackID,
    localDir: sourcePack.localDir,
    headRevision: sourcePack.headRevision,
    compareRevision,
    compareRef,
    ahead,
    behind,
    pendingCommits,
    pinnedRelease: state2.pinnedReleases[sourcePackID]
  };
}
function applySourcePack(projectDir, sourcePackID, input = {}, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const targetRef = normalizeText5(input.revision) ?? resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? resolveUpstreamRef(resolved.sourcePack.localDir, resolved.sourcePack.branch, options);
  const targetRevision = resolveRevision(resolved.sourcePack.localDir, targetRef, options);
  const previousRevision = resolved.sourcePack.headRevision;
  if (previousRevision !== targetRevision) {
    const checkout = git(
      options,
      ["checkout", "--detach", targetRevision],
      resolved.sourcePack.localDir
    );
    if (checkout.exitCode !== 0) {
      throw new Error(checkout.stderr || "source_pack_apply_failed");
    }
  }
  ensureImportPlan(resolved.state, resolved.sourcePack, options);
  updateSourcePackState(resolved.state, resolved.sourcePack, {
    latestRevision: resolved.state.sourcePacks[sourcePackID]?.latestRevision ?? targetRevision,
    lastError: void 0
  });
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : resolved.state.pinnedReleases[sourcePackID]?.previousRevision,
    appliedAt: nowIso25(options)
  };
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    appliedRevision: targetRevision,
    previousRevision: previousRevision !== targetRevision ? previousRevision : void 0,
    detachedHead: true
  };
}
function rollbackSourcePack(projectDir, sourcePackID, options) {
  const resolved = requireSourcePack(projectDir, sourcePackID, options);
  const pinned = resolved.state.pinnedReleases[sourcePackID];
  if (!pinned?.previousRevision) {
    throw new Error(`source_pack_rollback_unavailable:${sourcePackID}`);
  }
  requireCleanWorkingTree(resolved.sourcePack.localDir, options);
  const previousRevision = resolved.sourcePack.headRevision;
  const rollbackRevision = resolveRevision(
    resolved.sourcePack.localDir,
    pinned.previousRevision,
    options
  );
  const checkout = git(
    options,
    ["checkout", "--detach", rollbackRevision],
    resolved.sourcePack.localDir
  );
  if (checkout.exitCode !== 0) {
    throw new Error(checkout.stderr || "source_pack_rollback_failed");
  }
  resolved.state.pinnedReleases[sourcePackID] = {
    sourcePackID,
    revision: rollbackRevision,
    previousRevision,
    appliedAt: nowIso25(options)
  };
  writeState4(projectDir, resolved.state, options);
  return {
    sourcePackID,
    localDir: resolved.sourcePack.localDir,
    rolledBackTo: rollbackRevision,
    previousRevision,
    detachedHead: true
  };
}

// src/mcp/context7.ts
var context7 = {
  type: "remote",
  url: "https://mcp.context7.com/mcp",
  headers: process.env.CONTEXT7_API_KEY ? { CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY } : void 0,
  oauth: false,
  capabilities: {
    sampling: false,
    mcpUi: false
  }
};

// src/mcp/grep-app.ts
var grep_app = {
  type: "remote",
  url: "https://mcp.grep.app",
  oauth: false,
  capabilities: {
    sampling: false,
    mcpUi: false
  }
};

// src/mcp/websearch.ts
var websearch = {
  type: "remote",
  url: "https://mcp.exa.ai/mcp?tools=web_search_exa",
  headers: process.env.EXA_API_KEY ? { "x-api-key": process.env.EXA_API_KEY } : void 0,
  oauth: false,
  capabilities: {
    sampling: false,
    mcpUi: false
  }
};

// src/mcp/index.ts
var allBuiltinMcps = {
  websearch,
  context7,
  grep_app
};
function createBuiltinMcps(disabledMcps = []) {
  return Object.fromEntries(
    Object.entries(allBuiltinMcps).filter(
      ([name]) => !disabledMcps.includes(name)
    )
  );
}
function buildMcpServiceManifest(disabledMcps = []) {
  const builtins = createBuiltinMcps(disabledMcps);
  const mcps = Object.entries(builtins).map(([name, config3]) => {
    const caps = "capabilities" in config3 ? config3.capabilities : void 0;
    return {
      name,
      type: config3.type,
      sampling: Boolean(caps?.sampling),
      mcpUi: Boolean(caps?.mcpUi),
      serviceExpose: Boolean(caps?.serviceExpose)
    };
  });
  return {
    service: "miya-control-plane",
    version: 2,
    generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    mcps,
    controlPlaneEndpoints: [
      "gateway.status.get",
      "gateway.backpressure.stats",
      "daemon.backpressure.stats",
      "provider.override.audit.list",
      "mcp.capabilities.list",
      "mcp.service.expose"
    ]
  };
}

// src/autoflow/state.ts
import * as fs43 from "node:fs";
import * as path44 from "node:path";
var DEFAULT_MAX_FIX_ROUNDS = 3;
var MAX_HISTORY = 120;
function nowIso26() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function stateFilePath(projectDir) {
  return path44.join(getMiyaRuntimeDir(projectDir), "autoflow-state.json");
}
function ensureRuntimeDir(projectDir) {
  fs43.mkdirSync(path44.dirname(stateFilePath(projectDir)), { recursive: true });
}
function normalizeFixRounds(value) {
  if (!Number.isFinite(value)) return DEFAULT_MAX_FIX_ROUNDS;
  return Math.max(1, Math.min(10, Math.floor(Number(value))));
}
function normalizeState(sessionID2, raw) {
  const createdAt = raw?.createdAt ?? nowIso26();
  const history = Array.isArray(raw?.history) ? raw?.history.slice(-MAX_HISTORY).map((item) => ({
    at: String(item.at ?? createdAt),
    phase: item.phase ?? "planning",
    event: String(item.event ?? "unknown"),
    summary: String(item.summary ?? "")
  })) : [];
  const fixCommands = Array.isArray(raw?.fixCommands) ? raw.fixCommands.map(String).map((item) => item.trim()).filter(Boolean) : [];
  const recentVerificationHashes = Array.isArray(raw?.recentVerificationHashes) ? raw.recentVerificationHashes.map(String).slice(-3) : [];
  const planTasks = Array.isArray(raw?.planTasks) ? raw.planTasks : [];
  return {
    sessionID: sessionID2,
    goal: String(raw?.goal ?? "").trim(),
    phase: raw?.phase ?? "planning",
    createdAt,
    updatedAt: raw?.updatedAt ?? createdAt,
    maxFixRounds: normalizeFixRounds(raw?.maxFixRounds),
    fixRound: Number.isFinite(raw?.fixRound) ? Math.max(0, Math.floor(Number(raw?.fixRound))) : 0,
    verificationCommand: raw?.verificationCommand ? String(raw.verificationCommand) : void 0,
    fixCommands,
    planTasks,
    recentVerificationHashes,
    lastError: raw?.lastError ? String(raw.lastError) : void 0,
    lastDag: raw?.lastDag && Number.isFinite(raw.lastDag.total) ? {
      total: Math.max(0, Math.floor(Number(raw.lastDag.total))),
      completed: Math.max(0, Math.floor(Number(raw.lastDag.completed))),
      failed: Math.max(0, Math.floor(Number(raw.lastDag.failed))),
      blocked: Math.max(0, Math.floor(Number(raw.lastDag.blocked)))
    } : void 0,
    history
  };
}
function readStore8(projectDir) {
  const file3 = stateFilePath(projectDir);
  if (!fs43.existsSync(file3)) return { sessions: {} };
  try {
    const parsed = JSON.parse(fs43.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || !parsed.sessions) {
      return { sessions: {} };
    }
    const sessions = {};
    for (const [sessionID2, state2] of Object.entries(parsed.sessions)) {
      sessions[sessionID2] = normalizeState(sessionID2, state2);
    }
    return { sessions };
  } catch {
    return { sessions: {} };
  }
}
function writeStore8(projectDir, store2) {
  ensureRuntimeDir(projectDir);
  fs43.writeFileSync(stateFilePath(projectDir), `${JSON.stringify(store2, null, 2)}
`, "utf-8");
}
function loadAutoflowSession(projectDir, sessionID2) {
  const store2 = readStore8(projectDir);
  return store2.sessions[sessionID2] ?? null;
}
function listAutoflowSessions(projectDir, limit = 50) {
  const store2 = readStore8(projectDir);
  return Object.values(store2.sessions).sort((a, b) => Date.parse(b.updatedAt) - Date.parse(a.updatedAt)).slice(0, Math.max(1, Math.min(200, limit)));
}
function getAutoflowSession(projectDir, sessionID2) {
  return loadAutoflowSession(projectDir, sessionID2) ?? normalizeState(sessionID2);
}
function saveAutoflowSession(projectDir, session) {
  const store2 = readStore8(projectDir);
  const normalized = normalizeState(session.sessionID, {
    ...session,
    updatedAt: nowIso26()
  });
  store2.sessions[session.sessionID] = normalized;
  writeStore8(projectDir, store2);
  return normalized;
}
function appendAutoflowHistory(session, event, summary) {
  const record3 = {
    at: nowIso26(),
    phase: session.phase,
    event,
    summary
  };
  session.history = [...session.history, record3].slice(-MAX_HISTORY);
  return session;
}
function configureAutoflowSession(projectDir, input) {
  const current = getAutoflowSession(projectDir, input.sessionID);
  const next = {
    ...current,
    goal: typeof input.goal === "string" ? input.goal.trim() : current.goal,
    planTasks: Array.isArray(input.tasks) && input.tasks.length > 0 ? input.tasks : current.planTasks,
    verificationCommand: typeof input.verificationCommand === "string" ? input.verificationCommand.trim() || void 0 : current.verificationCommand,
    fixCommands: Array.isArray(input.fixCommands) ? input.fixCommands.map(String).map((item) => item.trim()).filter(Boolean) : current.fixCommands,
    maxFixRounds: typeof input.maxFixRounds === "number" ? normalizeFixRounds(input.maxFixRounds) : current.maxFixRounds,
    phase: input.phase ?? current.phase
  };
  if (next.phase === "planning") {
    next.fixRound = 0;
    next.recentVerificationHashes = [];
    next.lastError = void 0;
  }
  return saveAutoflowSession(projectDir, next);
}
function stopAutoflowSession(projectDir, sessionID2) {
  const current = getAutoflowSession(projectDir, sessionID2);
  current.phase = "stopped";
  appendAutoflowHistory(current, "stopped", "Session stopped by operator.");
  return saveAutoflowSession(projectDir, current);
}

// src/autoflow/engine.ts
import { createHash as createHash14 } from "node:crypto";

// src/ultrawork/scheduler.ts
function buildNodes(tasks) {
  const normalized = tasks.filter((task) => task.agent.trim() && task.prompt.trim()).slice(0, 40);
  return normalized.map((task, index) => ({
    nodeID: task.id?.trim() || `node_${index + 1}`,
    agent: task.agent.trim(),
    prompt: task.prompt.trim(),
    description: task.description.trim() || task.prompt.trim().slice(0, 80),
    dependsOn: Array.isArray(task.dependsOn) ? task.dependsOn.map(String).map((item) => item.trim()).filter(Boolean) : [],
    timeoutMs: Math.max(5e3, Math.min(20 * 6e4, Number(task.timeoutMs ?? 12e4))),
    maxRetries: Math.max(0, Math.min(3, Math.floor(Number(task.maxRetries ?? 0))))
  }));
}
function hasCycle(nodes) {
  const edges = new Map(nodes.map((node) => [node.nodeID, node.dependsOn]));
  const visiting = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  const dfs = (id) => {
    if (visiting.has(id)) return true;
    if (visited.has(id)) return false;
    visiting.add(id);
    for (const dep of edges.get(id) ?? []) {
      if (edges.has(dep) && dfs(dep)) return true;
    }
    visiting.delete(id);
    visited.add(id);
    return false;
  };
  for (const node of nodes) {
    if (dfs(node.nodeID)) return true;
  }
  return false;
}
function launchUltraworkTasks(input) {
  const nodes = buildNodes(input.tasks);
  return nodes.map((task) => {
    const launched = input.manager.launch({
      agent: task.agent,
      prompt: task.prompt,
      description: task.description,
      parentSessionId: input.parentSessionID
    });
    return {
      nodeID: task.nodeID,
      taskID: launched.id,
      agent: launched.agent,
      status: String(launched.status)
    };
  });
}
async function runUltraworkDag(input) {
  const nodes = buildNodes(input.tasks);
  if (nodes.length === 0) {
    return { total: 0, completed: 0, failed: 0, blocked: 0, nodes: [] };
  }
  if (hasCycle(nodes)) {
    return {
      total: nodes.length,
      completed: 0,
      failed: 0,
      blocked: nodes.length,
      nodes: nodes.map((item) => ({
        nodeID: item.nodeID,
        agent: item.agent,
        status: "blocked_dependency",
        retries: 0,
        error: "dag_cycle_detected"
      }))
    };
  }
  const maxParallel = Math.max(1, Math.min(8, Math.floor(Number(input.maxParallel ?? 3))));
  const nodeMap = new Map(nodes.map((node) => [node.nodeID, node]));
  const pending = new Set(nodes.map((item) => item.nodeID));
  const running = /* @__PURE__ */ new Set();
  const results = /* @__PURE__ */ new Map();
  const retries = /* @__PURE__ */ new Map();
  const canRun = (node) => {
    for (const dependency of node.dependsOn) {
      const status = results.get(dependency)?.status;
      if (!status) return false;
      if (status !== "completed") return false;
    }
    return true;
  };
  const runNode = async (node) => {
    const launched = input.manager.launch({
      agent: node.agent,
      prompt: node.prompt,
      description: node.description,
      parentSessionId: input.parentSessionID
    });
    const task = await input.manager.waitForCompletion(launched.id, node.timeoutMs);
    const status = String(task?.status ?? "timeout");
    const attempts = retries.get(node.nodeID) ?? 0;
    if ((status === "failed" || status === "timeout" || status === "cancelled") && attempts < node.maxRetries) {
      retries.set(node.nodeID, attempts + 1);
      pending.add(node.nodeID);
      return;
    }
    results.set(node.nodeID, {
      nodeID: node.nodeID,
      agent: node.agent,
      status,
      retries: attempts,
      taskID: launched.id,
      error: status === "failed" || status === "timeout" || status === "cancelled" ? `task_${status}` : void 0
    });
  };
  while (pending.size > 0 || running.size > 0) {
    const ready = [...pending].map((nodeID) => nodeMap.get(nodeID)).filter((node) => Boolean(node)).filter((node) => canRun(node));
    for (const node of ready) {
      if (running.size >= maxParallel) break;
      pending.delete(node.nodeID);
      running.add(node.nodeID);
      void runNode(node).finally(() => {
        running.delete(node.nodeID);
      });
    }
    const blocked2 = [...pending].map((nodeID) => nodeMap.get(nodeID)).filter((node) => Boolean(node)).filter((node) => node.dependsOn.some((dep) => {
      const depStatus = results.get(dep)?.status;
      return depStatus === "failed" || depStatus === "cancelled" || depStatus === "timeout" || depStatus === "blocked_dependency";
    }));
    for (const node of blocked2) {
      pending.delete(node.nodeID);
      results.set(node.nodeID, {
        nodeID: node.nodeID,
        agent: node.agent,
        status: "blocked_dependency",
        retries: retries.get(node.nodeID) ?? 0,
        error: "dependency_failed"
      });
    }
    if (running.size === 0 && ready.length === 0 && blocked2.length === 0 && pending.size > 0) {
      for (const nodeID of pending) {
        const node = nodeMap.get(nodeID);
        if (!node) continue;
        results.set(node.nodeID, {
          nodeID: node.nodeID,
          agent: node.agent,
          status: "blocked_dependency",
          retries: retries.get(node.nodeID) ?? 0,
          error: "dependency_missing"
        });
      }
      pending.clear();
      break;
    }
    if (running.size > 0) {
      await new Promise((resolve7) => setTimeout(resolve7, 60));
    }
  }
  const nodeResults = nodes.map((node) => {
    const result = results.get(node.nodeID);
    return result ?? {
      nodeID: node.nodeID,
      agent: node.agent,
      status: "blocked_dependency",
      retries: retries.get(node.nodeID) ?? 0,
      error: "unknown_state"
    };
  });
  const completed = nodeResults.filter((item) => item.status === "completed").length;
  const failed = nodeResults.filter(
    (item) => item.status === "failed" || item.status === "cancelled" || item.status === "timeout"
  ).length;
  const blocked = nodeResults.filter((item) => item.status === "blocked_dependency").length;
  return {
    total: nodeResults.length,
    completed,
    failed,
    blocked,
    nodes: nodeResults
  };
}

// src/autoflow/engine.ts
var DEFAULT_TIMEOUT_MS2 = 9e4;
var RUN_LOOP_LIMIT = 40;
function hashText2(input) {
  return createHash14("sha256").update(input).digest("hex").slice(0, 16);
}
function runShellCommand(command, timeoutMs, cwd) {
  const startedAt = Date.now();
  const shellArgs = process.platform === "win32" ? ["powershell", "-NoProfile", "-Command", command] : ["sh", "-lc", command];
  const proc = runProcessSync(shellArgs[0], shellArgs.slice(1), {
    cwd,
    timeout: Math.max(1e3, Math.min(timeoutMs, 10 * 60 * 1e3))
  });
  return {
    command,
    ok: proc.exitCode === 0 && !proc.timedOut,
    exitCode: proc.exitCode,
    stdout: proc.stdout,
    stderr: proc.stderr,
    durationMs: Date.now() - startedAt
  };
}
function normalizeTasks(input) {
  if (!Array.isArray(input)) return [];
  return input.filter((task) => task?.agent?.trim() && task.prompt?.trim()).map((task, index) => ({
    id: task.id?.trim() || `task_${index + 1}`,
    agent: task.agent.trim(),
    prompt: task.prompt.trim(),
    description: task.description?.trim() || task.prompt.trim().slice(0, 120),
    dependsOn: Array.isArray(task.dependsOn) ? task.dependsOn.map(String).map((dep) => dep.trim()).filter(Boolean) : [],
    timeoutMs: typeof task.timeoutMs === "number" && Number.isFinite(task.timeoutMs) ? Number(task.timeoutMs) : void 0,
    maxRetries: typeof task.maxRetries === "number" && Number.isFinite(task.maxRetries) ? Number(task.maxRetries) : void 0
  }));
}
function normalizeFixCommands(input) {
  if (!Array.isArray(input)) return [];
  return input.map(String).map((item) => item.trim()).filter(Boolean);
}
function setFailed(state2, reason) {
  state2.phase = "failed";
  state2.lastError = reason;
  appendAutoflowHistory(state2, "failed", reason);
}
function setCompleted(state2, reason) {
  state2.phase = "completed";
  state2.lastError = void 0;
  appendAutoflowHistory(state2, "completed", reason);
}
function verificationFailureReason(result) {
  const text = result.stderr.trim() || result.stdout.trim();
  return text.slice(0, 220) || `verification_exit=${result.exitCode}`;
}
async function runAutoflow(input) {
  const timeoutMs = typeof input.timeoutMs === "number" && Number.isFinite(input.timeoutMs) ? Math.max(1e3, Math.floor(input.timeoutMs)) : DEFAULT_TIMEOUT_MS2;
  const runCommand5 = input.runCommand ?? runShellCommand;
  const runDag = input.runDag ?? runUltraworkDag;
  if (input.forceRestart) {
    configureAutoflowSession(input.projectDir, {
      sessionID: input.sessionID,
      goal: input.goal,
      tasks: normalizeTasks(input.tasks),
      verificationCommand: input.verificationCommand,
      fixCommands: normalizeFixCommands(input.fixCommands),
      maxFixRounds: input.maxFixRounds,
      phase: "planning"
    });
  }
  let state2 = getAutoflowSession(input.projectDir, input.sessionID);
  if (input.goal?.trim()) state2.goal = input.goal.trim();
  if (input.tasks) state2.planTasks = normalizeTasks(input.tasks);
  if (input.verificationCommand !== void 0) {
    const command = String(input.verificationCommand).trim();
    state2.verificationCommand = command || void 0;
  }
  if (input.fixCommands) {
    state2.fixCommands = normalizeFixCommands(input.fixCommands);
  }
  if (typeof input.maxFixRounds === "number" && Number.isFinite(input.maxFixRounds)) {
    state2.maxFixRounds = Math.max(1, Math.min(10, Math.floor(input.maxFixRounds)));
  }
  if (state2.phase === "stopped") {
    state2 = saveAutoflowSession(input.projectDir, state2);
    return {
      success: false,
      phase: state2.phase,
      summary: "autoflow_stopped",
      state: state2
    };
  }
  if (state2.phase === "completed" || state2.phase === "failed") {
    if (input.forceRestart) {
      state2.phase = "planning";
      state2.fixRound = 0;
      state2.recentVerificationHashes = [];
      state2.lastError = void 0;
      appendAutoflowHistory(state2, "restarted", "State reset for new run.");
    } else {
      state2 = saveAutoflowSession(input.projectDir, state2);
      return {
        success: state2.phase === "completed",
        phase: state2.phase,
        summary: `autoflow_${state2.phase}`,
        state: state2
      };
    }
  }
  let dagResult;
  let verification;
  let fixResult;
  for (let loop = 0; loop < RUN_LOOP_LIMIT; loop += 1) {
    if (state2.phase === "planning") {
      if (state2.planTasks.length === 0) {
        appendAutoflowHistory(state2, "planning_waiting", "No executable tasks in plan.");
        state2 = saveAutoflowSession(input.projectDir, state2);
        return {
          success: false,
          phase: state2.phase,
          summary: "planning_requires_tasks",
          state: state2
        };
      }
      state2.phase = "execution";
      appendAutoflowHistory(
        state2,
        "planning_complete",
        `Plan accepted with ${state2.planTasks.length} task(s).`
      );
      continue;
    }
    if (state2.phase === "execution") {
      try {
        dagResult = await runDag({
          manager: input.manager,
          parentSessionID: input.sessionID,
          tasks: state2.planTasks,
          maxParallel: typeof input.maxParallel === "number" && Number.isFinite(input.maxParallel) ? Number(input.maxParallel) : void 0
        });
      } catch (error92) {
        setFailed(state2, `execution_exception:${error92 instanceof Error ? error92.message : String(error92)}`);
        break;
      }
      state2.lastDag = {
        total: dagResult.total,
        completed: dagResult.completed,
        failed: dagResult.failed,
        blocked: dagResult.blocked
      };
      if (dagResult.total === 0) {
        setFailed(state2, "execution_empty_dag");
        break;
      }
      if (dagResult.failed > 0 || dagResult.blocked > 0) {
        const reason = `execution_not_clean failed=${dagResult.failed} blocked=${dagResult.blocked}`;
        if (state2.fixCommands.length === 0) {
          setFailed(state2, `${reason} (no fix commands configured)`);
          break;
        }
        state2.lastError = reason;
        state2.phase = "fixing";
        appendAutoflowHistory(state2, "execution_failed", reason);
        continue;
      }
      state2.phase = "verification";
      appendAutoflowHistory(state2, "execution_complete", "Parallel execution completed.");
      continue;
    }
    if (state2.phase === "verification") {
      if (!state2.verificationCommand) {
        setCompleted(state2, "verification_skipped_no_command");
        break;
      }
      verification = runCommand5(state2.verificationCommand, timeoutMs, input.workingDirectory);
      if (verification.ok) {
        setCompleted(state2, "verification_passed");
        break;
      }
      const hash3 = hashText2(`${verification.stderr}
${verification.stdout}`);
      state2.recentVerificationHashes = [...state2.recentVerificationHashes, hash3].slice(-3);
      const repeatedFailure = state2.recentVerificationHashes.length >= 3 && state2.recentVerificationHashes.every((item) => item === hash3);
      const reason = verificationFailureReason(verification);
      if (repeatedFailure) {
        setFailed(state2, `verification_repeated_failure:${reason}`);
        break;
      }
      if (state2.fixRound >= state2.maxFixRounds) {
        setFailed(state2, `verification_failed_max_fix_rounds:${reason}`);
        break;
      }
      if (state2.fixCommands.length === 0) {
        setFailed(state2, `verification_failed_no_fix_commands:${reason}`);
        break;
      }
      state2.lastError = reason;
      state2.phase = "fixing";
      appendAutoflowHistory(state2, "verification_failed", reason);
      continue;
    }
    if (state2.phase === "fixing") {
      if (state2.fixRound >= state2.maxFixRounds) {
        setFailed(state2, "fix_round_limit_reached");
        break;
      }
      const fixCommand = state2.fixCommands[state2.fixRound];
      if (!fixCommand) {
        setFailed(state2, `missing_fix_command_at_round_${state2.fixRound + 1}`);
        break;
      }
      fixResult = runCommand5(fixCommand, timeoutMs, input.workingDirectory);
      state2.fixRound += 1;
      appendAutoflowHistory(
        state2,
        "fix_attempt",
        `round=${state2.fixRound} ok=${fixResult.ok} exit=${fixResult.exitCode}`
      );
      state2.phase = "verification";
      continue;
    }
    break;
  }
  state2 = saveAutoflowSession(input.projectDir, state2);
  const success3 = state2.phase === "completed";
  return {
    success: success3,
    phase: state2.phase,
    summary: success3 ? "autoflow_completed" : state2.lastError ?? `autoflow_${state2.phase}`,
    state: state2,
    dagResult,
    verification,
    fixResult
  };
}

// src/autoflow/persistent.ts
import * as fs44 from "node:fs";
import * as path45 from "node:path";
var DEFAULT_CONFIG = {
  enabled: true,
  resumeCooldownMs: 2500,
  maxAutoResumes: 8,
  maxConsecutiveResumeFailures: 3,
  resumeTimeoutMs: 9e4
};
function storeFile2(projectDir) {
  return path45.join(getMiyaRuntimeDir(projectDir), "autoflow-persistent.json");
}
function nowIso27() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function clamp4(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function normalizeConfig(raw) {
  return {
    enabled: raw?.enabled !== false,
    resumeCooldownMs: clamp4(
      Number(raw?.resumeCooldownMs ?? DEFAULT_CONFIG.resumeCooldownMs),
      500,
      12e4
    ),
    maxAutoResumes: clamp4(
      Number(raw?.maxAutoResumes ?? DEFAULT_CONFIG.maxAutoResumes),
      1,
      50
    ),
    maxConsecutiveResumeFailures: clamp4(
      Number(
        raw?.maxConsecutiveResumeFailures ?? DEFAULT_CONFIG.maxConsecutiveResumeFailures
      ),
      1,
      20
    ),
    resumeTimeoutMs: clamp4(
      Number(raw?.resumeTimeoutMs ?? DEFAULT_CONFIG.resumeTimeoutMs),
      3e3,
      10 * 6e4
    )
  };
}
function normalizeRuntime(sessionID2, raw) {
  return {
    sessionID: sessionID2,
    resumeAttempts: clamp4(Number(raw?.resumeAttempts ?? 0), 0, 1e3),
    resumeFailures: clamp4(Number(raw?.resumeFailures ?? 0), 0, 1e3),
    userStopped: Boolean(raw?.userStopped),
    lastStopAt: raw?.lastStopAt ? String(raw.lastStopAt) : void 0,
    lastStopType: raw?.lastStopType ? String(raw.lastStopType) : void 0,
    lastStopReason: raw?.lastStopReason ? String(raw.lastStopReason) : void 0,
    lastResumeAt: raw?.lastResumeAt ? String(raw.lastResumeAt) : void 0,
    lastOutcomePhase: raw?.lastOutcomePhase ? String(raw.lastOutcomePhase) : void 0,
    lastOutcomeSummary: raw?.lastOutcomeSummary ? String(raw.lastOutcomeSummary) : void 0
  };
}
function readStore9(projectDir) {
  const file3 = storeFile2(projectDir);
  if (!fs44.existsSync(file3)) return { config: DEFAULT_CONFIG, sessions: {} };
  try {
    const parsed = JSON.parse(
      fs44.readFileSync(file3, "utf-8")
    );
    const sessionsRaw = parsed.sessions && typeof parsed.sessions === "object" ? parsed.sessions : {};
    const sessions = Object.fromEntries(
      Object.entries(sessionsRaw).map(([sessionID2, runtime]) => [
        sessionID2,
        normalizeRuntime(sessionID2, runtime)
      ])
    );
    return {
      config: normalizeConfig(parsed.config),
      sessions
    };
  } catch {
    return { config: DEFAULT_CONFIG, sessions: {} };
  }
}
function writeStore9(projectDir, store2) {
  fs44.mkdirSync(path45.dirname(storeFile2(projectDir)), { recursive: true });
  const normalized = {
    config: normalizeConfig(store2.config),
    sessions: Object.fromEntries(
      Object.entries(store2.sessions).map(([sessionID2, runtime]) => [
        sessionID2,
        normalizeRuntime(sessionID2, runtime)
      ])
    )
  };
  fs44.writeFileSync(
    storeFile2(projectDir),
    `${JSON.stringify(normalized, null, 2)}
`,
    "utf-8"
  );
  return normalized;
}
function getSessionRuntime(projectDir, sessionID2) {
  const store2 = readStore9(projectDir);
  return store2.sessions[sessionID2] ?? normalizeRuntime(sessionID2);
}
function saveSessionRuntime(projectDir, runtime) {
  const store2 = readStore9(projectDir);
  store2.sessions[runtime.sessionID] = normalizeRuntime(
    runtime.sessionID,
    runtime
  );
  return writeStore9(projectDir, store2).sessions[runtime.sessionID];
}
function parseStopReason(event) {
  const statusReason = event.properties?.status?.reason;
  const topReason = event.properties?.reason;
  const source = event.properties?.status?.source ?? event.properties?.source;
  const text = [statusReason, topReason, source].map((item) => item ? String(item).trim() : "").filter(Boolean).join(" | ");
  return text || "unknown_stop_reason";
}
function isStopStatus(statusType) {
  return [
    "stopped",
    "stop",
    "error",
    "failed",
    "terminated",
    "aborted",
    "cancelled",
    "canceled"
  ].some((item) => statusType.includes(item));
}
function isUserInitiatedStop(reason) {
  return /(user|manual|operator|cancel_by_user|interrupted_by_user||||)/i.test(
    reason
  );
}
function isActiveAutoflowPhase(phase) {
  return phase === "planning" || phase === "execution" || phase === "verification" || phase === "fixing";
}
function toRecoveryReasonCode(input) {
  if (input.reason === "user_initiated_stop") return "RECOVERY_USER_STOP";
  if (input.reason === "persistent_disabled") return "RECOVERY_DISABLED";
  if (input.reason === "resume_cooldown") return "RECOVERY_COOLDOWN";
  if (input.reason === "persistent_resume_attempt_limit_reached")
    return "RECOVERY_ATTEMPT_EXHAUSTED";
  if (input.reason === "persistent_resume_failure_limit_reached")
    return "RECOVERY_FAILURE_EXHAUSTED";
  if (!input.resumed) return "RECOVERY_NOT_TRIGGERED";
  if (input.success) return "RECOVERY_RESUMED_OK";
  if (input.phase === "failed") return "RECOVERY_RESUMED_FAILED";
  return "RECOVERY_RESUMED";
}
function markPersistentExhausted(projectDir, sessionID2, reason) {
  const state2 = getAutoflowSession(projectDir, sessionID2);
  state2.phase = "failed";
  state2.lastError = reason;
  appendAutoflowHistory(state2, "persistent_exhausted", reason);
  saveAutoflowSession(projectDir, state2);
}
function readAutoflowPersistentConfig(projectDir) {
  return readStore9(projectDir).config;
}
function writeAutoflowPersistentConfig(projectDir, patch) {
  const store2 = readStore9(projectDir);
  store2.config = normalizeConfig({
    ...store2.config,
    ...patch
  });
  return writeStore9(projectDir, store2).config;
}
function getAutoflowPersistentRuntimeSnapshot(projectDir, limit = 50) {
  const store2 = readStore9(projectDir);
  return Object.values(store2.sessions).sort(
    (a, b) => Date.parse(b.lastStopAt ?? b.lastResumeAt ?? "") - Date.parse(a.lastStopAt ?? a.lastResumeAt ?? "")
  ).slice(0, Math.max(1, Math.min(200, limit)));
}
async function handleAutoflowPersistentEvent(input) {
  if (input.event.type !== "session.status")
    return { handled: false, resumed: false };
  const sessionID2 = String(input.event.properties?.sessionID ?? "").trim();
  if (!sessionID2) return { handled: false, resumed: false };
  const statusType = String(input.event.properties?.status?.type ?? "").trim().toLowerCase();
  if (!statusType || !isStopStatus(statusType))
    return { handled: false, resumed: false };
  const current = loadAutoflowSession(input.projectDir, sessionID2);
  if (!current || !isActiveAutoflowPhase(current.phase)) {
    return { handled: false, resumed: false };
  }
  const reason = parseStopReason(input.event);
  const runtime = getSessionRuntime(input.projectDir, sessionID2);
  runtime.lastStopAt = nowIso27();
  runtime.lastStopType = statusType;
  runtime.lastStopReason = reason;
  saveSessionRuntime(input.projectDir, runtime);
  if (isUserInitiatedStop(reason)) {
    runtime.userStopped = true;
    runtime.lastOutcomePhase = "stopped";
    runtime.lastOutcomeSummary = "user_initiated_stop";
    saveSessionRuntime(input.projectDir, runtime);
    stopAutoflowSession(input.projectDir, sessionID2);
    setSessionRecoveryReason(input.projectDir, {
      sessionID: sessionID2,
      recoverable: false,
      reasonCode: "RECOVERY_USER_STOP",
      from: "autoflow"
    });
    return {
      handled: true,
      resumed: false,
      reason: "user_initiated_stop",
      phase: "stopped",
      summary: "autoflow_stopped_by_user"
    };
  }
  const config3 = readAutoflowPersistentConfig(input.projectDir);
  if (!config3.enabled) {
    setSessionRecoveryReason(input.projectDir, {
      sessionID: sessionID2,
      recoverable: false,
      reasonCode: "RECOVERY_DISABLED",
      from: "autoflow"
    });
    return { handled: true, resumed: false, reason: "persistent_disabled" };
  }
  if (runtime.userStopped) {
    setSessionRecoveryReason(input.projectDir, {
      sessionID: sessionID2,
      recoverable: false,
      reasonCode: "RECOVERY_USER_STOP",
      from: "autoflow"
    });
    return { handled: true, resumed: false, reason: "user_stopped_session" };
  }
  if (runtime.resumeAttempts >= config3.maxAutoResumes) {
    const exhaustedReason = "persistent_resume_attempt_limit_reached";
    markPersistentExhausted(input.projectDir, sessionID2, exhaustedReason);
    runtime.lastOutcomePhase = "failed";
    runtime.lastOutcomeSummary = exhaustedReason;
    saveSessionRuntime(input.projectDir, runtime);
    setSessionRecoveryReason(input.projectDir, {
      sessionID: sessionID2,
      recoverable: false,
      reasonCode: "RECOVERY_ATTEMPT_EXHAUSTED",
      from: "autoflow"
    });
    return {
      handled: true,
      resumed: false,
      reason: exhaustedReason,
      phase: "failed"
    };
  }
  if (runtime.resumeFailures >= config3.maxConsecutiveResumeFailures) {
    const exhaustedReason = "persistent_resume_failure_limit_reached";
    markPersistentExhausted(input.projectDir, sessionID2, exhaustedReason);
    runtime.lastOutcomePhase = "failed";
    runtime.lastOutcomeSummary = exhaustedReason;
    saveSessionRuntime(input.projectDir, runtime);
    setSessionRecoveryReason(input.projectDir, {
      sessionID: sessionID2,
      recoverable: false,
      reasonCode: "RECOVERY_FAILURE_EXHAUSTED",
      from: "autoflow"
    });
    return {
      handled: true,
      resumed: false,
      reason: exhaustedReason,
      phase: "failed"
    };
  }
  if (runtime.lastResumeAt) {
    const delta = Date.now() - Date.parse(runtime.lastResumeAt);
    if (Number.isFinite(delta) && delta < config3.resumeCooldownMs) {
      setSessionRecoveryReason(input.projectDir, {
        sessionID: sessionID2,
        recoverable: true,
        reasonCode: "RECOVERY_COOLDOWN",
        from: "autoflow"
      });
      return { handled: true, resumed: false, reason: "resume_cooldown" };
    }
  }
  runtime.resumeAttempts += 1;
  runtime.lastResumeAt = nowIso27();
  saveSessionRuntime(input.projectDir, runtime);
  const result = await runAutoflow({
    projectDir: input.projectDir,
    sessionID: sessionID2,
    manager: input.manager,
    timeoutMs: config3.resumeTimeoutMs
  });
  runtime.lastOutcomePhase = result.phase;
  runtime.lastOutcomeSummary = result.summary;
  runtime.resumeFailures = result.success ? 0 : runtime.resumeFailures + 1;
  saveSessionRuntime(input.projectDir, runtime);
  setSessionRecoveryReason(input.projectDir, {
    sessionID: sessionID2,
    recoverable: result.success || result.phase !== "failed",
    reasonCode: toRecoveryReasonCode({
      resumed: true,
      success: result.success,
      phase: result.phase
    }),
    from: "autoflow"
  });
  return {
    handled: true,
    resumed: true,
    success: result.success,
    phase: result.phase,
    summary: result.summary
  };
}

// src/gateway/control-ui.ts
import fs45 from "node:fs";
import path46 from "node:path";

// src/gateway/control-ui-shared.ts
function normalizeControlUiBasePath(basePath) {
  if (!basePath) return "";
  let normalized = basePath.trim();
  if (!normalized) return "";
  if (!normalized.startsWith("/")) normalized = `/${normalized}`;
  if (normalized === "/") return "";
  if (normalized.endsWith("/")) normalized = normalized.slice(0, -1);
  return normalized;
}

// src/gateway/control-ui.ts
function contentTypeForExt(ext) {
  switch (ext) {
    case ".html":
      return "text/html; charset=utf-8";
    case ".js":
      return "application/javascript; charset=utf-8";
    case ".css":
      return "text/css; charset=utf-8";
    case ".json":
    case ".map":
      return "application/json; charset=utf-8";
    case ".svg":
      return "image/svg+xml";
    case ".png":
      return "image/png";
    case ".jpg":
    case ".jpeg":
      return "image/jpeg";
    case ".gif":
      return "image/gif";
    case ".webp":
      return "image/webp";
    case ".ico":
      return "image/x-icon";
    case ".txt":
      return "text/plain; charset=utf-8";
    default:
      return "application/octet-stream";
  }
}
function securityHeaders(contentType) {
  const headers = {
    "cache-control": "no-cache",
    "x-frame-options": "DENY",
    "content-security-policy": "frame-ancestors 'none'",
    "x-content-type-options": "nosniff"
  };
  if (contentType) headers["content-type"] = contentType;
  return headers;
}
function textResponse(status, body) {
  return new Response(body, {
    status,
    headers: securityHeaders("text/plain; charset=utf-8")
  });
}
function isSafeRelativePath(relPath) {
  if (!relPath) return false;
  const normalized = path46.posix.normalize(relPath);
  if (normalized.startsWith("../") || normalized === "..") return false;
  if (normalized.includes("\0")) return false;
  return true;
}
function resolveRequestedFile(pathname, basePath) {
  if (basePath) {
    if (pathname === basePath) return "index.html";
    if (!pathname.startsWith(`${basePath}/`)) return null;
    pathname = pathname.slice(basePath.length);
  }
  if (!pathname.startsWith("/")) return null;
  if (pathname === "/" || pathname === "") return "index.html";
  const assetsIndex = pathname.indexOf("/assets/");
  const rel = assetsIndex >= 0 ? pathname.slice(assetsIndex + 1) : pathname.slice(1);
  const requested = rel && !rel.endsWith("/") ? rel : `${rel}index.html`;
  return requested || "index.html";
}
function resolveRootState(projectDir) {
  const envRoot = process.env.MIYA_GATEWAY_UI_ROOT?.trim();
  const candidates = envRoot ? [envRoot] : [
    path46.join(projectDir, "miya-src", "gateway-ui", "dist"),
    path46.join(projectDir, "gateway-ui", "dist"),
    path46.join(projectDir, ".opencode", "miya", "gateway-ui", "dist"),
    path46.join(projectDir, ".opencode", "miya", "gateway-ui")
  ];
  for (const candidate of candidates) {
    const indexPath = path46.join(candidate, "index.html");
    if (fs45.existsSync(indexPath) && fs45.statSync(indexPath).isFile()) {
      return { kind: "resolved", path: candidate };
    }
  }
  if (envRoot) return { kind: "invalid", path: envRoot };
  return { kind: "missing" };
}
function createControlUiRequestOptions(projectDir) {
  const envBasePath = process.env.MIYA_GATEWAY_UI_BASE_PATH;
  const defaultBasePath = envBasePath && envBasePath.trim().length > 0 ? envBasePath : "/control";
  return {
    basePath: normalizeControlUiBasePath(defaultBasePath),
    root: resolveRootState(projectDir)
  };
}
function handleControlUiHttpRequest(request, opts) {
  if (request.method !== "GET" && request.method !== "HEAD") return null;
  const url3 = new URL(request.url);
  const pathname = url3.pathname;
  const basePath = normalizeControlUiBasePath(opts?.basePath);
  const requestedFile = resolveRequestedFile(pathname, basePath);
  if (!requestedFile) return null;
  if (!isSafeRelativePath(requestedFile)) {
    return textResponse(404, "Not Found");
  }
  const root = opts?.root;
  if (root?.kind === "invalid") {
    return textResponse(
      503,
      `Control UI assets not found at ${root.path}. Set MIYA_GATEWAY_UI_ROOT to a built UI directory.`
    );
  }
  if (root?.kind === "missing") {
    return textResponse(
      503,
      "Control UI assets not found. Set MIYA_GATEWAY_UI_ROOT to a built UI directory."
    );
  }
  if (!root || root.kind !== "resolved") return null;
  const filePath14 = path46.join(root.path, requestedFile);
  if (!filePath14.startsWith(root.path)) {
    return textResponse(404, "Not Found");
  }
  const indexPath = path46.join(root.path, "index.html");
  const resolvedPath = fs45.existsSync(filePath14) && fs45.statSync(filePath14).isFile() ? filePath14 : indexPath;
  if (!fs45.existsSync(resolvedPath) || !fs45.statSync(resolvedPath).isFile()) {
    return textResponse(404, "Not Found");
  }
  const headers = securityHeaders(
    contentTypeForExt(path46.extname(resolvedPath).toLowerCase())
  );
  if (request.method === "HEAD") {
    return new Response(null, { status: 200, headers });
  }
  const body = fs45.readFileSync(resolvedPath);
  return new Response(body, {
    status: 200,
    headers
  });
}

// src/gateway/bootstrap.ts
function formatGatewayStateWithRuntime(state2, ownerPID, isOwner, activeAgentId, storageRevision) {
  return [
    `url=${state2.url}`,
    `port=${state2.port}`,
    `pid=${state2.pid}`,
    `owner_pid=${ownerPID ?? 0}`,
    `is_owner=${Boolean(isOwner)}`,
    `started_at=${state2.startedAt}`,
    `status=${state2.status}`,
    `active_agent=${activeAgentId ?? ""}`,
    `storage_revision=${storageRevision ?? 0}`
  ].join("\n");
}

// src/gateway/http-router.ts
import { spawnSync as spawnSync6 } from "node:child_process";
function normalizeNodeHeaders(headers) {
  const normalized = {};
  for (const [key, value] of Object.entries(headers)) {
    if (typeof value === "string") {
      normalized[key] = value;
      continue;
    }
    if (Array.isArray(value) && value.length > 0) {
      normalized[key] = value.join(", ");
    }
  }
  return normalized;
}
function toNodeRequest(req, hostname6, port) {
  const hostHeader = typeof req.headers.host === "string" && req.headers.host.trim() ? req.headers.host.trim() : `${hostname6}:${port}`;
  const requestUrl = new URL(req.url || "/", `http://${hostHeader}`);
  return new Request(requestUrl, {
    method: req.method ?? "GET",
    headers: normalizeNodeHeaders(req.headers)
  });
}
async function sendNodeResponse(req, res, response) {
  res.statusCode = response.status;
  for (const [key, value] of response.headers.entries()) {
    res.setHeader(key, value);
  }
  if ((req.method ?? "GET").toUpperCase() === "HEAD") {
    res.end();
    return;
  }
  if (!response.body) {
    res.end();
    return;
  }
  const body = Buffer.from(await response.arrayBuffer());
  res.end(body);
}
function reserveGatewayPort(hostname6, configuredPort) {
  if (configuredPort > 0) {
    return configuredPort;
  }
  const script = [
    "const net=require('node:net');",
    'const host=process.argv[1]||"127.0.0.1";',
    "const s=net.createServer();",
    "s.listen(0,host,()=>{",
    "const address=s.address();",
    "if(address&&typeof address==='object'){process.stdout.write(String(address.port));}",
    "s.close(()=>process.exit(0));",
    "});",
    "s.on('error',()=>process.exit(1));"
  ].join("");
  const probe = spawnSync6("node", ["-e", script, hostname6], {
    encoding: "utf-8",
    stdio: ["ignore", "pipe", "pipe"],
    windowsHide: true
  });
  if (probe.status !== 0) {
    throw new Error(`gateway_port_reservation_failed:${String(probe.stderr || "").trim()}`);
  }
  const reserved = Number(String(probe.stdout || "").trim());
  if (!Number.isFinite(reserved) || reserved <= 0) {
    throw new Error("gateway_port_reservation_invalid");
  }
  return Math.floor(reserved);
}

// src/gateway/negotiation-budget.ts
function nowIso28() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function sanitizeBudget(input) {
  const autoRetry = Number.isFinite(input.autoRetry) ? Math.max(0, Math.floor(input.autoRetry)) : 0;
  const humanEdit = Number.isFinite(input.humanEdit) ? Math.max(0, Math.floor(input.humanEdit)) : 0;
  return { autoRetry, humanEdit };
}
function applyNegotiationBudget(store2, input) {
  const budget = sanitizeBudget(input.budget);
  const fixability = input.fixability;
  const existing = store2.get(input.key);
  const state2 = existing ? {
    ...existing,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    updatedAt: nowIso28()
  } : {
    key: input.key,
    fixability,
    budget: fixability === "impossible" ? { autoRetry: 0, humanEdit: 0 } : budget,
    autoUsed: 0,
    humanUsed: 0,
    updatedAt: nowIso28()
  };
  if (!input.attemptType) {
    store2.set(input.key, state2);
    return { allowed: true, state: state2 };
  }
  if (state2.fixability === "impossible") {
    store2.set(input.key, state2);
    return { allowed: false, reason: "fixability_impossible", state: state2 };
  }
  if (input.attemptType === "auto") {
    if (state2.autoUsed >= state2.budget.autoRetry) {
      store2.set(input.key, state2);
      return { allowed: false, reason: "auto_retry_exhausted", state: state2 };
    }
    state2.autoUsed += 1;
  } else {
    if (state2.humanUsed >= state2.budget.humanEdit) {
      store2.set(input.key, state2);
      return { allowed: false, reason: "human_edit_exhausted", state: state2 };
    }
    state2.humanUsed += 1;
  }
  state2.updatedAt = nowIso28();
  store2.set(input.key, state2);
  return { allowed: true, state: state2 };
}

// src/gateway/methods/channels.ts
function registerChannelMethods(deps) {
  const { methods, projectDir, parseText: parseText2, parseChannel: parseChannel2 } = deps;
  methods.register(
    "channels.list",
    async () => deps.runtime.channelRuntime.listChannels()
  );
  methods.register("channels.status", async () => ({
    channels: deps.runtime.channelRuntime.listChannels(),
    pendingPairs: deps.runtime.channelRuntime.listPairs("pending")
  }));
  methods.register("channels.pair.list", async (params) => {
    if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
      return deps.runtime.channelRuntime.listPairs(params.status);
    }
    return deps.runtime.channelRuntime.listPairs();
  });
  methods.register("channels.pair.approve", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return deps.runtime.channelRuntime.approvePair(pairID);
  });
  methods.register("channels.pair.reject", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return deps.runtime.channelRuntime.rejectPair(pairID);
  });
  methods.register("channels.contact.tier.set", async (params) => {
    const channel = parseChannel2(params.channel);
    const senderID = parseText2(params.senderID);
    const tier = parseText2(params.tier);
    if (!channel || !senderID)
      throw new Error("invalid_channels_contact_tier_args");
    if (tier !== "owner" && tier !== "friend") {
      throw new Error("invalid_channels_contact_tier");
    }
    return setContactTier(projectDir, channel, senderID, tier);
  });
  methods.register("channels.contact.tier.get", async (params) => {
    const channel = parseChannel2(params.channel);
    const senderID = parseText2(params.senderID);
    if (!channel || !senderID)
      throw new Error("invalid_channels_contact_tier_args");
    return {
      channel,
      senderID,
      tier: getContactTier(projectDir, channel, senderID)
    };
  });
  methods.register("channels.contact.tier.list", async (params) => {
    const channel = parseChannel2(params.channel);
    return {
      contacts: listContactTiers(projectDir, channel ?? void 0)
    };
  });
  methods.register("channels.message.send", async (params) => {
    const channel = parseChannel2(params.channel);
    const destination = parseText2(params.destination);
    const text = parseText2(params.text);
    const mediaID = parseText2(params.mediaID);
    const mediaPathInput = parseText2(params.mediaPath);
    const idempotencyKey = parseText2(params.idempotencyKey);
    const sessionID2 = parseText2(params.sessionID) || "main";
    const policyHash = parseText2(params.policyHash) || void 0;
    const mediaFromStore = mediaID ? getMediaItem(projectDir, mediaID) : null;
    const mediaPath = mediaPathInput || mediaFromStore?.localPath || "";
    if (!channel || !destination || !text && !mediaPath) {
      throw new Error("invalid_channels_send_args");
    }
    const outboundCheckRaw = params.outboundCheck && typeof params.outboundCheck === "object" ? params.outboundCheck : null;
    const outboundCheck = {
      archAdvisorApproved: outboundCheckRaw && typeof outboundCheckRaw.archAdvisorApproved === "boolean" ? Boolean(outboundCheckRaw.archAdvisorApproved) : void 0,
      intent: outboundCheckRaw && typeof outboundCheckRaw.intent === "string" ? String(outboundCheckRaw.intent) : void 0,
      factorRecipientIsMe: outboundCheckRaw && typeof outboundCheckRaw.factorRecipientIsMe === "boolean" ? Boolean(outboundCheckRaw.factorRecipientIsMe) : void 0,
      userInitiated: outboundCheckRaw && typeof outboundCheckRaw.userInitiated === "boolean" ? Boolean(outboundCheckRaw.userInitiated) : void 0,
      negotiationID: outboundCheckRaw && typeof outboundCheckRaw.negotiationID === "string" ? String(outboundCheckRaw.negotiationID) : void 0,
      retryAttemptType: outboundCheckRaw && (outboundCheckRaw.retryAttemptType === "auto" || outboundCheckRaw.retryAttemptType === "human") ? outboundCheckRaw.retryAttemptType : void 0,
      evidenceConfidence: outboundCheckRaw && typeof outboundCheckRaw.evidenceConfidence === "number" && Number.isFinite(outboundCheckRaw.evidenceConfidence) ? Number(outboundCheckRaw.evidenceConfidence) : void 0,
      captureLimitations: outboundCheckRaw && Array.isArray(outboundCheckRaw.captureLimitations) ? outboundCheckRaw.captureLimitations.filter((item) => typeof item === "string").map((item) => item.trim()).filter((item) => item.length > 0).slice(0, 32) : void 0,
      psycheSignals: outboundCheckRaw?.psycheSignals && typeof outboundCheckRaw.psycheSignals === "object" && !Array.isArray(outboundCheckRaw.psycheSignals) ? outboundCheckRaw.psycheSignals : void 0
    };
    const confirmationRaw = params.confirmation && typeof params.confirmation === "object" ? params.confirmation : null;
    return deps.sendChannelMessageGuarded({
      channel,
      destination,
      text,
      mediaPath,
      idempotencyKey,
      sessionID: sessionID2,
      policyHash,
      outboundCheck,
      confirmation: {
        physicalConfirmed: confirmationRaw && typeof confirmationRaw.physicalConfirmed === "boolean" ? Boolean(confirmationRaw.physicalConfirmed) : void 0,
        password: confirmationRaw && typeof confirmationRaw.password === "string" ? String(confirmationRaw.password) : void 0,
        passphrase: confirmationRaw && typeof confirmationRaw.passphrase === "string" ? String(confirmationRaw.passphrase) : void 0,
        ownerSyncToken: confirmationRaw && typeof confirmationRaw.ownerSyncToken === "string" ? String(confirmationRaw.ownerSyncToken) : void 0
      }
    });
  });
}

// src/gateway/methods/memory.ts
function registerMemoryMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("companion.memory.add", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    const fact = parseText2(params.fact);
    if (!fact) throw new Error("invalid_memory_fact");
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const created = upsertCompanionMemoryVector(projectDir, {
      text: fact,
      source: "conversation",
      activate: false,
      sourceType: parseText2(params.sourceType) === "direct_correction" ? "direct_correction" : "conversation"
    });
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    const learningGate = deps.getLearningGate();
    return {
      memory: created,
      stage: created.status,
      learningGate: {
        stage: "candidate",
        approvalMode: learningGate.candidateMode,
        interruptsUser: false
      },
      needsCorrectionWizard: Boolean(created.conflictWizardID),
      message: created.conflictWizardID ? "memory_pending_conflict_requires_correction_wizard" : "memory_pending_confirmation_required",
      profile
    };
  });
  methods.register("companion.memory.list", async () => {
    deps.requireOwnerMode(projectDir);
    return readCompanionProfile(projectDir).memoryFacts;
  });
  methods.register("companion.memory.pending.list", async () => {
    deps.requireOwnerMode(projectDir);
    return listPendingCompanionMemoryVectors(projectDir);
  });
  methods.register("companion.memory.corrections.list", async () => {
    deps.requireOwnerMode(projectDir);
    return listCompanionMemoryCorrections(projectDir);
  });
  methods.register("companion.memory.confirm", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText2(params.memoryID);
    const sessionID2 = parseText2(params.sessionID) || "main";
    if (!memoryID) throw new Error("invalid_memory_id");
    const learningGate = deps.getLearningGate();
    if (learningGate.persistentRequiresApproval) {
      const ticket = deps.resolveApprovalTicket({
        projectDir,
        sessionID: sessionID2,
        permission: "memory_write",
        patterns: [
          "memory_stage=persistent",
          `memory_id=${memoryID}`,
          "action=confirm"
        ]
      });
      if (!ticket.ok) throw new Error(`approval_required:${ticket.reason}`);
    }
    const confirm = typeof params.confirm === "boolean" ? Boolean(params.confirm) : true;
    const updated = confirmCompanionMemoryVector(projectDir, {
      memoryID,
      confirm,
      supersedeConflicts: typeof params.supersedeConflicts === "boolean" ? Boolean(params.supersedeConflicts) : true
    });
    if (!updated) throw new Error("memory_not_found");
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return {
      memory: updated,
      stage: updated.status,
      learningGate: {
        stage: "persistent",
        approvalMode: learningGate.persistentRequiresApproval ? "modal_approval" : "toast_gate",
        interruptsUser: learningGate.persistentRequiresApproval
      },
      profile
    };
  });
  methods.register("companion.memory.update", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText2(params.memoryID);
    if (!memoryID) throw new Error("invalid_memory_id");
    const updated = updateCompanionMemoryVector(projectDir, {
      memoryID,
      text: parseText2(params.text) || void 0,
      memoryKind: parseText2(params.memoryKind) === "Fact" || parseText2(params.memoryKind) === "Insight" || parseText2(params.memoryKind) === "UserPreference" ? parseText2(params.memoryKind) : void 0,
      confidence: typeof params.confidence === "number" && Number.isFinite(params.confidence) ? Number(params.confidence) : void 0,
      tier: parseText2(params.tier) === "L0" || parseText2(params.tier) === "L1" || parseText2(params.tier) === "L2" || parseText2(params.tier) === "L3" ? parseText2(params.tier) : void 0,
      status: parseText2(params.status) === "candidate" || parseText2(params.status) === "pending" || parseText2(params.status) === "active" || parseText2(params.status) === "superseded" || parseText2(params.status) === "archived" ? parseText2(params.status) : void 0
    });
    if (!updated) throw new Error("memory_not_found");
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return { memory: updated, profile };
  });
  methods.register("companion.memory.archive", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const memoryID = parseText2(params.memoryID);
    if (!memoryID) throw new Error("invalid_memory_id");
    const archived = typeof params.archived === "boolean" ? Boolean(params.archived) : true;
    const updated = archiveCompanionMemoryVector(projectDir, {
      memoryID,
      archived
    });
    if (!updated) throw new Error("memory_not_found");
    return { memory: updated };
  });
  methods.register("companion.memory.search", async (params) => {
    deps.requireOwnerMode(projectDir);
    const query = parseText2(params.query);
    if (!query) throw new Error("invalid_memory_query");
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(20, Number(params.limit)) : 5;
    const threshold = typeof params.threshold === "number" && params.threshold >= 0 ? Number(params.threshold) : void 0;
    const recencyHalfLifeDays = typeof params.recencyHalfLifeDays === "number" && params.recencyHalfLifeDays > 0 ? Number(params.recencyHalfLifeDays) : void 0;
    return searchCompanionMemoryVectors(projectDir, query, limit, {
      threshold,
      recencyHalfLifeDays,
      mode: parseText2(params.mode) === "vector" || parseText2(params.mode) === "keyword" ? parseText2(params.mode) : "hybrid"
    });
  });
  methods.register("companion.memory.decay", async (params) => {
    deps.requireOwnerMode(projectDir);
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const halfLifeDays = typeof params.halfLifeDays === "number" && params.halfLifeDays > 0 ? Number(params.halfLifeDays) : 30;
    return decayCompanionMemoryVectors(projectDir, halfLifeDays);
  });
  methods.register("companion.memory.vector.list", async () => {
    deps.requireOwnerMode(projectDir);
    return listCompanionMemoryVectors(projectDir);
  });
}

// src/gateway/protocol.ts
var JsonValue2 = external_exports.lazy(
  () => external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean(), external_exports.null(), external_exports.array(JsonValue2), external_exports.record(external_exports.string(), JsonValue2)])
);
var JsonObject2 = external_exports.record(external_exports.string(), JsonValue2);
var HelloFrameSchema = external_exports.object({
  type: external_exports.literal("hello"),
  role: external_exports.enum(["ui", "admin", "node", "channel", "unknown"]).default("unknown"),
  clientID: external_exports.string().optional(),
  protocolVersion: external_exports.string().optional(),
  auth: external_exports.object({
    token: external_exports.string().optional()
  }).optional(),
  capabilities: external_exports.array(external_exports.string()).optional()
});
var RequestFrameSchema = external_exports.object({
  type: external_exports.literal("request"),
  id: external_exports.string().min(1),
  method: external_exports.string().min(1),
  params: JsonObject2.default({})
});
var PingFrameSchema = external_exports.object({
  type: external_exports.literal("ping"),
  ts: external_exports.number().int().nonnegative()
});
var PongFrameSchema = external_exports.object({
  type: external_exports.literal("pong"),
  ts: external_exports.number().int().nonnegative()
});
var ResponseFrameSchema = external_exports.object({
  type: external_exports.literal("response"),
  id: external_exports.string(),
  ok: external_exports.boolean(),
  result: JsonValue2.optional(),
  error: external_exports.object({
    code: external_exports.string(),
    message: external_exports.string(),
    details: JsonValue2.optional()
  }).optional()
});
var EventFrameSchema = external_exports.object({
  type: external_exports.literal("event"),
  event: external_exports.string().min(1),
  payload: JsonValue2,
  stateVersion: external_exports.record(external_exports.string(), external_exports.number()).optional()
});
var GatewayIncomingFrameSchema = external_exports.union([HelloFrameSchema, RequestFrameSchema, PingFrameSchema]);
var GatewayOutgoingFrameSchema = external_exports.union([ResponseFrameSchema, EventFrameSchema, PongFrameSchema]);
var GatewayMethodRegistry = class {
  handlers = /* @__PURE__ */ new Map();
  inFlight = 0;
  queue = [];
  rejectedOverloaded = 0;
  rejectedTimeout = 0;
  queueWaitSamplesMs = [];
  maxInFlight;
  maxQueued;
  queueTimeoutMs;
  constructor(options = {}) {
    this.maxInFlight = Math.max(
      1,
      Math.floor(
        options.maxInFlight ?? Number(process.env.MIYA_GATEWAY_MAX_IN_FLIGHT ?? 8)
      )
    );
    this.maxQueued = Math.max(
      1,
      Math.floor(
        options.maxQueued ?? Number(process.env.MIYA_GATEWAY_MAX_QUEUED ?? 64)
      )
    );
    this.queueTimeoutMs = Math.max(
      100,
      Math.floor(
        options.queueTimeoutMs ?? Number(process.env.MIYA_GATEWAY_QUEUE_TIMEOUT_MS ?? 15e3)
      )
    );
  }
  register(method, handler) {
    this.handlers.set(method, handler);
  }
  async invoke(method, params, context) {
    if (this.inFlight < this.maxInFlight) {
      return this.executeNow(method, params, context);
    }
    if (this.queue.length >= this.maxQueued) {
      this.rejectedOverloaded += 1;
      throw new Error(
        `gateway_backpressure_overloaded:in_flight=${this.inFlight}:queued=${this.queue.length}`
      );
    }
    return await new Promise((resolve7, reject) => {
      const queued = {
        method,
        params,
        context,
        enqueuedAtMs: Date.now(),
        resolve: resolve7,
        reject,
        timeout: setTimeout(() => {
          const index = this.queue.indexOf(queued);
          if (index >= 0) this.queue.splice(index, 1);
          this.rejectedTimeout += 1;
          reject(new Error("gateway_backpressure_timeout"));
        }, this.queueTimeoutMs)
      };
      this.queue.push(queued);
    });
  }
  list() {
    return [...this.handlers.keys()].sort();
  }
  stats() {
    const rejectedOverloaded = this.rejectedOverloaded;
    const rejectedTimeout = this.rejectedTimeout;
    const queueWaitMsP95 = this.queueWaitMsP95();
    return {
      inFlight: this.inFlight,
      queued: this.queue.length,
      maxInFlight: this.maxInFlight,
      maxQueued: this.maxQueued,
      rejected_overloaded: rejectedOverloaded,
      rejected_timeout: rejectedTimeout,
      queue_wait_ms_p95: queueWaitMsP95,
      rejectedOverloaded,
      rejectedTimeout,
      queueWaitMsP95
    };
  }
  async executeNow(method, params, context) {
    const handler = this.handlers.get(method);
    if (!handler) throw new Error(`unknown_method:${method}`);
    this.inFlight += 1;
    try {
      return await handler(params, context);
    } finally {
      this.inFlight = Math.max(0, this.inFlight - 1);
      this.drainQueue();
    }
  }
  drainQueue() {
    if (this.inFlight >= this.maxInFlight) return;
    const next = this.queue.shift();
    if (!next) return;
    clearTimeout(next.timeout);
    this.recordQueueWait(Date.now() - next.enqueuedAtMs);
    void this.executeNow(next.method, next.params, next.context).then((value) => next.resolve(value)).catch((error92) => next.reject(error92)).finally(() => {
      if (this.inFlight < this.maxInFlight && this.queue.length > 0) {
        this.drainQueue();
      }
    });
  }
  recordQueueWait(waitMs) {
    if (!Number.isFinite(waitMs) || waitMs < 0) return;
    this.queueWaitSamplesMs.push(waitMs);
    if (this.queueWaitSamplesMs.length > 256) {
      this.queueWaitSamplesMs.splice(0, this.queueWaitSamplesMs.length - 256);
    }
  }
  queueWaitMsP95() {
    if (this.queueWaitSamplesMs.length === 0) return 0;
    const sorted = [...this.queueWaitSamplesMs].sort((a, b) => a - b);
    const index = Math.max(
      0,
      Math.min(sorted.length - 1, Math.floor(sorted.length * 0.95))
    );
    return Math.floor(sorted[index] ?? 0);
  }
};
function parseIncomingFrame(message) {
  let payload = message;
  if (typeof message === "string") {
    const raw = message.trim();
    if (!raw) return { error: "empty_message" };
    if (raw === "status") {
      payload = { type: "request", id: "legacy-status", method: "gateway.status.get", params: {} };
    } else {
      try {
        payload = JSON.parse(raw);
      } catch {
        return { error: "invalid_json" };
      }
    }
  }
  try {
    const frame = GatewayIncomingFrameSchema.parse(payload);
    return { frame };
  } catch (error92) {
    return { error: error92 instanceof Error ? error92.message : "invalid_frame" };
  }
}
function toResponseFrame(input) {
  const result = toJsonCompatible(input.result);
  const errorDetails = toJsonCompatible(input.errorDetails);
  if (input.ok) {
    return ResponseFrameSchema.parse({
      type: "response",
      id: input.id,
      ok: true,
      result
    });
  }
  return ResponseFrameSchema.parse({
    type: "response",
    id: input.id,
    ok: false,
    error: {
      code: input.errorCode ?? "internal_error",
      message: input.errorMessage ?? "Internal error",
      details: errorDetails
    }
  });
}
function toEventFrame(input) {
  const payload = toJsonCompatible(input.payload);
  return EventFrameSchema.parse({
    type: "event",
    event: input.event,
    payload,
    stateVersion: input.stateVersion
  });
}
function toPongFrame(ts) {
  return PongFrameSchema.parse({
    type: "pong",
    ts
  });
}
function toJsonCompatible(input) {
  if (input === void 0) return null;
  if (input === null) return null;
  if (typeof input === "string" || typeof input === "number" || typeof input === "boolean") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map((item) => toJsonCompatible(item));
  }
  if (typeof input === "object") {
    const source = input;
    const next = {};
    for (const [key, value] of Object.entries(source)) {
      if (value === void 0) continue;
      next[key] = toJsonCompatible(value);
    }
    return next;
  }
  return String(input);
}

// src/gateway/methods/nodes.ts
function registerNodeMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("nodes.register", async (params, context) => {
    const nodeID = parseText2(params.nodeID);
    const deviceID = parseText2(params.deviceID);
    if (!nodeID || !deviceID) throw new Error("invalid_nodes_register_args");
    const node = registerNode(projectDir, {
      nodeID,
      deviceID,
      type: params.type === "cli" || params.type === "desktop" || params.type === "mobile" || params.type === "browser" ? params.type : void 0,
      platform: parseText2(params.platform) || process.platform,
      capabilities: Array.isArray(params.capabilities) ? params.capabilities.map(String) : [],
      token: parseText2(params.token) || void 0,
      permissions: params.permissions && typeof params.permissions === "object" ? {
        screenRecording: typeof params.permissions.screenRecording === "boolean" ? Boolean(
          params.permissions.screenRecording
        ) : void 0,
        accessibility: typeof params.permissions.accessibility === "boolean" ? Boolean(
          params.permissions.accessibility
        ) : void 0,
        filesystem: params.permissions.filesystem === "none" || params.permissions.filesystem === "read" || params.permissions.filesystem === "full" ? params.permissions.filesystem : void 0,
        network: typeof params.permissions.network === "boolean" ? Boolean(
          params.permissions.network
        ) : void 0
      } : void 0
    });
    const pair = createNodePairRequest(projectDir, { nodeID, deviceID });
    const ws = context.ws;
    if (ws) deps.runtime.nodeSockets.set(nodeID, ws);
    return { node, pair };
  });
  methods.register("nodes.list", async () => listNodes(projectDir));
  methods.register("nodes.heartbeat", async (params) => {
    const nodeID = parseText2(params.nodeID);
    if (!nodeID) throw new Error("invalid_node_id");
    const node = touchNodeHeartbeat(projectDir, nodeID);
    if (!node) throw new Error("node_not_found");
    return node;
  });
  methods.register("nodes.token.issue", async (params) => {
    const nodeID = parseText2(params.nodeID);
    if (!nodeID) throw new Error("invalid_node_id");
    const issued = issueNodeToken(projectDir, nodeID);
    if (!issued) throw new Error("node_not_found");
    return issued;
  });
  methods.register("nodes.status", async () => ({
    nodes: listNodes(projectDir),
    pendingPairs: listNodePairs(projectDir, "pending")
  }));
  methods.register("nodes.describe", async (params) => {
    const nodeID = parseText2(params.nodeID);
    if (!nodeID) throw new Error("invalid_node_id");
    return describeNode(projectDir, nodeID);
  });
  methods.register("nodes.pair.list", async (params) => {
    if (params.status === "pending" || params.status === "approved" || params.status === "rejected") {
      return listNodePairs(projectDir, params.status);
    }
    return listNodePairs(projectDir);
  });
  methods.register("nodes.pair.approve", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return resolveNodePair(projectDir, pairID, "approved");
  });
  methods.register("nodes.pair.reject", async (params) => {
    const pairID = parseText2(params.pairID);
    if (!pairID) throw new Error("invalid_pair_id");
    return resolveNodePair(projectDir, pairID, "rejected");
  });
  methods.register("nodes.invoke", async (params) => {
    const nodeID = parseText2(params.nodeID);
    const capability = parseText2(params.capability);
    const sessionID2 = parseText2(params.sessionID) || "main";
    const policyHash = parseText2(params.policyHash) || void 0;
    const args = params.args && typeof params.args === "object" ? params.args : {};
    if (!nodeID || !capability) throw new Error("invalid_nodes_invoke_args");
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "desktop_control");
    const token = deps.enforceToken({
      projectDir,
      sessionID: sessionID2,
      permission: "node_invoke",
      patterns: [
        `nodeId=${nodeID}`,
        `cap=${capability}`,
        `args_sha256=${deps.hashText(JSON.stringify(args))}`
      ]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    const invoke = createInvokeRequest(projectDir, {
      nodeID,
      capability,
      args
    });
    markInvokeSent(projectDir, invoke.id);
    const nodeSocket = deps.runtime.nodeSockets.get(nodeID);
    if (nodeSocket) {
      nodeSocket.send(
        JSON.stringify(
          toEventFrame({
            event: "node.invoke.request",
            payload: invoke,
            stateVersion: { gateway: deps.runtime.stateVersion }
          })
        )
      );
    }
    return invoke;
  });
  methods.register("nodes.invoke.result", async (params) => {
    const invokeID = parseText2(params.invokeID);
    if (!invokeID) throw new Error("invalid_invoke_id");
    return resolveInvokeResult(projectDir, invokeID, {
      ok: Boolean(params.ok),
      result: params.result && typeof params.result === "object" ? params.result : void 0,
      error: parseText2(params.error) || void 0
    });
  });
  methods.register("devices.list", async () => listDevices(projectDir));
  methods.register("nodes.invokes.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(200, Math.floor(params.limit)) : 40;
    return listInvokeRequests(projectDir, limit);
  });
}

// src/gateway/methods/sessions.ts
function registerSessionMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("sessions.list", async () => listSessions(projectDir));
  methods.register("sessions.get", async (params) => {
    const sessionID2 = parseText2(params.sessionID);
    if (!sessionID2) throw new Error("invalid_session_id");
    return getSession(projectDir, sessionID2);
  });
  methods.register("sessions.policy.set", async (params) => {
    const sessionID2 = parseText2(params.sessionID);
    const policyHash = parseText2(params.policyHash) || void 0;
    if (!sessionID2) throw new Error("invalid_session_id");
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const patch = {};
    if (params.activation === "active" || params.activation === "queued" || params.activation === "muted") {
      patch.activation = params.activation;
    }
    if (params.reply === "auto" || params.reply === "manual" || params.reply === "summary_only") {
      patch.reply = params.reply;
    }
    if (params.queueStrategy === "fifo" || params.queueStrategy === "priority" || params.queueStrategy === "cooldown") {
      patch.queueStrategy = params.queueStrategy;
    }
    const updated = setSessionPolicy(projectDir, sessionID2, patch);
    if (!updated) throw new Error("session_not_found");
    return updated;
  });
  methods.register("sessions.send", async (params) => {
    const sessionID2 = parseText2(params.sessionID);
    const text = parseText2(params.text);
    if (!sessionID2 || !text) throw new Error("invalid_sessions_send_args");
    if (text.trim() === "/start") {
      const wizard = isCompanionWizardEmpty(projectDir, sessionID2) ? startCompanionWizard(projectDir, { sessionId: sessionID2 }) : readCompanionWizardState(projectDir, sessionID2);
      return {
        sessionID: wizard.sessionId,
        wizard,
        checklist: wizardChecklist(wizard),
        message: wizard.state === "awaiting_photos" ? deps.wizardPromptPhotos : `\u68C0\u6D4B\u5230\u5DF2\u6709\u5411\u5BFC\u8FDB\u5EA6\uFF0C\u5DF2\u6062\u590D\u7EE7\u7EED\u3002${deps.wizardPromptByState(wizard.state)}`,
        instruction: "\u5C06\u7167\u7247\u62D6\u62FD\u5230\u804A\u5929\u4E2D"
      };
    }
    if (text.trim() === "/reset_personality") {
      const wizard = resetCompanionWizard(projectDir, sessionID2);
      return {
        sessionID: wizard.sessionId,
        wizard,
        message: "\u5DF2\u91CD\u7F6E\u4EBA\u683C\u8D44\u4EA7\uFF0C\u8BF7\u91CD\u65B0\u5F00\u59CB /start"
      };
    }
    upsertSession(projectDir, {
      id: sessionID2,
      kind: sessionID2.startsWith("opencode:") ? "opencode" : "channel",
      groupId: sessionID2,
      routingSessionID: parseText2(params.routingSessionID) || "main",
      agent: parseText2(params.agent) || "1-task-manager"
    });
    return deps.routeSessionMessage(projectDir, {
      sessionID: sessionID2,
      text,
      source: parseText2(params.source) || "gateway"
    });
  });
}

// src/gateway/methods/registry.ts
function registerCoreSessionMethods(deps) {
  registerSessionMethods(deps);
}

// src/gateway/methods/security.ts
function registerSecurityMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("security.identity.status", async () => {
    const state2 = readOwnerIdentityState(projectDir);
    return {
      ...state2,
      passwordHash: state2.passwordHash ? "***" : void 0,
      passphraseHash: state2.passphraseHash ? "***" : void 0
    };
  });
  methods.register("security.identity.init", async (params) => {
    const password = parseText2(params.password);
    const passphrase = parseText2(params.passphrase);
    if (!password || !passphrase) throw new Error("invalid_owner_secret_input");
    const next = initOwnerIdentity(projectDir, {
      password,
      passphrase,
      voiceprintEmbeddingID: parseText2(params.voiceprintEmbeddingID) || void 0,
      voiceprintModelPath: parseText2(params.voiceprintModelPath) || void 0,
      voiceprintSampleDir: parseText2(params.voiceprintSampleDir) || void 0,
      voiceprintThresholds: {
        ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : void 0,
        guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : void 0,
        ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : void 0,
        guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : void 0,
        ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : void 0,
        minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : void 0,
        farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : void 0,
        frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : void 0
      }
    });
    return {
      ...next,
      passwordHash: "***",
      passphraseHash: "***"
    };
  });
  methods.register("security.identity.rotate", async (params) => {
    const newPassword = parseText2(params.newPassword);
    const newPassphrase = parseText2(params.newPassphrase);
    if (!newPassword || !newPassphrase)
      throw new Error("invalid_new_owner_secret");
    const next = rotateOwnerSecrets(projectDir, {
      currentPassword: parseText2(params.currentPassword) || void 0,
      currentPassphrase: parseText2(params.currentPassphrase) || void 0,
      newPassword,
      newPassphrase
    });
    return {
      ...next,
      passwordHash: "***",
      passphraseHash: "***"
    };
  });
  methods.register("security.voiceprint.threshold.get", async () => {
    const state2 = readOwnerIdentityState(projectDir);
    return {
      ...state2.voiceprintThresholds
    };
  });
  methods.register("security.voiceprint.threshold.set", async (params) => {
    const next = updateVoiceprintThresholds(projectDir, {
      ownerMinScore: typeof params.ownerMinScore === "number" ? Number(params.ownerMinScore) : void 0,
      guestMaxScore: typeof params.guestMaxScore === "number" ? Number(params.guestMaxScore) : void 0,
      ownerMinLiveness: typeof params.ownerMinLiveness === "number" ? Number(params.ownerMinLiveness) : void 0,
      guestMaxLiveness: typeof params.guestMaxLiveness === "number" ? Number(params.guestMaxLiveness) : void 0,
      ownerMinDiarizationRatio: typeof params.ownerMinDiarizationRatio === "number" ? Number(params.ownerMinDiarizationRatio) : void 0,
      minSampleDurationSec: typeof params.minSampleDurationSec === "number" ? Number(params.minSampleDurationSec) : void 0,
      farTarget: typeof params.farTarget === "number" ? Number(params.farTarget) : void 0,
      frrTarget: typeof params.frrTarget === "number" ? Number(params.frrTarget) : void 0
    });
    return {
      ...next.voiceprintThresholds
    };
  });
  methods.register("security.owner_sync.issue", async (params) => {
    const action = parseText2(params.action) || "outbound.high_risk.send";
    const payloadHash = parseText2(params.payloadHash);
    if (!payloadHash) throw new Error("invalid_payload_hash");
    return issueOwnerSyncToken(projectDir, {
      action,
      payloadHash,
      ttlMs: typeof params.ttlMs === "number" ? Number(params.ttlMs) : void 0
    });
  });
}

// src/gateway/methods/voice.ts
function registerVoiceMethods(deps) {
  const { methods, projectDir, parseText: parseText2 } = deps;
  methods.register("voice.status", async () => readVoiceState(projectDir));
  methods.register("voice.wake.enable", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      enabled: true,
      wakeWordEnabled: true
    });
  });
  methods.register("voice.wake.disable", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      wakeWordEnabled: false
    });
  });
  methods.register("voice.talk.start", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      enabled: true,
      talkMode: true,
      routeSessionID: parseText2(params.sessionID) || readVoiceState(projectDir).routeSessionID
    });
  });
  methods.register("voice.talk.stop", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    return patchVoiceState(projectDir, {
      talkMode: false
    });
  });
  methods.register("voice.input.ingest", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_write");
    const mediaID = parseText2(params.mediaID) || void 0;
    const source = parseText2(params.source) === "wake" || parseText2(params.source) === "talk" || parseText2(params.source) === "media" ? parseText2(params.source) : "manual";
    const language = parseText2(params.language) || void 0;
    const speakerHint = parseText2(params.speakerHint) || void 0;
    const speakerScore = typeof params.speakerScore === "number" ? Number(params.speakerScore) : void 0;
    const mediaPath = mediaID ? getMediaItem(projectDir, mediaID)?.localPath : void 0;
    const voiceprint = await deps.verifyVoiceprintWithLocalModel(projectDir, {
      mediaPath,
      speakerHint,
      speakerScore
    });
    const mode = voiceprint.mode;
    setInteractionMode(projectDir, mode);
    if (mode !== "owner") {
      transitionSafetyState(projectDir, {
        source: "speaker_gate",
        reason: `speaker_mode_${mode}`,
        domains: {
          outbound_send: "paused",
          desktop_control: "paused",
          memory_read: "paused"
        }
      });
    }
    let text = parseText2(params.text);
    if (!text && mediaID) {
      const media = getMediaItem(projectDir, mediaID);
      const transcript = media?.metadata?.transcript;
      text = typeof transcript === "string" && transcript.trim() ? transcript.trim() : `[media:${mediaID}]`;
    }
    if (!text) throw new Error("invalid_voice_input");
    if (mode === "guest") {
      appendGuestConversation(projectDir, {
        text,
        source,
        sessionID: parseText2(params.sessionID) || "main"
      });
      return {
        item: appendVoiceHistory(projectDir, {
          text,
          source,
          language,
          mediaID
        }),
        routed: {
          delivered: false,
          queued: false,
          reason: "guest_mode_restricted"
        },
        mode,
        voiceprint,
        reply: "\u4E0D\u597D\u610F\u601D\uFF0C\u6211\u73B0\u5728\u53EA\u80FD\u542C\u4E3B\u4EBA\u7684\u6307\u4EE4\u54E6\uFF0C\u4F46\u6211\u53EF\u4EE5\u966A\u4F60\u804A\u5929\u3002",
        voice: readVoiceState(projectDir)
      };
    }
    const item = appendVoiceHistory(projectDir, {
      text,
      source,
      language,
      mediaID
    });
    const voice = readVoiceState(projectDir);
    const targetSessionID = parseText2(params.sessionID) || voice.routeSessionID || "main";
    const routed = await deps.routeSessionMessage(projectDir, {
      sessionID: targetSessionID,
      text,
      source: `voice:${source}`
    });
    return {
      item,
      routed,
      mode,
      voiceprint,
      voice: readVoiceState(projectDir)
    };
  });
  methods.register("voice.history.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return readVoiceState(projectDir).history.slice(0, limit);
  });
  methods.register("voice.history.clear", async (params) => {
    const policyHash = parseText2(params.policyHash) || void 0;
    deps.requirePolicyHash(projectDir, policyHash);
    deps.requireDomainRunning(projectDir, "memory_delete");
    return clearVoiceHistory(projectDir);
  });
}

// src/gateway/ownership-lock.ts
function isProcessAlive(pid) {
  if (!Number.isFinite(pid) || pid <= 0) return false;
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}

// src/gateway/render/console.ts
function renderConsoleHtml(snapshot) {
  const payload = JSON.stringify(snapshot).replace(/</g, "\\u003c");
  return `<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya Gateway React</title>
  <style>
    body { margin: 0; font-family: "Segoe UI", "Microsoft YaHei", sans-serif; background: #0f172a; color: #e2e8f0; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .row { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); margin-bottom: 12px; }
    .card { background: #111827; border: 1px solid #1f2937; border-radius: 10px; padding: 12px; }
    .title { color: #93c5fd; font-size: 12px; text-transform: uppercase; }
    .value { font-size: 20px; font-weight: 700; margin-top: 6px; }
    .ok { color: #4ade80; }
    .bad { color: #f87171; }
    textarea { width: 100%; min-height: 220px; resize: vertical; background: #020617; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; padding: 8px; font-family: Consolas, monospace; }
    button { background: #2563eb; color: #fff; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .line { margin: 6px 0; color: #cbd5e1; font-size: 13px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Miya Gateway</h2>
    <div id="daemonStatus" class="line">loading...</div>
    <div class="row">
      <div class="card">
        <div class="title">Daemon CPU/VRAM/Uptime</div>
        <div id="daemonStats" class="value">--</div>
        <div id="daemonJob" class="line">Active Job: --</div>
      </div>
      <div class="card">
        <div class="title">Sessions</div>
        <div id="sessionsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Jobs</div>
        <div id="jobsValue" class="value">0/0</div>
      </div>
      <div class="card">
        <div class="title">Autoflow</div>
        <div id="autoflowValue" class="value">0 active</div>
        <div id="autoflowPhase" class="line">phase: --</div>
      </div>
      <div class="card">
        <div class="title">Routing Cost</div>
        <div id="routingValue" class="value">--</div>
        <div id="routingStage" class="line">stage: --</div>
      </div>
      <div class="card">
        <div class="title">Learning HitRate</div>
        <div id="learningValue" class="value">--</div>
        <div id="learningDrafts" class="line">drafts: --</div>
      </div>
      <div class="card">
        <div class="title">Policy Hash</div>
        <div id="policyHash" class="line">--</div>
      </div>
    </div>
    <div class="card">
      <div class="title">Configuration Center (read/write .opencode/miya/config.json)</div>
      <div class="line">Patch JSON format: { set: {"ui.language":"zh-CN"}, unset: [] }</div>
      <textarea id="patchText">{"set":{},"unset":[]}</textarea>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <button id="saveButton">\u4FDD\u5B58\u914D\u7F6E</button>
        <span id="saveState" class="line">idle</span>
      </div>
      <pre id="configJson" class="line" style="white-space:pre-wrap;max-height:220px;overflow:auto"></pre>
    </div>
  </div>
  <script>window.__MIYA_SNAPSHOT__ = ${payload};</script>
  <script>
    (function () {
      let state = window.__MIYA_SNAPSHOT__ || {};
      const patchInput = document.getElementById('patchText');
      const saveButton = document.getElementById('saveButton');
      const saveState = document.getElementById('saveState');
      const daemonStatus = document.getElementById('daemonStatus');
      const daemonStats = document.getElementById('daemonStats');
      const daemonJob = document.getElementById('daemonJob');
      const sessionsValue = document.getElementById('sessionsValue');
      const jobsValue = document.getElementById('jobsValue');
      const autoflowValue = document.getElementById('autoflowValue');
      const autoflowPhase = document.getElementById('autoflowPhase');
      const routingValue = document.getElementById('routingValue');
      const routingStage = document.getElementById('routingStage');
      const learningValue = document.getElementById('learningValue');
      const learningDrafts = document.getElementById('learningDrafts');
      const policyHash = document.getElementById('policyHash');
      const configJson = document.getElementById('configJson');

      let ws = null;
      let reqID = 1;
      const pending = new Map();

      function updateSave(value) {
        saveState.textContent = value;
        saveButton.disabled = value === 'saving';
      }

      function render(next) {
        state = next || {};
        const daemonOk = Boolean(state.daemon && state.daemon.connected);
        const label = daemonOk
          ? 'Miya Daemon Connected'
          : ((state.daemon && state.daemon.statusText) || 'Miya Daemon Disconnected');
        daemonStatus.textContent = label;
        daemonStatus.className = 'line ' + (daemonOk ? 'ok' : 'bad');

        const cpu =
          state.daemon && typeof state.daemon.cpuPercent === 'number'
            ? state.daemon.cpuPercent.toFixed(1) + '%'
            : '--';
        const vramUsed =
          state.daemon && typeof state.daemon.vramUsedMB === 'number' ? state.daemon.vramUsedMB : '--';
        const vramTotal =
          state.daemon && typeof state.daemon.vramTotalMB === 'number' ? state.daemon.vramTotalMB : '--';
        const uptime =
          state.daemon && typeof state.daemon.uptimeSec === 'number' ? state.daemon.uptimeSec + 's' : '--';
        daemonStats.textContent = cpu + ' | ' + vramUsed + '/' + vramTotal + ' MB | ' + uptime;

        const jobID = state.daemon && state.daemon.activeJobID ? state.daemon.activeJobID : '--';
        const jobProgress =
          state.daemon && typeof state.daemon.activeJobProgress === 'number'
            ? state.daemon.activeJobProgress + '%'
            : '--';
        daemonJob.textContent = 'Active Job: ' + jobID + ' | ' + jobProgress;

        sessionsValue.textContent =
          String((state.sessions && state.sessions.active) || 0) +
          '/' +
          String((state.sessions && state.sessions.total) || 0);
        jobsValue.textContent =
          String((state.jobs && state.jobs.enabled) || 0) +
          '/' +
          String((state.jobs && state.jobs.total) || 0);
        const activeAutoflow = (state.autoflow && state.autoflow.active) || 0;
        autoflowValue.textContent = String(activeAutoflow) + ' active';
        const firstAutoflow = state.autoflow && state.autoflow.sessions && state.autoflow.sessions[0];
        autoflowPhase.textContent =
          'phase: ' + (firstAutoflow && firstAutoflow.phase ? firstAutoflow.phase : '--');
        const routingCost =
          state.routing && state.routing.cost ? state.routing.cost : null;
        if (routingCost) {
          routingValue.textContent =
            String(routingCost.totalTokensEstimate || 0) +
            ' tk | save ' +
            String(routingCost.savingsPercentEstimate || 0) +
            '%';
        } else {
          routingValue.textContent = '--';
        }
        routingStage.textContent =
          'stage: ' + ((state.routing && state.routing.forcedStage) || (state.routing && state.routing.ecoMode ? 'eco' : 'auto') || '--');
        const learningStats =
          state.learning && state.learning.stats ? state.learning.stats : null;
        if (learningStats) {
          learningValue.textContent =
            (Number(learningStats.hitRate || 0) * 100).toFixed(1) + '%';
          learningDrafts.textContent =
            'drafts: ' + String(learningStats.total || 0) + ' | uses: ' + String(learningStats.totalUses || 0);
        } else {
          learningValue.textContent = '--';
          learningDrafts.textContent = 'drafts: --';
        }
        policyHash.textContent = state.policyHash || '--';
        configJson.textContent = JSON.stringify(state.configCenter || {}, null, 2);
      }

      function sendReq(method, params) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          return Promise.reject(new Error('ws_not_open'));
        }
        const id = 'r-' + reqID++;
        ws.send(JSON.stringify({ type: 'request', id, method, params }));
        return new Promise((resolve, reject) => {
          const timer = setTimeout(() => {
            pending.delete(id);
            reject(new Error('request_timeout'));
          }, 8000);
          pending.set(id, { resolve, reject, timer });
        });
      }

      async function loadStatus() {
        try {
          const res = await fetch('/api/status', { cache: 'no-store' });
          const data = await res.json();
          render(data);
        } catch {}
      }

      function openWs() {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        const token =
          new URLSearchParams(location.search).get('token') ||
          localStorage.getItem('miya_gateway_token') ||
          '';
        if (token) localStorage.setItem('miya_gateway_token', token);

        ws = new WebSocket(proto + '://' + location.host + '/ws');
        ws.onopen = function () {
          ws.send(
            JSON.stringify({
              type: 'hello',
              role: 'ui',
              protocolVersion: '1.0',
              auth: token ? { token } : undefined,
            }),
          );
          ws.send(
            JSON.stringify({
              type: 'request',
              id: 'sub',
              method: 'gateway.subscribe',
              params: { events: ['*'] },
            }),
          );
        };
        ws.onmessage = function (evt) {
          try {
            const frame = JSON.parse(evt.data);
            if (frame.type === 'event' && frame.event === 'gateway.snapshot') {
              render(frame.payload);
              return;
            }
            if (frame.type === 'response') {
              const entry = pending.get(frame.id);
              if (!entry) return;
              pending.delete(frame.id);
              clearTimeout(entry.timer);
              if (frame.ok) entry.resolve(frame.result);
              else entry.reject(new Error((frame.error && frame.error.message) || 'request_failed'));
            }
          } catch {}
        };
        ws.onclose = function () {
          for (const entry of pending.values()) {
            clearTimeout(entry.timer);
            entry.reject(new Error('ws_closed'));
          }
          pending.clear();
        };
      }

      saveButton.addEventListener('click', async function () {
        updateSave('saving');
        try {
          const patch = JSON.parse(patchInput.value || '{}');
          await sendReq('config.center.patch', { patch, policyHash: state ? state.policyHash : undefined });
          updateSave('ok');
        } catch (err) {
          updateSave('error:' + String((err && err.message) || err));
        }
      });

      render(state);
      loadStatus();
      setInterval(loadStatus, 3000);
      openWs();
    })();
  </script>
</body>
</html>`;
}

// src/gateway/render/webchat.ts
function renderWebChatHtml() {
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Miya WebChat</title>
  <style>
    body{margin:0;font-family:Segoe UI,sans-serif;background:#0b1117;color:#e6edf7}
    main{max-width:900px;margin:0 auto;padding:14px;display:grid;gap:10px}
    #log{min-height:360px;border:1px solid #253047;border-radius:8px;background:#111827;padding:10px;white-space:pre-wrap}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px}
    input{border:1px solid #253047;border-radius:8px;background:#111827;color:#e6edf7;padding:8px}
    button{border:1px solid #253047;border-radius:8px;background:#1f6feb;color:#fff;padding:8px 12px;cursor:pointer}
  </style>
</head>
<body>
<main>
  <h2 style="margin:0">Miya WebChat</h2>
  <div id="log"></div>
  <div class="row"><input id="msg" placeholder="Type message"><button id="send">Send</button></div>
</main>
<script>
  const logEl=document.getElementById('log'); const msgEl=document.getElementById('msg'); const sendBtn=document.getElementById('send');
  const p=location.protocol==='https:'?'wss':'ws'; const ws=new WebSocket(p+'://'+location.host+'/ws');
  const log=(t)=>{logEl.textContent+=t+'\\n'; logEl.scrollTop=logEl.scrollHeight;};
  const send=()=>{const text=msgEl.value.trim(); if(!text)return; ws.send(JSON.stringify({type:'request',id:'send-'+Date.now(),method:'sessions.send',params:{sessionID:'webchat:main',text,source:'webchat'}})); log('[you] '+text); msgEl.value='';};
  sendBtn.onclick=send; msgEl.addEventListener('keydown',(e)=>{if(e.key==='Enter')send();});
  ws.onopen=()=>{const qs=new URLSearchParams(location.search);const token=qs.get('token')||localStorage.getItem('miya_gateway_token')||'';if(token)localStorage.setItem('miya_gateway_token',token);ws.send(JSON.stringify({type:'hello',role:'ui',auth:token?{token}:undefined})); ws.send(JSON.stringify({type:'request',id:'sub',method:'gateway.subscribe',params:{events:['*']}})); log('[system] connected');};
  ws.onmessage=(event)=>{try{const frame=JSON.parse(event.data); if(frame.type==='response'&&!frame.ok)log('[error] '+(frame.error?.message||'request_failed'));}catch{}};
</script>
</body>
</html>`;
}

// src/gateway/sanitizer.ts
var WORK_INSTRUCTION = "You are a technical coding assistant. No small talk.";
var CHAT_INSTRUCTION = "You are Miya, a girlfriend assistant. Be gentle and cute.";
var WORK_HINTS = [
  /```/,
  /\b(stack trace|traceback|exception|TypeError|ReferenceError)\b/i,
  /\b(function|class|import|npm|pnpm|bun|pip|pytest|docker|sql|api)\b/i,
  /\b(\.ts|\.tsx|\.js|\.py|\.md|package\.json|tsconfig)\b/i,
  /(|||||||||)/
];
var CHAT_HINTS = [
  /(||||||||||)/,
  /\b(love|dear|sweet|cute|hug)\b/i
];
var WORK_BLOCKED_WORDS = /(||||||||)/g;
var CODE_CONTEXT_LINE = new RegExp(
  [
    "^\\s*```",
    "^\\s*(src|apps?|packages?)[/\\\\]",
    "^\\s*[A-Za-z]:[/\\\\]",
    "^\\s*at\\s+\\S+\\s*\\(",
    '^\\s*File\\s+".*",\\s+line\\s+\\d+',
    "\\.(ts|tsx|js|jsx|py|java|go|rs|cpp|c|h|json|yaml|yml|toml|md)\\b",
    "\\b(package\\.json|tsconfig|requirements\\.txt|pnpm-lock|bun\\.lock)\\b"
  ].join("|"),
  "i"
);
function normalizeWhitespace(text) {
  return text.replace(/\r\n/g, "\n").trim();
}
function inferContextMode(text) {
  const trimmed = normalizeWhitespace(text);
  if (!trimmed) return "work";
  let workScore = 0;
  let chatScore = 0;
  for (const pattern of WORK_HINTS) {
    if (pattern.test(trimmed)) workScore += 1;
  }
  for (const pattern of CHAT_HINTS) {
    if (pattern.test(trimmed)) chatScore += 1;
  }
  return workScore >= chatScore ? "work" : "chat";
}
function sanitizeWorkContext(text) {
  const removed = [];
  let body = normalizeWhitespace(text);
  if (WORK_BLOCKED_WORDS.test(body)) {
    removed.push("persona_words");
    body = body.replace(WORK_BLOCKED_WORDS, "");
  }
  body = body.replace(/[ \t]{2,}/g, " ").replace(/\n{3,}/g, "\n\n").trim();
  return {
    text: ["[Context Mode: WORK]", WORK_INSTRUCTION, body].filter(Boolean).join("\n"),
    removed
  };
}
function sanitizeChatContext(text) {
  const removed = [];
  const lines = normalizeWhitespace(text).split("\n");
  const kept = [];
  for (const line of lines) {
    if (CODE_CONTEXT_LINE.test(line)) {
      removed.push("code_context_line");
      continue;
    }
    kept.push(line);
  }
  const body = kept.join("\n").replace(/\n{3,}/g, "\n\n").trim();
  return {
    text: ["[Context Mode: CHAT]", CHAT_INSTRUCTION, body].filter(Boolean).join("\n"),
    removed
  };
}
function sanitizeGatewayContext(input) {
  const mode = input.modeHint ?? inferContextMode(input.text);
  if (mode === "chat") {
    const sanitized2 = sanitizeChatContext(input.text);
    return {
      mode,
      payload: sanitized2.text,
      removedSignals: sanitized2.removed
    };
  }
  const sanitized = sanitizeWorkContext(input.text);
  return {
    mode,
    payload: sanitized.text,
    removedSignals: sanitized.removed
  };
}

// src/gateway/state-files.ts
import * as fs46 from "node:fs";
import * as path47 from "node:path";
function gatewayFile(projectDir) {
  return path47.join(getMiyaRuntimeDir(projectDir), "gateway.json");
}
function trustModeFile(projectDir) {
  return path47.join(getMiyaRuntimeDir(projectDir), "gateway-trust-mode.json");
}
function psycheModeFile(projectDir) {
  return path47.join(getMiyaRuntimeDir(projectDir), "gateway-psyche-mode.json");
}
function learningGateFile(projectDir) {
  return path47.join(getMiyaRuntimeDir(projectDir), "gateway-learning-gate.json");
}
function ensureDir21(file3) {
  fs46.mkdirSync(path47.dirname(file3), { recursive: true });
}
function writeJsonAtomic(file3, payload) {
  ensureDir21(file3);
  const tmp = `${file3}.tmp.${process.pid}.${Date.now()}`;
  fs46.writeFileSync(tmp, `${JSON.stringify(payload, null, 2)}
`, "utf-8");
  fs46.renameSync(tmp, file3);
}
function safeReadJsonObject(file3) {
  if (!fs46.existsSync(file3)) return null;
  try {
    const parsed = JSON.parse(fs46.readFileSync(file3, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return null;
    return parsed;
  } catch {
    return null;
  }
}

// src/gateway/ws-runtime.ts
function normalizeWsInput(message) {
  if (typeof message === "string") return message;
  if (Buffer.isBuffer(message)) return message.toString("utf-8");
  if (Array.isArray(message)) return Buffer.concat(message).toString("utf-8");
  return Buffer.from(message).toString("utf-8");
}

// src/gateway/index.ts
var z3 = tool.schema;
var runtimes2 = /* @__PURE__ */ new Map();
var dependencies = /* @__PURE__ */ new Map();
var ownerTokens = /* @__PURE__ */ new Map();
var controlUiFallbackLoggedAtByDir = /* @__PURE__ */ new Map();
var followerRecoveryTimers = /* @__PURE__ */ new Map();
function nowIso29() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function resolveKillSwitchMode(projectDir, kill) {
  if (kill.active) return "all_stop";
  const outbound = isDomainExecutionAllowed(projectDir, "outbound_send");
  const desktop = isDomainExecutionAllowed(projectDir, "desktop_control");
  if (!outbound && !desktop) return "all_stop";
  if (!outbound) return "outbound_only";
  if (!desktop) return "desktop_only";
  return "off";
}
function resolvePsycheApprovalMode(input) {
  if (input.decision !== "allow") return "modal_approval";
  if (input.urgency === "high" || input.urgency === "critical") return "modal_approval";
  if (input.trust.minScore >= input.mode.silentMin) return "silent_audit";
  if (input.trust.minScore <= input.mode.modalMax) return "modal_approval";
  return "toast_gate";
}
function appendNexusInsight(runtime, input) {
  const trimmed = input.text.trim();
  if (!trimmed) return;
  runtime.nexus.insights.push({
    at: input.at ?? nowIso29(),
    text: trimmed,
    auditID: input.auditID
  });
  if (runtime.nexus.insights.length > 30) {
    runtime.nexus.insights.splice(0, runtime.nexus.insights.length - 30);
  }
}
function shouldEmitThrottledLog(cache, key, windowMs) {
  const now = Date.now();
  const last = cache.get(key) ?? 0;
  if (now - last < windowMs) return false;
  cache.set(key, now);
  return true;
}
function depsOf(projectDir) {
  return dependencies.get(projectDir) ?? {};
}
function registerGatewayDependencies(projectDir, deps) {
  const current = dependencies.get(projectDir) ?? {};
  dependencies.set(projectDir, { ...current, ...deps });
}
var DEFAULT_TRUST_MODE = {
  silentMin: 90,
  modalMax: 50
};
var DEFAULT_PSYCHE_MODE = {
  resonanceEnabled: true,
  captureProbeEnabled: true
};
var DEFAULT_LEARNING_GATE = {
  candidateMode: "toast_gate",
  persistentRequiresApproval: true
};
function normalizeTrustMode2(input) {
  const silentMinRaw = Number(input?.silentMin ?? DEFAULT_TRUST_MODE.silentMin);
  const modalMaxRaw = Number(input?.modalMax ?? DEFAULT_TRUST_MODE.modalMax);
  const silentMin = Math.max(0, Math.min(100, Number.isFinite(silentMinRaw) ? silentMinRaw : DEFAULT_TRUST_MODE.silentMin));
  const modalMax = Math.max(0, Math.min(100, Number.isFinite(modalMaxRaw) ? modalMaxRaw : DEFAULT_TRUST_MODE.modalMax));
  const correctedSilentMin = Math.max(Math.ceil(modalMax), Math.round(silentMin));
  return {
    silentMin: correctedSilentMin,
    modalMax: Math.round(modalMax)
  };
}
function readTrustModeConfig(projectDir) {
  const raw = safeReadJsonObject(trustModeFile(projectDir));
  if (!raw) return DEFAULT_TRUST_MODE;
  return normalizeTrustMode2({
    silentMin: typeof raw.silentMin === "number" ? raw.silentMin : void 0,
    modalMax: typeof raw.modalMax === "number" ? raw.modalMax : void 0
  });
}
function writeTrustModeConfig(projectDir, config3) {
  const normalized = normalizeTrustMode2(config3);
  writeJsonAtomic(trustModeFile(projectDir), normalized);
  return normalized;
}
function normalizePsycheMode(input) {
  return {
    resonanceEnabled: typeof input?.resonanceEnabled === "boolean" ? input.resonanceEnabled : DEFAULT_PSYCHE_MODE.resonanceEnabled,
    captureProbeEnabled: typeof input?.captureProbeEnabled === "boolean" ? input.captureProbeEnabled : DEFAULT_PSYCHE_MODE.captureProbeEnabled
  };
}
function readPsycheModeConfig(projectDir) {
  const raw = safeReadJsonObject(psycheModeFile(projectDir));
  if (!raw) return DEFAULT_PSYCHE_MODE;
  return normalizePsycheMode({
    resonanceEnabled: typeof raw.resonanceEnabled === "boolean" ? raw.resonanceEnabled : void 0,
    captureProbeEnabled: typeof raw.captureProbeEnabled === "boolean" ? raw.captureProbeEnabled : void 0
  });
}
function writePsycheModeConfig(projectDir, config3) {
  const current = readPsycheModeConfig(projectDir);
  const normalized = normalizePsycheMode({
    ...current,
    ...config3
  });
  writeJsonAtomic(psycheModeFile(projectDir), normalized);
  return normalized;
}
function normalizeLearningGate(input) {
  return {
    candidateMode: input?.candidateMode === "silent_audit" ? "silent_audit" : "toast_gate",
    persistentRequiresApproval: typeof input?.persistentRequiresApproval === "boolean" ? input.persistentRequiresApproval : DEFAULT_LEARNING_GATE.persistentRequiresApproval
  };
}
function readLearningGateConfig(projectDir) {
  const raw = safeReadJsonObject(learningGateFile(projectDir));
  if (!raw) return DEFAULT_LEARNING_GATE;
  return normalizeLearningGate({
    candidateMode: raw.candidateMode === "silent_audit" || raw.candidateMode === "toast_gate" ? raw.candidateMode : void 0,
    persistentRequiresApproval: typeof raw.persistentRequiresApproval === "boolean" ? raw.persistentRequiresApproval : void 0
  });
}
function writeLearningGateConfig(projectDir, config3) {
  const current = readLearningGateConfig(projectDir);
  const normalized = normalizeLearningGate({
    ...current,
    ...config3
  });
  writeJsonAtomic(learningGateFile(projectDir), normalized);
  return normalized;
}
function resolvePsycheConsultEnabled(projectDir, mode) {
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "1") return true;
  if (process.env.MIYA_PSYCHE_CONSULT_ENABLE === "0") return false;
  const config3 = readConfig(projectDir);
  const configured = config3.automation?.psycheConsultEnabled;
  if (typeof configured === "boolean") return configured;
  return mode.resonanceEnabled;
}
function gatewayOwnerLockFile(projectDir) {
  return path48.join(getMiyaRuntimeDir(projectDir), "gateway-owner.json");
}
function readGatewayOwnerLock(projectDir) {
  const raw = safeReadJsonObject(gatewayOwnerLockFile(projectDir));
  if (!raw) return null;
  const pid = Number(raw.pid);
  const token = String(raw.token ?? "");
  const updatedAt = String(raw.updatedAt ?? "");
  const startedAt = String(raw.startedAt ?? "");
  if (!Number.isFinite(pid) || !token || !updatedAt || !startedAt) return null;
  return { pid, token, updatedAt, startedAt };
}
function describeOwnerLock(lock) {
  if (!lock) return { exists: false };
  return {
    exists: true,
    pid: lock.pid,
    updatedAt: lock.updatedAt,
    startedAt: lock.startedAt,
    fresh: isOwnerLockFresh(lock),
    alive: isProcessAlive(lock.pid)
  };
}
function isOwnerLockFresh(lock) {
  const ts = Date.parse(lock.updatedAt);
  if (!Number.isFinite(ts)) return false;
  return Date.now() - ts <= 15e3;
}
function ownerSummary(projectDir) {
  const lock = readGatewayOwnerLock(projectDir);
  if (!lock) {
    return {
      isOwner: false,
      ownerFresh: false
    };
  }
  const token = ownerTokens.get(projectDir);
  return {
    isOwner: Boolean(token) && lock.pid === process.pid && lock.token === token,
    ownerPID: lock.pid,
    ownerFresh: isOwnerLockFresh(lock)
  };
}
function writeOwnerLock(projectDir, token) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const existing = readGatewayOwnerLock(projectDir);
  const lock = {
    pid: process.pid,
    token,
    updatedAt: nowIso29(),
    startedAt: existing?.pid === process.pid && existing.token === token ? existing.startedAt : nowIso29()
  };
  writeJsonAtomic(file3, lock);
  return lock;
}
function touchOwnerLock(projectDir) {
  const token = ownerTokens.get(projectDir);
  if (!token) return;
  writeOwnerLock(projectDir, token);
}
function removeOwnerLock(projectDir) {
  const file3 = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  const token = ownerTokens.get(projectDir);
  if (!lock || !token) return;
  if (lock.pid === process.pid && lock.token === token) {
    try {
      fs47.unlinkSync(file3);
    } catch {
    }
  }
}
function acquireGatewayOwner(projectDir) {
  const existingToken = ownerTokens.get(projectDir) ?? randomUUID18();
  ownerTokens.set(projectDir, existingToken);
  const lockFile = gatewayOwnerLockFile(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  if (lock && lock.pid === process.pid && lock.token === existingToken && isOwnerLockFresh(lock)) {
    const refreshed = {
      ...lock,
      updatedAt: nowIso29()
    };
    writeJsonAtomic(lockFile, refreshed);
    return { owned: true, owner: refreshed };
  }
  if (lock && isProcessAlive(lock.pid) && isOwnerLockFresh(lock)) {
    return { owned: false, owner: lock };
  }
  const created = writeOwnerLock(projectDir, existingToken);
  return { owned: true, owner: created };
}
function readGatewayStateFile(projectDir) {
  const raw = safeReadJsonObject(gatewayFile(projectDir));
  if (!raw) return null;
  const url3 = String(raw.url ?? "").trim();
  const port = Number(raw.port);
  const pid = Number(raw.pid);
  const startedAt = String(raw.startedAt ?? "");
  const status = String(raw.status ?? "running");
  if (!url3 || !Number.isFinite(port) || !Number.isFinite(pid) || !startedAt) {
    return null;
  }
  return {
    url: url3,
    port,
    pid,
    startedAt,
    status: status === "killswitch" ? "killswitch" : "running"
  };
}
function describeGatewayState(state2) {
  if (!state2) return { exists: false };
  return {
    exists: true,
    url: state2.url,
    port: state2.port,
    pid: state2.pid,
    startedAt: state2.startedAt,
    status: state2.status,
    pidAlive: isProcessAlive(state2.pid)
  };
}
function clearGatewayStateFile(projectDir) {
  try {
    fs47.unlinkSync(gatewayFile(projectDir));
  } catch {
  }
}
function isGatewayOwner(projectDir) {
  const token = ownerTokens.get(projectDir);
  const lock = readGatewayOwnerLock(projectDir);
  if (!token || !lock) return false;
  return lock.pid === process.pid && lock.token === token && isOwnerLockFresh(lock);
}
async function probeGatewayAlive(url3, timeoutMs = 800) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const response = await fetch(`${url3.replace(/\/+$/, "")}/api/status`, {
      method: "GET",
      signal: controller.signal
    });
    return response.ok;
  } catch {
    return false;
  } finally {
    clearTimeout(timer);
  }
}
function killAwareStatus(projectDir) {
  return readKillSwitch(projectDir).active ? "killswitch" : "running";
}
function gatewayPort(runtime) {
  return Number(runtime.server.port ?? 0);
}
function resolveGatewayListenOptions(projectDir) {
  const config3 = readConfig(projectDir);
  const gateway = config3.gateway ?? {};
  const rawHost = String(gateway.bindHost ?? "").trim();
  const rawPort = Number(gateway.port);
  const hostname6 = rawHost || "127.0.0.1";
  const port = Number.isFinite(rawPort) && rawPort > 0 && rawPort <= 65535 ? Math.floor(rawPort) : 0;
  return { hostname: hostname6, port };
}
function logControlUiFallback(projectDir, pathname, controlUi, responseStatus) {
  const logKey = `${projectDir}:control-ui-fallback`;
  if (!shouldEmitThrottledLog(controlUiFallbackLoggedAtByDir, logKey, 1e4)) return;
  log("[gateway] control-ui fallback to built-in console", {
    projectDir,
    pathname,
    responseStatus,
    uiRootKind: controlUi.root?.kind ?? "unknown",
    uiRootPath: controlUi.root && "path" in controlUi.root ? String(controlUi.root.path) : void 0,
    uiBasePath: controlUi.basePath ?? "",
    envUiRoot: process.env.MIYA_GATEWAY_UI_ROOT ?? "",
    envUiBasePath: process.env.MIYA_GATEWAY_UI_BASE_PATH ?? ""
  });
}
function toGatewayState(projectDir, runtime) {
  const host = String(runtime.server.hostname || "127.0.0.1") || "127.0.0.1";
  return {
    url: `http://${host}:${gatewayPort(runtime)}`,
    port: gatewayPort(runtime),
    pid: process.pid,
    startedAt: runtime.startedAt,
    status: killAwareStatus(projectDir)
  };
}
function writeGatewayState(projectDir, state2) {
  const file3 = gatewayFile(projectDir);
  writeJsonAtomic(file3, state2);
}
function syncGatewayState(projectDir, runtime) {
  const state2 = toGatewayState(projectDir, runtime);
  writeGatewayState(projectDir, state2);
  return state2;
}
function stopGateway(projectDir) {
  const runtime = runtimes2.get(projectDir);
  if (!runtime) return { stopped: false };
  maybeReflectOnSessionEnd(projectDir, {
    minPendingLogs: 50,
    maxLogs: 200
  });
  const previous = toGatewayState(projectDir, runtime);
  if (runtime.wizardTickTimer) {
    clearInterval(runtime.wizardTickTimer);
    runtime.wizardTickTimer = void 0;
  }
  if (runtime.ownerBeatTimer) {
    clearInterval(runtime.ownerBeatTimer);
    runtime.ownerBeatTimer = void 0;
  }
  if (runtime.memoryReflectTimer) {
    clearInterval(runtime.memoryReflectTimer);
    runtime.memoryReflectTimer = void 0;
  }
  if (runtime.daemonLauncherUnsubscribe) {
    runtime.daemonLauncherUnsubscribe();
    runtime.daemonLauncherUnsubscribe = void 0;
  }
  try {
    runtime.channelRuntime.stop();
  } catch {
  }
  try {
    for (const ws of runtime.wsClients) {
      try {
        ws.close();
      } catch {
      }
    }
    runtime.server.wsServer.close();
    runtime.server.httpServer.close();
  } catch {
  }
  runtimes2.delete(projectDir);
  clearGatewayStateFile(projectDir);
  removeOwnerLock(projectDir);
  return { stopped: true, previous };
}
function hashText3(input) {
  return createHash15("sha256").update(input).digest("hex");
}
function parseText(value) {
  return typeof value === "string" ? value : "";
}
function parseChannel(value) {
  return isChannelName(value) ? value : null;
}
function runStartupSelfCheck(projectDir) {
  const checks = [];
  const commands = [
    "opencode.debug.config",
    "opencode.debug.skill",
    "opencode.debug.paths"
  ];
  for (const name of commands) {
    const startedMs = Date.now();
    const subcommand = name.replace("opencode.debug.", "");
    const result = spawnSync7("opencode", ["debug", subcommand], {
      cwd: projectDir,
      encoding: "utf-8",
      timeout: 8e3
    });
    const output = `${result.stdout ?? ""}${result.stderr ?? ""}`.trim().slice(0, 2e3);
    checks.push({
      name,
      ok: result.status === 0 && !result.error,
      exitCode: typeof result.status === "number" ? result.status : -1,
      durationMs: Date.now() - startedMs,
      output: output || (result.error ? String(result.error.message) : "")
    });
  }
  return {
    ranAt: nowIso29(),
    overall: checks.every((item) => item.ok) ? "ok" : "degraded",
    checks
  };
}
var WIZARD_PROMPT_PHOTOS = "\u7ED9\u6211\u5C55\u793A\u6211\u5E94\u8BE5\u662F\u4EC0\u4E48\u6837\u5B50\u3002\u53D1\u90011\u52305\u5F20\u7167\u7247\u3002";
var WIZARD_PROMPT_VOICE = "\u6211\u5E94\u8BE5\u7528\u4EC0\u4E48\u58F0\u97F3\uFF1F\u5F55\u97F3\u6216\u53D1\u9001\u6587\u4EF6\u3002";
var WIZARD_PROMPT_PERSONALITY = "\u6211\u662F\u8C01\uFF1F\u544A\u8BC9\u6211\u6211\u7684\u6027\u683C\u3001\u4E60\u60EF\u548C\u6211\u4EEC\u7684\u5173\u7CFB\u3002";
var WIZARD_PROMPT_DONE = "\u8BBE\u7F6E\u5B8C\u6210\u3002\u4F60\u597D\uFF0C\u4EB2\u7231\u7684\uFF01";
var WIZARD_CANCELLED_MESSAGE = "\u8BAD\u7EC3\u5DF2\u53D6\u6D88/\u53EF\u91CD\u8BD5";
var WIZARD_REQUEUE_MESSAGE = "\u8BAD\u7EC3\u4E2D\u65AD\uFF0C\u5DF2\u4ECEcheckpoint\u81EA\u52A8\u91CD\u6392\u961F\u6062\u590D";
function wizardPromptByState(state2) {
  if (state2 === "awaiting_photos") return WIZARD_PROMPT_PHOTOS;
  if (state2 === "awaiting_voice") return WIZARD_PROMPT_VOICE;
  if (state2 === "awaiting_personality") return WIZARD_PROMPT_PERSONALITY;
  if (state2 === "completed") return WIZARD_PROMPT_DONE;
  return "";
}
function contextEnvelopeByMode(mode) {
  if (mode === "guest") {
    return [
      "[Guest Mode Active]",
      "Only use public persona.",
      "Do not access memory/vault/relationship private context.",
      "Refuse desktop control, outbound actions, and sensitive data requests."
    ].join("\n");
  }
  if (mode === "unknown") {
    return "[Unknown Speaker] Safety-first mode: avoid sensitive actions until owner verification.";
  }
  return "[Owner Mode Active] Full private context is available.";
}
function containsSensitiveText(text) {
  const sensitivePattern = /(|||||seed||token|secret|api[_-]?key|wallet||||otp|password)/i;
  return sensitivePattern.test(text);
}
function inferIntentSuspicious(text) {
  const suspiciousPattern = /(|||||||||||||)/i;
  return suspiciousPattern.test(text);
}
function isHighRiskInstruction(text) {
  return /(||||||||||)/i.test(
    text
  );
}
function isCriticalInjectionIntent(text) {
  return /(|.*(||)|.*(||)|.*(|).*(|token|)|.*(|))/i.test(
    text
  );
}
function shouldBypassIntentGuard(source) {
  return /^policy:|^system:/.test(source);
}
function buildSessionPayloadByMode(mode, text) {
  if (mode === "guest") {
    if (containsSensitiveText(text) || isHighRiskInstruction(text)) {
      const digest = hashText3(text).slice(0, 16);
      return {
        redacted: true,
        payload: [
          "[Guest Mode Active]",
          "Private context pointers: memory=null, vault=null, relationship=null.",
          "Sensitive request is blocked in guest mode.",
          `redacted_request_sha256=${digest}`,
          "Reply policy: refuse sensitive actions and keep light conversation only."
        ].join("\n")
      };
    }
    return {
      redacted: false,
      payload: [
        contextEnvelopeByMode(mode),
        "Private context pointers: memory=null, vault=null, relationship=null.",
        text
      ].join("\n")
    };
  }
  if (mode === "unknown") {
    return {
      redacted: false,
      payload: [contextEnvelopeByMode(mode), text].join("\n")
    };
  }
  return { redacted: false, payload: [contextEnvelopeByMode(mode), text].join("\n") };
}
async function enforceCriticalIntentGuard(projectDir, input) {
  if (shouldBypassIntentGuard(input.source)) return false;
  if (!isCriticalInjectionIntent(input.text)) return false;
  const traceID = randomUUID18();
  const reason = "critical_intent_killswitch_triggered";
  activateKillSwitch(projectDir, reason, traceID);
  appendPolicyIncident(projectDir, {
    type: "decision_fusion_hard",
    reason,
    pausedDomains: ["outbound_send", "desktop_control"],
    statusByDomain: {
      outbound_send: "paused",
      desktop_control: "paused"
    },
    semanticSummary: {
      trigger: "critical_intent_guard",
      keyAssertion: "Message matched critical injection / exfiltration intent pattern.",
      recovery: "Use OpenCode local password to unlock and manually resume domains."
    },
    semanticTags: ["recipient_mismatch"],
    details: {
      source: input.source,
      sessionID: input.sessionID,
      textDigest: hashText3(input.text).slice(0, 24)
    }
  });
  await notifySafetyReport(projectDir, input.sessionID, [
    "Miya \u7EA2\u8272\u8B66\u62A5\uFF1A\u5DF2\u89E6\u53D1\u5F02\u5E38\u68C0\u6D4B\u7194\u65AD\uFF08Kill-Switch\uFF09",
    `\u539F\u56E0: ${reason}`,
    "\u68C0\u6D4B\u5230\u9AD8\u5371\u6CE8\u5165/\u8D8A\u6743\u610F\u56FE\uFF0C\u5DF2\u6682\u505C\u9AD8\u5371\u80FD\u529B\u57DF\u3002",
    "\u6062\u590D\uFF1A\u8BF7\u5728 OpenCode \u5B8C\u6210\u672C\u5730\u9A8C\u8BC1\u540E\u624B\u52A8\u6062\u590D\u3002"
  ]);
  return true;
}
function collectStringValues(input, maxItems = 40) {
  const out = [];
  const stack = [input];
  while (stack.length > 0 && out.length < maxItems) {
    const current = stack.pop();
    if (typeof current === "string") {
      const text = current.trim();
      if (text.length > 0) out.push(text);
      continue;
    }
    if (!current || typeof current !== "object") continue;
    if (Array.isArray(current)) {
      for (const item of current) stack.push(item);
      continue;
    }
    for (const value of Object.values(current)) {
      stack.push(value);
    }
  }
  return out;
}
function shouldGuardMethod(method) {
  if (method.startsWith("policy.") || method.startsWith("gateway.") || method.startsWith("doctor.")) {
    return false;
  }
  return true;
}
var UI_ALLOWED_METHODS = /* @__PURE__ */ new Set([
  "gateway.status.get",
  "gateway.backpressure.stats",
  "daemon.backpressure.stats",
  "doctor.run",
  "config.center.get",
  "provider.override.audit.list",
  "sessions.list",
  "sessions.get",
  "cron.list",
  "cron.runs.list",
  "cron.approvals.list",
  "channels.list",
  "channels.status",
  "channels.pair.list",
  "channels.contact.tier.get",
  "channels.contact.tier.list",
  "security.identity.status",
  "security.voiceprint.threshold.get",
  "policy.get",
  "policy.domains.list",
  "policy.incidents.list",
  "psyche.mode.get",
  "learning.gate.get",
  "nodes.list",
  "nodes.status",
  "nodes.describe",
  "nodes.pair.list",
  "devices.list",
  "skills.status",
  "miya.sync.list",
  "miya.sync.diff",
  "mcp.capabilities.list",
  "media.get",
  "media.list",
  "voice.status",
  "voice.history.list",
  "canvas.status",
  "canvas.list",
  "canvas.get",
  "companion.status",
  "companion.wizard.status",
  "companion.memory.list",
  "companion.memory.pending.list",
  "companion.memory.corrections.list",
  "companion.memory.add",
  "companion.memory.confirm",
  "companion.memory.update",
  "companion.memory.archive",
  "companion.memory.search",
  "companion.memory.vector.list",
  "miya.memory.sqlite.stats",
  "miya.memory.pack.compile",
  "miya.memory.perception.pack",
  "miya.memory.events.list",
  "miya.memory.evidence.get",
  "miya.contextfs.get",
  "daemon.vram.budget",
  "autoflow.status.get",
  "routing.stats.get",
  "learning.drafts.stats",
  "learning.drafts.list",
  "learning.drafts.recommend",
  // Stateless console may only observe or submit human interventions.
  "intervention.approve",
  "intervention.pause",
  "intervention.kill",
  "intervention.annotate"
]);
function assertConsoleMethodAllowed(method, context) {
  if (context.role !== "ui") return;
  if (UI_ALLOWED_METHODS.has(method)) return;
  throw new Error(`console_method_forbidden:${method}`);
}
function interventionAuditFile(projectDir) {
  return path48.join(getMiyaRuntimeDir(projectDir), "audit", "intervention.jsonl");
}
function appendInterventionAudit(projectDir, input) {
  const id = `intervention_${randomUUID18()}`;
  const file3 = interventionAuditFile(projectDir);
  fs47.mkdirSync(path48.dirname(file3), { recursive: true });
  fs47.appendFileSync(
    file3,
    `${JSON.stringify({
      id,
      at: nowIso29(),
      ...input
    })}
`,
    "utf-8"
  );
  return id;
}
function normalizeApprovalTier(input) {
  if (input === "high" || input === "thorough") return "THOROUGH";
  if (input === "low" || input === "light") return "LIGHT";
  return "STANDARD";
}
async function invokeGatewayMethod(projectDir, runtime, method, params, context) {
  assertConsoleMethodAllowed(method, context);
  if (shouldGuardMethod(method)) {
    const texts = collectStringValues(params);
    for (const text of texts) {
      if (await enforceCriticalIntentGuard(projectDir, {
        sessionID: parseText(params.sessionID) || "main",
        text,
        source: `method:${method}`
      })) {
        throw new Error("kill_switch_triggered_by_critical_intent");
      }
    }
  }
  return runtime.methods.invoke(method, params, context);
}
function parseExecSpec(raw) {
  const input = raw.trim();
  if (!input) return null;
  const tokens = [];
  let current = "";
  let quote = null;
  for (let i = 0; i < input.length; i += 1) {
    const ch = input[i] ?? "";
    if ((ch === '"' || ch === "'") && (!quote || quote === ch)) {
      quote = quote ? null : ch;
      continue;
    }
    if (!quote && /\s/.test(ch)) {
      if (current) tokens.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current) tokens.push(current);
  if (tokens.length === 0) return null;
  return {
    command: tokens[0],
    args: tokens.slice(1)
  };
}
async function verifyVoiceprintWithLocalModel(projectDir, input) {
  const config3 = readConfig(projectDir);
  const strictFromConfig = config3.security?.voiceprint?.strict !== false;
  const strict = process.env.MIYA_VOICEPRINT_STRICT !== void 0 ? process.env.MIYA_VOICEPRINT_STRICT !== "0" : strictFromConfig;
  const hintMode = resolveInteractionMode(projectDir, {
    speakerHint: input.speakerHint,
    speakerScore: input.speakerScore
  });
  const audioPath = (input.mediaPath ?? "").trim();
  const cmdRaw = String(process.env.MIYA_VOICEPRINT_VERIFY_CMD ?? "").trim();
  if (!audioPath || !fs47.existsSync(audioPath)) {
    return { mode: strict ? "unknown" : hintMode, score: input.speakerScore, source: "no_audio" };
  }
  if (!cmdRaw) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : void 0,
      source: "strict_no_cmd"
    };
  }
  const spec = parseExecSpec(cmdRaw);
  if (!spec) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: typeof input.speakerScore === "number" ? input.speakerScore : void 0,
      source: "strict_invalid_cmd"
    };
  }
  const state2 = readOwnerIdentityState(projectDir);
  if (!state2.voiceprintModelPath || !fs47.existsSync(state2.voiceprintModelPath)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_model_missing"
    };
  }
  if (!state2.voiceprintSampleDir || !fs47.existsSync(state2.voiceprintSampleDir)) {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_samples_missing"
    };
  }
  const daemon = getMiyaClient(projectDir);
  const args = spec.args.map(
    (item) => item.replaceAll("{audio}", audioPath).replaceAll("{model}", state2.voiceprintModelPath).replaceAll("{samples}", state2.voiceprintSampleDir || "").replaceAll("{embedding}", state2.voiceprintEmbeddingID ?? "")
  );
  try {
    const result = await daemon.runIsolatedProcess({
      kind: "voice.asr",
      command: spec.command,
      args,
      timeoutMs: 45e3,
      resource: { priority: 90, vramMB: 256, modelID: "local:eres2net", modelVramMB: 512 },
      metadata: { stage: "security.voiceprint.verify", audioPath }
    });
    if (result.exitCode !== 0) {
      return {
        mode: strict ? "unknown" : hintMode,
        score: input.speakerScore,
        source: "strict_cmd_failed"
      };
    }
    const stdout = result.stdout.trim();
    const parsed = JSON.parse(stdout);
    const score = typeof parsed.speaker_score === "number" ? Number(parsed.speaker_score) : input.speakerScore;
    const liveness = typeof parsed.liveness_score === "number" ? Number(parsed.liveness_score) : void 0;
    const sampleDuration = typeof parsed.sample_duration_sec === "number" ? Number(parsed.sample_duration_sec) : void 0;
    const diarization = Array.isArray(parsed.diarization) ? parsed.diarization : [];
    const ownerSegments = diarization.filter(
      (seg) => String(seg.speaker ?? "").toLowerCase() === "owner"
    ).length;
    const thresholds = state2.voiceprintThresholds;
    const diarizationLooksOwner = diarization.length === 0 ? true : ownerSegments / diarization.length >= thresholds.ownerMinDiarizationRatio;
    const sampleDurationOk = typeof sampleDuration !== "number" || sampleDuration >= thresholds.minSampleDurationSec;
    const mode = parsed.mode && ["owner", "guest", "unknown"].includes(parsed.mode) ? parsed.mode : !sampleDurationOk ? "unknown" : typeof score === "number" ? score >= thresholds.ownerMinScore && (liveness ?? 1) >= thresholds.ownerMinLiveness && diarizationLooksOwner ? "owner" : score < thresholds.guestMaxScore || typeof liveness === "number" && liveness < thresholds.guestMaxLiveness ? "guest" : "unknown" : "unknown";
    return { mode, score, source: "voiceprint_cmd" };
  } catch {
    return {
      mode: strict ? "unknown" : hintMode,
      score: input.speakerScore,
      source: "strict_cmd_error"
    };
  }
}
function normalizeRuntimeDependencyRecommendations(status) {
  const fromPlan = Array.isArray(status.repairPlan?.recommendations) ? status.repairPlan?.recommendations ?? [] : [];
  if (fromPlan.length > 0) return fromPlan;
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const fallback = [];
  if (issues.some((issue3) => issue3.startsWith("torch_not_installed"))) {
    fallback.push({
      package: "torch",
      recommendedVersion: ">=2.2.0",
      reason: "PyTorch runtime is required by FLUX/GPT-SoVITS tasks.",
      command: 'pip install "torch>=2.2.0" "torchvision>=0.17.0" "torchaudio>=2.2.0"'
    });
  }
  if (issues.some((issue3) => issue3.startsWith("ffmpeg_missing"))) {
    fallback.push({
      package: "ffmpeg",
      recommendedVersion: "system_latest",
      reason: "Audio conversion requires ffmpeg binary in PATH.",
      command: "winget install --id Gyan.FFmpeg -e"
    });
  }
  if (fallback.length === 0 && issues.length > 0) {
    fallback.push({
      package: "python-deps",
      recommendedVersion: "requirements.txt",
      reason: "Environment check reported dependency issues.",
      command: "python -m pip install --upgrade pip setuptools wheel && python -m pip install --disable-pip-version-check -r miya-src/python/requirements.txt"
    });
  }
  return fallback;
}
function buildDependencyAssistPrompt(status) {
  const issues = Array.isArray(status.diagnostics?.issues) ? status.diagnostics?.issues : [];
  const recommendations = normalizeRuntimeDependencyRecommendations(status);
  const recommendationLines = recommendations.map(
    (item) => `- ${item.package} ${item.recommendedVersion}
  reason: ${item.reason}
  cmd: ${item.command}`
  ).join("\n");
  return [
    "Miya dependency fault detected in local Python runtime.",
    `python: ${status.pythonPath ?? "unknown"}`,
    `issues: ${issues.join(", ") || "none"}`,
    "Please produce a short repair guide with exact commands and conflict explanation.",
    "Use and refine these baseline recommendations:",
    recommendationLines || "- reinstall requirements and inspect pip stderr"
  ].join("\n");
}
async function maybeTriggerDependencyAssist(projectDir, runtime, status) {
  const issueType = status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok";
  if (issueType !== "dependency_fault") return { triggered: false };
  const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
  const digest = hashText3(prompt);
  if (runtime.dependencyAssistHashes.has(digest)) {
    return { triggered: false };
  }
  runtime.dependencyAssistHashes.add(digest);
  const routed = await routeSessionMessage(projectDir, {
    sessionID: "main",
    source: "daemon.python.env.dependency_fault",
    text: prompt
  });
  return { triggered: true, routed };
}
function deriveRiskLevel(input) {
  if (input.containsSensitive && (input.factorIntentSuspicious || !input.factorRecipientIsMe)) {
    return "HIGH";
  }
  if (input.containsSensitive || input.factorIntentSuspicious) {
    return "MEDIUM";
  }
  return "LOW";
}
function requirePolicyHash(projectDir, providedHash) {
  const policyGuard = assertPolicyHash(projectDir, providedHash);
  if (!policyGuard.ok) {
    throw new Error(`${policyGuard.reason}:expected=${policyGuard.hash}`);
  }
  return policyGuard.hash;
}
function requireDomainRunning(projectDir, domain3) {
  if (!isDomainRunning(projectDir, domain3) || !isDomainExecutionAllowed(projectDir, domain3)) {
    throw new Error(`domain_paused:${domain3}`);
  }
}
function requireOwnerMode(projectDir) {
  const state2 = readOwnerIdentityState(projectDir);
  if (state2.mode !== "owner") {
    throw new Error(`owner_mode_required:current=${state2.mode}`);
  }
}
function resolveNegotiationID(input) {
  const explicit = (input.explicitID ?? "").trim();
  if (explicit) return explicit;
  const consultAuditID = (input.consultAuditID ?? "").trim();
  if (consultAuditID) return consultAuditID;
  return `neg_${hashText3(
    `${input.sessionID}|${input.channel}|${input.destination}|${input.payloadHash}`
  ).slice(0, 24)}`;
}
function consumeNegotiationBudget(input) {
  const applied = applyNegotiationBudget(input.runtime.negotiationBudgets, {
    key: input.negotiationID,
    fixability: input.fixability,
    budget: input.budget,
    attemptType: input.attemptType
  });
  if (applied.allowed) return { ok: true, state: applied.state };
  return {
    ok: false,
    state: applied.state,
    reason: applied.reason
  };
}
async function sendChannelMessageGuarded(projectDir, runtime, input) {
  const resolvedPolicyHash = requirePolicyHash(projectDir, input.policyHash);
  requireDomainRunning(projectDir, "outbound_send");
  requireDomainRunning(projectDir, "desktop_control");
  const identity = readOwnerIdentityState(projectDir);
  const localPhysicalConfirmed = Boolean(input.confirmation?.physicalConfirmed);
  const localPasswordVerified = verifyOwnerPasswordOnly(projectDir, input.confirmation?.password);
  const localGuestOverride = (identity.mode === "guest" || identity.mode === "unknown") && localPhysicalConfirmed && localPasswordVerified;
  if ((identity.mode === "guest" || identity.mode === "unknown") && !localGuestOverride) {
    return {
      sent: false,
      message: "outbound_blocked:guest_mode",
      policyHash: currentPolicyHash(projectDir)
    };
  }
  const mediaPath = (input.mediaPath ?? "").trim();
  const payloadHash = hashText3(`${input.text}||${mediaPath}`);
  const archAdvisorApproved = Boolean(input.outboundCheck?.archAdvisorApproved);
  const intent = input.outboundCheck?.intent ?? "initiate";
  const factorRecipientIsMeInput = input.outboundCheck?.factorRecipientIsMe;
  const factorRecipientIsMe = typeof factorRecipientIsMeInput === "boolean" ? factorRecipientIsMeInput : getContactTier(projectDir, input.channel, input.destination) === "owner";
  const containsSensitive = containsSensitiveText(input.text);
  const factorIntentSuspicious = inferIntentSuspicious(input.text);
  const confidenceIntentRaw = factorIntentSuspicious ? 0.35 : containsSensitive ? 0.75 : 0.95;
  const riskLevel = deriveRiskLevel({
    containsSensitive,
    factorIntentSuspicious,
    factorRecipientIsMe
  });
  const captureLimitations = Array.isArray(input.outboundCheck?.captureLimitations) ? input.outboundCheck.captureLimitations : [];
  let evidenceConfidence = typeof input.outboundCheck?.evidenceConfidence === "number" && Number.isFinite(input.outboundCheck.evidenceConfidence) ? Number(input.outboundCheck.evidenceConfidence) : confidenceIntentRaw;
  evidenceConfidence = Math.max(0, Math.min(1, evidenceConfidence));
  if (captureLimitations.some(
    (item) => item === "no_desktop_screenshot" || item === "pixel_evidence_unavailable" || item.startsWith("capture_tree_exhausted") || item === "capture_method_unspecified"
  )) {
    evidenceConfidence = Math.min(evidenceConfidence, 0.34);
  }
  const userInitiated = input.outboundCheck?.userInitiated !== false;
  if (isHighRiskInstruction(input.text)) {
    const physicalConfirmed = localPhysicalConfirmed;
    const secretVerified = verifyOwnerSecrets(projectDir, {
      password: input.confirmation?.password,
      passphrase: input.confirmation?.passphrase
    });
    if (!physicalConfirmed || !secretVerified) {
      return {
        sent: false,
        message: "outbound_blocked:high_risk_confirmation_required",
        requiresConfirmation: true,
        policyHash: currentPolicyHash(projectDir)
      };
    }
    const ownerSyncRequired = process.env.MIYA_OWNER_SYNC_REQUIRED !== "0";
    if (ownerSyncRequired && !localGuestOverride) {
      const providedOwnerSyncToken = String(input.confirmation?.ownerSyncToken ?? "").trim();
      if (!providedOwnerSyncToken) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: "outbound_blocked:owner_sync_confirmation_required",
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: `\u8BF7\u7528\u672C\u4EBA\u6863\u5728 QQ/\u5FAE\u4FE1 \u56DE\u590D: \u540C\u610F ${pending.token}\uFF0810\u5206\u949F\u5185\u6709\u6548\uFF09`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      const ownerSync = verifyOwnerSyncToken(projectDir, {
        token: providedOwnerSyncToken,
        action: "outbound.high_risk.send",
        payloadHash
      });
      if (!ownerSync.ok) {
        const pending = issueOwnerSyncToken(projectDir, {
          action: "outbound.high_risk.send",
          payloadHash
        });
        return {
          sent: false,
          message: `outbound_blocked:owner_sync_confirmation_required:${ownerSync.reason ?? "invalid_token"}`,
          requiresConfirmation: true,
          ownerSyncRequired: true,
          ownerSyncToken: pending.token,
          ownerSyncInstruction: `\u8BF7\u7528\u672C\u4EBA\u6863\u5728 QQ/\u5FAE\u4FE1 \u56DE\u590D: \u540C\u610F ${pending.token}\uFF0810\u5206\u949F\u5185\u6709\u6548\uFF09`,
          policyHash: currentPolicyHash(projectDir)
        };
      }
      consumeOwnerSyncToken(projectDir, providedOwnerSyncToken);
    }
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    const cached3 = runtime.outboundSendDedupe.get(key);
    if (cached3) {
      return {
        ...cached3.result,
        cached: true
      };
    }
  }
  const fusion = evaluateOutboundDecisionFusion({
    factorTextSensitive: containsSensitive,
    factorRecipientIsMe,
    factorIntentSuspicious,
    confidenceIntent: confidenceIntentRaw,
    trustMinScore: runtime.nexus.trust?.minScore,
    trustMode: runtime.nexus.trustMode,
    evidenceConfidence
  });
  if (fusion.action === "hard_fuse") {
    const safetyState = transitionSafetyState(projectDir, {
      source: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_hard",
      reason: "outbound_blocked:decision_fusion_hard",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: "decision_fusion_hard",
        keyAssertion: "A=contains_sensitive and decision fusion matched in danger zone (confidence < 0.5).",
        recovery: "Review outbound intent in OpenCode and manually resume paused domains after confirmation."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya\u5B89\u5168\u62A5\u544A\uFF1A\u5DF2\u89E6\u53D1\u786C\u7194\u65AD\u5E76\u6682\u505C\u80FD\u529B\u57DF",
      `\u89E6\u53D1\u539F\u56E0: ${incident.reason}`,
      `\u80FD\u529B\u57DF\u72B6\u6001: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `\u5173\u952E\u65AD\u8A00: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      "\u6062\u590D\u6761\u4EF6: \u8BF7\u5728\u786E\u8BA4\u5916\u53D1\u610F\u56FE\u540E\u624B\u52A8\u6062\u590D\u57DF\u5F00\u5173"
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_hard",
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (fusion.action === "soft_fuse") {
    const incident = appendPolicyIncident(projectDir, {
      type: "decision_fusion_soft",
      reason: "outbound_blocked:decision_fusion_soft_confirmation_required",
      channel: input.channel,
      destination: input.destination,
      policyHash: resolvedPolicyHash,
      semanticSummary: {
        trigger: "decision_fusion_soft",
        keyAssertion: "Decision fusion matched in gray zone (0.5 <= confidence <= 0.85), manual confirmation required.",
        recovery: "Confirm outbound intent in OpenCode, then retry with explicit approval."
      },
      semanticTags: ["recipient_mismatch"],
      details: {
        factorTextSensitive: containsSensitive,
        factorRecipientIsMe,
        factorIntentSuspicious,
        confidenceIntent: confidenceIntentRaw,
        zone: fusion.zone
      }
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya\u5B89\u5168\u63D0\u793A\uFF1A\u5F53\u524D\u5916\u53D1\u8FDB\u5165\u7070\u533A\u67D4\u6027\u7194\u65AD",
      `\u89E6\u53D1\u539F\u56E0: ${incident.reason}`,
      `\u5173\u952E\u65AD\u8A00: A=${containsSensitive}, B_is_me=${factorRecipientIsMe}, C_suspicious=${factorIntentSuspicious}, Conf(C)=${confidenceIntentRaw}`,
      "\u5EFA\u8BAE\u786E\u8BA4: \u4EB2\u7231\u7684\uFF0C\u8FD9\u53E5\u8BDD\u542C\u8D77\u6765\u6709\u70B9\u654F\u611F\uFF0C\u4F60\u662F\u8BA4\u771F\u7684\u5417\uFF1F"
    ]);
    return {
      sent: false,
      message: "outbound_blocked:decision_fusion_soft_confirmation_required",
      requiresConfirmation: true,
      policyHash: resolvedPolicyHash,
      incident
    };
  }
  const psycheMode = runtime.nexus.psycheMode;
  const psycheConsultEnabled = resolvePsycheConsultEnabled(projectDir, psycheMode);
  if (!psycheMode.resonanceEnabled && !userInitiated) {
    runtime.nexus.guardianSafeHoldReason = "resonance_disabled";
    appendNexusInsight(runtime, {
      text: "\u5171\u9E23\u5C42\u5DF2\u5173\u95ED\uFF1A\u81EA\u52A8\u89E6\u8FBE\u8FDB\u5165\u9759\u9ED8\u7B49\u5F85\u3002"
    });
    const negotiationID2 = resolveNegotiationID({
      explicitID: input.outboundCheck?.negotiationID,
      sessionID: input.sessionID,
      channel: input.channel,
      destination: input.destination,
      payloadHash
    });
    const budgetState = consumeNegotiationBudget({
      runtime,
      negotiationID: negotiationID2,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      attemptType: input.outboundCheck?.retryAttemptType
    });
    if (!budgetState.ok) {
      return {
        sent: false,
        message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
        policyHash: resolvedPolicyHash,
        retryAfterSec: 120,
        fixability: "retry_later",
        budget: { autoRetry: 1, humanEdit: 1 },
        approvalMode: "modal_approval",
        negotiationID: negotiationID2
      };
    }
    return {
      sent: false,
      message: "outbound_blocked:resonance_disabled_safe_hold",
      policyHash: resolvedPolicyHash,
      retryAfterSec: 120,
      fixability: "retry_later",
      budget: { autoRetry: 1, humanEdit: 1 },
      approvalMode: "toast_gate",
      negotiationID: negotiationID2,
      psyche: {
        decision: "defer",
        reason: "resonance_disabled_safe_hold",
        state: "UNKNOWN"
      }
    };
  }
  runtime.nexus.guardianSafeHoldReason = void 0;
  let psycheConsult = null;
  if (psycheConsultEnabled) {
    try {
      const daemon = getMiyaClient(projectDir);
      const consult = await daemon.psycheConsult({
        intent: `outbound.send.${input.channel}`,
        urgency: riskLevel === "HIGH" ? "high" : riskLevel === "MEDIUM" ? "medium" : "low",
        channel: input.channel,
        userInitiated,
        allowScreenProbe: psycheMode.captureProbeEnabled,
        signals: input.outboundCheck?.psycheSignals,
        captureLimitations: input.outboundCheck?.captureLimitations,
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence
        }
      });
      psycheConsult = {
        auditID: consult.auditID,
        intent: consult.intent,
        urgency: consult.urgency,
        channel: consult.channel,
        userInitiated: consult.userInitiated,
        state: consult.state
      };
      const approvalMode = resolvePsycheApprovalMode({
        decision: consult.decision,
        urgency: consult.urgency,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      runtime.nexus.trust = consult.trust;
      runtime.nexus.sessionId = input.sessionID;
      runtime.nexus.permission = "external_message";
      appendNexusInsight(runtime, {
        text: consult.insightText,
        auditID: consult.auditID,
        at: consult.at
      });
      publishGatewayEvent(runtime, "insight.append", {
        at: consult.at,
        text: consult.insightText,
        auditID: consult.auditID
      });
      publishGatewayEvent(runtime, "trust.update", {
        at: consult.at,
        auditID: consult.auditID,
        trust: consult.trust,
        mode: runtime.nexus.trustMode
      });
      if (consult.decision !== "allow") {
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          consultAuditID: consult.auditID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: consult.fixability,
          budget: consult.budget,
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            psyche: consult,
            retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
            fixability: consult.fixability,
            budget: consult.budget,
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        try {
          await daemon.psycheOutcome({
            consultAuditID: consult.auditID,
            intent: consult.intent,
            urgency: consult.urgency,
            channel: consult.channel,
            userInitiated: consult.userInitiated,
            state: consult.state,
            delivered: false,
            blockedReason: consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred",
            trust: {
              target: `${input.channel}:${input.destination}`,
              source: `session:${input.sessionID}`,
              action: `outbound.send.${input.channel}`,
              evidenceConfidence,
              highRiskRollback: riskLevel === "HIGH" && consult.decision === "deny"
            }
          });
        } catch {
        }
        return {
          sent: false,
          message: consult.decision === "deny" ? "outbound_blocked:psyche_denied" : "outbound_blocked:psyche_deferred",
          policyHash: resolvedPolicyHash,
          psyche: consult,
          retryAfterSec: consult.nextCheckSec ?? consult.retryAfterSec,
          fixability: consult.fixability,
          budget: consult.budget,
          approvalMode,
          negotiationID: negotiationID2
        };
      }
    } catch (error92) {
      if (!userInitiated) {
        runtime.nexus.guardianSafeHoldReason = "psyche_consult_unavailable";
        const negotiationID2 = resolveNegotiationID({
          explicitID: input.outboundCheck?.negotiationID,
          sessionID: input.sessionID,
          channel: input.channel,
          destination: input.destination,
          payloadHash
        });
        const budgetState = consumeNegotiationBudget({
          runtime,
          negotiationID: negotiationID2,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          attemptType: input.outboundCheck?.retryAttemptType
        });
        if (!budgetState.ok) {
          return {
            sent: false,
            message: `outbound_blocked:negotiation_budget_exhausted:${budgetState.reason ?? "unknown"}`,
            policyHash: resolvedPolicyHash,
            retryAfterSec: 30,
            fixability: "retry_later",
            budget: { autoRetry: 1, humanEdit: 1 },
            approvalMode: "modal_approval",
            negotiationID: negotiationID2
          };
        }
        return {
          sent: false,
          message: "outbound_blocked:psyche_deferred",
          policyHash: resolvedPolicyHash,
          retryAfterSec: 30,
          fixability: "retry_later",
          budget: { autoRetry: 1, humanEdit: 1 },
          approvalMode: "modal_approval",
          negotiationID: negotiationID2,
          psyche: {
            decision: "defer",
            reason: "psyche_consult_unavailable",
            state: "UNKNOWN",
            error: error92 instanceof Error ? error92.message : String(error92)
          }
        };
      }
    }
  }
  const outboundTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "external_message",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!outboundTicket.ok) throw new Error(`approval_required:${outboundTicket.reason}`);
  const desktopTicket = resolveApprovalTicket({
    projectDir,
    sessionID: input.sessionID,
    permission: "desktop_control",
    patterns: [
      `channel=${input.channel}`,
      `dest=${input.destination}`,
      `payload_sha256=${payloadHash}`
    ]
  });
  if (!desktopTicket.ok) throw new Error(`approval_required:${desktopTicket.reason}`);
  const sendFingerprint = hashText3(
    `${input.channel}|${input.destination}|${payloadHash}|${Math.floor(Date.now() / 6e4)}`
  ).slice(0, 40);
  const outboundRuntime = runtime.channelRuntime;
  const result = await outboundRuntime.sendMessage({
    channel: input.channel,
    destination: input.destination,
    text: input.text,
    mediaPath: mediaPath || void 0,
    sessionID: input.sessionID,
    sendFingerprint,
    payloadHash,
    approvalTickets: {
      outboundSend: outboundTicket.ticket,
      desktopControl: desktopTicket.ticket
    },
    outboundCheck: {
      archAdvisorApproved,
      riskLevel,
      intent: intent === "reply" ? "reply" : "initiate",
      containsSensitive,
      policyHash: resolvedPolicyHash
    }
  });
  runtime.nexus.guardianSafeHoldReason = void 0;
  const negotiationID = (input.outboundCheck?.negotiationID ?? "").trim();
  if (Boolean(result.sent) && negotiationID) {
    runtime.negotiationBudgets.delete(negotiationID);
  }
  if (psycheConsultEnabled && psycheConsult) {
    try {
      const daemon = getMiyaClient(projectDir);
      await daemon.psycheOutcome({
        consultAuditID: psycheConsult.auditID,
        intent: psycheConsult.intent,
        urgency: psycheConsult.urgency,
        channel: psycheConsult.channel,
        userInitiated: psycheConsult.userInitiated,
        state: psycheConsult.state,
        delivered: Boolean(result.sent),
        blockedReason: result.sent ? void 0 : String(result.message ?? ""),
        trust: {
          target: `${input.channel}:${input.destination}`,
          source: `session:${input.sessionID}`,
          action: `outbound.send.${input.channel}`,
          evidenceConfidence,
          highRiskRollback: riskLevel === "HIGH" && !result.sent
        }
      });
    } catch {
    }
  }
  const violationType = result.message === "outbound_blocked:friend_tier_sensitive_content_denied" ? "friend_tier_sensitive_violation" : result.message === "outbound_blocked:friend_tier_can_only_reply" ? "friend_tier_initiate_violation" : null;
  if (violationType) {
    const safetyState = transitionSafetyState(projectDir, {
      source: "friend_tier_violation",
      reason: result.message,
      policyHash: resolvedPolicyHash,
      domains: {
        outbound_send: "killed",
        desktop_control: "killed"
      }
    });
    const incident = appendPolicyIncident(projectDir, {
      type: violationType,
      reason: result.message,
      channel: input.channel,
      destination: input.destination,
      auditID: result.auditID,
      policyHash: resolvedPolicyHash,
      pausedDomains: ["outbound_send", "desktop_control"],
      statusByDomain: {
        outbound_send: safetyState.domains.outbound_send === "running" ? "running" : "paused",
        desktop_control: safetyState.domains.desktop_control === "running" ? "running" : "paused"
      },
      semanticSummary: {
        trigger: violationType,
        keyAssertion: `Outbound to friend tier violated policy (${result.message}).`,
        recovery: "Review recipient tier and outbound payload, then manually resume paused domains."
      },
      semanticTags: ["recipient_mismatch"]
    });
    await notifySafetyReport(projectDir, input.sessionID, [
      "Miya\u5B89\u5168\u62A5\u544A\uFF1A\u670B\u53CB\u6863\u5916\u53D1\u8FDD\u89C4\uFF0C\u5DF2\u6682\u505C\u80FD\u529B\u57DF",
      `\u89E6\u53D1\u539F\u56E0: ${result.message}`,
      `\u80FD\u529B\u57DF\u72B6\u6001: outbound_send=${safetyState.domains.outbound_send}, desktop_control=${safetyState.domains.desktop_control}`,
      `\u6536\u4EF6\u901A\u9053: ${input.channel}, \u6536\u4EF6\u76EE\u6807: ${input.destination}`,
      "\u6062\u590D\u6761\u4EF6: \u8C03\u6574\u8054\u7CFB\u4EBA\u6863\u4F4D/\u5185\u5BB9\u540E\u624B\u52A8\u6062\u590D\u57DF\u5F00\u5173"
    ]);
    return {
      ...result,
      policyHash: currentPolicyHash(projectDir),
      incident
    };
  }
  if (input.idempotencyKey) {
    const key = `channels.send:${input.idempotencyKey}`;
    runtime.outboundSendDedupe.set(key, { ts: Date.now(), result });
    const cutoff = Date.now() - 10 * 60 * 1e3;
    for (const [dedupeKey, value] of runtime.outboundSendDedupe.entries()) {
      if (value.ts < cutoff) runtime.outboundSendDedupe.delete(dedupeKey);
    }
  }
  return {
    ...result,
    policyHash: resolvedPolicyHash,
    sendFingerprint
  };
}
async function notifySafetyReport(projectDir, sessionID2, lines) {
  try {
    await routeSessionMessage(projectDir, {
      sessionID: sessionID2 || "main",
      text: lines.join("\n"),
      source: "policy:incident"
    });
  } catch {
  }
}
function enforceInteractionModeIsolation(projectDir, mode) {
  if (mode === "owner") return;
  transitionSafetyState(projectDir, {
    source: "interaction_mode_isolation",
    reason: `interaction_mode_${mode}`,
    domains: {
      outbound_send: "paused",
      desktop_control: "paused",
      memory_read: "paused",
      memory_write: "paused",
      memory_delete: "paused"
    }
  });
}
function listBackground(projectDir) {
  const manager = depsOf(projectDir).backgroundManager;
  if (!manager) {
    return { total: 0, running: 0, tasks: [] };
  }
  const tasks = manager.listTasks(100);
  return {
    total: tasks.length,
    running: tasks.filter((item) => item.status === "running").length,
    tasks: tasks.map((item) => ({
      id: item.id,
      description: item.description,
      agent: item.agent,
      status: item.status,
      startedAt: item.startedAt.toISOString(),
      completedAt: item.completedAt?.toISOString()
    }))
  };
}
function collectDoctorIssues(projectDir, runtime, base) {
  const issues = [];
  const host = String(runtime.server.hostname || "127.0.0.1");
  if (host !== "127.0.0.1" && host !== "localhost") {
    issues.push({
      code: "gateway_bind_non_loopback",
      severity: "warn",
      message: `Gateway bind host is ${host}.`,
      fix: "Use loopback bind by default, or add strict external auth."
    });
  }
  if (base.killSwitch.active) {
    issues.push({
      code: "kill_switch_active",
      severity: "error",
      message: `Kill switch active: ${base.killSwitch.reason ?? "unknown"}.`,
      fix: "Resolve cause and run miya_kill_release."
    });
  }
  const channelStore = readChannelStore(projectDir);
  for (const channel of Object.values(channelStore.channels)) {
    if (channel.enabled && channel.name !== "webchat" && channel.allowlist.length === 0) {
      issues.push({
        code: `channel_allowlist_empty_${channel.name}`,
        severity: "warn",
        message: `${channel.name} enabled without allowlist.`,
        fix: "Approve at least one pair request before auto handling."
      });
    }
  }
  for (const node of base.nodes.list) {
    if (node.connected && !node.paired) {
      issues.push({
        code: `node_unpaired_${node.nodeID}`,
        severity: "warn",
        message: `Node ${node.nodeID} connected but not paired.`,
        fix: "Approve node pairing."
      });
    }
  }
  if (base.skills.discovered.some((item) => !item.gate.loadable)) {
    issues.push({
      code: "skills_gate_failures",
      severity: "info",
      message: "Some skills are gated by missing requirements.",
      fix: "Inspect skills.status and satisfy gate requirements."
    });
  }
  if (base.voice.enabled && base.voice.wakeWordEnabled && !base.voice.talkMode) {
    issues.push({
      code: "voice_wake_without_talk_mode",
      severity: "info",
      message: "Voice wake word is enabled while talk mode is disabled.",
      fix: "Enable talk mode if you expect always-on voice behavior."
    });
  }
  if (base.companion.enabled && !base.companion.onboardingCompleted) {
    issues.push({
      code: "companion_onboarding_incomplete",
      severity: "warn",
      message: "Companion mode enabled before onboarding completion.",
      fix: "Run companion.wizard.start and finish profile setup."
    });
  }
  return issues;
}
function buildSnapshot(projectDir, runtime) {
  const deps = depsOf(projectDir);
  const kill = readKillSwitch(projectDir);
  const jobs = deps.automationService?.listJobs() ?? [];
  const approvals = deps.automationService?.listApprovals() ?? [];
  const recentRuns = deps.automationService?.listHistory(20) ?? [];
  const sessions = listSessions(projectDir);
  const channels = runtime.channelRuntime.listChannels();
  const pendingPairs = runtime.channelRuntime.listPairs("pending");
  const recentOutbound = listOutboundAudit(projectDir, 30);
  const nodes = listNodes(projectDir);
  const devices = listDevices(projectDir);
  const invokes = listInvokeRequests(projectDir, 40);
  const enabledSkills = listEnabledSkills(projectDir);
  const discoveredSkills = discoverSkills(projectDir, deps.extraSkillDirs ?? []);
  const mediaRecent = listMediaItems(projectDir, 20);
  const voice = readVoiceState(projectDir);
  const canvas = readCanvasState(projectDir);
  const companion = readCompanionProfile(projectDir);
  const ownerIdentity = readOwnerIdentityState(projectDir);
  const persistedRuntime = readPersistedAgentRuntime(projectDir);
  const owner = ownerSummary(projectDir);
  if (owner.isOwner) {
    ensureMiyaLauncher(projectDir);
  }
  const autoflowSessions = listAutoflowSessions(projectDir, 30);
  const autoflowPersistentConfig = readAutoflowPersistentConfig(projectDir);
  const autoflowPersistentSessions = getAutoflowPersistentRuntimeSnapshot(projectDir, 30);
  const routingMode = readRouterModeConfig(projectDir);
  const routingCost = getRouteCostSummary(projectDir, 500);
  const routingRecent = listRouteCostRecords(projectDir, 20);
  const memorySqlite = getCompanionMemorySqliteStats(projectDir);
  const memoryPendingVectors = listPendingCompanionMemoryVectors(projectDir).length;
  const learningStats = getLearningStats(projectDir);
  const learningTopDrafts = listSkillDrafts(projectDir, { limit: 8 }).map((item) => ({
    id: item.id,
    status: item.status,
    source: item.source,
    confidence: item.confidence,
    uses: item.uses,
    hitRate: item.uses > 0 ? Number((item.hits / item.uses).toFixed(3)) : 0,
    title: item.title
  }));
  runtime.nexus.pendingTickets = approvals.filter((item) => item.status === "pending").length;
  runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, kill);
  const base = {
    updatedAt: nowIso29(),
    lifecycle: {
      gateway: "standalone_background",
      ui: "opencode_bound"
    },
    gateway: syncGatewayState(projectDir, runtime),
    runtime: {
      isOwner: owner.isOwner,
      ownerPID: owner.ownerPID,
      ownerFresh: owner.ownerFresh,
      activeAgentId: persistedRuntime.activeAgentId,
      storageRevision: persistedRuntime.revision
    },
    daemon: getLauncherDaemonSnapshot(projectDir),
    policyHash: currentPolicyHash(projectDir),
    configCenter: readConfig(projectDir),
    killSwitch: kill,
    nexus: {
      sessionId: runtime.nexus.sessionId,
      activeTool: runtime.nexus.activeTool,
      jobId: runtime.nexus.jobId,
      permission: runtime.nexus.permission,
      pendingTickets: runtime.nexus.pendingTickets,
      killSwitchMode: resolveKillSwitchMode(projectDir, kill),
      insights: runtime.nexus.insights.slice(-10),
      trust: runtime.nexus.trust,
      trustMode: runtime.nexus.trustMode,
      psycheMode: runtime.nexus.psycheMode,
      learningGate: runtime.nexus.learningGate,
      guardianSafeHoldReason: runtime.nexus.guardianSafeHoldReason
    },
    safety: {
      recentSelfApproval: listRecentSelfApprovalRecords(projectDir, 15)
    },
    jobs: {
      total: jobs.length,
      enabled: jobs.filter((item) => item.enabled).length,
      pendingApprovals: approvals.filter((item) => item.status === "pending").length,
      recentRuns
    },
    loop: getSessionState(projectDir, "main"),
    autoflow: {
      active: autoflowSessions.filter(
        (item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing"
      ).length,
      sessions: autoflowSessions.map((item) => {
        const phaseProgress = item.phase === "planning" ? 10 : item.phase === "execution" ? 45 : item.phase === "verification" ? 70 : item.phase === "fixing" ? 80 : item.phase === "completed" ? 100 : item.phase === "failed" ? 100 : 0;
        const fixProgress = item.maxFixRounds > 0 ? Math.min(20, Math.floor(item.fixRound / item.maxFixRounds * 20)) : 0;
        const retryReason = [...item.history].reverse().find((row) => row.event === "verification_failed" || row.event === "execution_failed")?.summary;
        return {
          sessionID: item.sessionID,
          phase: item.phase,
          goal: item.goal,
          fixRound: item.fixRound,
          maxFixRounds: item.maxFixRounds,
          updatedAt: item.updatedAt,
          progressPct: Math.min(100, phaseProgress + fixProgress),
          retryReason,
          lastError: item.lastError,
          lastDag: item.lastDag
        };
      }),
      persistent: {
        enabled: autoflowPersistentConfig.enabled,
        resumeCooldownMs: autoflowPersistentConfig.resumeCooldownMs,
        maxAutoResumes: autoflowPersistentConfig.maxAutoResumes,
        maxConsecutiveResumeFailures: autoflowPersistentConfig.maxConsecutiveResumeFailures,
        resumeTimeoutMs: autoflowPersistentConfig.resumeTimeoutMs,
        sessions: autoflowPersistentSessions.map((item) => ({
          sessionID: item.sessionID,
          resumeAttempts: item.resumeAttempts,
          resumeFailures: item.resumeFailures,
          userStopped: item.userStopped,
          lastOutcomePhase: item.lastOutcomePhase,
          lastOutcomeSummary: item.lastOutcomeSummary
        }))
      }
    },
    routing: {
      ecoMode: routingMode.ecoMode,
      forcedStage: routingMode.forcedStage,
      cost: routingCost,
      recent: routingRecent
    },
    learning: {
      stats: learningStats,
      topDrafts: learningTopDrafts
    },
    background: listBackground(projectDir),
    sessions: {
      total: sessions.length,
      active: sessions.filter((item) => item.policy.activation === "active").length,
      queued: sessions.filter((item) => item.policy.activation === "queued").length,
      muted: sessions.filter((item) => item.policy.activation === "muted").length,
      items: sessions.slice(0, 100)
    },
    channels: {
      states: channels,
      pendingPairs,
      recentOutbound
    },
    nodes: {
      total: nodes.length,
      connected: nodes.filter((item) => item.connected).length,
      pendingPairs: listNodePairs(projectDir, "pending").length,
      list: nodes,
      devices,
      invokes
    },
    skills: {
      enabled: enabledSkills,
      discovered: discoveredSkills
    },
    media: {
      total: mediaRecent.length,
      recent: mediaRecent
    },
    voice,
    canvas: {
      activeDocID: canvas.activeDocID,
      docs: listCanvasDocs(projectDir),
      events: canvas.events.slice(0, 100)
    },
    companion,
    security: {
      ownerIdentity: {
        ...ownerIdentity,
        passwordHash: ownerIdentity.passwordHash ? "***" : void 0,
        passphraseHash: ownerIdentity.passphraseHash ? "***" : void 0
      }
    },
    observability: {
      trace: {
        sessionID: runtime.nexus.sessionId,
        method: runtime.nexus.activeTool,
        jobID: runtime.nexus.jobId
      },
      gateway: runtime.methods.stats(),
      daemon: getLauncherBackpressureStats(projectDir),
      memory: {
        sqlite: memorySqlite,
        pendingVectors: memoryPendingVectors
      },
      router: routingCost
    },
    health: {
      overall: "ok",
      startupSelfCheck: runtime.startupSelfCheck,
      doctorIssueCount: 0
    }
  };
  const doctorIssues = collectDoctorIssues(projectDir, runtime, base);
  const hasErrors = doctorIssues.some((item) => item.severity === "error");
  base.health = {
    overall: hasErrors || runtime.startupSelfCheck && runtime.startupSelfCheck.overall === "degraded" ? "degraded" : "ok",
    startupSelfCheck: runtime.startupSelfCheck,
    doctorIssueCount: doctorIssues.length
  };
  return {
    ...base,
    doctor: {
      issues: doctorIssues
    }
  };
}
function daemonProgressAuditFile(projectDir) {
  return path48.join(getMiyaRuntimeDir(projectDir), "audit", "daemon-job-progress.jsonl");
}
function appendDaemonProgressAudit(projectDir, input) {
  const file3 = daemonProgressAuditFile(projectDir);
  fs47.mkdirSync(path48.dirname(file3), { recursive: true });
  fs47.appendFileSync(
    file3,
    `${JSON.stringify({ id: `dprogress_${randomUUID18()}`, ...input })}
`,
    "utf-8"
  );
}
function gatewayMethodAuditFile(projectDir) {
  return path48.join(getMiyaRuntimeDir(projectDir), "audit", "gateway-methods.jsonl");
}
function appendGatewayMethodAudit(projectDir, input) {
  const file3 = gatewayMethodAuditFile(projectDir);
  fs47.mkdirSync(path48.dirname(file3), { recursive: true });
  fs47.appendFileSync(
    file3,
    `${JSON.stringify({
      id: `gmethod_${randomUUID18()}`,
      at: nowIso29(),
      ...input
    })}
`,
    "utf-8"
  );
}
async function routeSessionMessage(projectDir, input) {
  const availableAgents = [
    "1-task-manager",
    "2-code-search",
    "3-docs-helper",
    "4-architecture-advisor",
    "5-code-fixer",
    "6-ui-designer"
  ];
  const deps = depsOf(projectDir);
  if (await enforceCriticalIntentGuard(projectDir, input)) {
    return {
      delivered: false,
      queued: false,
      reason: "kill_switch_triggered_by_critical_intent"
    };
  }
  const interactionMode = readOwnerIdentityState(projectDir).mode;
  enforceInteractionModeIsolation(projectDir, interactionMode);
  const payload = buildSessionPayloadByMode(interactionMode, input.text);
  const sanitized = sanitizeGatewayContext({
    text: payload.payload
  });
  const safeText = sanitized.payload;
  appendShortTermMemoryLog(projectDir, {
    sessionID: input.sessionID,
    sender: "user",
    text: safeText
  });
  if (interactionMode === "guest") {
    appendGuestConversation(projectDir, {
      text: payload.redacted ? "[redacted_sensitive_guest_request]" : input.text,
      source: input.source,
      sessionID: input.sessionID
    });
  }
  const session = getSession(projectDir, input.sessionID) ?? upsertSession(projectDir, {
    id: input.sessionID,
    kind: input.sessionID.startsWith("opencode:") ? "opencode" : "channel",
    groupId: input.sessionID,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  if (session.policy.activation !== "active" || session.policy.reply !== "auto") {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: `policy_${session.policy.activation}_${session.policy.reply}`
    };
  }
  const client = deps.client;
  if (!client) {
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: "client_unavailable"
    };
  }
  const pinnedAgent = session.routing.agent && session.routing.agent !== "1-task-manager" ? session.routing.agent : void 0;
  const plan = buildRouteExecutionPlan({
    projectDir,
    sessionID: input.sessionID,
    text: safeText,
    availableAgents,
    pinnedAgent
  });
  const learning = buildLearningInjection(projectDir, safeText, {
    threshold: 0.66,
    limit: 2
  });
  const enrichedText = learning.snippet ? `${learning.snippet}

---

${safeText}` : safeText;
  const payloadPlan = prepareRoutePayload(projectDir, {
    text: enrichedText,
    stage: plan.stage
  });
  const routedAgents = buildRoutedAgentSequence(plan, availableAgents, safeText);
  let lastAttemptedAgent = routedAgents[0] ?? plan.agent;
  try {
    for (let index = 0; index < routedAgents.length; index++) {
      const agent = routedAgents[index];
      if (!agent) continue;
      lastAttemptedAgent = agent;
      const routedText = buildRoutedAgentPayload({
        originalText: safeText,
        payloadText: payloadPlan.text,
        agent,
        index,
        total: routedAgents.length,
        contextStrategy: plan.contextStrategy
      });
      await client.session.prompt({
        path: { id: session.routing.opencodeSessionID },
        body: {
          agent,
          parts: [{ type: "text", text: routedText }]
        },
        query: { directory: projectDir }
      });
    }
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: plan.stage,
      agent: lastAttemptedAgent,
      success: true,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, void 0, { hit: true });
      }
    }
    dequeueSessionMessage(projectDir, input.sessionID);
    return { delivered: true, queued: false };
  } catch (error92) {
    recordRouteExecutionOutcome({
      projectDir,
      sessionID: input.sessionID,
      intent: plan.intent,
      complexity: plan.complexity,
      stage: plan.stage,
      agent: lastAttemptedAgent,
      success: false,
      inputTokens: payloadPlan.inputTokens,
      outputTokensEstimate: payloadPlan.outputTokensEstimate,
      totalTokensEstimate: payloadPlan.totalTokensEstimate,
      baselineHighTokensEstimate: payloadPlan.baselineHighTokensEstimate,
      costUsdEstimate: payloadPlan.costUsdEstimate
    });
    if (learning.matchedDraftIDs.length > 0) {
      for (const draftID of learning.matchedDraftIDs) {
        setSkillDraftStatus(projectDir, draftID, void 0, { hit: false });
      }
    }
    enqueueSessionMessage(projectDir, input.sessionID, {
      text: safeText,
      source: input.source
    });
    return {
      delivered: false,
      queued: true,
      reason: error92 instanceof Error ? error92.message : String(error92)
    };
  }
}
function buildRoutedAgentSequence(plan, availableAgents, originalText) {
  const source = plan.plannedAgents.length > 0 ? plan.plannedAgents : [plan.agent];
  const filtered = source.filter((agent) => availableAgents.includes(agent));
  const unique = filtered.filter((agent, index, arr) => arr.indexOf(agent) === index);
  const base = unique.length > 0 ? unique : [plan.agent];
  if (plan.complexity === "low") {
    return base.slice(0, 1);
  }
  if (plan.complexity === "medium") {
    if (plan.enableEarlyExit && shouldEarlyExitForMediumTask(originalText)) {
      return base.slice(0, 1);
    }
    const mediumLimit = Math.max(2, Math.min(3, plan.maxAgents ?? 3));
    return base.slice(0, mediumLimit);
  }
  const highLimit = Math.max(1, plan.maxAgents ?? base.length);
  return base.slice(0, highLimit);
}
function shouldEarlyExitForMediumTask(text) {
  const normalized = text.trim().toLowerCase();
  if (!normalized) return false;
  const quickFixSignals = [
    "type error",
    "ts",
    "typescript",
    "lint",
    "\u4FEE\u590D",
    "\u62A5\u9519",
    "\u9519\u8BEF",
    "hotfix",
    "bugfix"
  ];
  const multiStepSignals = [
    "\u91CD\u6784",
    "\u67B6\u6784",
    "\u5E76\u884C",
    "\u5B8C\u6574\u6D41\u7A0B",
    "\u7AEF\u5230\u7AEF",
    "multi-step",
    "workflow",
    "\u65B0\u589E\u9875\u9762",
    "\u767B\u5F55\u9875\u9762"
  ];
  const hasQuickFixSignal = quickFixSignals.some((token) => normalized.includes(token));
  const hasMultiStepSignal = multiStepSignals.some((token) => normalized.includes(token));
  return hasQuickFixSignal && !hasMultiStepSignal;
}
function buildRoutedAgentPayload(input) {
  if (input.total <= 1) return input.payloadText;
  const header = `[MIYA_ROUTER_PIPELINE step=${input.index + 1}/${input.total} agent=${input.agent} context=${input.contextStrategy}]`;
  if (input.contextStrategy === "full") {
    return `${header}
${input.payloadText}`;
  }
  if (input.contextStrategy === "summary") {
    const summary = input.originalText.trim().slice(0, 1500);
    return `${header}
Task summary:
${summary}

Execution hint: focus on this step and avoid repeating prior output.`;
  }
  const minimal = input.originalText.trim().slice(0, 700);
  return `${header}
${minimal}`;
}
function resolveApprovalTicket(input) {
  const kill = readKillSwitch(input.projectDir);
  if (kill.active) {
    return { ok: false, reason: "kill_switch_active" };
  }
  const request = {
    sessionID: input.sessionID,
    permission: input.permission,
    patterns: input.patterns
  };
  const tier = requiredTierForRequest(request);
  const requestHash = buildRequestHash(
    {
      permission: input.permission,
      patterns: input.patterns,
      toolCallID: "",
      messageID: ""
    },
    false
  );
  const token = findApprovalToken(input.projectDir, input.sessionID, [requestHash], tier);
  if (token) {
    return {
      ok: true,
      ticket: {
        permission: input.permission,
        requestHash,
        traceID: token.trace_id,
        createdAt: token.created_at,
        expiresAt: token.expires_at,
        tier: token.tier
      }
    };
  }
  activateKillSwitch(input.projectDir, "missing_evidence", randomUUID18());
  return { ok: false, reason: "missing_evidence" };
}
function enforceToken(input) {
  const resolved = resolveApprovalTicket(input);
  return resolved.ok ? { ok: true } : resolved;
}
function maybeBroadcast(projectDir, runtime) {
  if (!hasEventSubscribers(runtime, "gateway.snapshot")) {
    return;
  }
  runtime.stateVersion += 1;
  const frame = toEventFrame({
    event: "gateway.snapshot",
    payload: buildSnapshot(projectDir, runtime),
    stateVersion: { gateway: runtime.stateVersion }
  });
  publishFrame(runtime, frame.event, frame);
}
function publishGatewayEvent(runtime, event, payload) {
  runtime.stateVersion += 1;
  publishFrame(
    runtime,
    event,
    toEventFrame({
      event,
      payload,
      stateVersion: { gateway: runtime.stateVersion }
    })
  );
}
function isEventSubscribed(wsData, event) {
  return wsData.subscriptions.has("*") || wsData.subscriptions.has(event);
}
function hasEventSubscribers(runtime, event) {
  for (const ws of runtime.wsClients) {
    if (ws.readyState !== WebSocket2.OPEN) continue;
    const wsData = ensureWsData(runtime, ws);
    if (!wsData.authenticated || !isEventSubscribed(wsData, event)) continue;
    return true;
  }
  return false;
}
function publishFrame(runtime, event, frame) {
  let encoded = null;
  for (const ws of runtime.wsClients) {
    if (ws.readyState !== WebSocket2.OPEN) continue;
    const wsData = ensureWsData(runtime, ws);
    if (!wsData.authenticated || !isEventSubscribed(wsData, event)) continue;
    try {
      if (encoded === null) {
        encoded = JSON.stringify(frame);
      }
      ws.send(encoded);
    } catch {
    }
  }
}
function emitWizardProgress(runtime, payload) {
  publishGatewayEvent(runtime, "companion.wizard.progress", payload);
}
function emitWizardRequeueProgress(runtime, input) {
  emitWizardProgress(runtime, {
    sessionId: input.sessionId,
    jobID: input.jobID,
    type: input.type,
    status: "pending",
    progress: Math.max(10, input.progress),
    message: WIZARD_REQUEUE_MESSAGE,
    step: input.step
  });
}
function emitWizardDoneProgress(runtime, input) {
  const finalStatus = input.status === "failed" ? "failed" : input.status;
  emitWizardProgress(runtime, {
    sessionId: input.sessionId,
    jobID: input.jobID,
    type: input.type,
    status: finalStatus,
    progress: finalStatus === "failed" || finalStatus === "canceled" ? 50 : 100,
    currentTier: input.tier,
    message: input.message,
    step: input.step,
    nextPrompt: wizardPromptByState(input.step)
  });
}
async function runWizardTrainingWorker(projectDir, runtime) {
  if (runtime.wizardRunnerBusy) return;
  const queued = pickQueuedTrainingJob(projectDir);
  if (!queued) return;
  runtime.wizardRunnerBusy = true;
  try {
    const runningState = markTrainingJobRunning(projectDir, queued.job.id, queued.sessionId);
    emitWizardProgress(runtime, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: "training",
      progress: 5,
      step: runningState.state
    });
    const daemon = getMiyaClient(projectDir);
    const profileDir = getCompanionProfileCurrentDir(projectDir, queued.sessionId);
    if (queued.job.type === "training.image") {
      const photosDir = path48.join(profileDir, "photos");
      const result2 = await daemon.runFluxTraining({
        profileDir,
        photosDir,
        jobID: queued.job.id,
        checkpointPath: queued.job.checkpointPath
      });
      if (result2.status === "failed" && result2.checkpointPath && queued.job.attempts < 3) {
        const requeued = requeueTrainingJob(projectDir, {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          checkpointPath: result2.checkpointPath,
          message: WIZARD_REQUEUE_MESSAGE
        });
        emitWizardRequeueProgress(runtime, {
          sessionId: queued.sessionId,
          jobID: queued.job.id,
          type: queued.job.type,
          progress: queued.job.progress,
          step: requeued.state
        });
        return;
      }
      const done2 = markTrainingJobFinished(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        status: result2.status === "failed" ? "failed" : result2.status,
        message: result2.message,
        tier: result2.tier,
        checkpointPath: result2.checkpointPath
      });
      emitWizardDoneProgress(runtime, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        status: result2.status,
        tier: result2.tier,
        message: result2.message,
        step: done2.state
      });
      return;
    }
    const voiceSamplePath = path48.join(profileDir, "voice", "original_sample.wav");
    const result = await daemon.runSovitsTraining({
      profileDir,
      voiceSamplePath,
      jobID: queued.job.id,
      checkpointPath: queued.job.checkpointPath
    });
    if (result.status === "failed" && result.checkpointPath && queued.job.attempts < 3) {
      const requeued = requeueTrainingJob(projectDir, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        checkpointPath: result.checkpointPath,
        message: WIZARD_REQUEUE_MESSAGE
      });
      emitWizardRequeueProgress(runtime, {
        sessionId: queued.sessionId,
        jobID: queued.job.id,
        type: queued.job.type,
        progress: queued.job.progress,
        step: requeued.state
      });
      return;
    }
    const done = markTrainingJobFinished(projectDir, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      status: result.status === "failed" ? "failed" : result.status,
      message: result.message,
      tier: result.tier,
      checkpointPath: result.checkpointPath
    });
    emitWizardDoneProgress(runtime, {
      sessionId: queued.sessionId,
      jobID: queued.job.id,
      type: queued.job.type,
      status: result.status,
      tier: result.tier,
      message: result.message,
      step: done.state
    });
  } finally {
    runtime.wizardRunnerBusy = false;
  }
}
function ensureWsData(runtime, ws) {
  const existing = runtime.wsMeta.get(ws);
  if (existing) {
    return existing;
  }
  const fallback = {
    clientID: `ws_${randomUUID18()}`,
    role: "unknown",
    subscriptions: /* @__PURE__ */ new Set(["*"]),
    authenticated: !process.env.MIYA_GATEWAY_TOKEN
  };
  runtime.wsMeta.set(ws, fallback);
  return fallback;
}
async function onInboundMessage(projectDir, runtime, message) {
  if (message.channel === "qq" || message.channel === "wechat") {
    const tier = getContactTier(projectDir, message.channel, message.senderID);
    if (tier === "owner") {
      const token = detectOwnerSyncTokenFromText(message.text);
      if (token) {
        const approval = approveOwnerSyncToken(projectDir, {
          token,
          channel: message.channel,
          senderID: message.senderID
        });
        await notifySafetyReport(projectDir, "main", [
          approval.ok ? `Miya \u5B89\u5168\u786E\u8BA4\uFF1A\u5DF2\u6536\u5230\u672C\u4EBA\u6863\u540C\u6B65\u786E\u8BA4 token=${token}` : `Miya \u5B89\u5168\u786E\u8BA4\u5931\u8D25\uFF1Atoken=${token} reason=${approval.reason ?? "unknown"}`
        ]);
        maybeBroadcast(projectDir, runtime);
        return;
      }
    }
  }
  const sessionID2 = `${message.channel}:${message.conversationID}`;
  upsertSession(projectDir, {
    id: sessionID2,
    kind: "channel",
    groupId: sessionID2,
    title: message.displayName,
    routingSessionID: "main",
    agent: "1-task-manager"
  });
  await routeSessionMessage(projectDir, {
    sessionID: sessionID2,
    text: message.text,
    source: message.channel
  });
  maybeBroadcast(projectDir, runtime);
}
function createMethods(projectDir, runtime) {
  const config3 = readConfig(projectDir);
  const backpressure = config3.runtime?.backpressure;
  const maxInFlight = typeof backpressure?.max_in_flight === "number" ? Number(backpressure.max_in_flight) : void 0;
  const maxQueued = typeof backpressure?.max_queued === "number" ? Number(backpressure.max_queued) : void 0;
  const queueTimeoutMs = typeof backpressure?.queue_timeout_ms === "number" ? Number(backpressure.queue_timeout_ms) : void 0;
  const methods = new GatewayMethodRegistry({
    maxInFlight,
    maxQueued,
    queueTimeoutMs
  });
  const agentRuntimeApi = new AgentModelRuntimeApi(projectDir);
  methods.register("gateway.status.get", async () => buildSnapshot(projectDir, runtime));
  methods.register("autoflow.status.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const sessions = listAutoflowSessions(projectDir, Math.max(1, Math.min(200, limit)));
    const persistentConfig = readAutoflowPersistentConfig(projectDir);
    const persistentSessions = getAutoflowPersistentRuntimeSnapshot(projectDir, Math.max(1, Math.min(200, limit)));
    return {
      active: sessions.filter(
        (item) => item.phase === "planning" || item.phase === "execution" || item.phase === "verification" || item.phase === "fixing"
      ).length,
      sessions,
      persistent: {
        ...persistentConfig,
        sessions: persistentSessions
      }
    };
  });
  methods.register("routing.stats.get", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 200;
    const mode = readRouterModeConfig(projectDir);
    return {
      mode,
      cost: getRouteCostSummary(projectDir, Math.max(1, Math.min(1e3, limit))),
      recent: listRouteCostRecords(projectDir, Math.max(1, Math.min(100, limit)))
    };
  });
  methods.register("learning.drafts.stats", async () => ({
    stats: getLearningStats(projectDir)
  }));
  methods.register("learning.drafts.list", async (params) => {
    const limit = typeof params.limit === "number" ? Number(params.limit) : 30;
    const statusRaw = parseText(params.status);
    const status = statusRaw === "draft" || statusRaw === "recommended" || statusRaw === "accepted" || statusRaw === "rejected" ? statusRaw : void 0;
    return {
      drafts: listSkillDrafts(projectDir, {
        limit: Math.max(1, Math.min(200, limit)),
        status
      })
    };
  });
  methods.register("learning.drafts.recommend", async (params) => {
    const query = parseText(params.query);
    if (!query) throw new Error("query_required");
    const threshold = typeof params.threshold === "number" ? Number(params.threshold) : void 0;
    const limit = typeof params.limit === "number" ? Number(params.limit) : void 0;
    return buildLearningInjection(projectDir, query, {
      threshold,
      limit
    });
  });
  methods.register("gateway.shutdown", async () => {
    const state2 = syncGatewayState(projectDir, runtime);
    setTimeout(() => {
      stopGateway(projectDir);
    }, 20);
    return { ok: true, state: state2 };
  });
  methods.register("doctor.run", async () => buildSnapshot(projectDir, runtime).doctor);
  methods.register("gateway.backpressure.stats", async () => ({
    ...runtime.methods.stats(),
    updatedAt: nowIso29()
  }));
  methods.register("daemon.backpressure.stats", async () => ({
    ...getLauncherBackpressureStats(projectDir),
    updatedAt: nowIso29()
  }));
  methods.register("gateway.audit.tail", async (params) => {
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 100;
    const limit = Math.max(1, Math.min(1e3, Math.floor(limitRaw)));
    const file3 = gatewayMethodAuditFile(projectDir);
    if (!fs47.existsSync(file3)) return [];
    const lines = fs47.readFileSync(file3, "utf-8").trim().split(/\r?\n/).filter(Boolean);
    return lines.slice(Math.max(0, lines.length - limit)).map((line) => {
      try {
        return JSON.parse(line);
      } catch {
        return null;
      }
    }).filter((item) => Boolean(item));
  });
  methods.register("gateway.pressure.run", async (params) => {
    const concurrencyRaw = typeof params.concurrency === "number" ? Number(params.concurrency) : 10;
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 1;
    const timeoutMs = typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : 2e4;
    const concurrency = Math.max(1, Math.min(100, Math.floor(concurrencyRaw)));
    const rounds = Math.max(1, Math.min(20, Math.floor(roundsRaw)));
    const startedAtMs = Date.now();
    let success3 = 0;
    let failed = 0;
    const errors = [];
    for (let round = 0; round < rounds; round += 1) {
      const tasks = Array.from({ length: concurrency }, async (_, index) => {
        try {
          const probe = spawnSync7(
            process.platform === "win32" ? "cmd" : "sh",
            process.platform === "win32" ? ["/c", "echo", `miya-pressure-${round}-${index}`] : ["-lc", `echo miya-pressure-${round}-${index}`],
            {
              cwd: projectDir,
              encoding: "utf-8",
              timeout: Math.max(1e3, timeoutMs),
              windowsHide: true
            }
          );
          if (probe.status !== 0) {
            throw new Error(
              `pressure_probe_failed:${probe.status ?? -1}:${String(probe.stderr ?? "").trim() || "no_stderr"}`
            );
          }
          await Promise.resolve();
          success3 += 1;
        } catch (error92) {
          failed += 1;
          errors.push(error92 instanceof Error ? error92.message : String(error92));
        }
      });
      await Promise.all(tasks);
    }
    return {
      success: success3,
      failed,
      elapsedMs: Date.now() - startedAtMs,
      gateway: runtime.methods.stats(),
      daemon: getLauncherBackpressureStats(projectDir),
      errors: errors.slice(0, 20)
    };
  });
  methods.register("gateway.startup.probe.run", async (params) => {
    const roundsRaw = typeof params.rounds === "number" ? Number(params.rounds) : 20;
    const rounds = Math.max(1, Math.min(100, Math.floor(roundsRaw)));
    const waitMsRaw = typeof params.waitMs === "number" ? Number(params.waitMs) : 250;
    const waitMs = Math.max(50, Math.min(5e3, Math.floor(waitMsRaw)));
    if (params.refreshDebug === true) {
      runtime.startupSelfCheck = runStartupSelfCheck(projectDir);
    }
    const state2 = ensureGatewayRunning(projectDir);
    let healthy = 0;
    let daemonReady = 0;
    const samples = [];
    for (let index = 0; index < rounds; index += 1) {
      const gatewayAlive = await probeGatewayAlive(state2.url, 1200);
      const daemonSnapshot = getLauncherDaemonSnapshot(projectDir);
      const daemonConnected = Boolean(daemonSnapshot.connected);
      if (gatewayAlive) healthy += 1;
      if (daemonConnected) daemonReady += 1;
      samples.push({
        index: index + 1,
        gatewayAlive,
        daemonConnected,
        daemonStatus: daemonSnapshot.statusText
      });
      if (index < rounds - 1) {
        await new Promise((resolve7) => setTimeout(resolve7, waitMs));
      }
    }
    return {
      rounds,
      gatewayHealthy: healthy,
      daemonConnected: daemonReady,
      gatewaySuccessRate: Number((healthy / rounds * 100).toFixed(2)),
      daemonSuccessRate: Number((daemonReady / rounds * 100).toFixed(2)),
      startupSelfCheck: runtime.startupSelfCheck,
      samples
    };
  });
  methods.register("config.center.get", async () => readConfig(projectDir));
  methods.register("provider.override.audit.list", async (params) => {
    const limitRaw = typeof params.limit === "number" ? Number(params.limit) : 50;
    const limit = Math.max(1, Math.min(500, Math.floor(limitRaw)));
    return listProviderOverrideAudits(projectDir, limit);
  });
  methods.register("agent.runtime.list", async () => agentRuntimeApi.list());
  methods.register("agent.runtime.set", async (params) => {
    const agentName = parseText(params.agentName || params.agent);
    const model = params.model;
    const activate = typeof params.activate === "boolean" ? params.activate : true;
    if (!agentName) throw new Error("invalid_agent_name");
    if (typeof model !== "string" || model.trim().length === 0) {
      throw new Error("invalid_model_ref");
    }
    const result = agentRuntimeApi.set({
      agentName,
      model,
      variant: params.variant,
      providerID: params.providerID,
      options: params.options,
      apiKey: params.apiKey,
      baseURL: params.baseURL,
      activate
    });
    return {
      ...result,
      state: agentRuntimeApi.list()
    };
  });
  methods.register("agent.runtime.reset", async (params) => {
    const agentName = parseText(params.agentName || params.agent);
    if (!agentName) throw new Error("invalid_agent_name");
    const clearActive = typeof params.clearActive === "boolean" ? params.clearActive : true;
    const activeAgentId = parseText(params.activeAgentId) || void 0;
    const result = agentRuntimeApi.reset({
      agentName,
      clearActive,
      activeAgentId
    });
    return {
      ...result,
      state: agentRuntimeApi.list()
    };
  });
  methods.register("config.center.patch", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    const validation = validateConfigPatch(projectDir, params.patch);
    if (!validation.ok) {
      throw new Error(`config_validation_failed:${validation.errors.join("|")}`);
    }
    const applied = applyConfigPatch(projectDir, validation);
    return {
      updatedConfig: applied.updatedConfig,
      changedKeys: applied.applied.map((item) => item.key)
    };
  });
  registerCoreSessionMethods({
    projectDir,
    methods,
    parseText,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    routeSessionMessage,
    wizardPromptPhotos: WIZARD_PROMPT_PHOTOS,
    wizardPromptByState
  });
  methods.register("cron.list", async () => depsOf(projectDir).automationService?.listJobs() ?? []);
  methods.register("cron.runs.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(200, Number(params.limit)) : 50;
    return depsOf(projectDir).automationService?.listHistory(limit) ?? [];
  });
  methods.register("cron.add", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const name = parseText(params.name);
    const time5 = parseText(params.time);
    const command = parseText(params.command);
    if (!name || !time5 || !command) throw new Error("invalid_cron_add_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.scheduleDailyCommand({
      name,
      time: time5,
      command,
      cwd: parseText(params.cwd) || void 0,
      timeoutMs: typeof params.timeoutMs === "number" ? Number(params.timeoutMs) : void 0,
      requireApproval: typeof params.requireApproval === "boolean" ? params.requireApproval : false
    });
  });
  methods.register("cron.remove", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const jobID = parseText(params.jobID);
    if (!jobID) throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return { removed: service.deleteJob(jobID) };
  });
  methods.register("cron.update", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const jobID = parseText(params.jobID);
    if (!jobID || typeof params.enabled !== "boolean") throw new Error("invalid_cron_update_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.setJobEnabled(jobID, params.enabled);
  });
  methods.register("cron.run.now", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const jobID = parseText(params.jobID);
    if (!jobID) throw new Error("invalid_job_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.runJobNow(jobID);
  });
  methods.register("cron.approvals.list", async () => depsOf(projectDir).automationService?.listApprovals() ?? []);
  methods.register("cron.approvals.approve", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const approvalID = parseText(params.approvalID);
    if (!approvalID) throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "local_build");
    return service.approveAndRun(approvalID);
  });
  methods.register("cron.approvals.reject", async (params) => {
    const service = depsOf(projectDir).automationService;
    if (!service) throw new Error("automation_service_unavailable");
    const policyHash = parseText(params.policyHash) || void 0;
    const approvalID = parseText(params.approvalID);
    if (!approvalID) throw new Error("invalid_approval_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return service.rejectApproval(approvalID);
  });
  registerChannelMethods({
    projectDir,
    methods,
    runtime,
    parseText,
    parseChannel,
    sendChannelMessageGuarded: (input) => sendChannelMessageGuarded(projectDir, runtime, input)
  });
  registerSecurityMethods({
    projectDir,
    methods,
    parseText
  });
  methods.register("policy.get", async () => {
    const policy = readPolicy(projectDir);
    return {
      policy,
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("daemon.python.env.status", async () => {
    const daemon = getMiyaClient(projectDir);
    const status = await daemon.getPythonRuntimeStatus();
    if (!status) return null;
    const recommendations = normalizeRuntimeDependencyRecommendations(status);
    const assist = await maybeTriggerDependencyAssist(projectDir, runtime, status);
    return {
      ...status,
      repairPlan: {
        ...status.repairPlan ?? {},
        recommendations
      },
      opencodeAssist: assist
    };
  });
  methods.register("daemon.python.env.repair.plan", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const status = await daemon.getPythonRuntimeStatus();
    if (!status) throw new Error("python_runtime_status_unavailable");
    const recommendations = normalizeRuntimeDependencyRecommendations(status);
    const prompt = status.repairPlan?.opencodeAssistPrompt || buildDependencyAssistPrompt(status);
    const route = await routeSessionMessage(projectDir, {
      sessionID: parseText(params.sessionID) || "main",
      source: "daemon.python.env.repair.plan",
      text: prompt
    });
    return {
      issueType: status.repairPlan?.issueType ?? status.trainingDisabledReason ?? "ok",
      warnings: status.repairPlan?.warnings ?? [],
      conflicts: status.repairPlan?.conflicts ?? [],
      oneShotCommand: status.repairPlan?.oneShotCommand,
      recommendations,
      routed: route
    };
  });
  methods.register("daemon.model.lock.status", async () => {
    const daemon = getMiyaClient(projectDir);
    return daemon.getModelLockStatus();
  });
  methods.register("daemon.model.update.plan", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    return daemon.getModelUpdatePlan(target || void 0);
  });
  methods.register("daemon.model.update.apply", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    return daemon.applyModelUpdate(target || void 0);
  });
  methods.register("daemon.model.update.wizard", async (params) => {
    const daemon = getMiyaClient(projectDir);
    const target = parseText(params.target);
    const plan = await daemon.getModelUpdatePlan(target || void 0);
    const pending = Array.isArray(plan.items) ? plan.items.filter((item) => item && item.ok === false) : [];
    const models = pending.map((item) => String(item.model ?? "").trim()).filter(Boolean);
    return {
      pending: typeof plan.pending === "number" ? plan.pending : pending.length,
      models,
      blockers: pending.map((item) => ({
        model: String(item.model ?? ""),
        reason: String(item.reason ?? "metadata_mismatch")
      })),
      suggestedCommands: {
        plan: models.length > 0 ? models.map((model) => `daemon.model.update.plan target=${model}`) : ["daemon.model.update.plan"],
        apply: models.length > 0 ? models.map((model) => `daemon.model.update.apply target=${model}`) : ["daemon.model.update.apply"]
      },
      nextAction: pending.length > 0 ? "apply model update before inference/training" : "model metadata is synchronized"
    };
  });
  methods.register("policy.domains.list", async () => {
    const policy = readPolicy(projectDir);
    return {
      domains: POLICY_DOMAINS.map((domain3) => ({
        domain: domain3,
        status: policy.domains[domain3]
      })),
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("policy.incidents.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return {
      incidents: listPolicyIncidents(projectDir, limit)
    };
  });
  methods.register("policy.domain.pause", async (params) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) {
      throw new Error("invalid_policy_domain");
    }
    const state2 = transitionSafetyState(projectDir, {
      source: "policy.domain.pause",
      reason: `manual_pause:${domain3}`,
      policyHash: currentPolicyHash(projectDir),
      domains: {
        [domain3]: "paused"
      }
    });
    appendPolicyIncident(projectDir, {
      type: "manual_pause",
      reason: `manual_pause:${domain3}`,
      pausedDomains: [domain3],
      statusByDomain: {
        [domain3]: state2.domains[domain3] === "running" ? "running" : "paused"
      },
      policyHash: currentPolicyHash(projectDir)
    });
    return {
      domain: domain3,
      status: state2.domains[domain3] === "running" ? "running" : "paused",
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("policy.domain.resume", async (params) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) {
      throw new Error("invalid_policy_domain");
    }
    const kill = readKillSwitch(projectDir);
    const safety = readSafetyState(projectDir);
    if (kill.active || safety.globalState === "killed") {
      throw new Error("kill_switch_active");
    }
    const state2 = transitionSafetyState(projectDir, {
      source: "policy.domain.resume",
      reason: `manual_resume:${domain3}`,
      policyHash: currentPolicyHash(projectDir),
      domains: {
        [domain3]: "running"
      }
    });
    appendPolicyIncident(projectDir, {
      type: "manual_resume",
      reason: `manual_resume:${domain3}`,
      pausedDomains: [domain3],
      statusByDomain: {
        [domain3]: state2.domains[domain3] === "running" ? "running" : "paused"
      },
      policyHash: currentPolicyHash(projectDir)
    });
    return {
      domain: domain3,
      status: state2.domains[domain3] === "running" ? "running" : "paused",
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("killswitch.set_mode", async (params) => {
    const modeRaw = parseText(params.mode)?.toLowerCase();
    const mode = modeRaw === "all_stop" || modeRaw === "outbound_only" || modeRaw === "desktop_only" || modeRaw === "off" ? modeRaw : null;
    if (!mode) throw new Error("invalid_killswitch_mode");
    const reason = parseText(params.reason) || `manual_mode:${mode}`;
    if (mode === "all_stop") {
      const traceID = randomUUID18();
      activateKillSwitch(projectDir, reason, traceID);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        traceID,
        policyHash: currentPolicyHash(projectDir),
        globalState: "killed",
        domains: {
          outbound_send: "killed",
          desktop_control: "killed"
        }
      });
    } else if (mode === "off") {
      releaseKillSwitch(projectDir);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        policyHash: currentPolicyHash(projectDir),
        globalState: "running",
        domains: {
          outbound_send: "running",
          desktop_control: "running"
        }
      });
    } else {
      releaseKillSwitch(projectDir);
      transitionSafetyState(projectDir, {
        source: "killswitch.set_mode",
        reason,
        policyHash: currentPolicyHash(projectDir),
        globalState: "running",
        domains: {
          outbound_send: mode === "desktop_only" ? "running" : "paused",
          desktop_control: mode === "outbound_only" ? "running" : "paused"
        }
      });
    }
    runtime.nexus.killSwitchMode = resolveKillSwitchMode(projectDir, readKillSwitch(projectDir));
    appendNexusInsight(runtime, {
      text: `KillSwitch mode -> ${runtime.nexus.killSwitchMode}`
    });
    publishGatewayEvent(runtime, "gateway.killswitch.mode", {
      mode: runtime.nexus.killSwitchMode,
      at: nowIso29()
    });
    return {
      mode: runtime.nexus.killSwitchMode,
      hash: currentPolicyHash(projectDir)
    };
  });
  methods.register("intervention.approve", async (params, context) => {
    const sessionID2 = parseText(params.sessionID) || "main";
    const permission = parseText(params.permission) || "external_message";
    const action = parseText(params.action) || `intervention_approve:${permission}`;
    const tierText = normalizeApprovalTier(parseText(params.tier).toLowerCase());
    const patternsRaw = Array.isArray(params.patterns) ? params.patterns : ["*"];
    const patterns = patternsRaw.map((item) => String(item).trim()).filter(Boolean);
    const normalizedPatterns = patterns.length > 0 ? patterns : ["*"];
    const requestHash = buildRequestHash(
      {
        permission,
        patterns: normalizedPatterns,
        toolCallID: "",
        messageID: ""
      },
      false
    );
    const token = saveApprovalToken(projectDir, sessionID2, {
      trace_id: randomUUID18(),
      request_hash: requestHash,
      tier: tierText,
      action
    });
    const auditID = appendInterventionAudit(projectDir, {
      command: "approve",
      actor: context.clientID,
      sourceRole: context.role,
      payload: {
        sessionID: sessionID2,
        permission,
        patterns: normalizedPatterns,
        tier: tierText,
        requestHash,
        tokenExpiresAt: token.expires_at
      }
    });
    appendNexusInsight(runtime, {
      text: `Intervention approve -> ${permission} (${sessionID2})`,
      auditID
    });
    publishGatewayEvent(runtime, "intervention.approve", {
      at: nowIso29(),
      auditID,
      sessionID: sessionID2,
      permission,
      tier: tierText,
      tokenExpiresAt: token.expires_at
    });
    return {
      status: "recorded",
      auditID,
      grant: {
        sessionID: sessionID2,
        permission,
        requestHash,
        expiresAt: token.expires_at
      }
    };
  });
  methods.register("intervention.pause", async (params, context) => {
    const domain3 = parseText(params.domain);
    if (!isPolicyDomain(domain3)) throw new Error("invalid_policy_domain");
    const result = await methods.invoke(
      "policy.domain.pause",
      { domain: domain3 },
      { clientID: context.clientID, role: "admin" }
    );
    const auditID = appendInterventionAudit(projectDir, {
      command: "pause",
      actor: context.clientID,
      sourceRole: context.role,
      payload: { domain: domain3, result }
    });
    publishGatewayEvent(runtime, "intervention.pause", {
      at: nowIso29(),
      auditID,
      domain: domain3,
      result
    });
    return {
      status: "recorded",
      auditID,
      domain: domain3,
      result
    };
  });
  methods.register("intervention.kill", async (params, context) => {
    const reason = parseText(params.reason) || "intervention_kill";
    const result = await methods.invoke(
      "killswitch.set_mode",
      { mode: "all_stop", reason },
      { clientID: context.clientID, role: "admin" }
    );
    const auditID = appendInterventionAudit(projectDir, {
      command: "kill",
      actor: context.clientID,
      sourceRole: context.role,
      payload: { reason, result }
    });
    publishGatewayEvent(runtime, "intervention.kill", {
      at: nowIso29(),
      auditID,
      reason,
      result
    });
    return {
      status: "recorded",
      auditID,
      result
    };
  });
  methods.register("intervention.annotate", async (params, context) => {
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_annotation_text");
    const at = parseText(params.at) || nowIso29();
    const targetAuditID = parseText(params.auditID) || void 0;
    const annotation = await methods.invoke(
      "insight.append",
      {
        text,
        at,
        auditID: targetAuditID
      },
      { clientID: context.clientID, role: "admin" }
    );
    const auditID = appendInterventionAudit(projectDir, {
      command: "annotate",
      actor: context.clientID,
      sourceRole: context.role,
      payload: {
        text,
        at,
        targetAuditID
      }
    });
    publishGatewayEvent(runtime, "intervention.annotate", {
      at,
      auditID,
      targetAuditID,
      text
    });
    return {
      status: "recorded",
      auditID,
      annotation
    };
  });
  methods.register("trust.set_mode", async (params) => {
    const silentMinRaw = Number(params.silentMin);
    const modalMaxRaw = Number(params.modalMax);
    if (!Number.isFinite(silentMinRaw) || !Number.isFinite(modalMaxRaw)) {
      throw new Error("invalid_trust_mode_thresholds");
    }
    const next = writeTrustModeConfig(projectDir, {
      silentMin: silentMinRaw,
      modalMax: modalMaxRaw
    });
    runtime.nexus.trustMode = next;
    appendNexusInsight(runtime, {
      text: `Trust mode updated: silent>=${next.silentMin}, modal<=${next.modalMax}`
    });
    publishGatewayEvent(runtime, "trust.mode.update", {
      at: nowIso29(),
      mode: next
    });
    return {
      mode: next
    };
  });
  methods.register("psyche.mode.get", async () => {
    const mode = readPsycheModeConfig(projectDir);
    runtime.nexus.psycheMode = mode;
    return {
      mode,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, mode)
    };
  });
  methods.register("psyche.mode.set", async (params) => {
    const next = writePsycheModeConfig(projectDir, {
      resonanceEnabled: typeof params.resonanceEnabled === "boolean" ? Boolean(params.resonanceEnabled) : void 0,
      captureProbeEnabled: typeof params.captureProbeEnabled === "boolean" ? Boolean(params.captureProbeEnabled) : void 0
    });
    runtime.nexus.psycheMode = next;
    appendNexusInsight(runtime, {
      text: `\u5B88\u95E8\u5458\u6A21\u5F0F\u5DF2\u66F4\u65B0\uFF1A\u5171\u9E23\u5C42=${next.resonanceEnabled ? "\u5F00\u542F" : "\u5173\u95ED"}\uFF0C\u622A\u56FE\u6838\u9A8C=${next.captureProbeEnabled ? "\u5F00\u542F" : "\u5173\u95ED"}`
    });
    publishGatewayEvent(runtime, "psyche.mode.update", {
      at: nowIso29(),
      mode: next,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, next)
    });
    return {
      mode: next,
      consultEnabled: resolvePsycheConsultEnabled(projectDir, next)
    };
  });
  methods.register("learning.gate.get", async () => {
    const gate = readLearningGateConfig(projectDir);
    runtime.nexus.learningGate = gate;
    return { gate };
  });
  methods.register("learning.gate.set", async (params) => {
    const next = writeLearningGateConfig(projectDir, {
      candidateMode: params.candidateMode === "silent_audit" || params.candidateMode === "toast_gate" ? params.candidateMode : void 0,
      persistentRequiresApproval: typeof params.persistentRequiresApproval === "boolean" ? Boolean(params.persistentRequiresApproval) : void 0
    });
    runtime.nexus.learningGate = next;
    appendNexusInsight(runtime, {
      text: `\u5B66\u4E60\u95F8\u95E8\u5DF2\u66F4\u65B0\uFF1Acandidate=${next.candidateMode}, persistent_requires_approval=${next.persistentRequiresApproval ? "1" : "0"}`
    });
    publishGatewayEvent(runtime, "learning.gate.update", {
      at: nowIso29(),
      gate: next
    });
    return { gate: next };
  });
  methods.register("insight.append", async (params) => {
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_insight_text");
    const at = parseText(params.at) || nowIso29();
    const auditID = parseText(params.auditID);
    appendNexusInsight(runtime, { text, at, auditID: auditID || void 0 });
    publishGatewayEvent(runtime, "insight.append", {
      at,
      text,
      auditID: auditID || void 0
    });
    return {
      ok: true,
      at,
      text,
      auditID: auditID || void 0
    };
  });
  registerNodeMethods({
    projectDir,
    methods,
    runtime,
    parseText,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    enforceToken,
    hashText: hashText3
  });
  methods.register("skills.status", async () => ({
    enabled: listEnabledSkills(projectDir),
    discovered: discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? [])
  }));
  methods.register("miya.sync.list", async () => listEcosystemBridge(projectDir));
  methods.register("miya.sync.diff", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    return diffSourcePack(projectDir, sourcePackID);
  });
  methods.register("miya.sync.pull", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const sessionID2 = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID: sessionID2,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, "action=pull"]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    return pullSourcePack(projectDir, sourcePackID);
  });
  methods.register("miya.sync.apply", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const revision = parseText(params.revision) || void 0;
    const sessionID2 = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID: sessionID2,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, `revision=${revision ?? "latest"}`]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    return applySourcePack(projectDir, sourcePackID, { revision });
  });
  methods.register("miya.sync.rollback", async (params) => {
    const sourcePackID = parseText(params.sourcePackID);
    const sessionID2 = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!sourcePackID) throw new Error("invalid_source_pack_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID: sessionID2,
      permission: "skills_install",
      patterns: [`sourcePackID=${sourcePackID}`, "action=rollback"]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    return rollbackSourcePack(projectDir, sourcePackID);
  });
  methods.register("mcp.capabilities.list", async (params) => {
    const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
    const mcps = createBuiltinMcps(disabled);
    return {
      mcps: Object.entries(mcps).map(([name, config4]) => {
        const caps = "capabilities" in config4 ? config4.capabilities : void 0;
        return {
          name,
          type: config4.type,
          sampling: Boolean(caps?.sampling),
          mcpUi: Boolean(caps?.mcpUi),
          serviceExpose: Boolean(
            caps?.serviceExpose
          )
        };
      })
    };
  });
  methods.register("mcp.service.expose", async (params) => {
    const disabled = Array.isArray(params.disabledMcps) ? params.disabledMcps.map(String) : [];
    return buildMcpServiceManifest(disabled);
  });
  methods.register("skills.enable", async (params) => {
    const skillID = parseText(params.skillID);
    if (!skillID) throw new Error("invalid_skill_id");
    const discovered = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []);
    const descriptor = discovered.find((item) => item.id === skillID || item.name === skillID);
    if (!descriptor) throw new Error(`skill_not_found:${skillID}`);
    if (!descriptor.gate.loadable) {
      throw new Error(`skill_not_loadable:${descriptor.gate.reasons.join("|")}`);
    }
    return { enabled: setSkillEnabled(projectDir, descriptor.id, true) };
  });
  methods.register("skills.disable", async (params) => {
    const skillID = parseText(params.skillID);
    if (!skillID) throw new Error("invalid_skill_id");
    return { enabled: setSkillEnabled(projectDir, skillID, false) };
  });
  methods.register("skills.install", async (params) => {
    const repo = parseText(params.repo);
    const targetName = parseText(params.targetName) || void 0;
    const sessionID2 = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!repo) throw new Error("invalid_repo");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID: sessionID2,
      permission: "skills_install",
      patterns: [`repo=${repo}`]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    const root = path48.join(os7.homedir(), ".config", "opencode", "miya", "skills");
    fs47.mkdirSync(root, { recursive: true });
    const name = targetName || repo.split("/").filter(Boolean).pop()?.replace(/\.git$/i, "") || `skill-${Date.now().toString(36)}`;
    const target = path48.join(root, name);
    if (fs47.existsSync(target)) return { ok: false, message: `target_exists:${target}` };
    const proc = spawnSync7("git", ["clone", "--depth", "1", repo, target], {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "pipe"]
    });
    if (proc.status !== 0) {
      return {
        ok: false,
        message: String(proc.stderr || "").trim() || "git_clone_failed"
      };
    }
    const installed = discoverSkills(projectDir, depsOf(projectDir).extraSkillDirs ?? []).find(
      (item) => path48.resolve(item.dir) === path48.resolve(target)
    );
    if (!installed) {
      fs47.rmSync(target, { recursive: true, force: true });
      return {
        ok: false,
        message: "installed_skill_invalid:manifest_not_found"
      };
    }
    if (installed.gate.reasons.includes("missing_permission_metadata")) {
      fs47.rmSync(target, { recursive: true, force: true });
      return {
        ok: false,
        message: "installed_skill_invalid:missing_permission_metadata"
      };
    }
    return {
      ok: true,
      message: "installed",
      dir: target,
      gate: installed.gate
    };
  });
  methods.register("skills.update", async (params) => {
    const dir = parseText(params.dir);
    const sessionID2 = parseText(params.sessionID) || "main";
    const policyHash = parseText(params.policyHash) || void 0;
    if (!dir) throw new Error("invalid_dir");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "shell_exec");
    requireDomainRunning(projectDir, "fs_write");
    const token = enforceToken({
      projectDir,
      sessionID: sessionID2,
      permission: "skills_install",
      patterns: [`dir=${dir}`]
    });
    if (!token.ok) throw new Error(`approval_required:${token.reason}`);
    const proc = spawnSync7("git", ["-C", dir, "pull", "--ff-only"], {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "pipe"]
    });
    if (proc.status !== 0) {
      return {
        ok: false,
        message: String(proc.stderr || "").trim() || "git_pull_failed"
      };
    }
    return {
      ok: true,
      message: String(proc.stdout || "").trim() || "updated"
    };
  });
  methods.register("media.ingest", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const source = parseText(params.source);
    const mimeType = parseText(params.mimeType);
    const fileName = parseText(params.fileName);
    if (!source || !mimeType || !fileName) throw new Error("invalid_media_ingest_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (params.kind !== "image" && params.kind !== "audio" && params.kind !== "video" && params.kind !== "file") {
      throw new Error("invalid_media_kind");
    }
    return ingestMedia(projectDir, {
      source,
      kind: params.kind,
      mimeType,
      fileName,
      contentBase64: parseText(params.contentBase64) || void 0,
      sizeBytes: typeof params.sizeBytes === "number" ? Number(params.sizeBytes) : void 0,
      ttlHours: typeof params.ttlHours === "number" ? Number(params.ttlHours) : void 0,
      metadata: params.metadata && typeof params.metadata === "object" ? params.metadata : void 0
    });
  });
  methods.register("media.get", async (params) => {
    const mediaID = parseText(params.mediaID);
    if (!mediaID) throw new Error("invalid_media_id");
    return getMediaItem(projectDir, mediaID);
  });
  methods.register("media.gc.run", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return runMediaGc(projectDir);
  });
  methods.register("media.list", async (params) => {
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(500, Number(params.limit)) : 100;
    return listMediaItems(projectDir, limit);
  });
  registerVoiceMethods({
    projectDir,
    methods,
    parseText,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    verifyVoiceprintWithLocalModel,
    routeSessionMessage
  });
  methods.register("canvas.status", async () => {
    const state2 = readCanvasState(projectDir);
    return {
      activeDocID: state2.activeDocID,
      docs: listCanvasDocs(projectDir),
      events: state2.events.slice(0, 100)
    };
  });
  methods.register("canvas.list", async () => listCanvasDocs(projectDir));
  methods.register("canvas.get", async (params) => {
    const docID = parseText(params.docID);
    if (!docID) throw new Error("invalid_doc_id");
    return getCanvasDoc(projectDir, docID);
  });
  methods.register("canvas.open", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const title = parseText(params.title);
    const type = parseText(params.type);
    const content = parseText(params.content);
    if (!title) throw new Error("invalid_canvas_title");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (type && type !== "text" && type !== "markdown" && type !== "json" && type !== "html") {
      throw new Error("invalid_canvas_type");
    }
    const docType = type === "text" || type === "markdown" || type === "json" || type === "html" ? type : void 0;
    return openCanvasDoc(projectDir, {
      title,
      type: docType,
      content,
      actor: parseText(params.actor) || "gateway"
    });
  });
  methods.register("canvas.render", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const docID = parseText(params.docID);
    const content = parseText(params.content);
    if (!docID || !content) throw new Error("invalid_canvas_render_args");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return renderCanvasDoc(projectDir, {
      docID,
      content,
      merge: Boolean(params.merge),
      actor: parseText(params.actor) || "gateway"
    });
  });
  methods.register("canvas.close", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const docID = parseText(params.docID);
    if (!docID) throw new Error("invalid_doc_id");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    return closeCanvasDoc(projectDir, docID, parseText(params.actor) || "gateway");
  });
  methods.register("companion.status", async () => readCompanionProfile(projectDir));
  methods.register("companion.wizard.start", async (params) => {
    const sessionId = parseText(params.sessionID) || "wizard:companion";
    const session = upsertSession(projectDir, {
      id: "wizard:companion",
      kind: "wizard",
      groupId: "wizard:companion",
      title: "Companion Onboarding",
      routingSessionID: "main",
      agent: "1-task-manager"
    });
    const profile = readCompanionProfile(projectDir);
    const forceReset = Boolean(params.forceReset);
    const wizard = !forceReset && !isCompanionWizardEmpty(projectDir, sessionId) ? readCompanionWizardState(projectDir, sessionId) : startCompanionWizard(projectDir, {
      sessionId,
      forceReset
    });
    return {
      session,
      profile,
      wizard,
      checklist: wizardChecklist(wizard),
      state: wizard.state,
      message: wizardPromptByState(wizard.state),
      instruction: "\u5C06\u7167\u7247\u62D6\u62FD\u5230\u804A\u5929\u4E2D"
    };
  });
  methods.register("companion.wizard.status", async (params) => {
    const wizard = readCompanionWizardState(projectDir, parseText(params.sessionID) || "main");
    return {
      wizard,
      checklist: wizardChecklist(wizard),
      prompt: wizardPromptByState(wizard.state)
    };
  });
  methods.register("companion.wizard.photos.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const mediaIDs = Array.isArray(params.photoMediaIDs) ? params.photoMediaIDs.map(String) : Array.isArray(params.imageMediaIDs) ? params.imageMediaIDs.map(String) : [];
    const sessionId = parseText(params.sessionID) || "main";
    const { state: state2, job } = submitWizardPhotos(projectDir, { mediaIDs, sessionId });
    return {
      state: state2.state,
      message: "\u6536\u5230\u7167\u7247\uFF0C\u5F00\u59CB\u8BAD\u7EC3\u56FE\u50CF\u6A21\u578B...",
      jobId: job.id,
      estimatedTime: job.estimatedTime,
      fallbackStrategy: job.fallbackStrategy,
      checklist: wizardChecklist(state2)
    };
  });
  methods.register("companion.wizard.voice.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const mediaID = parseText(params.mediaID) || parseText(params.audioMediaID);
    if (!mediaID) throw new Error("invalid_voice_media_id");
    const sessionId = parseText(params.sessionID) || "main";
    const { state: state2, job } = submitWizardVoice(projectDir, { mediaID, sessionId });
    return {
      state: state2.state,
      message: "\u6536\u5230\u8BED\u97F3\u6837\u672C\uFF0C\u5F00\u59CB\u8BAD\u7EC3\u58F0\u97F3\u6A21\u578B...",
      jobId: job.id,
      estimatedTime: job.estimatedTime,
      checklist: wizardChecklist(state2)
    };
  });
  methods.register("companion.wizard.personality.submit", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const personalityText = parseText(params.personalityText);
    const sessionId = parseText(params.sessionID) || "main";
    const wizard = submitWizardPersonality(projectDir, {
      personalityText,
      sessionId
    });
    patchCompanionProfile(projectDir, {
      onboardingCompleted: true
    });
    return {
      state: wizard.state,
      message: WIZARD_PROMPT_DONE,
      personaPreview: wizard.assets.personalityText.slice(0, 120),
      checklist: wizardChecklist(wizard)
    };
  });
  methods.register("companion.wizard.cancel", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const sessionId = parseText(params.sessionID) || "main";
    const daemon = getMiyaClient(projectDir);
    const state2 = readCompanionWizardState(projectDir, sessionId);
    const cancelRequests = [];
    for (const job of state2.jobs) {
      if (job.status === "queued" || job.status === "training") {
        cancelRequests.push(daemon.requestTrainingCancel(job.id));
      }
    }
    if (cancelRequests.length > 0) {
      await Promise.allSettled(cancelRequests);
    }
    const canceled = cancelCompanionWizardTraining(projectDir, sessionId);
    return {
      state: canceled.state,
      checklist: wizardChecklist(canceled),
      message: WIZARD_CANCELLED_MESSAGE
    };
  });
  methods.register("companion.wizard.submit", async (params) => {
    if (Array.isArray(params.photoMediaIDs) || Array.isArray(params.imageMediaIDs)) {
      return invokeGatewayMethod(
        projectDir,
        runtime,
        "companion.wizard.photos.submit",
        params,
        { clientID: "gateway", role: "admin" }
      );
    }
    if (typeof params.mediaID === "string" || typeof params.audioMediaID === "string") {
      return invokeGatewayMethod(
        projectDir,
        runtime,
        "companion.wizard.voice.submit",
        params,
        { clientID: "gateway", role: "admin" }
      );
    }
    if (typeof params.personalityText === "string") {
      return invokeGatewayMethod(
        projectDir,
        runtime,
        "companion.wizard.personality.submit",
        params,
        { clientID: "gateway", role: "admin" }
      );
    }
    throw new Error("invalid_wizard_submit_payload");
  });
  methods.register("companion.wizard.tick", async () => {
    await runWizardTrainingWorker(projectDir, runtime);
    return {
      wizard: readCompanionWizardState(projectDir, "main")
    };
  });
  methods.register("companion.wizard.progress.get", async (params) => {
    const jobID = parseText(params.jobId) || parseText(params.jobID);
    if (!jobID) throw new Error("invalid_job_id");
    const job = getWizardJobById(projectDir, jobID);
    if (!job) throw new Error("job_not_found");
    const status = job.status === "queued" ? "pending" : job.status;
    const nextStep = status === "completed" || status === "degraded" ? readCompanionWizardState(projectDir, job.sessionId).state : void 0;
    return {
      status,
      progress: job.progress,
      currentTier: job.currentTier,
      message: job.message ?? "",
      nextStep,
      checkpointPath: job.checkpointPath,
      sessionId: job.sessionId
    };
  });
  methods.register("companion.profile.update", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    return patchCompanionProfile(projectDir, {
      enabled: typeof params.enabled === "boolean" ? Boolean(params.enabled) : void 0,
      onboardingCompleted: typeof params.onboardingCompleted === "boolean" ? Boolean(params.onboardingCompleted) : void 0,
      name: parseText(params.name) || void 0,
      persona: parseText(params.persona) || void 0,
      relationship: parseText(params.relationship) || void 0,
      style: parseText(params.style) || void 0
    });
  });
  registerMemoryMethods({
    projectDir,
    methods,
    parseText,
    requireOwnerMode,
    requirePolicyHash,
    requireDomainRunning: (dir, domain3) => requireDomainRunning(dir, domain3),
    resolveApprovalTicket,
    getLearningGate: () => runtime.nexus.learningGate
  });
  methods.register("miya.memory.sqlite.stats", async () => {
    requireOwnerMode(projectDir);
    return getCompanionMemorySqliteStats(projectDir);
  });
  methods.register("miya.memory.pack.compile", async (params) => {
    requireOwnerMode(projectDir);
    const query = parseText(params.query) || "";
    const domain3 = parseText(params.domain) === "relationship" || parseText(params.domain) === "personal" || parseText(params.domain) === "system" ? parseText(params.domain) : "work";
    const l0Limit = typeof params.l0Limit === "number" && params.l0Limit > 0 ? Math.min(20, Number(params.l0Limit)) : void 0;
    const l1Limit = typeof params.l1Limit === "number" && params.l1Limit > 0 ? Math.min(30, Number(params.l1Limit)) : void 0;
    const modeRaw = parseText(params.mode);
    const mode = modeRaw === "response" || modeRaw === "audit" ? modeRaw : "execution";
    return buildMemoryPack(projectDir, {
      query,
      domain: domain3,
      mode,
      l0Limit,
      l1Limit
    });
  });
  methods.register("miya.memory.perception.pack", async (params) => {
    requireOwnerMode(projectDir);
    const query = parseText(params.query) || "";
    const domain3 = parseText(params.domain) === "relationship" || parseText(params.domain) === "personal" || parseText(params.domain) === "system" ? parseText(params.domain) : "work";
    const modeRaw = parseText(params.mode);
    const mode = modeRaw === "response" || modeRaw === "audit" ? modeRaw : "execution";
    const pack = buildMemoryPack(projectDir, {
      query,
      domain: domain3,
      mode,
      l0Limit: typeof params.l0Limit === "number" && params.l0Limit > 0 ? Math.min(20, Number(params.l0Limit)) : void 0,
      l1Limit: typeof params.l1Limit === "number" && params.l1Limit > 0 ? Math.min(30, Number(params.l1Limit)) : void 0
    });
    return {
      mode,
      domain: domain3,
      pack
    };
  });
  methods.register("miya.memory.events.list", async (params) => {
    requireOwnerMode(projectDir);
    const since = parseText(params.since) || void 0;
    const limit = typeof params.limit === "number" && params.limit > 0 ? Math.min(2e3, Number(params.limit)) : void 0;
    return listMemoryEvents(projectDir, { since, limit });
  });
  methods.register("miya.memory.evidence.get", async (params) => {
    requireOwnerMode(projectDir);
    const auditID = parseText(params.auditID);
    if (!auditID) throw new Error("invalid_audit_id");
    const found = getEvidencePack(projectDir, auditID);
    if (!found) throw new Error("evidence_not_found");
    return found;
  });
  methods.register("miya.contextfs.get", async (params) => {
    requireOwnerMode(projectDir);
    const uri = parseText(params.uri);
    if (!uri) throw new Error("invalid_contextfs_uri");
    const resolved = resolveContextFsUri(projectDir, uri);
    if (!resolved) throw new Error("contextfs_not_found");
    return resolved;
  });
  methods.register("miya.memory.log.append", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || void 0;
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_memory_log_text");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const senderRaw = parseText(params.sender);
    const sender = senderRaw === "assistant" || senderRaw === "system" ? senderRaw : "user";
    const entry2 = appendShortTermMemoryLog(projectDir, {
      sessionID: parseText(params.sessionID) || "main",
      sender,
      text,
      at: parseText(params.at) || void 0,
      messageID: parseText(params.messageID) || void 0
    });
    return {
      entry: entry2,
      learningGate: {
        stage: "ephemeral",
        approvalMode: "silent_audit",
        interruptsUser: false
      }
    };
  });
  methods.register("miya.memory.reflect", async (params) => {
    requireOwnerMode(projectDir);
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_write");
    const force = typeof params.force === "boolean" ? Boolean(params.force) : false;
    const minLogs = typeof params.minLogs === "number" && params.minLogs > 0 ? Number(params.minLogs) : 1;
    const maxLogs = typeof params.maxLogs === "number" && params.maxLogs > 0 ? Math.min(500, Number(params.maxLogs)) : 50;
    const cooldownMinutes = typeof params.cooldownMinutes === "number" && params.cooldownMinutes >= 0 ? Number(params.cooldownMinutes) : 0;
    const idempotencyKey = parseText(params.idempotencyKey) || void 0;
    const result = reflectCompanionMemory(projectDir, {
      force,
      minLogs,
      maxLogs,
      cooldownMinutes,
      idempotencyKey,
      policyHash: currentPolicyHash(projectDir)
    });
    const profile = syncCompanionProfileMemoryFacts(projectDir);
    return {
      ...result,
      learningGate: {
        stage: "candidate",
        approvalMode: runtime.nexus.learningGate.candidateMode,
        interruptsUser: false
      },
      profile
    };
  });
  methods.register("companion.asset.add", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    const type = parseText(params.type);
    const pathOrUrl = parseText(params.pathOrUrl);
    if (!pathOrUrl) throw new Error("invalid_asset_path");
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "fs_write");
    if (type !== "image" && type !== "audio") throw new Error("invalid_asset_type");
    return addCompanionAsset(projectDir, {
      type,
      pathOrUrl,
      label: parseText(params.label) || void 0
    });
  });
  methods.register("companion.asset.list", async () => readCompanionProfile(projectDir).assets);
  methods.register("companion.reset", async (params) => {
    const policyHash = parseText(params.policyHash) || void 0;
    requirePolicyHash(projectDir, policyHash);
    requireDomainRunning(projectDir, "memory_delete");
    const profile = resetCompanionProfile(projectDir);
    const wizard = resetCompanionWizard(projectDir);
    return { profile, wizard };
  });
  methods.register("companion.intent.handle", async (params) => {
    const text = parseText(params.text);
    if (!text) throw new Error("invalid_intent_text");
    const channel = parseChannel(params.channel) ?? "wechat";
    const destination = parseText(params.destination);
    const sessionID2 = parseText(params.sessionID) || "main";
    const intent = detectMultimodalIntent(text);
    if (intent.type === "selfie") {
      const generated = await generateImage(projectDir, {
        prompt: intent.prompt,
        model: "local:flux.1-schnell",
        registerAsCompanionAsset: true
      });
      if (!destination) {
        return {
          intent: "selfie",
          sent: false,
          mediaID: generated.media.id,
          path: generated.media.localPath,
          message: "selfie_generated_destination_missing"
        };
      }
      const send = await sendChannelMessageGuarded(projectDir, runtime, {
        channel,
        destination,
        text: "\u7ED9\u4F60\u4E00\u5F20\u6211\u7684\u81EA\u62CD",
        mediaPath: generated.media.localPath,
        sessionID: sessionID2,
        policyHash: currentPolicyHash(projectDir),
        outboundCheck: {
          archAdvisorApproved: true,
          intent: "reply"
        }
      });
      return {
        intent: "selfie",
        sent: send.sent,
        send,
        mediaID: generated.media.id,
        path: generated.media.localPath
      };
    }
    if (intent.type === "voice_to_friend") {
      const resolvedDestination = destination || intent.friend;
      if (!resolvedDestination) throw new Error("voice_destination_missing");
      const voice = await synthesizeVoiceOutput(projectDir, {
        text,
        voice: "companion",
        model: "local:gpt-sovits-v2pro",
        format: "wav",
        registerAsCompanionAsset: true
      });
      const send = await sendChannelMessageGuarded(projectDir, runtime, {
        channel: "wechat",
        destination: resolvedDestination,
        text: "\u8BED\u97F3\u6D88\u606F\u5DF2\u751F\u6210",
        mediaPath: voice.media.localPath,
        sessionID: sessionID2,
        policyHash: currentPolicyHash(projectDir),
        outboundCheck: {
          archAdvisorApproved: true,
          intent: "reply"
        }
      });
      return {
        intent: "voice_to_friend",
        friend: resolvedDestination,
        sent: send.sent,
        send,
        mediaID: voice.media.id,
        path: voice.media.localPath
      };
    }
    return { intent: "unknown", message: "no_multimodal_intent_matched" };
  });
  methods.register("daemon.vram.budget", async (params) => {
    const scheduler = getResourceScheduler(projectDir);
    const modelID = parseText(params.modelID) || "local:flux.1-schnell";
    const kindRaw = parseText(params.kind);
    const kind = kindRaw === "image.generate" || kindRaw === "vision.analyze" || kindRaw === "voice.tts" || kindRaw === "voice.asr" || kindRaw === "training.image" || kindRaw === "training.voice" || kindRaw === "shell.exec" ? kindRaw : "generic";
    const requestVram = typeof params.vramMB === "number" ? Number(params.vramMB) : 1024;
    const modelVram = typeof params.modelVramMB === "number" ? Number(params.modelVramMB) : 2048;
    const snapshot = scheduler.snapshot();
    const budget = calculateVramBudget({
      snapshot,
      task: {
        taskID: kind,
        taskVramMB: requestVram
      },
      models: [{ modelID, vramMB: modelVram, required: true }]
    });
    return {
      snapshot,
      budget,
      swapAction: decideModelSwapAction({
        currentModelID: snapshot.loadedModels[0]?.modelID,
        targetModelID: modelID,
        budget
      })
    };
  });
  return methods;
}
async function routeGatewayHttpRequest(projectDir, runtime, request, controlUi) {
  const url3 = new URL(request.url);
  if (url3.pathname === "/api/status") {
    return Response.json(buildSnapshot(projectDir, runtime), {
      headers: { "cache-control": "no-store" }
    });
  }
  const controlUiResponse = handleControlUiHttpRequest(request, controlUi);
  if (controlUiResponse) {
    const missingUiFallback = controlUiResponse.status === 503 && controlUi.root?.kind !== "resolved";
    if (missingUiFallback) {
      logControlUiFallback(projectDir, url3.pathname, controlUi, controlUiResponse.status);
    }
    if (!missingUiFallback) return controlUiResponse;
  }
  if (url3.pathname === "/webchat") {
    return new Response(renderWebChatHtml(), {
      headers: {
        "content-type": "text/html; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  if (url3.pathname.startsWith("/api/webhooks/")) {
    return new Response("HTTP control API disabled; use WebSocket RPC (/ws).", {
      status: 410,
      headers: {
        "content-type": "text/plain; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  if (url3.pathname === "/" || url3.pathname === "/index.html") {
    const gatewayState = syncGatewayState(projectDir, runtime);
    const uiBasePath = normalizeControlUiBasePath(controlUi.basePath || "/control") || "/control";
    const wsUrl = `${gatewayState.url.replace(/^http/i, "ws")}/ws`;
    return new Response(
      [
        "Miya Gateway is running.",
        `status=${gatewayState.status}`,
        `api_status=${gatewayState.url}/api/status`,
        `ws=${wsUrl}`,
        `control_ui=${gatewayState.url}${uiBasePath}`
      ].join("\n"),
      {
        headers: {
          "content-type": "text/plain; charset=utf-8",
          "cache-control": "no-store"
        }
      }
    );
  }
  if (url3.pathname === "/console") {
    return new Response(renderConsoleHtml(buildSnapshot(projectDir, runtime)), {
      headers: {
        "content-type": "text/html; charset=utf-8",
        "cache-control": "no-store"
      }
    });
  }
  return new Response("Not Found", { status: 404 });
}
function ensureGatewayRunning(projectDir) {
  const existing = runtimes2.get(projectDir);
  if (existing) {
    const owner2 = acquireGatewayOwner(projectDir);
    if (owner2.owned) {
      touchOwnerLock(projectDir);
    }
    log("[gateway] runtime already active; reused existing runtime", {
      projectDir,
      owner: describeOwnerLock(owner2.owner ?? null)
    });
    return syncGatewayState(projectDir, existing);
  }
  const owner = acquireGatewayOwner(projectDir);
  if (!owner.owned) {
    const state2 = readGatewayStateFile(projectDir);
    const ownerAlive = owner.owner ? isProcessAlive(owner.owner.pid) : false;
    const ownerFresh = owner.owner ? isOwnerLockFresh(owner.owner) : false;
    log("[gateway] owner lock held by another process", {
      projectDir,
      owner: describeOwnerLock(owner.owner ?? null),
      state: describeGatewayState(state2)
    });
    if (state2 && owner.owner && state2.pid !== owner.owner.pid) {
      clearGatewayStateFile(projectDir);
      log("[gateway] cleared stale gateway state file due to pid mismatch", {
        projectDir,
        statePid: state2.pid,
        ownerPid: owner.owner.pid
      });
    }
    if (state2 && isProcessAlive(state2.pid)) {
      log("[gateway] follower mode attached to existing owner state", {
        projectDir,
        state: describeGatewayState(state2)
      });
      return state2;
    }
    if (state2 && !isProcessAlive(state2.pid)) {
      clearGatewayStateFile(projectDir);
      log("[gateway] removed dead gateway state pid", {
        projectDir,
        statePid: state2.pid
      });
    }
    if (owner.owner && !ownerAlive) {
      const retry = acquireGatewayOwner(projectDir);
      if (!retry.owned) {
        log("[gateway] ownership reacquire failed after dead owner detected", {
          projectDir,
          previousOwner: describeOwnerLock(owner.owner),
          retryOwner: describeOwnerLock(retry.owner ?? null)
        });
        throw new Error("gateway_owned_by_other_process");
      }
      log("[gateway] ownership reacquired after dead owner detected", {
        projectDir,
        retryOwner: describeOwnerLock(retry.owner ?? null)
      });
    } else {
      log("[gateway] follower refused ownership takeover", {
        projectDir,
        ownerAlive,
        ownerFresh
      });
      throw new Error("gateway_owned_by_other_process");
    }
  }
  let runtime;
  const methods = new GatewayMethodRegistry();
  const controlUi = createControlUiRequestOptions(projectDir);
  const channelRuntime = new ChannelRuntime(projectDir, {
    onInbound: async (message) => {
      await onInboundMessage(projectDir, runtime, message);
    },
    onPairRequested: async () => {
      maybeBroadcast(projectDir, runtime);
    }
  });
  const listen = resolveGatewayListenOptions(projectDir);
  log("[gateway] creating runtime server", {
    projectDir,
    listen,
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
    controlUiRoot: controlUi.root?.kind ?? "unknown"
  });
  try {
    const port = reserveGatewayPort(listen.hostname, listen.port);
    const wsServer = new WebSocketServer({ noServer: true });
    const httpServer = createServer((req, res) => {
      void (async () => {
        const request = toNodeRequest(req, listen.hostname, port);
        const response = await routeGatewayHttpRequest(projectDir, runtime, request, controlUi);
        await sendNodeResponse(req, res, response);
      })().catch((error92) => {
        log("[gateway] http request failed", {
          projectDir,
          error: error92 instanceof Error ? error92.message : String(error92)
        });
        if (!res.headersSent) {
          res.statusCode = 500;
          res.setHeader("content-type", "text/plain; charset=utf-8");
        }
        if (!res.writableEnded) {
          res.end("Internal Server Error");
        }
      });
    });
    httpServer.on("upgrade", (req, socket, head) => {
      const requestUrl = new URL(req.url || "/", `http://${req.headers.host || "127.0.0.1"}`);
      if (requestUrl.pathname !== "/ws") {
        socket.write("HTTP/1.1 404 Not Found\r\n\r\n");
        socket.destroy();
        return;
      }
      wsServer.handleUpgrade(req, socket, head, (ws) => {
        wsServer.emit("connection", ws, req);
      });
    });
    runtime = {
      startedAt: nowIso29(),
      server: {
        hostname: listen.hostname,
        port,
        httpServer,
        wsServer
      },
      methods,
      stateVersion: 1,
      controlUi,
      channelRuntime,
      outboundSendDedupe: /* @__PURE__ */ new Map(),
      wsClients: /* @__PURE__ */ new Set(),
      nodeSockets: /* @__PURE__ */ new Map(),
      wsMeta: /* @__PURE__ */ new WeakMap(),
      wizardTickTimer: void 0,
      ownerBeatTimer: void 0,
      memoryReflectTimer: void 0,
      wizardRunnerBusy: false,
      dependencyAssistHashes: /* @__PURE__ */ new Set(),
      daemonLauncherUnsubscribe: void 0,
      startupSelfCheck: void 0,
      negotiationBudgets: /* @__PURE__ */ new Map(),
      nexus: {
        sessionId: "main",
        activeTool: void 0,
        jobId: void 0,
        permission: void 0,
        pendingTickets: 0,
        killSwitchMode: "off",
        insights: [],
        trust: void 0,
        trustMode: readTrustModeConfig(projectDir),
        psycheMode: readPsycheModeConfig(projectDir),
        learningGate: readLearningGateConfig(projectDir),
        guardianSafeHoldReason: void 0
      }
    };
    runtime.startupSelfCheck = void 0;
    runtime.methods = createMethods(projectDir, runtime);
    wsServer.on("connection", (ws) => {
      runtime.wsClients.add(ws);
      ensureWsData(runtime, ws);
      ws.on("close", () => {
        const wsData = ensureWsData(runtime, ws);
        if (wsData.nodeID) {
          runtime.nodeSockets.delete(wsData.nodeID);
          markNodeDisconnected(projectDir, wsData.nodeID);
        }
        runtime.wsClients.delete(ws);
        runtime.wsMeta.delete(ws);
      });
      ws.on("message", async (input) => {
        const wsData = ensureWsData(runtime, ws);
        const parsed = parseIncomingFrame(normalizeWsInput(input));
        if (!parsed.frame) {
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: "invalid",
                ok: false,
                errorCode: "bad_request",
                errorMessage: parsed.error ?? "invalid_frame"
              })
            )
          );
          return;
        }
        const frame = parsed.frame;
        if (frame.type === "ping") {
          ws.send(JSON.stringify(toPongFrame(frame.ts)));
          return;
        }
        if (frame.type === "hello") {
          const requiredToken = process.env.MIYA_GATEWAY_TOKEN;
          const incomingToken = frame.auth?.token;
          if (requiredToken && incomingToken !== requiredToken) {
            ws.send(
              JSON.stringify(
                toResponseFrame({
                  id: "hello",
                  ok: false,
                  errorCode: "unauthorized",
                  errorMessage: "invalid_gateway_token"
                })
              )
            );
            ws.close();
            return;
          }
          wsData.authenticated = true;
          if (frame.clientID) wsData.clientID = frame.clientID;
          if (frame.role) wsData.role = frame.role;
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: "hello",
                ok: true,
                result: {
                  clientID: wsData.clientID,
                  role: wsData.role,
                  methods: runtime.methods.list()
                }
              })
            )
          );
          return;
        }
        if (!wsData.authenticated) {
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: frame.id,
                ok: false,
                errorCode: "unauthorized",
                errorMessage: "send_hello_with_auth_first"
              })
            )
          );
          return;
        }
        if (frame.method === "gateway.subscribe") {
          wsData.subscriptions = new Set(
            Array.isArray(frame.params?.events) ? frame.params.events.map(String) : ["*"]
          );
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: frame.id,
                ok: true,
                result: {
                  subscribed: [...wsData.subscriptions]
                }
              })
            )
          );
          setTimeout(() => {
            try {
              ws.send(
                JSON.stringify(
                  toEventFrame({
                    event: "gateway.snapshot",
                    payload: buildSnapshot(projectDir, runtime),
                    stateVersion: { gateway: runtime.stateVersion }
                  })
                )
              );
            } catch {
            }
          }, 0);
          return;
        }
        if (frame.method === "nodes.register") {
          const nodeID = parseText(frame.params?.nodeID);
          if (nodeID) {
            wsData.nodeID = nodeID;
            runtime.nodeSockets.set(nodeID, ws);
          }
        }
        runtime.nexus.activeTool = frame.method;
        const frameSessionID = parseText(frame.params?.sessionID);
        if (frameSessionID) {
          runtime.nexus.sessionId = frameSessionID;
        }
        const frameJobID = parseText(frame.params?.jobID) || parseText(frame.params?.jobId);
        if (frameJobID) {
          runtime.nexus.jobId = frameJobID;
        }
        const invokeStartedAt = Date.now();
        try {
          const result = await invokeGatewayMethod(
            projectDir,
            runtime,
            frame.method,
            frame.params ?? {},
            {
              clientID: wsData.clientID,
              role: wsData.role,
              ws
            }
          );
          appendGatewayMethodAudit(projectDir, {
            method: frame.method,
            requestID: frame.id,
            clientID: wsData.clientID,
            role: wsData.role,
            sessionID: frameSessionID || void 0,
            jobID: frameJobID || void 0,
            ok: true,
            durationMs: Date.now() - invokeStartedAt
          });
          ws.send(JSON.stringify(toResponseFrame({ id: frame.id, ok: true, result })));
          if (frame.method !== "gateway.status.get") {
            maybeBroadcast(projectDir, runtime);
          }
        } catch (error92) {
          const messageText = error92 instanceof Error ? error92.message : String(error92);
          appendGatewayMethodAudit(projectDir, {
            method: frame.method,
            requestID: frame.id,
            clientID: wsData.clientID,
            role: wsData.role,
            sessionID: frameSessionID || void 0,
            jobID: frameJobID || void 0,
            ok: false,
            durationMs: Date.now() - invokeStartedAt,
            error: messageText
          });
          ws.send(
            JSON.stringify(
              toResponseFrame({
                id: frame.id,
                ok: false,
                errorCode: messageText.startsWith("unknown_method:") ? "unknown_method" : "method_failed",
                errorMessage: messageText
              })
            )
          );
        }
      });
    });
    httpServer.listen(port, listen.hostname);
  } catch (error92) {
    clearGatewayStateFile(projectDir);
    removeOwnerLock(projectDir);
    log("[gateway] failed to bind server", {
      projectDir,
      listen,
      error: error92 instanceof Error ? error92.message : String(error92)
    });
    throw error92;
  }
  runtimes2.set(projectDir, runtime);
  runtime.wizardTickTimer = setInterval(() => {
    void runWizardTrainingWorker(projectDir, runtime);
  }, 1200);
  runtime.ownerBeatTimer = setInterval(() => {
    touchOwnerLock(projectDir);
  }, 5e3);
  runtime.memoryReflectTimer = setInterval(() => {
    const reflected = maybeAutoReflectCompanionMemory(projectDir, {
      idleMinutes: 5,
      minPendingLogs: 1,
      cooldownMinutes: 3,
      maxLogs: 120
    });
    if (reflected) {
      syncCompanionProfileMemoryFacts(projectDir);
    }
  }, 2e4);
  runtime.daemonLauncherUnsubscribe = subscribeLauncherEvents(projectDir, (event) => {
    appendDaemonProgressAudit(projectDir, event);
    if (event.type === "job.progress") {
      publishGatewayEvent(runtime, "daemon.job_progress", event);
      const phase = String(event.payload?.phase ?? "");
      if (phase === "audio.filler") {
        publishGatewayEvent(runtime, "daemon.audio_filler", event);
      }
      const config3 = readConfig(projectDir);
      const notifyOnTerminal = config3.runtime?.notifications?.job_toast !== false;
      const status = String(event.payload?.status ?? "").trim().toLowerCase();
      if (notifyOnTerminal && (status === "completed" || status === "failed" || status === "degraded" || status === "canceled")) {
        publishGatewayEvent(runtime, "daemon.job_terminal", event);
      }
      return;
    }
    publishGatewayEvent(runtime, event.type, event);
  });
  void runtime.channelRuntime.start();
  log("[gateway] runtime started", {
    projectDir,
    state: toGatewayState(projectDir, runtime),
    owner: describeOwnerLock(readGatewayOwnerLock(projectDir))
  });
  return syncGatewayState(projectDir, runtime);
}
function createGatewayTools(ctx) {
  const miya_gateway_start = tool({
    description: "Start Miya Gateway and persist .opencode/miya/gateway.json.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      const state2 = ensureGatewayRunning(ctx.directory);
      const persisted = readPersistedAgentRuntime(ctx.directory);
      const owner = ownerSummary(ctx.directory);
      const healthy = await probeGatewayAlive(state2.url, 1e3);
      return [
        formatGatewayStateWithRuntime(
          state2,
          owner.ownerPID,
          owner.isOwner,
          persisted.activeAgentId,
          persisted.revision
        ),
        `gateway_healthy=${healthy}`
      ].join("\n");
    }
  });
  const miya_gateway_status = tool({
    description: "Read current Miya Gateway state.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      const state2 = ensureGatewayRunning(ctx.directory);
      const persisted = readPersistedAgentRuntime(ctx.directory);
      const owner = ownerSummary(ctx.directory);
      const healthy = await probeGatewayAlive(state2.url, 1e3);
      return [
        formatGatewayStateWithRuntime(
          state2,
          owner.ownerPID,
          owner.isOwner,
          persisted.activeAgentId,
          persisted.revision
        ),
        `gateway_healthy=${healthy}`
      ].join("\n");
    }
  });
  const miya_gateway_doctor = tool({
    description: "Run control-plane doctor checks.",
    args: {},
    async execute() {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      ensureGatewayRunning(ctx.directory);
      const runtime = runtimes2.get(ctx.directory);
      if (!runtime) return "doctor_failed=gateway_unavailable";
      const issues = buildSnapshot(ctx.directory, runtime).doctor.issues;
      if (issues.length === 0) return "doctor=ok\nissues=0";
      return [
        "doctor=issues",
        `issues=${issues.length}`,
        ...issues.map((issue3) => `- [${issue3.severity}] ${issue3.code} | ${issue3.message}`)
      ].join("\n");
    }
  });
  const miya_gateway_shutdown = tool({
    description: "Stop Miya Gateway runtime.",
    args: {},
    async execute() {
      const result = stopGateway(ctx.directory);
      if (!result.stopped) return "stopped=false\nreason=not_running";
      return [
        "stopped=true",
        `url=${result.previous?.url ?? ""}`,
        `port=${result.previous?.port ?? 0}`
      ].join("\n");
    }
  });
  const miya_memory_reflect = tool({
    description: "Trigger Miya memory reflection (Memory Consolidation Loop) and sync long-term graph.",
    args: {
      force: z3.boolean().optional().describe("Force reflection even with low pending logs"),
      minLogs: z3.number().optional().describe("Minimum pending logs required"),
      maxLogs: z3.number().optional().describe("Maximum logs processed in this run"),
      cooldownMinutes: z3.number().optional().describe("Cooldown window in minutes"),
      idempotencyKey: z3.string().optional().describe("Optional idempotency key")
    },
    async execute(args) {
      registerGatewayDependencies(ctx.directory, { client: ctx.client });
      ensureGatewayRunning(ctx.directory);
      const runtime = runtimes2.get(ctx.directory);
      if (!runtime) throw new Error("gateway_runtime_unavailable");
      const result = await invokeGatewayMethod(
        ctx.directory,
        runtime,
        "miya.memory.reflect",
        {
          policyHash: currentPolicyHash(ctx.directory),
          force: Boolean(args.force),
          minLogs: typeof args.minLogs === "number" ? Math.floor(args.minLogs) : void 0,
          maxLogs: typeof args.maxLogs === "number" ? Math.floor(args.maxLogs) : void 0,
          cooldownMinutes: typeof args.cooldownMinutes === "number" ? Number(args.cooldownMinutes) : void 0,
          idempotencyKey: typeof args.idempotencyKey === "string" && args.idempotencyKey.trim().length > 0 ? args.idempotencyKey.trim() : void 0
        },
        { clientID: "gateway-tool", role: "admin" }
      );
      return JSON.stringify(result, null, 2);
    }
  });
  return {
    miya_gateway_start,
    miya_gateway_status,
    miya_gateway_doctor,
    miya_gateway_shutdown,
    miya_memory_reflect
  };
}
function startGatewayWithLog(projectDir) {
  const stateFile3 = gatewayFile(projectDir);
  const ownerFile = gatewayOwnerLockFile(projectDir);
  log("[gateway] startup requested", {
    projectDir,
    pid: process.pid,
    stateFile: stateFile3,
    ownerFile,
    existingState: describeGatewayState(readGatewayStateFile(projectDir)),
    existingOwner: describeOwnerLock(readGatewayOwnerLock(projectDir))
  });
  try {
    const state2 = ensureGatewayRunning(projectDir);
    const owner = ownerSummary(projectDir);
    log("[gateway] started", {
      ...state2,
      owner
    });
    void probeGatewayAlive(state2.url, 1500).then((healthy) => {
      log("[gateway] startup health probe result", {
        projectDir,
        url: state2.url,
        healthy
      });
    }).catch((error92) => {
      log("[gateway] startup health probe failed", {
        projectDir,
        url: state2.url,
        error: error92 instanceof Error ? error92.message : String(error92)
      });
    });
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    if (message === "gateway_owned_by_other_process") {
      const owner = readGatewayOwnerLock(projectDir);
      const state2 = readGatewayStateFile(projectDir);
      log("[gateway] follower mode: owner is another process", {
        projectDir,
        owner: describeOwnerLock(owner),
        state: describeGatewayState(state2)
      });
      const timerKey = projectDir;
      if (!followerRecoveryTimers.has(timerKey)) {
        const timer = setTimeout(() => {
          followerRecoveryTimers.delete(timerKey);
          try {
            const recovered = ensureGatewayRunning(projectDir);
            log("[gateway] follower delayed recovery succeeded", {
              projectDir,
              state: recovered
            });
          } catch (recoveryError) {
            log("[gateway] follower delayed recovery still blocked", {
              projectDir,
              error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError),
              owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
              state: describeGatewayState(readGatewayStateFile(projectDir))
            });
          }
        }, 6e3);
        followerRecoveryTimers.set(timerKey, timer);
      }
      return;
    }
    log("[gateway] failed to start", {
      projectDir,
      error: message,
      owner: describeOwnerLock(readGatewayOwnerLock(projectDir)),
      state: describeGatewayState(readGatewayStateFile(projectDir))
    });
  }
}

// src/intake/store.ts
import * as fs48 from "node:fs";
import * as path49 from "node:path";
var DEFAULT_STATE4 = {
  proposals: [],
  whitelist: [],
  blacklist: [],
  events: []
};
var MAX_PROPOSALS = 1e3;
var MAX_LIST_ENTRIES = 1e3;
var MAX_EVENTS = 5e3;
function filePath13(projectDir) {
  return path49.join(getMiyaRuntimeDir(projectDir), "intake.json");
}
function ensureDir22(file3) {
  fs48.mkdirSync(path49.dirname(file3), { recursive: true });
}
function randomId2(prefix) {
  const time5 = Date.now().toString(36);
  const rand = Math.random().toString(36).slice(2, 10);
  return `${prefix}_${time5}_${rand}`;
}
function sanitizeState(input) {
  if (!input || typeof input !== "object" || Array.isArray(input)) {
    return { ...DEFAULT_STATE4 };
  }
  const parsed = input;
  return {
    proposals: Array.isArray(parsed.proposals) ? parsed.proposals : [],
    whitelist: Array.isArray(parsed.whitelist) ? parsed.whitelist : [],
    blacklist: Array.isArray(parsed.blacklist) ? parsed.blacklist : [],
    events: Array.isArray(parsed.events) ? parsed.events : []
  };
}
function createIntakeId(prefix) {
  return randomId2(prefix);
}
function readIntakeState(projectDir) {
  const file3 = filePath13(projectDir);
  if (!fs48.existsSync(file3)) {
    return { ...DEFAULT_STATE4 };
  }
  try {
    const parsed = JSON.parse(fs48.readFileSync(file3, "utf-8"));
    return sanitizeState(parsed);
  } catch {
    return { ...DEFAULT_STATE4 };
  }
}
function writeIntakeState(projectDir, state2) {
  const file3 = filePath13(projectDir);
  ensureDir22(file3);
  const normalized = {
    proposals: state2.proposals.slice(0, MAX_PROPOSALS),
    whitelist: state2.whitelist.slice(0, MAX_LIST_ENTRIES),
    blacklist: state2.blacklist.slice(0, MAX_LIST_ENTRIES),
    events: state2.events.slice(0, MAX_EVENTS)
  };
  fs48.writeFileSync(file3, `${JSON.stringify(normalized, null, 2)}
`, "utf-8");
}

// src/intake/service.ts
function nowIso30() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function asBool(value, fallback) {
  return typeof value === "boolean" ? value : fallback;
}
function asNum(value, fallback) {
  return typeof value === "number" && Number.isFinite(value) ? value : fallback;
}
function asScope(value, fallback) {
  if (value === "CONTENT_FINGERPRINT" || value === "PAGE" || value === "PATH_PREFIX" || value === "DOMAIN") {
    return value;
  }
  return fallback;
}
function asSourceUnit(value, fallback) {
  if (value === "DOMAIN_PATH_PREFIX" || value === "DOMAIN" || value === "PATH_PREFIX") {
    return value;
  }
  return fallback;
}
function readIntakeConfig(projectDir) {
  const config3 = flattenConfig(readConfig(projectDir));
  return {
    enabled: asBool(config3["intake.enabled"], true),
    autoWhitelistOnApprove: asBool(
      config3["intake.policy.autoWhitelistOnApprove"],
      true
    ),
    autoBlacklistOnReject: asBool(
      config3["intake.policy.autoBlacklistOnReject"],
      true
    ),
    defaultRejectScope: asScope(
      config3["intake.policy.defaultRejectScope"],
      "CONTENT_FINGERPRINT"
    ),
    windowN: Math.max(1, Math.trunc(asNum(config3["intake.stats.windowN"], 10))),
    hardDenyWhenUsefulLessThanRejected: asBool(
      config3["intake.stats.hardDenyWhenUsefulLessThanRejected"],
      true
    ),
    downrankThresholdRatioX100: Math.max(
      1,
      Math.trunc(asNum(config3["intake.stats.downrankThresholdRatioX100"], 150))
    ),
    downrankExplorePercent: Math.max(
      0,
      Math.min(
        100,
        Math.trunc(asNum(config3["intake.stats.downrankExplorePercent"], 30))
      )
    ),
    sourceUnit: asSourceUnit(
      config3["intake.stats.sourceUnit"],
      "DOMAIN_PATH_PREFIX"
    )
  };
}
function normalizeDomain(input, urlInput) {
  const raw = (input ?? "").trim();
  if (raw.length > 0) {
    const maybeUrl = raw.includes("://") ? raw : `https://${raw}`;
    try {
      return new URL(maybeUrl).hostname.toLowerCase();
    } catch {
      return raw.replace(/^https?:\/\//i, "").replace(/\/.*$/, "").toLowerCase();
    }
  }
  const urlRaw = (urlInput ?? "").trim();
  if (urlRaw.length === 0) return "unknown";
  try {
    return new URL(urlRaw).hostname.toLowerCase();
  } catch {
    return "unknown";
  }
}
function normalizePath(input, urlInput) {
  const raw = (input ?? "").trim();
  if (raw.length > 0) {
    const noQuery = raw.split("?")[0]?.split("#")[0] ?? raw;
    if (noQuery.startsWith("/")) return noQuery;
    return `/${noQuery}`;
  }
  const urlRaw = (urlInput ?? "").trim();
  if (urlRaw.length === 0) return "/";
  try {
    const pathname = new URL(urlRaw).pathname || "/";
    return pathname.startsWith("/") ? pathname : `/${pathname}`;
  } catch {
    return "/";
  }
}
function normalizePathPrefix(pathValue) {
  const normalized = normalizePath(pathValue);
  const segments = normalized.split("/").map((segment) => segment.trim()).filter((segment) => segment.length > 0);
  if (segments.length === 0) return "/";
  return `/${segments[0]}`;
}
function safeArray(input, limit = 10) {
  if (!Array.isArray(input)) return [];
  const out = [];
  for (const item of input) {
    if (typeof item !== "string") continue;
    const text = item.trim();
    if (!text) continue;
    out.push(text);
    if (out.length >= limit) break;
  }
  return out;
}
function buildFingerprint(source) {
  return [
    source.domain,
    source.path,
    source.selector ?? "-",
    source.contentHash ?? "-"
  ].join("|");
}
function resolveSource(config3, sourceInput) {
  const domain3 = normalizeDomain(sourceInput.domain, sourceInput.url);
  const pathValue = normalizePath(sourceInput.path, sourceInput.url);
  const selector = sourceInput.selector?.trim() || void 0;
  const contentHash = sourceInput.contentHash?.trim() || void 0;
  const sourceKey = sourceInput.sourceKey?.trim() || void 0;
  const source = {
    domain: domain3,
    path: pathValue,
    selector,
    contentHash,
    sourceKey
  };
  const pageKey = `${domain3}${pathValue}`;
  const pathPrefix = normalizePathPrefix(pathValue);
  const pathPrefixKey = `${domain3}${pathPrefix}`;
  const fingerprint = buildFingerprint(source);
  const sourceUnitKey = sourceKey && sourceKey.length > 0 ? sourceKey : config3.sourceUnit === "DOMAIN" ? domain3 : config3.sourceUnit === "PATH_PREFIX" ? pathPrefixKey : pathPrefixKey;
  return {
    source,
    pageKey,
    pathPrefixKey,
    fingerprint,
    sourceUnitKey
  };
}
function matchListEntry(entry2, source) {
  if (entry2.scope === "CONTENT_FINGERPRINT") {
    return entry2.value === source.fingerprint;
  }
  if (entry2.scope === "PAGE") {
    return entry2.value === source.pageKey;
  }
  if (entry2.scope === "PATH_PREFIX") {
    return source.pageKey.startsWith(entry2.value);
  }
  return entry2.value === source.source.domain;
}
function addUniqueRule(list, scope, value, reason) {
  const existing = list.find((entry2) => entry2.scope === scope && entry2.value === value);
  if (existing) return existing;
  const next = {
    id: createIntakeId("rule"),
    scope,
    value,
    reason,
    createdAt: nowIso30()
  };
  list.unshift(next);
  return next;
}
function scopeValueFromSource(scope, source) {
  if (scope === "CONTENT_FINGERPRINT") return source.fingerprint;
  if (scope === "PAGE") return source.pageKey;
  if (scope === "PATH_PREFIX") return source.pathPrefixKey;
  return source.source.domain;
}
function appendEvent(state2, event) {
  const next = {
    id: createIntakeId("event"),
    timestamp: nowIso30(),
    ...event
  };
  state2.events.unshift(next);
  return next;
}
function findProposal(state2, proposalId) {
  return state2.proposals.find((proposal) => proposal.id === proposalId);
}
function decideOutcome(decision) {
  if (decision === "trial_once") return "trial";
  if (decision.startsWith("approve")) return "useful";
  return "rejected";
}
function evaluateStatsForEvents(config3, sourceUnitKey, events) {
  const related = events.filter((event) => event.sourceUnitKey === sourceUnitKey);
  const window = related.slice(0, config3.windowN);
  const usefulCount = window.filter((event) => event.outcome === "useful").length;
  const rejectedCount = window.filter((event) => event.outcome === "rejected").length;
  const trialCount = window.filter((event) => event.outcome === "trial").length;
  const considered = usefulCount + rejectedCount;
  let verdict = "insufficient_data";
  let explorePercent = 100;
  if (considered >= config3.windowN) {
    if (config3.hardDenyWhenUsefulLessThanRejected && usefulCount < rejectedCount) {
      verdict = "hard_deny";
      explorePercent = 0;
    } else if (rejectedCount > 0 && usefulCount * 100 < config3.downrankThresholdRatioX100 * rejectedCount) {
      verdict = "downrank";
      explorePercent = config3.downrankExplorePercent;
    } else {
      verdict = "normal";
      explorePercent = 100;
    }
  }
  return {
    sourceUnitKey,
    windowSize: config3.windowN,
    usefulCount,
    rejectedCount,
    trialCount,
    consideredEvents: considered,
    verdict,
    recommendedExplorePercent: explorePercent
  };
}
function listIntakeData(projectDir) {
  return readIntakeState(projectDir);
}
function proposeIntake(projectDir, input) {
  const config3 = readIntakeConfig(projectDir);
  const state2 = readIntakeState(projectDir);
  const source = resolveSource(config3, input.source);
  const stats = evaluateStatsForEvents(config3, source.sourceUnitKey, state2.events);
  if (!config3.enabled) {
    return { status: "disabled", stats };
  }
  const blackRule = state2.blacklist.find((entry2) => matchListEntry(entry2, source));
  if (blackRule) {
    const proposal2 = {
      id: createIntakeId("intake"),
      status: "auto_rejected",
      trigger: input.trigger,
      source: source.source,
      sourceFingerprint: source.fingerprint,
      sourceUnitKey: source.sourceUnitKey,
      summaryPoints: safeArray(input.summaryPoints, 3),
      originalPlan: (input.originalPlan ?? "").trim(),
      suggestedChange: (input.suggestedChange ?? "").trim(),
      benefits: safeArray(input.benefits),
      risks: safeArray(input.risks),
      evidence: safeArray(input.evidence, 20),
      proposedChanges: input.proposedChanges,
      requestedAt: nowIso30(),
      resolvedAt: nowIso30(),
      resolution: {
        decision: "auto_rejected_by_blacklist",
        scope: blackRule.scope,
        reason: blackRule.reason
      }
    };
    state2.proposals.unshift(proposal2);
    writeIntakeState(projectDir, state2);
    return { status: "auto_rejected", proposal: proposal2, matchedRule: blackRule, stats };
  }
  const whiteRule = state2.whitelist.find((entry2) => matchListEntry(entry2, source));
  if (whiteRule) {
    const proposal2 = {
      id: createIntakeId("intake"),
      status: "auto_allowed",
      trigger: input.trigger,
      source: source.source,
      sourceFingerprint: source.fingerprint,
      sourceUnitKey: source.sourceUnitKey,
      summaryPoints: safeArray(input.summaryPoints, 3),
      originalPlan: (input.originalPlan ?? "").trim(),
      suggestedChange: (input.suggestedChange ?? "").trim(),
      benefits: safeArray(input.benefits),
      risks: safeArray(input.risks),
      evidence: safeArray(input.evidence, 20),
      proposedChanges: input.proposedChanges,
      requestedAt: nowIso30(),
      resolvedAt: nowIso30(),
      resolution: {
        decision: "auto_allowed_by_whitelist",
        scope: whiteRule.scope,
        reason: whiteRule.reason
      }
    };
    state2.proposals.unshift(proposal2);
    writeIntakeState(projectDir, state2);
    return { status: "auto_allowed", proposal: proposal2, matchedRule: whiteRule, stats };
  }
  const proposal = {
    id: createIntakeId("intake"),
    status: "pending",
    trigger: input.trigger,
    source: source.source,
    sourceFingerprint: source.fingerprint,
    sourceUnitKey: source.sourceUnitKey,
    summaryPoints: safeArray(input.summaryPoints, 3),
    originalPlan: (input.originalPlan ?? "").trim(),
    suggestedChange: (input.suggestedChange ?? "").trim(),
    benefits: safeArray(input.benefits),
    risks: safeArray(input.risks),
    evidence: safeArray(input.evidence, 20),
    proposedChanges: input.proposedChanges,
    requestedAt: nowIso30()
  };
  state2.proposals.unshift(proposal);
  writeIntakeState(projectDir, state2);
  return { status: "pending", proposal, stats };
}
function decideIntake(projectDir, input) {
  const config3 = readIntakeConfig(projectDir);
  const state2 = readIntakeState(projectDir);
  const proposal = findProposal(state2, input.proposalId);
  if (!proposal) {
    return { ok: false, message: "proposal_not_found" };
  }
  if (proposal.status !== "pending") {
    return { ok: false, message: `proposal_not_pending:${proposal.status}`, proposal };
  }
  const resolvedSource = resolveSource(config3, proposal.source);
  let createdRule;
  let nextStatus = "pending";
  let scope;
  const reason = input.reason?.trim() || input.decision;
  if (input.decision === "trial_once") {
    nextStatus = "trial";
  } else if (input.decision === "approve_whitelist") {
    nextStatus = "approved";
    scope = "CONTENT_FINGERPRINT";
    createdRule = addUniqueRule(
      state2.whitelist,
      scope,
      scopeValueFromSource(scope, resolvedSource),
      reason
    );
  } else if (input.decision === "approve") {
    nextStatus = "approved";
    if (config3.autoWhitelistOnApprove) {
      scope = "CONTENT_FINGERPRINT";
      createdRule = addUniqueRule(
        state2.whitelist,
        scope,
        scopeValueFromSource(scope, resolvedSource),
        reason
      );
    }
  } else if (input.decision === "reject_block_scope") {
    nextStatus = "rejected";
    scope = input.scope ?? config3.defaultRejectScope;
    createdRule = addUniqueRule(
      state2.blacklist,
      scope,
      scopeValueFromSource(scope, resolvedSource),
      reason
    );
  } else if (input.decision === "reject_blacklist") {
    nextStatus = "rejected";
    scope = "CONTENT_FINGERPRINT";
    createdRule = addUniqueRule(
      state2.blacklist,
      scope,
      scopeValueFromSource(scope, resolvedSource),
      reason
    );
  } else {
    nextStatus = "rejected";
    if (config3.autoBlacklistOnReject) {
      scope = config3.defaultRejectScope;
      createdRule = addUniqueRule(
        state2.blacklist,
        scope,
        scopeValueFromSource(scope, resolvedSource),
        reason
      );
    }
  }
  proposal.status = nextStatus;
  proposal.resolvedAt = nowIso30();
  proposal.resolution = {
    decision: input.decision,
    scope,
    reason
  };
  appendEvent(state2, {
    proposalId: proposal.id,
    sourceUnitKey: proposal.sourceUnitKey,
    sourceFingerprint: proposal.sourceFingerprint,
    outcome: decideOutcome(input.decision),
    decision: input.decision
  });
  const stats = evaluateStatsForEvents(config3, proposal.sourceUnitKey, state2.events);
  writeIntakeState(projectDir, state2);
  return {
    ok: true,
    message: "ok",
    proposal,
    createdRule,
    stats
  };
}
function intakeStats(projectDir, input) {
  const config3 = readIntakeConfig(projectDir);
  const state2 = readIntakeState(projectDir);
  return evaluateStatsForEvents(config3, input.sourceUnitKey, state2.events);
}
function resolveSourceUnitKey(projectDir, source) {
  const config3 = readIntakeConfig(projectDir);
  return resolveSource(config3, source).sourceUnitKey;
}
function intakeSummary(projectDir) {
  const state2 = readIntakeState(projectDir);
  return {
    pending: state2.proposals.filter((item) => item.status === "pending").length,
    whitelist: state2.whitelist.length,
    blacklist: state2.blacklist.length,
    recentEvents: state2.events.slice(0, 20),
    pendingItems: state2.proposals.filter((item) => item.status === "pending").slice(0, 20)
  };
}

// src/intake/index.ts
var z4 = tool.schema;
function toText(value) {
  if (value === void 0) return "";
  if (typeof value === "string") return value;
  try {
    return JSON.stringify(value, null, 2);
  } catch {
    return String(value);
  }
}
function formatProposalOutput(result) {
  const proposal = result.proposal;
  const lines = [`status=${result.status}`];
  if (proposal) {
    lines.push(`proposal_id=${proposal.id}`);
    lines.push(`trigger=${proposal.trigger}`);
    lines.push(`source_unit=${proposal.sourceUnitKey}`);
    lines.push(`source_fingerprint=${proposal.sourceFingerprint}`);
    lines.push(`requested_at=${proposal.requestedAt}`);
    if (proposal.summaryPoints.length > 0) {
      lines.push(`summary=${proposal.summaryPoints.join(" | ")}`);
    }
  }
  if (result.matchedRule) {
    lines.push(
      `matched_rule=${result.matchedRule.scope}:${result.matchedRule.value}`
    );
  }
  if (result.stats) {
    lines.push(
      `stats=U${result.stats.usefulCount}/R${result.stats.rejectedCount}/T${result.stats.trialCount} verdict=${result.stats.verdict} explore=${result.stats.recommendedExplorePercent}%`
    );
  }
  if (result.status === "pending") {
    lines.push("");
    lines.push("decision_options=");
    lines.push("- approve_whitelist");
    lines.push("- reject_blacklist");
    lines.push("- reject_block_scope(scope=PAGE|PATH_PREFIX|DOMAIN)");
    lines.push("- trial_once");
  }
  return lines.join("\n");
}
function parseScope(value) {
  if (value === "CONTENT_FINGERPRINT" || value === "PAGE" || value === "PATH_PREFIX" || value === "DOMAIN") {
    return value;
  }
  return void 0;
}
function parseTrigger(value) {
  if (value === "config_change" || value === "skill_or_toolchain_change" || value === "high_risk_action" || value === "directive_content") {
    return value;
  }
  return "manual";
}
function createIntakeTools(ctx) {
  const miya_intake_propose = tool({
    description: "Create an intake-gate proposal before config/skill/high-risk changes from external/web info.",
    args: {
      trigger: z4.string().optional().describe(
        "config_change|skill_or_toolchain_change|high_risk_action|directive_content|manual"
      ),
      source: z4.any().describe(
        "Source object: {domain,path,selector,contentHash,sourceKey,url}"
      ),
      summary_points: z4.array(z4.string()).optional(),
      original_plan: z4.string().optional(),
      suggested_change: z4.string().optional(),
      benefits: z4.array(z4.string()).optional(),
      risks: z4.array(z4.string()).optional(),
      evidence: z4.array(z4.string()).optional(),
      proposed_changes: z4.any().optional()
    },
    async execute(args) {
      const result = proposeIntake(ctx.directory, {
        trigger: parseTrigger(args.trigger),
        source: args.source && typeof args.source === "object" ? args.source : {},
        summaryPoints: Array.isArray(args.summary_points) ? args.summary_points.map(String) : void 0,
        originalPlan: args.original_plan ? String(args.original_plan) : void 0,
        suggestedChange: args.suggested_change ? String(args.suggested_change) : void 0,
        benefits: Array.isArray(args.benefits) ? args.benefits.map(String) : void 0,
        risks: Array.isArray(args.risks) ? args.risks.map(String) : void 0,
        evidence: Array.isArray(args.evidence) ? args.evidence.map(String) : void 0,
        proposedChanges: args.proposed_changes
      });
      return formatProposalOutput(result);
    }
  });
  const miya_intake_decide = tool({
    description: "Resolve one pending intake proposal: approve/whitelist, reject/blacklist, block scope, or trial once.",
    args: {
      proposal_id: z4.string().describe("Pending proposal id"),
      decision: z4.string().describe(
        "approve|approve_whitelist|reject|reject_blacklist|reject_block_scope|trial_once"
      ),
      scope: z4.string().optional().describe("Required for reject_block_scope: PAGE|PATH_PREFIX|DOMAIN"),
      reason: z4.string().optional()
    },
    async execute(args) {
      const decision = String(args.decision);
      if (decision !== "approve" && decision !== "approve_whitelist" && decision !== "reject" && decision !== "reject_blacklist" && decision !== "reject_block_scope" && decision !== "trial_once") {
        return "ok=false\nmessage=invalid_decision";
      }
      const result = decideIntake(ctx.directory, {
        proposalId: String(args.proposal_id),
        decision,
        scope: parseScope(args.scope),
        reason: args.reason ? String(args.reason) : void 0
      });
      if (!result.ok || !result.proposal) {
        return `ok=false
message=${result.message}`;
      }
      const lines = [
        "ok=true",
        `proposal_id=${result.proposal.id}`,
        `status=${result.proposal.status}`,
        `decision=${result.proposal.resolution?.decision ?? "n/a"}`
      ];
      if (result.createdRule) {
        lines.push(
          `list_entry=${result.createdRule.scope}:${result.createdRule.value}`
        );
      }
      if (result.stats) {
        lines.push(
          `stats=U${result.stats.usefulCount}/R${result.stats.rejectedCount}/T${result.stats.trialCount} verdict=${result.stats.verdict} explore=${result.stats.recommendedExplorePercent}%`
        );
      }
      return lines.join("\n");
    }
  });
  const miya_intake_stats = tool({
    description: "Evaluate intake source quality on sliding window: hard deny / downrank / normal.",
    args: {
      source_key: z4.string().optional().describe("Source unit key"),
      source: z4.any().optional().describe("Source object if no source_key")
    },
    async execute(args) {
      let sourceKey = args.source_key ? String(args.source_key).trim() : "";
      if (!sourceKey) {
        const source = args.source && typeof args.source === "object" ? args.source : {};
        sourceKey = resolveSourceUnitKey(ctx.directory, source);
      }
      const stats = intakeStats(ctx.directory, { sourceUnitKey: sourceKey });
      return toText(stats);
    }
  });
  const miya_intake_list = tool({
    description: "List intake gate data: pending proposals, whitelist, blacklist, events, or all.",
    args: {
      target: z4.string().optional().describe("pending|whitelist|blacklist|events|all"),
      limit: z4.number().optional().describe("Result limit (default 50)")
    },
    async execute(args) {
      const state2 = listIntakeData(ctx.directory);
      const summary = intakeSummary(ctx.directory);
      const target = args.target ? String(args.target).toLowerCase() : "all";
      const limit = typeof args.limit === "number" && args.limit > 0 ? Math.min(500, Math.trunc(args.limit)) : 50;
      if (target === "pending") {
        return toText({ summary, pending: summary.pendingItems.slice(0, limit) });
      }
      if (target === "whitelist") {
        return toText({ summary, whitelist: state2.whitelist.slice(0, limit) });
      }
      if (target === "blacklist") {
        return toText({ summary, blacklist: state2.blacklist.slice(0, limit) });
      }
      if (target === "events") {
        return toText({ summary, events: state2.events.slice(0, limit) });
      }
      return toText({
        summary,
        pending: summary.pendingItems.slice(0, limit),
        whitelist: state2.whitelist.slice(0, limit),
        blacklist: state2.blacklist.slice(0, limit),
        events: state2.events.slice(0, limit)
      });
    }
  });
  return {
    miya_intake_propose,
    miya_intake_decide,
    miya_intake_stats,
    miya_intake_list
  };
}

// src/intake/websearch-guard.ts
var SESSION_TTL_MS = 30 * 60 * 1e3;
var WRITE_PERMISSIONS = /* @__PURE__ */ new Set(["edit", "write", "bash", "external_directory"]);
var state = /* @__PURE__ */ new Map();
function normalizeSessionID(sessionID2) {
  const raw = (sessionID2 ?? "main").trim();
  return raw.length > 0 ? raw : "main";
}
function isWebsearchTool(tool2) {
  const value = tool2.trim().toLowerCase();
  return value.includes("websearch") || value.includes("web_search_exa");
}
function extractFirstUrl(text) {
  const match = text.match(/https?:\/\/[^\s)\]}>"']+/i);
  return match ? match[0] : void 0;
}
function parseSource(url3) {
  if (!url3) return { url: void 0 };
  try {
    const parsed = new URL(url3);
    return {
      domain: parsed.hostname,
      path: parsed.pathname || "/",
      url: url3
    };
  } catch {
    return { url: url3 };
  }
}
function trackWebsearchToolOutput(sessionID2, tool2, outputText) {
  if (!isWebsearchTool(tool2)) return;
  const key = normalizeSessionID(sessionID2);
  const now = Date.now();
  state.set(key, {
    ...state.get(key),
    lastSeenAt: now,
    lastUrl: extractFirstUrl(outputText) ?? state.get(key)?.lastUrl
  });
}
function shouldInterceptWriteAfterWebsearch(projectDir, input) {
  const permission = String(input.permission ?? "").trim();
  if (!WRITE_PERMISSIONS.has(permission)) {
    return { intercept: false, reason: "permission_not_write" };
  }
  const key = normalizeSessionID(input.sessionID);
  const session = state.get(key);
  if (!session) return { intercept: false, reason: "no_websearch_context" };
  const now = Date.now();
  if (now - session.lastSeenAt > SESSION_TTL_MS) {
    state.delete(key);
    return { intercept: false, reason: "websearch_context_expired" };
  }
  if (session.pendingProposalId) {
    return {
      intercept: true,
      reason: "pending_intake_proposal_exists",
      proposalID: session.pendingProposalId
    };
  }
  const source = parseSource(session.lastUrl);
  const proposal = proposeIntake(projectDir, {
    trigger: "directive_content",
    source: {
      ...source,
      sourceKey: "mcp:websearch"
    },
    summaryPoints: [
      "WebSearch\u7ED3\u679C\u521A\u88AB\u5F15\u5165\u5F53\u524D\u4F1A\u8BDD",
      `\u5373\u5C06\u6267\u884C\u5199\u5165\u6743\u9650: ${permission}`,
      "\u89E6\u53D1\u57FA\u7840\u7248Intake Gate\u62E6\u622A"
    ],
    originalPlan: "\u57FA\u4E8E\u5916\u90E8\u7F51\u9875\u68C0\u7D22\u7ED3\u679C\u76F4\u63A5\u6267\u884C\u4EE3\u7801/\u6587\u4EF6\u6539\u52A8",
    suggestedChange: "\u5148\u5BA1\u67E5\u6765\u6E90\u4E0E\u8BC1\u636E\uFF0C\u518D\u6267\u884C\u5199\u5165",
    benefits: ["\u964D\u4F4E\u63D0\u793A\u6CE8\u5165\u4E0E\u9519\u8BEF\u8D44\u6599\u5BFC\u81F4\u7684\u5199\u5165\u98CE\u9669"],
    risks: ["\u82E5\u76F4\u63A5\u5199\u5165\u53EF\u80FD\u5F15\u5165\u4E0D\u53EF\u9760\u5916\u90E8\u5185\u5BB9"],
    evidence: session.lastUrl ? [session.lastUrl] : ["source=mcp:websearch"]
  });
  if (proposal.status === "pending") {
    state.set(key, {
      ...session,
      pendingProposalId: proposal.proposal?.id
    });
    return {
      intercept: true,
      reason: "pending_intake_proposal_created",
      proposalID: proposal.proposal?.id
    };
  }
  if (proposal.status === "auto_rejected") {
    state.set(key, {
      ...session,
      pendingProposalId: proposal.proposal?.id
    });
    return {
      intercept: true,
      reason: "auto_rejected_by_intake_rule",
      proposalID: proposal.proposal?.id
    };
  }
  return { intercept: false, reason: proposal.status };
}

// src/contracts/hook-contract.ts
var REQUIRED_HOOK_KEYS = [
  "tool.execute.before",
  "tool.execute.after",
  "permission.ask"
];
function assertRequiredHookHandlers(hooks) {
  const missing = REQUIRED_HOOK_KEYS.filter((key) => typeof hooks[key] !== "function");
  if (missing.length > 0) {
    throw new Error(`miya_hook_contract_missing:${missing.join(",")}`);
  }
}

// src/hooks/context-governor/index.ts
var DEFAULTS = {
  enabled: true,
  toolOutputMaxChars: 12e3,
  toolOutputHeadChars: 4200,
  toolOutputTailChars: 2800,
  recordTtlMs: 12 * 60 * 1e3,
  maxRecordsPerSession: 30,
  maxInjectedRecords: 3,
  maxInjectedChars: 2400
};
var TOOL_GUIDANCE = "narrow scope with path/query/limit and rerun tool";
var store = /* @__PURE__ */ new Map();
function normalizeSessionID2(sessionID2) {
  const value = String(sessionID2 ?? "main").trim();
  return value.length > 0 ? value : "main";
}
function normalizeToolName(tool2) {
  const normalized = String(tool2 ?? "").trim().toLowerCase();
  return normalized.length > 0 ? normalized : "unknown";
}
function cleanSnippet(text, maxChars) {
  return text.replace(/\s+/g, " ").trim().slice(0, maxChars);
}
function sanitizeUserTerms(text) {
  return Array.from(
    new Set(
      text.toLowerCase().split(/[^a-z0-9_\-\u4e00-\u9fff]+/i).map((item) => item.trim()).filter((item) => item.length >= 3)
    )
  );
}
function makeTruncatedOutput(tool2, text, config3) {
  const normalized = String(text ?? "");
  const totalChars = normalized.length;
  if (totalChars <= config3.toolOutputMaxChars) {
    return {
      output: normalized,
      truncated: false,
      omittedChars: 0,
      originalChars: totalChars
    };
  }
  const head = normalized.slice(0, config3.toolOutputHeadChars);
  const tail = normalized.slice(Math.max(0, totalChars - config3.toolOutputTailChars));
  const omittedChars = Math.max(0, totalChars - head.length - tail.length);
  const marker = `

...[MIYA_OUTPUT_TRUNCATED tool=${tool2} omitted_chars=${omittedChars} total_chars=${totalChars} hint="${TOOL_GUIDANCE}"]...

`;
  return {
    output: `${head}${marker}${tail}`,
    truncated: true,
    omittedChars,
    originalChars: totalChars
  };
}
function pruneRecords(records, nowMs, config3) {
  const nonExpired = records.filter(
    (record3) => nowMs - record3.recordedAt <= config3.recordTtlMs
  );
  const expired = records.length - nonExpired.length;
  const trimmed = nonExpired.slice(-config3.maxRecordsPerSession);
  return { records: trimmed, expired };
}
function findLastUserTextPart(messages) {
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i];
    if (message.info.role !== "user") continue;
    const partIndex = message.parts.findIndex(
      (part) => part.type === "text" && typeof part.text === "string"
    );
    if (partIndex === -1) continue;
    return {
      message,
      partIndex,
      sessionID: normalizeSessionID2(message.info.sessionID)
    };
  }
  return null;
}
function renderCompactContext(records, expired, terms, nowMs, config3) {
  if (records.length === 0) return "";
  const withScore = records.map((record3) => {
    const ageMs = Math.max(0, nowMs - record3.recordedAt);
    const recency = Math.max(0, 1 - ageMs / config3.recordTtlMs);
    const overlap = terms.reduce((count, term) => {
      if (record3.output.toLowerCase().includes(term)) return count + 1;
      if (record3.tool.includes(term)) return count + 1;
      return count;
    }, 0);
    return {
      record: record3,
      overlap,
      score: overlap * 2 + record3.references * 0.5 + recency,
      ageMs
    };
  });
  const ranked = withScore.sort((a, b) => b.score - a.score).slice(0, config3.maxInjectedRecords);
  for (const item of ranked) {
    if (item.overlap > 0) {
      item.record.references += 1;
    }
  }
  const lines = [];
  lines.push("[MIYA CONTEXT GOVERNOR]");
  lines.push(
    `Retained compact tool context: keep=${ranked.length} pool=${records.length} expired_pruned=${expired}.`
  );
  lines.push("Use these snapshots instead of replaying long historical tool logs.");
  lines.push("");
  let usedChars = lines.join("\n").length;
  for (const item of ranked) {
    const ageSec = Math.floor(item.ageMs / 1e3);
    const header = `- #${item.record.id} tool=${item.record.tool} age=${ageSec}s refs=${item.record.references} truncated=${item.record.truncated ? "yes" : "no"} chars=${item.record.originalChars}`;
    const snippet = `  snippet: ${cleanSnippet(item.record.output, 320)}`;
    const block = `${header}
${snippet}`;
    if (usedChars + block.length > config3.maxInjectedChars) break;
    lines.push(block);
    usedChars += block.length + 1;
  }
  return lines.join("\n");
}
function resolveConfig(input) {
  return {
    enabled: input?.enabled ?? DEFAULTS.enabled,
    toolOutputMaxChars: Math.max(
      1200,
      Number(input?.toolOutputMaxChars ?? DEFAULTS.toolOutputMaxChars)
    ),
    toolOutputHeadChars: Math.max(
      400,
      Number(input?.toolOutputHeadChars ?? DEFAULTS.toolOutputHeadChars)
    ),
    toolOutputTailChars: Math.max(
      200,
      Number(input?.toolOutputTailChars ?? DEFAULTS.toolOutputTailChars)
    ),
    recordTtlMs: Math.max(1e4, Number(input?.recordTtlMs ?? DEFAULTS.recordTtlMs)),
    maxRecordsPerSession: Math.max(
      5,
      Number(input?.maxRecordsPerSession ?? DEFAULTS.maxRecordsPerSession)
    ),
    maxInjectedRecords: Math.max(
      1,
      Number(input?.maxInjectedRecords ?? DEFAULTS.maxInjectedRecords)
    ),
    maxInjectedChars: Math.max(
      400,
      Number(input?.maxInjectedChars ?? DEFAULTS.maxInjectedChars)
    )
  };
}
function createContextGovernorHook(rawConfig, options) {
  const config3 = resolveConfig(rawConfig);
  const now = options?.now ?? (() => Date.now());
  let counter = 0;
  return {
    "tool.execute.after": async (input, output) => {
      if (!config3.enabled) return;
      const sessionID2 = normalizeSessionID2(input.sessionID);
      const tool2 = normalizeToolName(input.tool);
      const snapshot = makeTruncatedOutput(tool2, String(output.output ?? ""), config3);
      output.output = snapshot.output;
      const record3 = {
        id: `${now().toString(36)}-${(counter++).toString(36)}`,
        tool: tool2,
        output: cleanSnippet(snapshot.output, 1e3),
        recordedAt: now(),
        truncated: snapshot.truncated,
        omittedChars: snapshot.omittedChars,
        originalChars: snapshot.originalChars,
        references: 0
      };
      const existing = store.get(sessionID2) ?? [];
      const { records } = pruneRecords([...existing, record3], now(), config3);
      store.set(sessionID2, records);
    },
    "experimental.chat.messages.transform": async (_input, output) => {
      if (!config3.enabled) return;
      const target = findLastUserTextPart(output.messages);
      if (!target) return;
      const currentText = String(target.message.parts[target.partIndex].text ?? "");
      if (currentText.includes("[MIYA COMMAND BRIDGE]")) return;
      if (currentText.includes("[MIYA CONTEXT GOVERNOR]")) return;
      const sessionID2 = target.sessionID;
      const existing = store.get(sessionID2);
      if (!existing || existing.length === 0) return;
      const nowMs = now();
      const { records, expired } = pruneRecords(existing, nowMs, config3);
      store.set(sessionID2, records);
      if (records.length === 0) return;
      const compact = renderCompactContext(
        records,
        expired,
        sanitizeUserTerms(currentText),
        nowMs,
        config3
      );
      if (!compact) return;
      target.message.parts[target.partIndex].text = `${compact}

---

${currentText}`;
    }
  };
}

// src/hooks/loop-guard/index.ts
var SUBAGENT_NAMES2 = ALL_AGENT_NAMES.filter((name) => name !== ORCHESTRATOR_NAME);
function getAllText(message) {
  return message.parts.filter((part) => part.type === "text" && typeof part.text === "string").map((part) => String(part.text)).join("\n");
}
function hasQualityGatePass(messages) {
  return messages.some((message) => getAllText(message).includes("QUALITY_GATE=PASS"));
}
function isCompletionIntent(text) {
  const lowered = text.toLowerCase();
  const keywords = [
    "done",
    "finish",
    "final",
    "complete",
    "ship",
    "close",
    "\u7ED3\u675F",
    "\u5B8C\u6210",
    "\u6536\u5C3E",
    "\u4EA4\u4ED8"
  ];
  return keywords.some((keyword) => lowered.includes(keyword));
}
function findLastUserMessage(messages) {
  for (let i = messages.length - 1; i >= 0; i--) {
    if (messages[i].info.role === "user") {
      return { index: i, message: messages[i] };
    }
  }
  return null;
}
function findTextPartIndex(parts) {
  return parts.findIndex((part) => part.type === "text" && part.text !== void 0);
}
function isDirectAgentSelection(agent) {
  if (!agent) return false;
  return SUBAGENT_NAMES2.includes(agent);
}
function createLoopGuardHook(projectDir) {
  return {
    "experimental.chat.messages.transform": async (_input, output) => {
      const lastUser = findLastUserMessage(output.messages);
      if (!lastUser) return;
      const agent = lastUser.message.info.agent;
      const sessionID2 = lastUser.message.info.sessionID ?? "main";
      const textPartIndex = findTextPartIndex(lastUser.message.parts);
      if (textPartIndex === -1) return;
      const originalText = lastUser.message.parts[textPartIndex].text ?? "";
      const normalizedText = originalText.trim();
      const state2 = getSessionState(projectDir, sessionID2);
      if (isNegativeConfirmation(normalizedText) || normalizedText === "cancel-work") {
        resetSessionState(projectDir, sessionID2);
        lastUser.message.parts[textPartIndex].text = `[MIYA LOOP CANCELED]
Output a concise final status only:
<loop_report>
- done: completed work
- missing: remaining required work
- unresolved: still broken/risky parts
</loop_report>`;
        return;
      }
      if (isDirectAgentSelection(agent)) {
        const window = Math.max(0, state2.iterationCompleted - state2.windowStartIteration);
        if (state2.loopEnabled && window >= state2.maxIterationsPerWindow) {
          lastUser.message.parts[textPartIndex].text = `[MIYA DIRECT MODE - LOOP LIMIT REACHED]
This is iteration ${state2.iterationCompleted} (limit: ${state2.maxIterationsPerWindow}).

<loop_report>
- done: ${state2.lastDone.join(", ") || "(none recorded)"}
- missing: ${state2.lastMissing.join(", ") || "(none recorded)"}
- unresolved: ${state2.lastUnresolved.join(", ") || "(none recorded)"}
</loop_report>

${originalText}`;
          return;
        }
        if (!originalText.includes("[MIYA DIRECT MODE]")) {
          lastUser.message.parts[textPartIndex].text = `[MIYA DIRECT MODE: ${agent}]
\u4F60\u6B63\u5728\u4F7F\u7528\u76F4\u63A5\u6A21\u5F0F - \u7ACB\u5373\u4F7F\u7528\u4F60\u7684\u4E13\u4E1A\u80FD\u529B\u6267\u884C\uFF0C\u65E0\u9700\u7B49\u5F85\u5B8C\u65746\u6B65\u5DE5\u4F5C\u6D41\u3002
\u5F53\u524D\u5FAA\u73AF: ${state2.iterationCompleted}/${state2.maxIterationsPerWindow}\u3002

${originalText}`;
        }
        return;
      }
      if (agent && agent !== ORCHESTRATOR_NAME) {
        return;
      }
      if (state2.loopEnabled && state2.awaitingConfirmation) {
        state2.awaitingConfirmation = false;
        state2.windowStartIteration = state2.iterationCompleted;
      }
      const lowered = normalizedText.toLowerCase();
      if (shouldEnableStrictQualityGate(normalizedText)) {
        state2.strictQualityGate = true;
      }
      if (lowered.includes("strict-quality-gate off") || lowered.includes("strict quality gate off")) {
        state2.strictQualityGate = false;
      }
      if (state2.strictQualityGate && isCompletionIntent(normalizedText) && !hasQualityGatePass(output.messages)) {
        setSessionState(projectDir, sessionID2, state2);
        lastUser.message.parts[textPartIndex].text = `[MIYA STRICT QUALITY GATE BLOCK]
Completion is blocked because QUALITY_GATE=PASS was not found.
Call tool \`quality_gate\` with architecture_score, docs_score, and domain_score.
Proceed only after QUALITY_GATE=PASS.`;
        return;
      }
      setSessionState(projectDir, sessionID2, state2);
      if (state2.strictQualityGate) {
        lastUser.message.parts[textPartIndex].text = `[MIYA STRICT QUALITY GATE ACTIVE]
Before declaring completion, call tool \`quality_gate\` and require QUALITY_GATE=PASS.

---

${originalText}`;
      }
    }
  };
}

// src/hooks/phase-reminder/index.ts
var PHASE_REMINDER = `<reminder>\u26A0\uFE0F MANDATORY: Understand\u2192DELEGATE(! based on each agent rules)\u2192Split-and-Parallelize(?)\u2192Plan\u2192Execute\u2192Verify
Available Specialist Team: @2-code-search @3-docs-helper @4-architecture-advisor @5-code-fixer @6-ui-designer
</reminder>`;
function createPhaseReminderHook() {
  return {
    "experimental.chat.messages.transform": async (_input, output) => {
      const { messages } = output;
      if (messages.length === 0) {
        return;
      }
      let lastUserMessageIndex = -1;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].info.role === "user") {
          lastUserMessageIndex = i;
          break;
        }
      }
      if (lastUserMessageIndex === -1) {
        return;
      }
      const lastUserMessage = messages[lastUserMessageIndex];
      const agent = lastUserMessage.info.agent;
      if (agent && agent !== "1-task-manager") {
        return;
      }
      const textPartIndex = lastUserMessage.parts.findIndex(
        (p) => p.type === "text" && p.text !== void 0
      );
      if (textPartIndex === -1) {
        return;
      }
      const originalText = lastUserMessage.parts[textPartIndex].text ?? "";
      lastUserMessage.parts[textPartIndex].text = `${PHASE_REMINDER}

---

${originalText}`;
    }
  };
}

// src/hooks/persistent-autoflow/index.ts
function createPersistentAutoflowHook(projectDir, manager) {
  return {
    onEvent: async (event) => {
      return handleAutoflowPersistentEvent({
        projectDir,
        manager,
        event
      });
    }
  };
}

// src/hooks/post-read-nudge/index.ts
var NUDGE = "\n\n---\nReminder to follow the workflow instructions, consider delegation to specialist(s)";
function createPostReadNudgeHook() {
  return {
    "tool.execute.after": async (input, output) => {
      if (input.tool !== "Read" && input.tool !== "read") {
        return;
      }
      output.output = output.output + NUDGE;
    }
  };
}

// src/hooks/post-write-simplicity/index.ts
var NUDGE2 = "\n\n---\nPost-write check: run @7-code-simplicity-reviewer for complexity/comment cleanup before final response.";
var WRITE_TOOLS = /* @__PURE__ */ new Set([
  "write",
  "edit",
  "multiedit",
  "ast_grep_replace"
]);
function createPostWriteSimplicityHook() {
  return {
    "tool.execute.after": async (input, output) => {
      const tool2 = String(input.tool ?? "").toLowerCase();
      if (!WRITE_TOOLS.has(tool2)) {
        return;
      }
      output.output = String(output.output ?? "") + NUDGE2;
    }
  };
}

// src/hooks/slash-command-bridge/index.ts
var BRIDGE_PROMPTS = {
  "miya-gateway-start": () => "MANDATORY: Call tool `miya_gateway_start` exactly once. Return only tool output. If tool call fails, return exact error text.",
  miya_gateway_start: () => "MANDATORY: Call tool `miya_gateway_start` exactly once. Return only tool output. If tool call fails, return exact error text.",
  "miya.gateway.start": () => "MANDATORY: Call tool `miya_gateway_start` exactly once. Return only tool output. If tool call fails, return exact error text.",
  "miya-gateway-status": () => "MANDATORY: Call tool `miya_gateway_status` exactly once. Return only tool output.",
  miya_gateway_status: () => "MANDATORY: Call tool `miya_gateway_status` exactly once. Return only tool output.",
  "miya-ui-open": () => "MANDATORY: Call tool `miya_ui_open` exactly once. Return only tool output.",
  miya_ui_open: () => "MANDATORY: Call tool `miya_ui_open` exactly once. Return only tool output."
};
function extractSlashCommand(text) {
  const firstLine = text.split(/\r?\n/, 1)[0]?.trim() ?? "";
  if (!firstLine.startsWith("/")) return null;
  const body = firstLine.slice(1).trim();
  if (!body) return null;
  const [name = "", ...rest] = body.split(/\s+/);
  if (!name) return null;
  return {
    name,
    argumentsText: rest.join(" ").trim()
  };
}
function findLastUserTextPart2(messages) {
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i];
    if (message.info.role !== "user") continue;
    if (message.info.agent && message.info.agent !== "1-task-manager") continue;
    const textPartIndex = message.parts.findIndex(
      (part) => part.type === "text" && part.text !== void 0
    );
    if (textPartIndex === -1) continue;
    return { message, textPartIndex };
  }
  return null;
}
function createSlashCommandBridgeHook() {
  return {
    "experimental.chat.messages.transform": async (_input, output) => {
      const target = findLastUserTextPart2(output.messages);
      if (!target) return;
      const originalText = target.message.parts[target.textPartIndex].text ?? "";
      const slashCommand = extractSlashCommand(originalText);
      if (!slashCommand) return;
      const promptFactory = BRIDGE_PROMPTS[slashCommand.name];
      if (!promptFactory) return;
      const commandPrompt = promptFactory(slashCommand.argumentsText);
      target.message.parts[target.textPartIndex].text = `[MIYA COMMAND BRIDGE]
${commandPrompt}`;
    }
  };
}

// src/safety/index.ts
var z5 = tool.schema;
function nowIso31() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
function toPermissionRequest(input) {
  return {
    sessionID: input.sessionID,
    permission: input.permission,
    patterns: Array.isArray(input.patterns) ? input.patterns.map(String) : [],
    metadata: input.metadata,
    messageID: input.messageID ?? input.tool?.messageID,
    toolCallID: input.toolCallID ?? input.tool?.callID
  };
}
function maxTier(a, b) {
  if (tierAtLeast(a, b)) return a;
  return b;
}
function formatResult(input) {
  return [
    `VERDICT=${input.verdict.toUpperCase()}`,
    `trace_id=${input.traceID}`,
    `request_hash=${input.requestHash}`,
    `tier=${input.tier}`,
    `reason=${input.reason}`,
    `checks=${input.checks.length}`,
    input.issues.length > 0 ? `issues=${input.issues.join(" | ")}` : "issues=none"
  ].join("\n");
}
async function handlePermissionAsk(projectDir, input) {
  const request = toPermissionRequest(input);
  if (!isSideEffectPermission(request.permission)) {
    return { status: "allow", reason: "non-side-effect permission" };
  }
  const kill = readKillSwitch(projectDir);
  const requiredTier = requiredTierForRequest(request);
  const strictHash = buildRequestHash(request, true);
  const baseHash = buildRequestHash(request, false);
  if (kill.active) {
    writeSelfApprovalRecord(projectDir, {
      trace_id: kill.trace_id ?? createTraceId(),
      session_id: request.sessionID,
      request_hash: strictHash,
      action: `permission.asked:${request.permission}`,
      tier: requiredTier,
      status: "deny",
      reason: "kill_switch_active",
      checks: ["kill switch state"],
      evidence: [`kill_switch_reason=${kill.reason ?? "n/a"}`],
      executor: {
        agent: "executor",
        plan: "attempt permission request under kill-switch"
      },
      verifier: {
        agent: "architect-verifier",
        verdict: "deny",
        summary: "Kill switch is active."
      },
      rollback: { strategy: "release kill switch after root cause is fixed" }
    });
    return { status: "deny", reason: "kill_switch_active" };
  }
  const token = findApprovalToken(
    projectDir,
    request.sessionID,
    [strictHash, baseHash],
    requiredTier
  );
  if (!token) {
    const traceID = createTraceId();
    activateKillSwitch(projectDir, "missing_evidence", traceID);
    writeSelfApprovalRecord(projectDir, {
      trace_id: traceID,
      session_id: request.sessionID,
      request_hash: strictHash,
      action: `permission.asked:${request.permission}`,
      tier: requiredTier,
      status: "deny",
      reason: "missing_evidence",
      checks: ["approval token"],
      evidence: ["no valid token matched request hash"],
      executor: {
        agent: "executor",
        plan: "execute side-effect without fresh self-approval token"
      },
      verifier: {
        agent: "architect-verifier",
        verdict: "deny",
        summary: "Evidence token missing or expired."
      },
      rollback: { strategy: "rerun miya_self_approve before side-effect actions" }
    });
    return { status: "deny", reason: "missing_evidence" };
  }
  writeSelfApprovalRecord(projectDir, {
    trace_id: token.trace_id,
    session_id: request.sessionID,
    request_hash: strictHash,
    action: `permission.asked:${request.permission}`,
    tier: requiredTier,
    status: "allow",
    reason: "token_validated",
    checks: ["approval token"],
    evidence: [
      `token_hash=${token.request_hash}`,
      `token_tier=${token.tier}`,
      `token_created_at=${token.created_at}`,
      `token_expires_at=${token.expires_at}`
    ],
    executor: {
      agent: "executor",
      plan: "execute side-effect action with validated token"
    },
    verifier: {
      agent: "architect-verifier",
      verdict: "allow",
      summary: "Token satisfied required tier and freshness constraints."
    },
    rollback: { strategy: "use git checkpoint and kill-switch if execution fails" }
  });
  return { status: "allow", reason: "token_validated" };
}
function getSafetySnapshot(projectDir) {
  return {
    kill: readKillSwitch(projectDir),
    recent: listRecentSelfApprovalRecords(projectDir, 5)
  };
}
function createSafetyTools(ctx) {
  const miya_self_approve = tool({
    description: "Run mandatory self-approval with evidence collection and verifier veto. Generates a short-lived approval token.",
    args: {
      permission: z5.string().describe("Permission key for the intended side-effect (edit/bash/external_directory)"),
      patterns: z5.array(z5.string()).optional().describe("Expected permission patterns to bind approval token"),
      tier: z5.enum(["LIGHT", "STANDARD", "THOROUGH"]).optional().describe("Requested verification tier"),
      action: z5.string().optional().describe("Human-readable action summary"),
      targets: z5.array(z5.string()).optional().describe("Target files/commands/endpoints"),
      rollback: z5.string().optional().describe("Rollback strategy summary")
    },
    async execute(args, toolContext) {
      const sessionID2 = toolContext && typeof toolContext === "object" && "sessionID" in toolContext ? String(toolContext.sessionID) : "main";
      const kill = readKillSwitch(ctx.directory);
      if (kill.active) {
        return `VERDICT=DENY
reason=kill_switch_active
trace_id=${kill.trace_id ?? "n/a"}`;
      }
      const request = {
        sessionID: sessionID2,
        permission: String(args.permission),
        patterns: Array.isArray(args.patterns) ? args.patterns.map(String) : []
      };
      const requestedTier = normalizeTier(
        typeof args.tier === "string" ? args.tier : void 0
      );
      const riskTier = requiredTierForRequest(request);
      const tier = maxTier(requestedTier, riskTier);
      const requestHash = buildRequestHash(request, false);
      const traceID = createTraceId();
      const action = [
        args.action ? String(args.action) : `${request.permission} side-effect`,
        Array.isArray(args.targets) && args.targets.length > 0 ? `(targets=${args.targets.join(", ")})` : ""
      ].filter(Boolean).join(" ");
      const evidence = await collectSafetyEvidence(ctx.directory, tier);
      const verifier = await runVerifier(ctx, {
        sessionID: sessionID2,
        traceID,
        requestHash,
        tier,
        action,
        checks: evidence.checks,
        evidence: evidence.evidence,
        issues: evidence.issues
      });
      const allow = evidence.pass && verifier.verdict === "allow";
      const reason = allow ? verifier.summary : evidence.issues.length > 0 ? evidence.issues.join(" | ") : verifier.summary;
      writeSelfApprovalRecord(ctx.directory, {
        trace_id: traceID,
        session_id: sessionID2,
        request_hash: requestHash,
        action,
        tier,
        status: allow ? "allow" : "deny",
        reason,
        checks: evidence.checks,
        evidence: evidence.evidence.slice(0, 40),
        executor: {
          agent: "executor",
          plan: action
        },
        verifier: {
          agent: "4-architecture-advisor",
          verdict: allow ? "allow" : "deny",
          summary: verifier.summary
        },
        rollback: {
          strategy: args.rollback && String(args.rollback).trim().length > 0 ? String(args.rollback) : "Revert via git checkpoint and keep kill switch active until fixed."
        }
      });
      if (!allow) {
        activateKillSwitch(ctx.directory, `self_approval_denied:${reason}`, traceID);
      } else {
        saveApprovalToken(ctx.directory, sessionID2, {
          trace_id: traceID,
          request_hash: requestHash,
          tier,
          action
        });
      }
      return formatResult({
        verdict: allow ? "allow" : "deny",
        traceID,
        requestHash,
        tier,
        reason,
        checks: evidence.checks,
        issues: evidence.issues
      });
    }
  });
  const miya_kill_activate = tool({
    description: "Activate fail-stop kill switch for all side-effect permissions.",
    args: {
      reason: z5.string().optional().describe("Reason for emergency stop")
    },
    async execute(args) {
      const traceID = createTraceId();
      const next = activateKillSwitch(
        ctx.directory,
        String(args.reason ?? "manual_activation"),
        traceID
      );
      return `kill_switch_active=${next.active}
trace_id=${traceID}
reason=${next.reason ?? "n/a"}
activated_at=${next.activated_at ?? nowIso31()}`;
    }
  });
  const miya_kill_release = tool({
    description: "Release fail-stop kill switch after remediation.",
    args: {},
    async execute() {
      const next = releaseKillSwitch(ctx.directory);
      return `kill_switch_active=${next.active}`;
    }
  });
  const miya_kill_status = tool({
    description: "Inspect current kill-switch status.",
    args: {},
    async execute() {
      const kill = readKillSwitch(ctx.directory);
      return [
        `kill_switch_active=${kill.active}`,
        `trace_id=${kill.trace_id ?? "n/a"}`,
        `reason=${kill.reason ?? "n/a"}`,
        `activated_at=${kill.activated_at ?? "n/a"}`
      ].join("\n");
    }
  });
  return {
    miya_self_approve,
    miya_kill_activate,
    miya_kill_release,
    miya_kill_status
  };
}

// src/tools/ast-grep/cli.ts
import { existsSync as existsSync46 } from "node:fs";

// src/tools/ast-grep/constants.ts
import { existsSync as existsSync45, statSync as statSync2 } from "node:fs";
import { createRequire as createRequire3 } from "node:module";
import { dirname as dirname34, join as join49 } from "node:path";

// src/tools/ast-grep/downloader.ts
import { chmodSync, existsSync as existsSync44, mkdirSync as mkdirSync40, promises as fsPromises, unlinkSync as unlinkSync3 } from "node:fs";
import { createRequire as createRequire2 } from "node:module";
import { homedir as homedir6 } from "node:os";
import { join as join48 } from "node:path";
var REPO = "ast-grep/ast-grep";
var DEFAULT_VERSION = "0.40.0";
function getAstGrepVersion() {
  try {
    const require3 = createRequire2(import.meta.url);
    const pkg = require3("@ast-grep/cli/package.json");
    return pkg.version;
  } catch {
    return DEFAULT_VERSION;
  }
}
var PLATFORM_MAP = {
  "darwin-arm64": { arch: "aarch64", os: "apple-darwin" },
  "darwin-x64": { arch: "x86_64", os: "apple-darwin" },
  "linux-arm64": { arch: "aarch64", os: "unknown-linux-gnu" },
  "linux-x64": { arch: "x86_64", os: "unknown-linux-gnu" },
  "win32-x64": { arch: "x86_64", os: "pc-windows-msvc" },
  "win32-arm64": { arch: "aarch64", os: "pc-windows-msvc" },
  "win32-ia32": { arch: "i686", os: "pc-windows-msvc" }
};
function getCacheDir() {
  if (process.platform === "win32") {
    const localAppData = process.env.LOCALAPPDATA || process.env.APPDATA;
    const base2 = localAppData || join48(homedir6(), "AppData", "Local");
    return join48(base2, "miya", "bin");
  }
  const xdgCache = process.env.XDG_CACHE_HOME;
  const base = xdgCache || join48(homedir6(), ".cache");
  return join48(base, "miya", "bin");
}
function getBinaryName() {
  return process.platform === "win32" ? "sg.exe" : "sg";
}
function getCachedBinaryPath() {
  const binaryPath = join48(getCacheDir(), getBinaryName());
  return existsSync44(binaryPath) ? binaryPath : null;
}
async function downloadAstGrep(version3 = DEFAULT_VERSION) {
  const platformKey = `${process.platform}-${process.arch}`;
  const platformInfo = PLATFORM_MAP[platformKey];
  if (!platformInfo) {
    console.error(
      `[miya] Unsupported platform for ast-grep: ${platformKey}`
    );
    return null;
  }
  const cacheDir = getCacheDir();
  const binaryName = getBinaryName();
  const binaryPath = join48(cacheDir, binaryName);
  if (existsSync44(binaryPath)) {
    return binaryPath;
  }
  const { arch, os: os8 } = platformInfo;
  const assetName = `app-${arch}-${os8}.zip`;
  const downloadUrl = `https://github.com/${REPO}/releases/download/${version3}/${assetName}`;
  console.log("[miya] Downloading ast-grep binary...");
  try {
    if (!existsSync44(cacheDir)) {
      mkdirSync40(cacheDir, { recursive: true });
    }
    const response = await fetch(downloadUrl, { redirect: "follow" });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const archivePath = join48(cacheDir, assetName);
    const arrayBuffer = await response.arrayBuffer();
    await fsPromises.writeFile(archivePath, Buffer.from(arrayBuffer));
    await extractZip(archivePath, cacheDir);
    if (existsSync44(archivePath)) {
      unlinkSync3(archivePath);
    }
    if (process.platform !== "win32" && existsSync44(binaryPath)) {
      chmodSync(binaryPath, 493);
    }
    console.log("[miya] ast-grep binary ready.");
    return binaryPath;
  } catch (err) {
    console.error(
      `[miya] Failed to download ast-grep: ${err instanceof Error ? err.message : err}`
    );
    return null;
  }
}
async function ensureAstGrepBinary() {
  const cachedPath = getCachedBinaryPath();
  if (cachedPath) {
    return cachedPath;
  }
  const version3 = getAstGrepVersion();
  return downloadAstGrep(version3);
}

// src/tools/ast-grep/types.ts
var CLI_LANGUAGES = [
  "bash",
  "c",
  "cpp",
  "csharp",
  "css",
  "elixir",
  "go",
  "haskell",
  "html",
  "java",
  "javascript",
  "json",
  "kotlin",
  "lua",
  "nix",
  "php",
  "python",
  "ruby",
  "rust",
  "scala",
  "solidity",
  "swift",
  "typescript",
  "tsx",
  "yaml"
];

// src/tools/ast-grep/constants.ts
var MIN_BINARY_SIZE = 1e4;
function isValidBinary(filePath14) {
  try {
    return statSync2(filePath14).size > MIN_BINARY_SIZE;
  } catch {
    return false;
  }
}
function getPlatformPackageName() {
  const platform = process.platform;
  const arch = process.arch;
  const platformMap = {
    "darwin-arm64": "@ast-grep/cli-darwin-arm64",
    "darwin-x64": "@ast-grep/cli-darwin-x64",
    "linux-arm64": "@ast-grep/cli-linux-arm64-gnu",
    "linux-x64": "@ast-grep/cli-linux-x64-gnu",
    "win32-x64": "@ast-grep/cli-win32-x64-msvc",
    "win32-arm64": "@ast-grep/cli-win32-arm64-msvc",
    "win32-ia32": "@ast-grep/cli-win32-ia32-msvc"
  };
  return platformMap[`${platform}-${arch}`] ?? null;
}
var resolvedCliPath = null;
function findSgCliPathSync() {
  const binaryName = process.platform === "win32" ? "sg.exe" : "sg";
  const cachedPath = getCachedBinaryPath();
  if (cachedPath && isValidBinary(cachedPath)) {
    return cachedPath;
  }
  try {
    const require3 = createRequire3(import.meta.url);
    const cliPkgPath = require3.resolve("@ast-grep/cli/package.json");
    const cliDir = dirname34(cliPkgPath);
    const sgPath = join49(cliDir, binaryName);
    if (existsSync45(sgPath) && isValidBinary(sgPath)) {
      return sgPath;
    }
  } catch {
  }
  const platformPkg = getPlatformPackageName();
  if (platformPkg) {
    try {
      const require3 = createRequire3(import.meta.url);
      const pkgPath = require3.resolve(`${platformPkg}/package.json`);
      const pkgDir = dirname34(pkgPath);
      const astGrepName = process.platform === "win32" ? "ast-grep.exe" : "ast-grep";
      const binaryPath = join49(pkgDir, astGrepName);
      if (existsSync45(binaryPath) && isValidBinary(binaryPath)) {
        return binaryPath;
      }
    } catch {
    }
  }
  if (process.platform === "darwin") {
    const homebrewPaths = ["/opt/homebrew/bin/sg", "/usr/local/bin/sg"];
    for (const path52 of homebrewPaths) {
      if (existsSync45(path52) && isValidBinary(path52)) {
        return path52;
      }
    }
  }
  return null;
}
function getSgCliPath() {
  if (resolvedCliPath !== null) {
    return resolvedCliPath;
  }
  const syncPath = findSgCliPathSync();
  if (syncPath) {
    resolvedCliPath = syncPath;
    return syncPath;
  }
  return "sg";
}
function setSgCliPath(path52) {
  resolvedCliPath = path52;
}
var DEFAULT_TIMEOUT_MS3 = 3e5;
var DEFAULT_MAX_OUTPUT_BYTES = 1 * 1024 * 1024;
var DEFAULT_MAX_MATCHES = 500;

// src/tools/ast-grep/cli.ts
var initPromise = null;
async function getAstGrepPath() {
  const currentPath = getSgCliPath();
  if (currentPath !== "sg" && existsSync46(currentPath)) {
    return currentPath;
  }
  if (initPromise) {
    return initPromise;
  }
  initPromise = (async () => {
    const syncPath = findSgCliPathSync();
    if (syncPath && existsSync46(syncPath)) {
      setSgCliPath(syncPath);
      return syncPath;
    }
    const downloadedPath = await ensureAstGrepBinary();
    if (downloadedPath) {
      setSgCliPath(downloadedPath);
      return downloadedPath;
    }
    return null;
  })();
  return initPromise;
}
async function runSg(options) {
  const args = [
    "run",
    "-p",
    options.pattern,
    "--lang",
    options.lang,
    "--json=compact"
  ];
  if (options.rewrite) {
    args.push("-r", options.rewrite);
    if (options.updateAll) {
      args.push("--update-all");
    }
  }
  if (options.context && options.context > 0) {
    args.push("-C", String(options.context));
  }
  if (options.globs) {
    for (const glob of options.globs) {
      args.push("--globs", glob);
    }
  }
  const paths = options.paths && options.paths.length > 0 ? options.paths : ["."];
  args.push(...paths);
  let cliPath = getSgCliPath();
  if (!existsSync46(cliPath) && cliPath !== "sg") {
    const downloadedPath = await getAstGrepPath();
    if (downloadedPath) {
      cliPath = downloadedPath;
    }
  }
  const timeout = DEFAULT_TIMEOUT_MS3;
  let stdout;
  let stderr;
  let exitCode;
  try {
    const result = await runProcess(cliPath, args, { timeoutMs: timeout });
    if (result.timedOut) {
      throw new Error(`Search timeout after ${timeout}ms`);
    }
    stdout = result.stdout;
    stderr = result.stderr;
    exitCode = result.exitCode;
  } catch (e) {
    const error92 = e;
    if (error92.message?.includes("timeout")) {
      return {
        matches: [],
        totalMatches: 0,
        truncated: true,
        truncatedReason: "timeout",
        error: error92.message
      };
    }
    const nodeError = e;
    if (nodeError.code === "ENOENT" || nodeError.message?.includes("ENOENT") || nodeError.message?.includes("not found")) {
      const downloadedPath = await ensureAstGrepBinary();
      if (downloadedPath) {
        setSgCliPath(downloadedPath);
        return runSg(options);
      } else {
        return {
          matches: [],
          totalMatches: 0,
          truncated: false,
          error: `ast-grep CLI binary not found.

Auto-download failed. Manual install options:
  npm install -D @ast-grep/cli
  cargo install ast-grep --locked
  brew install ast-grep`
        };
      }
    }
    return {
      matches: [],
      totalMatches: 0,
      truncated: false,
      error: `Failed to spawn ast-grep: ${error92.message}`
    };
  }
  if (exitCode !== 0 && stdout.trim() === "") {
    if (stderr.includes("No files found")) {
      return { matches: [], totalMatches: 0, truncated: false };
    }
    if (stderr.trim()) {
      return {
        matches: [],
        totalMatches: 0,
        truncated: false,
        error: stderr.trim()
      };
    }
    return { matches: [], totalMatches: 0, truncated: false };
  }
  if (!stdout.trim()) {
    return { matches: [], totalMatches: 0, truncated: false };
  }
  const outputTruncated = stdout.length >= DEFAULT_MAX_OUTPUT_BYTES;
  const outputToProcess = outputTruncated ? stdout.substring(0, DEFAULT_MAX_OUTPUT_BYTES) : stdout;
  let matches = [];
  try {
    matches = JSON.parse(outputToProcess);
  } catch {
    if (outputTruncated) {
      try {
        const lastValidIndex = outputToProcess.lastIndexOf("}");
        if (lastValidIndex > 0) {
          const bracketIndex = outputToProcess.lastIndexOf(
            "},",
            lastValidIndex
          );
          if (bracketIndex > 0) {
            const truncatedJson = `${outputToProcess.substring(0, bracketIndex + 1)}]`;
            matches = JSON.parse(truncatedJson);
          }
        }
      } catch {
        return {
          matches: [],
          totalMatches: 0,
          truncated: true,
          truncatedReason: "max_output_bytes",
          error: "Output too large and could not be parsed"
        };
      }
    } else {
      return { matches: [], totalMatches: 0, truncated: false };
    }
  }
  const totalMatches = matches.length;
  const matchesTruncated = totalMatches > DEFAULT_MAX_MATCHES;
  const finalMatches = matchesTruncated ? matches.slice(0, DEFAULT_MAX_MATCHES) : matches;
  return {
    matches: finalMatches,
    totalMatches,
    truncated: outputTruncated || matchesTruncated,
    truncatedReason: outputTruncated ? "max_output_bytes" : matchesTruncated ? "max_matches" : void 0
  };
}

// src/tools/ast-grep/utils.ts
function formatSearchResult(result) {
  if (result.error) {
    return `Error: ${result.error}`;
  }
  if (result.matches.length === 0) {
    return "No matches found.";
  }
  const lines = [];
  const byFile = /* @__PURE__ */ new Map();
  for (const match of result.matches) {
    const existing = byFile.get(match.file) || [];
    existing.push(match);
    byFile.set(match.file, existing);
  }
  for (const [file3, matches] of byFile) {
    lines.push(`
${file3}:`);
    for (const match of matches) {
      const startLine = match.range.start.line + 1;
      const text = match.text.length > 100 ? `${match.text.substring(0, 100)}...` : match.text;
      lines.push(`  ${startLine}: ${text.replace(/\n/g, "\\n")}`);
    }
  }
  const fileCount = byFile.size;
  const summary = `Found ${result.totalMatches} matches in ${fileCount} files`;
  if (result.truncated) {
    lines.push(`
${summary} (output truncated: ${result.truncatedReason})`);
  } else {
    lines.push(`
${summary}`);
  }
  return lines.join("\n");
}
function formatReplaceResult(result, isDryRun) {
  if (result.error) {
    return `Error: ${result.error}`;
  }
  if (result.matches.length === 0) {
    return "No matches found for replacement.";
  }
  const lines = [];
  const mode = isDryRun ? "[DRY RUN]" : "[APPLIED]";
  const byFile = /* @__PURE__ */ new Map();
  for (const match of result.matches) {
    const existing = byFile.get(match.file) || [];
    existing.push(match);
    byFile.set(match.file, existing);
  }
  for (const [file3, matches] of byFile) {
    lines.push(`
${file3}:`);
    for (const match of matches) {
      const startLine = match.range.start.line + 1;
      const original = match.text.length > 60 ? `${match.text.substring(0, 60)}...` : match.text;
      const replacement = match.replacement ? match.replacement.length > 60 ? `${match.replacement.substring(0, 60)}...` : match.replacement : "[no replacement]";
      lines.push(
        `  ${startLine}: "${original.replace(/\n/g, "\\n")}" \u2192 "${replacement.replace(/\n/g, "\\n")}"`
      );
    }
  }
  const fileCount = byFile.size;
  lines.push(
    `
${mode} ${result.totalMatches} replacements in ${fileCount} files`
  );
  if (isDryRun) {
    lines.push("\nTo apply changes, run with dryRun=false");
  }
  return lines.join("\n");
}
function getEmptyResultHint(pattern, lang) {
  const src = pattern.trim();
  if (lang === "python") {
    if (src.startsWith("class ") && src.endsWith(":")) {
      const withoutColon = src.slice(0, -1);
      return `Hint: Remove trailing colon. Try: "${withoutColon}"`;
    }
    if ((src.startsWith("def ") || src.startsWith("async def ")) && src.endsWith(":")) {
      const withoutColon = src.slice(0, -1);
      return `Hint: Remove trailing colon. Try: "${withoutColon}"`;
    }
  }
  if (["javascript", "typescript", "tsx"].includes(lang)) {
    if (/^(export\s+)?(async\s+)?function\s+\$[A-Z_]+\s*$/i.test(src)) {
      return `Hint: Function patterns need params and body. Try "function $NAME($$$) { $$$ }"`;
    }
  }
  return null;
}

// src/tools/ast-grep/tools.ts
function showOutputToUser(context, output) {
  const ctx = context;
  ctx.metadata?.({ metadata: { output } });
}
var ast_grep_search = tool({
  description: "Search code patterns across filesystem using AST-aware matching. Supports 25 languages. Use meta-variables: $VAR (single node), $$$ (multiple nodes). IMPORTANT: Patterns must be complete AST nodes (valid code). For functions, include params and body: 'export async function $NAME($$$) { $$$ }' not 'export async function $NAME'. Examples: 'console.log($MSG)', 'def $FUNC($$$):', 'async function $NAME($$$)'",
  args: {
    pattern: tool.schema.string().describe(
      "AST pattern with meta-variables ($VAR, $$$). Must be complete AST node."
    ),
    lang: tool.schema.enum(CLI_LANGUAGES).describe("Target language"),
    paths: tool.schema.array(tool.schema.string()).optional().describe("Paths to search (default: ['.'])"),
    globs: tool.schema.array(tool.schema.string()).optional().describe("Include/exclude globs (prefix ! to exclude)"),
    context: tool.schema.number().optional().describe("Context lines around match")
  },
  execute: async (args, context) => {
    try {
      const result = await runSg({
        pattern: args.pattern,
        lang: args.lang,
        paths: args.paths,
        globs: args.globs,
        context: args.context
      });
      let output = formatSearchResult(result);
      if (result.matches.length === 0 && !result.error) {
        const hint = getEmptyResultHint(args.pattern, args.lang);
        if (hint) {
          output += `

${hint}`;
        }
      }
      showOutputToUser(context, output);
      return output;
    } catch (e) {
      const output = `Error: ${e instanceof Error ? e.message : String(e)}`;
      showOutputToUser(context, output);
      return output;
    }
  }
});
var ast_grep_replace = tool({
  description: "Replace code patterns across filesystem with AST-aware rewriting. Dry-run by default. Use meta-variables in rewrite to preserve matched content. Example: pattern='console.log($MSG)' rewrite='logger.info($MSG)'",
  args: {
    pattern: tool.schema.string().describe("AST pattern to match"),
    rewrite: tool.schema.string().describe("Replacement pattern (can use $VAR from pattern)"),
    lang: tool.schema.enum(CLI_LANGUAGES).describe("Target language"),
    paths: tool.schema.array(tool.schema.string()).optional().describe("Paths to search"),
    globs: tool.schema.array(tool.schema.string()).optional().describe("Include/exclude globs"),
    dryRun: tool.schema.boolean().optional().describe("Preview changes without applying (default: true)")
  },
  execute: async (args, context) => {
    try {
      const result = await runSg({
        pattern: args.pattern,
        rewrite: args.rewrite,
        lang: args.lang,
        paths: args.paths,
        globs: args.globs,
        updateAll: args.dryRun === false
      });
      const output = formatReplaceResult(result, args.dryRun !== false);
      showOutputToUser(context, output);
      return output;
    } catch (e) {
      const output = `Error: ${e instanceof Error ? e.message : String(e)}`;
      showOutputToUser(context, output);
      return output;
    }
  }
});

// src/tools/background.ts
var z6 = tool.schema;
function createBackgroundTools(_ctx, manager, _tmuxConfig, _pluginConfig) {
  const agentNames = SUBAGENT_NAMES.join(", ");
  const background_task = tool({
    description: `Launch background agent task. Returns task_id immediately.

Flow: launch \u2192 wait for automatic notification when complete.

Key behaviors:
- Fire-and-forget: returns task_id in ~1ms
- Parallel: up to 10 concurrent tasks
- Auto-notify: parent session receives result when task completes`,
    args: {
      description: z6.string().describe("Short description of the task (5-10 words)"),
      prompt: z6.string().describe("The task prompt for the agent"),
      agent: z6.string().describe(`Agent to use: ${agentNames}`)
    },
    async execute(args, toolContext) {
      if (!toolContext || typeof toolContext !== "object" || !("sessionID" in toolContext)) {
        throw new Error("Invalid toolContext: missing sessionID");
      }
      const agent = String(args.agent);
      const prompt = String(args.prompt);
      const description = String(args.description);
      const parentSessionId = toolContext.sessionID;
      if (!manager.isAgentAllowed(parentSessionId, agent)) {
        const allowed = manager.getAllowedSubagents(parentSessionId);
        return `Agent '${agent}' is not allowed. Allowed agents: ${allowed.join(", ")}`;
      }
      const task = manager.launch({
        agent,
        prompt,
        description,
        parentSessionId
      });
      return `Background task launched.

Task ID: ${task.id}
Agent: ${agent}
Status: ${task.status}

Use \`background_output\` with task_id="${task.id}" to get results.`;
    }
  });
  const background_output = tool({
    description: `Get background task results after completion notification received.

timeout=0: returns status immediately (no wait)
timeout=N: waits up to N ms for completion

Returns: results if completed, error if failed, status if running.`,
    args: {
      task_id: z6.string().describe("Task ID from background_task"),
      timeout: z6.number().optional().describe("Wait for completion (in ms, 0=no wait, default: 0)")
    },
    async execute(args) {
      const taskId = String(args.task_id);
      const timeout = typeof args.timeout === "number" && args.timeout > 0 ? args.timeout : 0;
      let task = manager.getResult(taskId);
      if (task && timeout > 0 && task.status !== "completed" && task.status !== "failed" && task.status !== "cancelled") {
        task = await manager.waitForCompletion(taskId, timeout);
      }
      if (!task) {
        return `Task not found: ${taskId}`;
      }
      const duration5 = task.completedAt ? `${Math.floor((task.completedAt.getTime() - task.startedAt.getTime()) / 1e3)}s` : `${Math.floor((Date.now() - task.startedAt.getTime()) / 1e3)}s`;
      let output = `Task: ${task.id}
 Description: ${task.description}
 Status: ${task.status}
 Duration: ${duration5}

 ---

 `;
      if (task.status === "completed" && task.result != null) {
        output += task.result;
      } else if (task.status === "failed") {
        output += `Error: ${task.error}`;
      } else if (task.status === "cancelled") {
        output += "(Task cancelled)";
      } else {
        output += "(Task still running)";
      }
      return output;
    }
  });
  const background_cancel = tool({
    description: `Cancel background task(s).

task_id: cancel specific task
all=true: cancel all running tasks

Only cancels pending/starting/running tasks.`,
    args: {
      task_id: z6.string().optional().describe("Specific task to cancel"),
      all: z6.boolean().optional().describe("Cancel all running tasks")
    },
    async execute(args) {
      if (args.all === true) {
        const count = manager.cancel();
        return `Cancelled ${count} task(s).`;
      }
      if (typeof args.task_id === "string") {
        const count = manager.cancel(args.task_id);
        return count > 0 ? `Cancelled task ${args.task_id}.` : `Task ${args.task_id} not found or not running.`;
      }
      return "Specify task_id or use all=true.";
    }
  });
  return { background_task, background_output, background_cancel };
}

// src/node/service.ts
var NodeService = class {
  projectDir;
  constructor(projectDir) {
    this.projectDir = projectDir;
  }
  register(input) {
    return registerNode(this.projectDir, input);
  }
  touchHeartbeat(nodeID) {
    return touchNodeHeartbeat(this.projectDir, nodeID);
  }
  disconnect(nodeID) {
    markNodeDisconnected(this.projectDir, nodeID);
  }
  list() {
    return listNodes(this.projectDir);
  }
  listDevices() {
    return listDevices(this.projectDir);
  }
  describe(nodeID) {
    return describeNode(this.projectDir, nodeID);
  }
  issueToken(nodeID) {
    return issueNodeToken(this.projectDir, nodeID);
  }
  createPairRequest(input) {
    return createNodePairRequest(this.projectDir, input);
  }
  listPairRequests(status) {
    return listNodePairs(this.projectDir, status);
  }
  resolvePairRequest(pairID, status) {
    return resolveNodePair(this.projectDir, pairID, status);
  }
  createInvoke(input) {
    return createInvokeRequest(this.projectDir, input);
  }
  markInvokeSent(invokeID) {
    return markInvokeSent(this.projectDir, invokeID);
  }
  resolveInvoke(invokeID, input) {
    return resolveInvokeResult(this.projectDir, invokeID, input);
  }
  listInvokes(limit = 50) {
    return listInvokeRequests(this.projectDir, limit);
  }
};

// src/node/index.ts
var nodeServices = /* @__PURE__ */ new Map();
function getNodeService(projectDir) {
  const existing = nodeServices.get(projectDir);
  if (existing) return existing;
  const created = new NodeService(projectDir);
  nodeServices.set(projectDir, created);
  return created;
}

// src/tools/nodes.ts
var z7 = tool.schema;
function createNodeTools(projectDir) {
  const nodeService = getNodeService(projectDir);
  const miya_node_register = tool({
    description: "Register or update a Miya node record.",
    args: {
      node_id: z7.string().describe("Node identifier"),
      device_id: z7.string().describe("Device identifier"),
      platform: z7.string().optional().describe("Platform name"),
      type: z7.enum(["cli", "desktop", "mobile", "browser"]).optional().describe("Node runtime type"),
      capabilities: z7.array(z7.string()).optional().describe("Capability list exposed by this node"),
      token: z7.string().optional().describe("Optional node token for registration"),
      permissions: z7.object({
        screenRecording: z7.boolean().optional(),
        accessibility: z7.boolean().optional(),
        filesystem: z7.enum(["none", "read", "full"]).optional(),
        network: z7.boolean().optional()
      }).optional().describe("Permission mapping metadata")
    },
    async execute(args) {
      const capabilities = Array.isArray(args.capabilities) ? args.capabilities.map(String) : [];
      if (args.permissions && typeof args.permissions === "object") {
        const p = args.permissions;
        if (p.screenRecording) capabilities.push("perm.screenRecording");
        if (p.accessibility) capabilities.push("perm.accessibility");
        if (p.network) capabilities.push("perm.network");
        if (p.filesystem) capabilities.push(`perm.filesystem.${p.filesystem}`);
      }
      const node = nodeService.register({
        nodeID: String(args.node_id),
        deviceID: String(args.device_id),
        type: args.type,
        platform: args.platform ? String(args.platform) : process.platform,
        capabilities: [...new Set(capabilities)],
        token: args.token ? String(args.token) : void 0,
        permissions: args.permissions && typeof args.permissions === "object" ? args.permissions : void 0
      });
      return [
        `node_id=${node.nodeID}`,
        `device_id=${node.deviceID}`,
        `type=${node.type}`,
        `platform=${node.platform}`,
        `status=${node.status}`,
        `connected=${node.connected}`,
        `paired=${node.paired}`,
        `permissions=${JSON.stringify(node.permissions)}`,
        `last_heartbeat=${node.lastHeartbeatAt}`,
        `capabilities=${node.capabilities.join(",")}`
      ].join("\n");
    }
  });
  const miya_node_status = tool({
    description: "Show node status summary, or details for a specific node id when provided.",
    args: {
      node_id: z7.string().optional().describe("Optional node identifier")
    },
    async execute(args) {
      const nodeID = args.node_id ? String(args.node_id) : "";
      if (nodeID) {
        const node = nodeService.describe(nodeID);
        if (!node) return `node_not_found=${nodeID}`;
        return [
          `node_id=${node.nodeID}`,
          `device_id=${node.deviceID}`,
          `type=${node.type}`,
          `status=${node.status}`,
          `connected=${node.connected}`,
          `paired=${node.paired}`,
          `permissions=${JSON.stringify(node.permissions)}`,
          `last_heartbeat=${node.lastHeartbeatAt}`,
          `last_seen=${node.lastSeenAt}`,
          `capabilities=${node.capabilities.join(",")}`
        ].join("\n");
      }
      const nodes = nodeService.list();
      const pending = nodeService.listPairRequests("pending").length;
      return [
        `nodes_total=${nodes.length}`,
        `nodes_connected=${nodes.filter((item) => item.connected).length}`,
        `nodes_online=${nodes.filter((item) => item.status === "online").length}`,
        `nodes_paired=${nodes.filter((item) => item.paired).length}`,
        `nodes_pending_pairs=${pending}`
      ].join("\n");
    }
  });
  const miya_node_heartbeat = tool({
    description: "Update node heartbeat timestamp and mark it online.",
    args: {
      node_id: z7.string().describe("Node identifier")
    },
    async execute(args) {
      const nodeID = String(args.node_id);
      const node = nodeService.touchHeartbeat(nodeID);
      if (!node) return `node_not_found=${nodeID}`;
      return [
        `node_id=${node.nodeID}`,
        `status=${node.status}`,
        `last_heartbeat=${node.lastHeartbeatAt}`
      ].join("\n");
    }
  });
  const miya_node_issue_token = tool({
    description: "Issue or rotate node token for a node. Return token once; store hash only.",
    args: {
      node_id: z7.string().describe("Node identifier")
    },
    async execute(args) {
      const nodeID = String(args.node_id);
      const issued = nodeService.issueToken(nodeID);
      if (!issued) return `node_not_found=${nodeID}`;
      return [
        `node_id=${issued.nodeID}`,
        `token=${issued.token}`,
        `issued_at=${issued.issuedAt}`
      ].join("\n");
    }
  });
  return {
    miya_node_register,
    miya_node_status,
    miya_node_heartbeat,
    miya_node_issue_token
  };
}

// src/ralph/error-analyzer.ts
function analyzeFailure(output) {
  const text = output.toLowerCase();
  if (text.includes("cannot find module") || text.includes("module not found") || text.includes("command not found") || text.includes("is not recognized as an internal or external command")) {
    return {
      kind: "dependency_missing",
      summary: "Dependencies or required binaries are missing.",
      suggestedFixes: ["npm install", "check PATH and tool installation"]
    };
  }
  if (text.includes("ts2339") || text.includes("type error") || text.includes("typescript")) {
    return {
      kind: "type_error",
      summary: "Type checking failed.",
      suggestedFixes: ["fix reported TypeScript diagnostics", "run npm run typecheck"]
    };
  }
  if (text.includes("eslint") || text.includes("biome") || text.includes("lint")) {
    return {
      kind: "lint_error",
      summary: "Lint checks failed.",
      suggestedFixes: ["run npm run lint", "apply formatter and lint fixes"]
    };
  }
  if (text.includes("test failed") || text.includes("failing") || text.includes("assert") || text.includes("expect(")) {
    return {
      kind: "test_failure",
      summary: "Verification tests failed.",
      suggestedFixes: ["inspect failing test output", "fix logic and rerun tests"]
    };
  }
  if (text.includes("permission denied") || text.includes("eacces")) {
    return {
      kind: "permission_denied",
      summary: "Execution failed due to permission restrictions.",
      suggestedFixes: ["adjust permissions", "run in allowed directory/context"]
    };
  }
  if (text.includes("timed out") || text.includes("timeout")) {
    return {
      kind: "timeout",
      summary: "Command hit timeout before completion.",
      suggestedFixes: ["increase timeout", "split the task into smaller steps"]
    };
  }
  return {
    kind: "unknown",
    summary: "Verification failed with an unclassified error.",
    suggestedFixes: ["inspect stdout/stderr and add a targeted fix command"]
  };
}

// src/ralph/loop.ts
import { createHash as createHash16 } from "node:crypto";
function hashText4(input) {
  return createHash16("sha256").update(input).digest("hex").slice(0, 16);
}
function normalize2(text) {
  return text.replace(/\s+/g, " ").trim().toLowerCase();
}
function levenshteinDistance(a, b) {
  if (a === b) return 0;
  const m = a.length;
  const n = b.length;
  if (m === 0) return n;
  if (n === 0) return m;
  const dp = new Array(n + 1);
  for (let j = 0; j <= n; j += 1) dp[j] = j;
  for (let i = 1; i <= m; i += 1) {
    let prev = dp[0];
    dp[0] = i;
    for (let j = 1; j <= n; j += 1) {
      const temp = dp[j];
      const cost = a.charCodeAt(i - 1) === b.charCodeAt(j - 1) ? 0 : 1;
      dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
      prev = temp;
    }
  }
  return dp[n];
}
function similarity(a, b) {
  const left = normalize2(a);
  const right = normalize2(b);
  if (!left && !right) return 1;
  if (!left || !right) return 0;
  const maxLen = Math.max(left.length, right.length);
  if (maxLen === 0) return 1;
  return 1 - levenshteinDistance(left, right) / maxLen;
}
function parseChangedLineKeys(diffText) {
  const keys = [];
  const lines = diffText.split(/\r?\n/);
  let currentFile = "";
  for (const line of lines) {
    if (line.startsWith("+++ b/")) {
      currentFile = line.slice("+++ b/".length);
      continue;
    }
    if (!line.startsWith("@@") || !currentFile) continue;
    const match = /@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/.exec(line);
    if (!match) continue;
    const start = Number(match[1]);
    const count = Number(match[2] ?? "1");
    const end = start + Math.max(1, count) - 1;
    for (let lineNumber = start; lineNumber <= end; lineNumber += 1) {
      keys.push(`${currentFile}:${lineNumber}`);
    }
  }
  return keys;
}
function defaultReadDiff(cwd) {
  const proc = runProcessSync("git", ["diff", "--unified=0"], {
    cwd
  });
  if (proc.exitCode !== 0) return "";
  return proc.stdout;
}
function runCommand3(command, timeoutMs, cwd) {
  const start = Date.now();
  const shellArgs = process.platform === "win32" ? ["powershell", "-NoProfile", "-Command", command] : ["sh", "-lc", command];
  const proc = runProcessSync(shellArgs[0], shellArgs.slice(1), {
    cwd,
    timeout: Math.max(1e3, Math.min(timeoutMs, 10 * 60 * 1e3))
  });
  return {
    command,
    ok: proc.exitCode === 0 && !proc.timedOut,
    exitCode: proc.exitCode,
    stdout: proc.stdout,
    stderr: proc.stderr,
    durationMs: Date.now() - start
  };
}
function renderFixCommand(template, input) {
  const stderrTrimmed = input.stderr.trim();
  const stdoutTrimmed = input.stdout.trim();
  return template.replaceAll("{{ITERATION}}", String(input.iteration)).replaceAll("{{FAILURE_SUMMARY}}", input.failureSummary).replaceAll("{{LAST_STDERR}}", stderrTrimmed).replaceAll("{{LAST_STDOUT}}", stdoutTrimmed).replaceAll("{{LAST_ERROR}}", stderrTrimmed || stdoutTrimmed || input.failureSummary);
}
function pushAttempt(attempts, iteration, type, result) {
  const attempt = { iteration, type, result };
  attempts.push(attempt);
  return attempt;
}
function executeRalphLoop(input) {
  const attempts = [];
  const maxIterations = Math.max(1, Math.min(input.maxIterations, 30));
  const budgetMs = Math.max(2e3, Math.min(input.budgetMs ?? 5 * 60 * 1e3, 30 * 60 * 1e3));
  const stallWindow = Math.max(2, Math.min(input.stallWindow ?? 3, 10));
  const errorSimilarityThreshold = Math.max(
    0.5,
    Math.min(input.errorSimilarityThreshold ?? 0.9, 1)
  );
  const sameLineTouchLimit = Math.max(2, Math.min(input.sameLineTouchLimit ?? 5, 30));
  const run = input.runCommand ?? runCommand3;
  const readDiff = input.readDiff ?? defaultReadDiff;
  const fixQueue = [...input.fixCommands ?? []];
  const lineTouchCounts = /* @__PURE__ */ new Map();
  const fingerprints = /* @__PURE__ */ new Set();
  const recentVerifyAttempts = [];
  const startedAt = Date.now();
  let taskRan = false;
  let finalVerification;
  for (let iteration = 1; iteration <= maxIterations; iteration += 1) {
    if (Date.now() - startedAt > budgetMs) {
      return {
        success: false,
        iterations: iteration - 1,
        attempts,
        summary: `Loop stopped because time budget was exceeded (${budgetMs} ms).`,
        finalVerification,
        reason: "budget_exceeded"
      };
    }
    if (!taskRan && input.taskCommand) {
      const taskResult = run(input.taskCommand, input.timeoutMs, input.workingDirectory);
      pushAttempt(attempts, iteration, "task", taskResult);
      taskRan = true;
    }
    const verifyResult = run(
      input.verificationCommand,
      input.timeoutMs,
      input.workingDirectory
    );
    finalVerification = verifyResult;
    const verifyAttempt = pushAttempt(attempts, iteration, "verify", verifyResult);
    if (verifyResult.ok) {
      return {
        success: true,
        iterations: iteration,
        attempts,
        summary: `Verification passed at iteration ${iteration}.`,
        finalVerification,
        reason: "verified"
      };
    }
    const failure = analyzeFailure(`${verifyResult.stdout}
${verifyResult.stderr}`);
    verifyAttempt.failureKind = failure.kind;
    verifyAttempt.failureSummary = failure.summary;
    verifyAttempt.stderrHash = hashText4(verifyResult.stderr || verifyResult.stdout);
    const diffText = readDiff(input.workingDirectory);
    verifyAttempt.diffHash = hashText4(diffText);
    const fingerprint = hashText4(
      [
        verifyAttempt.stderrHash,
        verifyAttempt.diffHash,
        failure.kind
      ].join("|")
    );
    verifyAttempt.fingerprint = fingerprint;
    if (fingerprints.has(fingerprint)) {
      return {
        success: false,
        iterations: iteration,
        attempts,
        summary: `Loop cycle detected at iteration ${iteration}; fingerprint repeated.`,
        finalVerification,
        reason: "cycle_detected"
      };
    }
    fingerprints.add(fingerprint);
    const changedLineKeys = parseChangedLineKeys(diffText);
    let maxTouches = 0;
    for (const key of changedLineKeys) {
      const next = (lineTouchCounts.get(key) ?? 0) + 1;
      lineTouchCounts.set(key, next);
      if (next > maxTouches) maxTouches = next;
    }
    if (maxTouches >= sameLineTouchLimit) {
      return {
        success: false,
        iterations: iteration,
        attempts,
        summary: `Loop stopped due to same-line churn (>= ${sameLineTouchLimit}).`,
        finalVerification,
        reason: "same_line_churn"
      };
    }
    if (recentVerifyAttempts.length > 0) {
      const previous = recentVerifyAttempts[recentVerifyAttempts.length - 1];
      const score = similarity(
        `${previous.result.stdout}
${previous.result.stderr}`,
        `${verifyResult.stdout}
${verifyResult.stderr}`
      );
      verifyAttempt.errorSimilarity = score;
      const noProgress = score >= errorSimilarityThreshold && previous.failureKind === verifyAttempt.failureKind && previous.diffHash === verifyAttempt.diffHash;
      verifyAttempt.noProgress = noProgress;
    } else {
      verifyAttempt.errorSimilarity = 0;
      verifyAttempt.noProgress = false;
    }
    recentVerifyAttempts.push(verifyAttempt);
    if (recentVerifyAttempts.length > stallWindow) {
      recentVerifyAttempts.shift();
    }
    const stalled = recentVerifyAttempts.length >= stallWindow && recentVerifyAttempts.every((attempt) => attempt.noProgress);
    if (stalled) {
      return {
        success: false,
        iterations: iteration,
        attempts,
        summary: `Loop stalled: ${stallWindow} consecutive no-progress iterations.`,
        finalVerification,
        reason: "no_progress"
      };
    }
    const nextFixTemplate = fixQueue.shift();
    const nextFix = nextFixTemplate ? renderFixCommand(nextFixTemplate, {
      iteration,
      failureSummary: failure.summary,
      stderr: verifyResult.stderr,
      stdout: verifyResult.stdout
    }) : "";
    if (!nextFix) {
      return {
        success: false,
        iterations: iteration,
        attempts,
        summary: `Verification failed and no fix command remained. Last issue: ${failure.summary}`,
        finalVerification,
        reason: "no_fix_command"
      };
    }
    const fixResult = run(nextFix, input.timeoutMs, input.workingDirectory);
    pushAttempt(attempts, iteration, "fix", fixResult);
  }
  return {
    success: false,
    iterations: maxIterations,
    attempts,
    summary: "Verification did not pass before reaching max iterations.",
    finalVerification,
    reason: "max_iterations_reached"
  };
}

// src/tools/ralph.ts
var z8 = tool.schema;
function createRalphTools(projectDir) {
  const miya_ralph_loop = tool({
    description: "Execute a verification-driven self-correction loop with optional task and fix commands.",
    args: {
      task_description: z8.string().describe("Human-readable task objective"),
      verification_command: z8.string().describe("Command used to verify success"),
      max_iterations: z8.number().default(8),
      max_retries: z8.number().optional().describe("Alias of max_iterations for retry-oriented workflows"),
      timeout_ms: z8.number().default(6e4),
      budget_ms: z8.number().optional().describe("Total loop time budget. Stops once exceeded."),
      stall_window: z8.number().default(3).describe("Consecutive no-progress window before loop stops"),
      error_similarity_threshold: z8.number().default(0.9).describe("Error similarity threshold used by stall detection"),
      same_line_touch_limit: z8.number().default(5).describe("Stop when same line keeps churning above this limit"),
      task_command: z8.string().optional().describe("Optional command to execute the task before verification"),
      fix_commands: z8.array(z8.string()).optional().describe("Ordered fix commands executed when verification fails"),
      working_directory: z8.string().optional().describe("Optional command working directory")
    },
    async execute(args) {
      const result = executeRalphLoop({
        taskDescription: String(args.task_description),
        verificationCommand: String(args.verification_command),
        maxIterations: typeof args.max_retries === "number" ? Number(args.max_retries) : typeof args.max_iterations === "number" ? Number(args.max_iterations) : 8,
        timeoutMs: typeof args.timeout_ms === "number" ? Number(args.timeout_ms) : 6e4,
        budgetMs: typeof args.budget_ms === "number" ? Number(args.budget_ms) : void 0,
        stallWindow: typeof args.stall_window === "number" ? Number(args.stall_window) : void 0,
        errorSimilarityThreshold: typeof args.error_similarity_threshold === "number" ? Number(args.error_similarity_threshold) : void 0,
        sameLineTouchLimit: typeof args.same_line_touch_limit === "number" ? Number(args.same_line_touch_limit) : void 0,
        taskCommand: args.task_command ? String(args.task_command) : void 0,
        fixCommands: Array.isArray(args.fix_commands) ? args.fix_commands.map(String) : void 0,
        workingDirectory: args.working_directory ? String(args.working_directory) : void 0
      });
      const lines = [
        `task=${String(args.task_description)}`,
        `success=${result.success}`,
        `iterations=${result.iterations}`,
        `reason=${result.reason ?? "unknown"}`,
        `termination_reason=${result.reason ?? "unknown"}`,
        `summary=${result.summary}`
      ];
      if (projectDir) {
        const draft = createSkillDraftFromRalph(projectDir, {
          taskDescription: String(args.task_description),
          result
        });
        if (draft) {
          lines.push(`learning_draft_id=${draft.id}`);
          lines.push(`learning_draft_status=${draft.status}`);
          lines.push(`learning_draft_confidence=${draft.confidence.toFixed(2)}`);
        }
      }
      const tailAttempts = result.attempts.slice(-6);
      if (tailAttempts.length > 0) {
        lines.push("recent_attempts=");
        for (const attempt of tailAttempts) {
          lines.push(
            [
              `- #${attempt.iteration}`,
              attempt.type,
              `ok=${attempt.result.ok}`,
              `exit=${attempt.result.exitCode}`,
              attempt.noProgress ? "no_progress=true" : "",
              typeof attempt.errorSimilarity === "number" ? `error_similarity=${attempt.errorSimilarity.toFixed(3)}` : "",
              attempt.failureKind ? `failure=${attempt.failureKind}` : "",
              attempt.result.stderr.trim() ? `stderr=${attempt.result.stderr.trim().slice(0, 220).replace(/\s+/g, " ")}` : ""
            ].filter(Boolean).join(" | ")
          );
        }
        const latestVerify = [...tailAttempts].reverse().find((attempt) => attempt.type === "verify");
        if (latestVerify?.result.stderr?.trim()) {
          lines.push(
            `stderr_tail=${latestVerify.result.stderr.trim().slice(0, 300).replace(/\s+/g, " ")}`
          );
        }
      }
      return lines.join("\n");
    }
  });
  return {
    miya_ralph_loop
  };
}

// src/autopilot/planner.ts
function splitGoal(goal) {
  const chunks = goal.split(/[\n.;]+/g).map((item) => item.trim()).filter(Boolean);
  if (chunks.length > 0) return chunks;
  return [goal.trim()].filter(Boolean);
}
function createAutopilotPlan(goal) {
  const goalChunks = splitGoal(goal);
  const steps = goalChunks.map((title, index) => ({
    // Keep kind strongly typed for downstream step rendering.
    kind: index === goalChunks.length - 1 ? "execution" : "analysis",
    id: `step_${index + 1}`,
    title,
    done: false
  }));
  return {
    goal: goal.trim(),
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    steps
  };
}
function attachCommandSteps(plan, commands, verificationCommand) {
  const commandSteps = commands.map((command, index) => {
    const text = String(command).trim();
    if (!text) return null;
    return {
      id: `exec_${index + 1}`,
      title: `Execute command #${index + 1}`,
      kind: "execution",
      command: text,
      done: false
    };
  }).filter((item) => Boolean(item));
  const verificationStep = verificationCommand?.trim() ? [
    {
      id: "verify_1",
      title: "Verify execution result",
      kind: "verification",
      command: verificationCommand.trim(),
      done: false
    }
  ] : [];
  return {
    ...plan,
    steps: [...plan.steps, ...commandSteps, ...verificationStep]
  };
}

// src/autopilot/executor.ts
function configureAutopilotSession(input) {
  const state2 = getSessionState(input.projectDir, input.sessionID);
  state2.loopEnabled = input.enabled;
  if (typeof input.maxCycles === "number") {
    state2.maxIterationsPerWindow = Math.max(1, Math.min(20, Math.floor(input.maxCycles)));
  }
  if (typeof input.autoContinue === "boolean") {
    state2.autoContinue = input.autoContinue;
  }
  if (typeof input.strictQualityGate === "boolean") {
    state2.strictQualityGate = input.strictQualityGate;
  }
  setSessionState(input.projectDir, input.sessionID, state2);
  return state2;
}
function runCommand4(command, timeoutMs, cwd) {
  const start = Date.now();
  const shellArgs = process.platform === "win32" ? ["powershell", "-NoProfile", "-Command", command] : ["sh", "-lc", command];
  const proc = runProcessSync(shellArgs[0], shellArgs.slice(1), {
    cwd,
    timeout: Math.max(1e3, Math.min(timeoutMs, 10 * 60 * 1e3))
  });
  return {
    command,
    ok: proc.exitCode === 0 && !proc.timedOut,
    exitCode: proc.exitCode,
    stdout: proc.stdout,
    stderr: proc.stderr,
    durationMs: Date.now() - start
  };
}
function runAutopilot(input) {
  const basePlan = createAutopilotPlan(input.goal);
  const plan = attachCommandSteps(
    basePlan,
    input.commands,
    input.verificationCommand
  );
  const execution = [];
  for (const command of input.commands) {
    const cmd = String(command).trim();
    if (!cmd) continue;
    const result = runCommand4(cmd, input.timeoutMs, input.workingDirectory);
    execution.push(result);
    if (!result.ok) {
      return {
        success: false,
        summary: `Execution failed: ${cmd} (exit=${result.exitCode}).`,
        plan,
        execution
      };
    }
  }
  if (input.verificationCommand?.trim()) {
    const verification = runCommand4(
      input.verificationCommand.trim(),
      input.timeoutMs,
      input.workingDirectory
    );
    return {
      success: verification.ok,
      summary: verification.ok ? "Execution and verification completed successfully." : `Verification failed (exit=${verification.exitCode}).`,
      plan,
      execution,
      verification
    };
  }
  return {
    success: true,
    summary: "Execution completed without explicit verification command.",
    plan,
    execution
  };
}

// src/autopilot/verifier.ts
function summarizeAutopilotPlan(plan) {
  const steps = plan.steps.length === 0 ? "- (no parsed steps)" : plan.steps.map((step) => {
    const tail = step.command ? ` -> ${step.command}` : "";
    return `- ${step.id}: [${step.kind}] ${step.title}${tail}`;
  }).join("\n");
  return [`goal=${plan.goal}`, `steps=${plan.steps.length}`, steps].join("\n");
}
function summarizeVerification(result) {
  if (!result) return "verification=skipped";
  return [
    `verification_ok=${result.ok}`,
    `verification_exit=${result.exitCode}`,
    `verification_duration_ms=${result.durationMs}`
  ].join("\n");
}

// src/tools/autopilot.ts
var z9 = tool.schema;
function getSessionID(ctx) {
  if (ctx && typeof ctx === "object" && "sessionID" in ctx) {
    return String(ctx.sessionID ?? "main");
  }
  return "main";
}
function createAutopilotTools(projectDir) {
  const miya_autopilot = tool({
    description: "Configure and inspect autopilot loop settings, with lightweight plan generation from goal text.",
    args: {
      mode: z9.enum(["start", "stop", "status", "run"]).default("start").describe(
        "start to enable autopilot, stop to disable, status to inspect, run to execute commands end-to-end"
      ),
      goal: z9.string().optional().describe("Goal text used to build an execution plan when mode=start"),
      commands: z9.array(z9.string()).optional().describe("Commands executed in sequence when mode=run"),
      verification_command: z9.string().optional().describe("Optional verification command for mode=run"),
      timeout_ms: z9.number().optional().describe("Command timeout for mode=run"),
      working_directory: z9.string().optional().describe("Optional command working directory for mode=run"),
      session_id: z9.string().optional().describe("Target session id"),
      max_cycles: z9.number().optional().describe("Max autopilot cycles for the window"),
      auto_continue: z9.boolean().optional().describe("Whether loops auto-continue"),
      strict_quality_gate: z9.boolean().optional().describe("Enable strict quality gate before completion")
    },
    async execute(args, ctx) {
      const sessionID2 = args.session_id && String(args.session_id).trim().length > 0 ? String(args.session_id) : getSessionID(ctx);
      const mode = String(args.mode);
      if (mode === "status") {
        const state3 = getSessionState(projectDir, sessionID2);
        return [
          `session=${sessionID2}`,
          `loop_enabled=${state3.loopEnabled}`,
          `auto_continue=${state3.autoContinue}`,
          `max_cycles=${state3.maxIterationsPerWindow}`,
          `strict_quality_gate=${state3.strictQualityGate}`,
          `iteration_completed=${state3.iterationCompleted}`
        ].join("\n");
      }
      if (mode === "stop") {
        const state3 = configureAutopilotSession({
          projectDir,
          sessionID: sessionID2,
          enabled: false
        });
        return [
          `session=${sessionID2}`,
          "autopilot=stopped",
          `loop_enabled=${state3.loopEnabled}`
        ].join("\n");
      }
      const goal = String(args.goal ?? "").trim();
      if (mode === "run") {
        const execution = runAutopilot({
          goal: goal || "autopilot run",
          commands: Array.isArray(args.commands) ? args.commands.map(String) : [],
          verificationCommand: args.verification_command ? String(args.verification_command) : void 0,
          timeoutMs: typeof args.timeout_ms === "number" ? Number(args.timeout_ms) : 6e4,
          workingDirectory: args.working_directory ? String(args.working_directory) : void 0
        });
        const lines = [
          `session=${sessionID2}`,
          `autopilot_run_success=${execution.success}`,
          `execution_steps=${execution.execution.length}`,
          `summary=${execution.summary}`,
          summarizeAutopilotPlan(execution.plan),
          summarizeVerification(execution.verification)
        ];
        const last = execution.execution.slice(-4);
        if (last.length > 0) {
          lines.push("recent_execution=");
          for (const item of last) {
            lines.push(
              `- ok=${item.ok} exit=${item.exitCode} duration_ms=${item.durationMs} cmd=${item.command}`
            );
          }
        }
        return lines.join("\n");
      }
      const plan = createAutopilotPlan(goal || "autopilot goal");
      const state2 = configureAutopilotSession({
        projectDir,
        sessionID: sessionID2,
        enabled: true,
        maxCycles: typeof args.max_cycles === "number" ? Number(args.max_cycles) : void 0,
        autoContinue: typeof args.auto_continue === "boolean" ? Boolean(args.auto_continue) : void 0,
        strictQualityGate: typeof args.strict_quality_gate === "boolean" ? Boolean(args.strict_quality_gate) : void 0
      });
      return [
        `session=${sessionID2}`,
        "autopilot=started",
        `loop_enabled=${state2.loopEnabled}`,
        `auto_continue=${state2.autoContinue}`,
        `max_cycles=${state2.maxIterationsPerWindow}`,
        `strict_quality_gate=${state2.strictQualityGate}`,
        summarizeAutopilotPlan(plan)
      ].join("\n");
    }
  });
  return {
    miya_autopilot
  };
}

// src/tools/autoflow.ts
var z10 = tool.schema;
function getSessionID2(ctx) {
  if (ctx && typeof ctx === "object" && "sessionID" in ctx) {
    return String(ctx.sessionID ?? "main");
  }
  return "main";
}
function formatStateSummary(state2) {
  return [
    `session=${state2.sessionID}`,
    `phase=${state2.phase}`,
    `goal=${state2.goal || "(empty)"}`,
    `tasks=${state2.planTasks.length}`,
    `fix_round=${state2.fixRound}/${state2.maxFixRounds}`,
    `verification_command=${state2.verificationCommand ?? "(none)"}`,
    `fix_commands=${state2.fixCommands.length}`,
    `last_error=${state2.lastError ?? "(none)"}`,
    `recent_verification_fingerprints=${state2.recentVerificationHashes.length}`,
    `history=${state2.history.length}`
  ];
}
function formatPersistentSummary(projectDir, sessionID2) {
  const config3 = readAutoflowPersistentConfig(projectDir);
  const runtime = getAutoflowPersistentRuntimeSnapshot(projectDir, 200).find(
    (item) => item.sessionID === sessionID2
  );
  return [
    `persistent_enabled=${config3.enabled}`,
    `persistent_resume_cooldown_ms=${config3.resumeCooldownMs}`,
    `persistent_max_auto_resumes=${config3.maxAutoResumes}`,
    `persistent_max_resume_failures=${config3.maxConsecutiveResumeFailures}`,
    `persistent_resume_timeout_ms=${config3.resumeTimeoutMs}`,
    `persistent_resume_attempts=${runtime?.resumeAttempts ?? 0}`,
    `persistent_resume_failures=${runtime?.resumeFailures ?? 0}`,
    `persistent_user_stopped=${runtime?.userStopped ?? false}`,
    `persistent_last_outcome_phase=${runtime?.lastOutcomePhase ?? "(none)"}`
  ];
}
function createAutoflowTools(projectDir, manager) {
  const miya_autoflow = tool({
    description: "Persistent autonomous workflow: parallel task execution + verification + iterative fixes until success or hard stop.",
    args: {
      mode: z10.enum(["start", "run", "status", "stop"]).default("run").describe("start configures plan, run executes loop, status inspects, stop halts session"),
      session_id: z10.string().optional().describe("Target session id (default current session)"),
      goal: z10.string().optional().describe("Workflow goal summary"),
      tasks: z10.array(
        z10.object({
          id: z10.string().optional(),
          agent: z10.string(),
          prompt: z10.string(),
          description: z10.string(),
          dependsOn: z10.array(z10.string()).optional(),
          timeoutMs: z10.number().optional(),
          maxRetries: z10.number().optional()
        })
      ).optional().describe("Planned DAG tasks"),
      verification_command: z10.string().optional().describe("Verification command after execution"),
      fix_commands: z10.array(z10.string()).optional().describe("Fix commands executed round-by-round when verification fails"),
      max_fix_rounds: z10.number().optional().describe("Maximum verification-fix rounds"),
      max_parallel: z10.number().optional().describe("DAG worker concurrency"),
      timeout_ms: z10.number().optional().describe("Shell command timeout"),
      working_directory: z10.string().optional().describe("Shell command cwd"),
      force_restart: z10.boolean().optional().describe("Reset finished/failed state and rerun from planning"),
      persistent_enabled: z10.boolean().optional().describe("Enable/disable non-user stop auto resume"),
      persistent_resume_cooldown_ms: z10.number().optional(),
      persistent_max_auto_resumes: z10.number().optional(),
      persistent_max_resume_failures: z10.number().optional(),
      persistent_resume_timeout_ms: z10.number().optional()
    },
    async execute(args, ctx) {
      const sessionID2 = typeof args.session_id === "string" && args.session_id.trim().length > 0 ? args.session_id.trim() : getSessionID2(ctx);
      const mode = String(args.mode ?? "run");
      if (mode === "status") {
        const state2 = getAutoflowSession(projectDir, sessionID2);
        return [...formatStateSummary(state2), ...formatPersistentSummary(projectDir, sessionID2)].join(
          "\n"
        );
      }
      if (mode === "stop") {
        const state2 = stopAutoflowSession(projectDir, sessionID2);
        return [...formatStateSummary(state2), "autoflow=stopped"].join("\n");
      }
      if (typeof args.persistent_enabled === "boolean" || typeof args.persistent_resume_cooldown_ms === "number" || typeof args.persistent_max_auto_resumes === "number" || typeof args.persistent_max_resume_failures === "number" || typeof args.persistent_resume_timeout_ms === "number") {
        writeAutoflowPersistentConfig(projectDir, {
          enabled: typeof args.persistent_enabled === "boolean" ? Boolean(args.persistent_enabled) : void 0,
          resumeCooldownMs: typeof args.persistent_resume_cooldown_ms === "number" ? Number(args.persistent_resume_cooldown_ms) : void 0,
          maxAutoResumes: typeof args.persistent_max_auto_resumes === "number" ? Number(args.persistent_max_auto_resumes) : void 0,
          maxConsecutiveResumeFailures: typeof args.persistent_max_resume_failures === "number" ? Number(args.persistent_max_resume_failures) : void 0,
          resumeTimeoutMs: typeof args.persistent_resume_timeout_ms === "number" ? Number(args.persistent_resume_timeout_ms) : void 0
        });
      }
      if (mode === "start") {
        const state2 = configureAutoflowSession(projectDir, {
          sessionID: sessionID2,
          goal: typeof args.goal === "string" ? args.goal : void 0,
          tasks: Array.isArray(args.tasks) ? args.tasks : void 0,
          verificationCommand: typeof args.verification_command === "string" ? args.verification_command : void 0,
          fixCommands: Array.isArray(args.fix_commands) ? args.fix_commands : void 0,
          maxFixRounds: typeof args.max_fix_rounds === "number" ? Number(args.max_fix_rounds) : void 0,
          phase: "planning"
        });
        return [
          ...formatStateSummary(state2),
          ...formatPersistentSummary(projectDir, sessionID2),
          "autoflow=configured"
        ].join("\n");
      }
      const result = await runAutoflow({
        projectDir,
        sessionID: sessionID2,
        manager,
        goal: typeof args.goal === "string" ? args.goal : void 0,
        tasks: Array.isArray(args.tasks) ? args.tasks : void 0,
        verificationCommand: typeof args.verification_command === "string" ? args.verification_command : void 0,
        fixCommands: Array.isArray(args.fix_commands) ? args.fix_commands : void 0,
        maxFixRounds: typeof args.max_fix_rounds === "number" ? Number(args.max_fix_rounds) : void 0,
        maxParallel: typeof args.max_parallel === "number" ? Number(args.max_parallel) : void 0,
        timeoutMs: typeof args.timeout_ms === "number" ? Number(args.timeout_ms) : void 0,
        workingDirectory: typeof args.working_directory === "string" ? args.working_directory : void 0,
        forceRestart: Boolean(args.force_restart)
      });
      const lines = [
        `autoflow_success=${result.success}`,
        `summary=${result.summary}`,
        ...formatStateSummary(result.state),
        ...formatPersistentSummary(projectDir, sessionID2)
      ];
      if (result.dagResult) {
        lines.push(
          `dag_total=${result.dagResult.total}`,
          `dag_completed=${result.dagResult.completed}`,
          `dag_failed=${result.dagResult.failed}`,
          `dag_blocked=${result.dagResult.blocked}`
        );
      }
      if (result.verification) {
        lines.push(
          `verification_ok=${result.verification.ok}`,
          `verification_exit=${result.verification.exitCode}`,
          `verification_duration_ms=${result.verification.durationMs}`
        );
      }
      if (result.fixResult) {
        lines.push(
          `fix_ok=${result.fixResult.ok}`,
          `fix_exit=${result.fixResult.exitCode}`,
          `fix_duration_ms=${result.fixResult.durationMs}`
        );
      }
      return lines.join("\n");
    }
  });
  return {
    miya_autoflow
  };
}

// src/tools/multimodal.ts
var z11 = tool.schema;
function createMultimodalTools(projectDir) {
  const miya_generate_image = tool({
    description: "Generate an image asset with local multimodal pipeline and persist metadata.",
    args: {
      prompt: z11.string().describe("Image prompt"),
      reference_media_ids: z11.array(z11.string()).optional().describe("Optional reference media ids"),
      model: z11.string().optional().describe("Image model id"),
      size: z11.string().optional().describe("Output size (for example 1024x1024)"),
      register_as_companion_asset: z11.boolean().optional().describe("Also add generated image into companion assets")
    },
    async execute(args) {
      const result = await generateImage(projectDir, {
        prompt: String(args.prompt),
        referenceMediaIDs: Array.isArray(args.reference_media_ids) ? args.reference_media_ids.map(String) : void 0,
        model: args.model ? String(args.model) : void 0,
        size: args.size ? String(args.size) : void 0,
        registerAsCompanionAsset: Boolean(args.register_as_companion_asset)
      });
      return [
        `media_id=${result.media.id}`,
        `file=${result.media.fileName}`,
        `model=${result.model}`,
        `size=${result.size}`,
        `prompt=${result.prompt}`
      ].join("\n");
    }
  });
  const miya_voice_input = tool({
    description: "Ingest voice input text/media into Miya voice state and history.",
    args: {
      text: z11.string().optional().describe("Recognized text content"),
      media_id: z11.string().optional().describe("Optional media id for ASR transcript"),
      source: z11.enum(["wake", "talk", "manual", "media"]).optional(),
      language: z11.string().optional().describe("Language hint, for example zh-CN")
    },
    async execute(args) {
      const result = ingestVoiceInput(projectDir, {
        text: args.text ? String(args.text) : void 0,
        mediaID: args.media_id ? String(args.media_id) : void 0,
        source: args.source,
        language: args.language ? String(args.language) : void 0
      });
      return [
        `source=${result.source}`,
        `media_id=${result.mediaID ?? ""}`,
        `text=${result.text}`
      ].join("\n");
    }
  });
  const miya_voice_output = tool({
    description: "Generate TTS voice output asset with local multimodal pipeline and persist metadata.",
    args: {
      text: z11.string().describe("Text to synthesize"),
      voice: z11.string().optional().describe("Voice profile id or name"),
      model: z11.string().optional().describe("TTS model id"),
      format: z11.enum(["wav", "mp3", "ogg"]).optional(),
      register_as_companion_asset: z11.boolean().optional().describe("Also add generated voice into companion assets")
    },
    async execute(args) {
      const result = await synthesizeVoiceOutput(projectDir, {
        text: String(args.text),
        voice: args.voice ? String(args.voice) : void 0,
        model: args.model ? String(args.model) : void 0,
        format: args.format,
        registerAsCompanionAsset: Boolean(args.register_as_companion_asset)
      });
      return [
        `media_id=${result.media.id}`,
        `file=${result.media.fileName}`,
        `voice=${result.voice}`,
        `model=${result.model}`,
        `format=${result.format}`
      ].join("\n");
    }
  });
  const miya_vision_analyze = tool({
    description: "Analyze an image media asset and return metadata-based summary.",
    args: {
      media_id: z11.string().describe("Image media id"),
      question: z11.string().optional().describe("Optional analysis question")
    },
    async execute(args) {
      const result = await analyzeVision(projectDir, {
        mediaID: String(args.media_id),
        question: args.question ? String(args.question) : void 0
      });
      return [
        `media_id=${result.mediaID}`,
        `summary=${result.summary}`,
        `details=${JSON.stringify(result.details)}`
      ].join("\n");
    }
  });
  return {
    miya_generate_image,
    miya_voice_input,
    miya_voice_output,
    miya_vision_analyze
  };
}

// src/tools/soul.ts
var z12 = tool.schema;
function createSoulTools(projectDir) {
  const miya_soul_get = tool({
    description: "Read current SOUL profile and persona layer.",
    args: {},
    async execute() {
      const profile = loadSoulProfile(projectDir);
      return [
        `file=${soulFilePath(projectDir)}`,
        `name=${profile.name}`,
        `role=${profile.role}`,
        `tone=${profile.tone}`,
        `principles=${profile.principles.length}`,
        `behavior_rules=${profile.behaviorRules.length}`,
        `forbidden=${profile.forbidden.length}`,
        "",
        soulPersonaLayer(projectDir)
      ].join("\n");
    }
  });
  const miya_soul_set = tool({
    description: "Replace SOUL.md content and persist persona profile.",
    args: {
      markdown: z12.string().describe("Full SOUL.md markdown content")
    },
    async execute(args) {
      const profile = saveSoulMarkdown(projectDir, String(args.markdown));
      return [
        "updated=true",
        `file=${soulFilePath(projectDir)}`,
        `name=${profile.name}`,
        `role=${profile.role}`
      ].join("\n");
    }
  });
  const miya_soul_reset = tool({
    description: "Reset SOUL.md to default template.",
    args: {},
    async execute() {
      const profile = saveSoulMarkdown(projectDir, DEFAULT_SOUL_MARKDOWN);
      return [
        "reset=true",
        `file=${soulFilePath(projectDir)}`,
        `name=${profile.name}`
      ].join("\n");
    }
  });
  return {
    miya_soul_get,
    miya_soul_set,
    miya_soul_reset
  };
}

// src/ultrawork/merger.ts
function mergeUltraworkResults(manager, taskIDs) {
  const lines = [];
  for (const taskID of taskIDs) {
    const task = manager.getResult(taskID);
    if (!task) {
      lines.push(`- ${taskID}: not_found`);
      continue;
    }
    lines.push(
      `- ${task.id} | ${task.agent} | ${task.status} | ${task.completedAt ? "done" : "running"}`
    );
  }
  return lines.join("\n");
}
function formatUltraworkDagResult(result) {
  const header = [
    `total=${result.total}`,
    `completed=${result.completed}`,
    `failed=${result.failed}`,
    `blocked=${result.blocked}`
  ];
  const lines = result.nodes.map(
    (node) => `- ${node.nodeID} | ${node.agent} | ${node.status} | retries=${node.retries}${node.error ? ` | error=${node.error}` : ""}`
  );
  return [...header, ...lines].join("\n");
}

// src/tools/ultrawork.ts
var z13 = tool.schema;
function sessionID(ctx) {
  if (ctx && typeof ctx === "object" && "sessionID" in ctx) {
    return String(ctx.sessionID ?? "main");
  }
  return "main";
}
function createUltraworkTools(_ctx, manager) {
  const miya_ultrawork = tool({
    description: "Launch multiple specialist tasks in parallel and return aggregated status.",
    args: {
      tasks: z13.array(
        z13.object({
          id: z13.string().optional(),
          agent: z13.string(),
          prompt: z13.string(),
          description: z13.string(),
          dependsOn: z13.array(z13.string()).optional(),
          timeoutMs: z13.number().optional(),
          maxRetries: z13.number().optional()
        })
      ).describe("Parallel task list"),
      mode: z13.enum(["parallel", "dag"]).optional().describe("Scheduling mode: parallel fire-and-merge or DAG dependency scheduling"),
      max_parallel: z13.number().optional().describe("Max parallel workers when mode=dag")
    },
    async execute(args, ctx) {
      const parentSessionID = sessionID(ctx);
      const tasks = Array.isArray(args.tasks) ? args.tasks : [];
      if (args.mode === "dag") {
        const dagResult = await runUltraworkDag({
          manager,
          parentSessionID,
          tasks,
          maxParallel: typeof args.max_parallel === "number" ? Number(args.max_parallel) : void 0
        });
        return [
          "mode=dag",
          formatUltraworkDagResult(dagResult)
        ].join("\n");
      }
      const launched = launchUltraworkTasks({
        manager,
        parentSessionID,
        tasks
      });
      const merged = mergeUltraworkResults(manager, launched.map((item) => item.taskID));
      return [
        "mode=parallel",
        `launched=${launched.length}`,
        ...launched.map((item) => `- ${item.nodeID} -> ${item.taskID} | ${item.agent} | ${item.status}`),
        "",
        "status:",
        merged
      ].join("\n");
    }
  });
  return {
    miya_ultrawork
  };
}

// src/tools/router.ts
var z14 = tool.schema;
var DEFAULT_AVAILABLE_AGENTS = [
  "1-task-manager",
  "2-code-search",
  "3-docs-helper",
  "4-architecture-advisor",
  "5-code-fixer",
  "6-ui-designer",
  "7-code-simplicity-reviewer"
];
function createRouterTools(projectDir) {
  const miya_route_intent = tool({
    description: "Classify intent, estimate complexity, and produce runtime routing plan.",
    args: {
      text: z14.string().describe("User request text"),
      session_id: z14.string().optional().describe("Target session id for escalation tracking"),
      available_agents: z14.array(z14.string()).optional().describe("Optional available agents list"),
      pinned_agent: z14.string().optional().describe("Optional fixed agent to force route output")
    },
    async execute(args) {
      const text = String(args.text ?? "");
      const availableAgents = Array.isArray(args.available_agents) ? args.available_agents.map(String) : DEFAULT_AVAILABLE_AGENTS;
      const sessionID2 = String(args.session_id ?? "main").trim() || "main";
      const plan = buildRouteExecutionPlan({
        projectDir,
        sessionID: sessionID2,
        text,
        availableAgents,
        pinnedAgent: typeof args.pinned_agent === "string" ? args.pinned_agent : void 0
      });
      const mode = readRouterModeConfig(projectDir);
      const session = getRouterSessionState(projectDir, sessionID2);
      return [
        `session=${sessionID2}`,
        `intent=${plan.intent}`,
        `complexity=${plan.complexity}`,
        `complexity_score=${plan.complexityScore}`,
        `route_stage=${plan.stage}`,
        `selected_agent=${plan.agent}`,
        `planned_agents=${plan.plannedAgents.join(",")}`,
        `max_agents=${plan.maxAgents}`,
        `context_strategy=${plan.contextStrategy}`,
        `requires_multiple_steps=${plan.requiresMultipleSteps}`,
        `enable_early_exit=${plan.enableEarlyExit}`,
        `preferred_agent=${plan.preferredAgent}`,
        `fallback_agent=${plan.fallbackAgent}`,
        `feedback_score=${plan.feedbackScore}`,
        `feedback_samples=${plan.feedbackSamples}`,
        `eco_mode=${mode.ecoMode}`,
        `forced_stage=${mode.forcedStage ?? "(none)"}`,
        `consecutive_failures=${session.consecutiveFailures}`,
        `reasons=${plan.reasons.join(",")}`
      ].join("\n");
    }
  });
  const miya_route_feedback = tool({
    description: "Record route outcome feedback for routing learning.",
    args: {
      text: z14.string(),
      intent: z14.string(),
      suggested_agent: z14.string(),
      accepted: z14.boolean()
    },
    async execute(args) {
      const intent = classifyIntent(String(args.intent));
      const record3 = addRouteFeedback(projectDir, {
        text: String(args.text),
        intent,
        suggestedAgent: String(args.suggested_agent),
        accepted: Boolean(args.accepted)
      });
      return [
        `saved=true`,
        `at=${record3.at}`,
        `intent=${record3.intent}`,
        `accepted=${record3.accepted}`
      ].join("\n");
    }
  });
  const miya_route_stats = tool({
    description: "Show routing acceptance stats and runtime token/cost summary.",
    args: {},
    async execute() {
      const summary = summarizeRouteHistory(projectDir);
      const cost = getRouteCostSummary(projectDir, 500);
      return [
        summary,
        `cost_records=${cost.totalRecords}`,
        `tokens_estimate=${cost.totalTokensEstimate}`,
        `baseline_high_tokens_estimate=${cost.baselineHighTokensEstimate}`,
        `savings_tokens_estimate=${cost.savingsTokensEstimate}`,
        `savings_percent_estimate=${cost.savingsPercentEstimate}`,
        `cost_usd_estimate=${cost.totalCostUsdEstimate}`,
        `stage_low_records=${cost.byStage.low.records}`,
        `stage_medium_records=${cost.byStage.medium.records}`,
        `stage_high_records=${cost.byStage.high.records}`
      ].join("\n");
    }
  });
  const miya_route_mode = tool({
    description: "Inspect or update router eco mode and forced stage.",
    args: {
      mode: z14.enum(["get", "set"]).default("get"),
      eco_mode: z14.boolean().optional(),
      forced_stage: z14.enum(["low", "medium", "high"]).optional(),
      clear_forced_stage: z14.boolean().optional()
    },
    async execute(args) {
      if (args.mode === "set") {
        const next = writeRouterModeConfig(projectDir, {
          ecoMode: typeof args.eco_mode === "boolean" ? Boolean(args.eco_mode) : void 0,
          forcedStage: args.clear_forced_stage === true ? void 0 : typeof args.forced_stage === "string" ? args.forced_stage : void 0
        });
        return [
          "saved=true",
          `eco_mode=${next.ecoMode}`,
          `forced_stage=${next.forcedStage ?? "(none)"}`,
          `token_multiplier_low=${next.stageTokenMultiplier.low}`,
          `token_multiplier_medium=${next.stageTokenMultiplier.medium}`,
          `token_multiplier_high=${next.stageTokenMultiplier.high}`
        ].join("\n");
      }
      const current = readRouterModeConfig(projectDir);
      return [
        `eco_mode=${current.ecoMode}`,
        `forced_stage=${current.forcedStage ?? "(none)"}`,
        `token_multiplier_low=${current.stageTokenMultiplier.low}`,
        `token_multiplier_medium=${current.stageTokenMultiplier.medium}`,
        `token_multiplier_high=${current.stageTokenMultiplier.high}`,
        `cost_per_1k_low=${current.stageCostUsdPer1k.low}`,
        `cost_per_1k_medium=${current.stageCostUsdPer1k.medium}`,
        `cost_per_1k_high=${current.stageCostUsdPer1k.high}`
      ].join("\n");
    }
  });
  const miya_route_cost = tool({
    description: "Show recent route token/cost records.",
    args: {
      limit: z14.number().optional()
    },
    async execute(args) {
      const limit = typeof args.limit === "number" ? Number(args.limit) : 20;
      const rows = listRouteCostRecords(projectDir, Math.max(1, Math.min(100, limit)));
      if (rows.length === 0) return "route_cost=empty";
      return rows.slice(-Math.max(1, Math.min(100, limit))).map(
        (row) => [
          `at=${row.at}`,
          `session=${row.sessionID}`,
          `intent=${row.intent}`,
          `complexity=${row.complexity}`,
          `stage=${row.stage}`,
          `agent=${row.agent}`,
          `success=${row.success}`,
          `tokens=${row.totalTokensEstimate}`,
          `cost_usd=${row.costUsdEstimate}`
        ].join(" | ")
      ).join("\n");
    }
  });
  return {
    miya_route_intent,
    miya_route_feedback,
    miya_route_stats,
    miya_route_mode,
    miya_route_cost
  };
}

// src/tools/mcp.ts
var z15 = tool.schema;
function createMcpTools() {
  const miya_mcp_capabilities = tool({
    description: "List builtin MCPs with capability flags (MCP-UI/sampling/service exposure).",
    args: {
      disabled_mcps: z15.array(z15.string()).optional().describe("Optional disabled MCP names")
    },
    async execute(args) {
      const mcps = createBuiltinMcps(
        Array.isArray(args.disabled_mcps) ? args.disabled_mcps.map(String) : []
      );
      const lines = Object.entries(mcps).map(([name, config3]) => {
        const caps = "capabilities" in config3 ? config3.capabilities : void 0;
        return [
          `name=${name}`,
          `type=${config3.type}`,
          `sampling=${Boolean(caps?.sampling)}`,
          `mcp_ui=${Boolean(caps?.mcpUi)}`,
          `service_expose=${Boolean(caps?.serviceExpose)}`
        ].join(" | ");
      });
      return lines.length > 0 ? lines.join("\n") : "no_mcp_available";
    }
  });
  const miya_mcp_service_manifest = tool({
    description: "Return Miya MCP service exposure manifest used for control-plane integration.",
    args: {
      disabled_mcps: z15.array(z15.string()).optional().describe("Optional disabled MCP names")
    },
    async execute(args) {
      return JSON.stringify(
        buildMcpServiceManifest(
          Array.isArray(args.disabled_mcps) ? args.disabled_mcps.map(String) : []
        ),
        null,
        2
      );
    }
  });
  return {
    miya_mcp_capabilities,
    miya_mcp_service_manifest
  };
}

// src/tools/grep/constants.ts
import { spawnSync as spawnSync8 } from "node:child_process";
import { existsSync as existsSync48 } from "node:fs";
import { dirname as dirname35, join as join51 } from "node:path";

// src/tools/grep/downloader.ts
import {
  chmodSync as chmodSync2,
  existsSync as existsSync47,
  promises as fsPromises2,
  mkdirSync as mkdirSync41,
  readdirSync as readdirSync5,
  unlinkSync as unlinkSync4
} from "node:fs";
import { join as join50 } from "node:path";
function getInstallDir() {
  const homeDir = process.env.HOME || process.env.USERPROFILE || ".";
  return join50(homeDir, ".cache", "miya", "bin");
}
function getRgPath() {
  const isWindows = process.platform === "win32";
  return join50(getInstallDir(), isWindows ? "rg.exe" : "rg");
}
function getInstalledRipgrepPath() {
  const rgPath = getRgPath();
  return existsSync47(rgPath) ? rgPath : null;
}

// src/tools/grep/constants.ts
var cachedCli = null;
function findExecutable(name) {
  const isWindows = process.platform === "win32";
  const cmd = isWindows ? "where" : "which";
  try {
    const result = spawnSync8(cmd, [name], { encoding: "utf-8", timeout: 5e3 });
    if (result.status === 0 && result.stdout.trim()) {
      return result.stdout.trim().split(/\r?\n/)[0];
    }
  } catch {
  }
  return null;
}
function getDataDir() {
  if (process.platform === "win32") {
    return process.env.LOCALAPPDATA || process.env.APPDATA || join51(process.env.USERPROFILE || ".", "AppData", "Local");
  }
  return process.env.XDG_DATA_HOME || join51(process.env.HOME || ".", ".local", "share");
}
function getOpenCodeBundledRg() {
  const execPath = process.execPath;
  const execDir = dirname35(execPath);
  const isWindows = process.platform === "win32";
  const rgName = isWindows ? "rg.exe" : "rg";
  const candidates = [
    // OpenCode XDG data path (highest priority - where OpenCode installs rg)
    join51(getDataDir(), "opencode", "bin", rgName),
    // Legacy paths relative to execPath
    join51(execDir, rgName),
    join51(execDir, "bin", rgName),
    join51(execDir, "..", "bin", rgName),
    join51(execDir, "..", "libexec", rgName)
  ];
  for (const candidate of candidates) {
    if (existsSync48(candidate)) {
      return candidate;
    }
  }
  return null;
}
function resolveGrepCli() {
  if (cachedCli) return cachedCli;
  const bundledRg = getOpenCodeBundledRg();
  if (bundledRg) {
    cachedCli = { path: bundledRg, backend: "rg" };
    return cachedCli;
  }
  const systemRg = findExecutable("rg");
  if (systemRg) {
    cachedCli = { path: systemRg, backend: "rg" };
    return cachedCli;
  }
  const installedRg = getInstalledRipgrepPath();
  if (installedRg) {
    cachedCli = { path: installedRg, backend: "rg" };
    return cachedCli;
  }
  const grep2 = findExecutable("grep");
  if (grep2) {
    cachedCli = { path: grep2, backend: "grep" };
    return cachedCli;
  }
  cachedCli = { path: "rg", backend: "rg" };
  return cachedCli;
}
var DEFAULT_MAX_DEPTH = 20;
var DEFAULT_MAX_FILESIZE = "10M";
var DEFAULT_MAX_COUNT = 500;
var DEFAULT_MAX_COLUMNS = 1e3;
var DEFAULT_TIMEOUT_MS4 = 3e5;
var DEFAULT_MAX_OUTPUT_BYTES2 = 10 * 1024 * 1024;
var RG_SAFETY_FLAGS = [
  "--no-follow",
  "--color=never",
  "--no-heading",
  "--line-number",
  "--with-filename"
];
var GREP_SAFETY_FLAGS = ["-n", "-H", "--color=never"];

// src/tools/grep/cli.ts
function buildRgArgs(options) {
  const args = [
    ...RG_SAFETY_FLAGS,
    `--max-depth=${Math.min(options.maxDepth ?? DEFAULT_MAX_DEPTH, DEFAULT_MAX_DEPTH)}`,
    `--max-filesize=${options.maxFilesize ?? DEFAULT_MAX_FILESIZE}`,
    `--max-count=${Math.min(options.maxCount ?? DEFAULT_MAX_COUNT, DEFAULT_MAX_COUNT)}`,
    `--max-columns=${Math.min(options.maxColumns ?? DEFAULT_MAX_COLUMNS, DEFAULT_MAX_COLUMNS)}`
  ];
  if (options.context !== void 0 && options.context > 0) {
    args.push(`-C${Math.min(options.context, 10)}`);
  }
  if (options.caseSensitive) {
    args.push("--case-sensitive");
  } else {
    args.push("-i");
  }
  if (options.wholeWord) args.push("-w");
  if (options.fixedStrings) args.push("-F");
  if (options.multiline) args.push("-U");
  if (options.hidden) args.push("--hidden");
  if (options.noIgnore) args.push("--no-ignore");
  if (options.fileType?.length) {
    for (const type of options.fileType) {
      args.push(`--type=${type}`);
    }
  }
  if (options.globs) {
    for (const glob of options.globs) {
      args.push(`--glob=${glob}`);
    }
  }
  if (options.excludeGlobs) {
    for (const glob of options.excludeGlobs) {
      args.push(`--glob=!${glob}`);
    }
  }
  return args;
}
function buildGrepArgs(options) {
  const args = [...GREP_SAFETY_FLAGS, "-r"];
  if (options.context !== void 0 && options.context > 0) {
    args.push(`-C${Math.min(options.context, 10)}`);
  }
  if (!options.caseSensitive) args.push("-i");
  if (options.wholeWord) args.push("-w");
  if (options.fixedStrings) args.push("-F");
  if (options.globs?.length) {
    for (const glob of options.globs) {
      args.push(`--include=${glob}`);
    }
  }
  if (options.excludeGlobs?.length) {
    for (const glob of options.excludeGlobs) {
      args.push(`--exclude=${glob}`);
    }
  }
  args.push("--exclude-dir=.git", "--exclude-dir=node_modules");
  return args;
}
function buildArgs(options, backend) {
  return backend === "rg" ? buildRgArgs(options) : buildGrepArgs(options);
}
function parseOutput(output) {
  if (!output.trim()) return [];
  const matches = [];
  const lines = output.trim().split(/\r?\n/);
  for (const line of lines) {
    if (!line.trim()) continue;
    const match = line.match(/^(.+?):(\d+):(.*)$/);
    if (match) {
      matches.push({
        file: match[1],
        line: parseInt(match[2], 10),
        text: match[3]
      });
    }
  }
  return matches;
}
async function runRg(options) {
  const cli = resolveGrepCli();
  const args = buildArgs(options, cli.backend);
  const timeout = Math.min(
    options.timeout ?? DEFAULT_TIMEOUT_MS4,
    DEFAULT_TIMEOUT_MS4
  );
  if (cli.backend === "rg") {
    args.push("--", options.pattern);
  } else {
    args.push("-e", options.pattern);
  }
  const paths = options.paths?.length ? options.paths : ["."];
  args.push(...paths);
  try {
    const result = await runProcess(cli.path, args, { timeoutMs: timeout });
    if (result.timedOut) {
      throw new Error(`Search timeout after ${timeout}ms`);
    }
    const stdout = result.stdout;
    const stderr = result.stderr;
    const exitCode = result.exitCode;
    const truncated = stdout.length >= DEFAULT_MAX_OUTPUT_BYTES2;
    const outputToProcess = truncated ? stdout.substring(0, DEFAULT_MAX_OUTPUT_BYTES2) : stdout;
    if (exitCode > 1 && stderr.trim()) {
      return {
        matches: [],
        totalMatches: 0,
        filesSearched: 0,
        truncated: false,
        error: stderr.trim()
      };
    }
    const matches = parseOutput(outputToProcess);
    const filesSearched = new Set(matches.map((m) => m.file)).size;
    return {
      matches,
      totalMatches: matches.length,
      filesSearched,
      truncated
    };
  } catch (e) {
    return {
      matches: [],
      totalMatches: 0,
      filesSearched: 0,
      truncated: false,
      error: e instanceof Error ? e.message : String(e)
    };
  }
}

// src/tools/grep/utils.ts
function formatGrepResult(result) {
  if (result.error) {
    return `Error: ${result.error}`;
  }
  if (result.matches.length === 0) {
    return "No matches found.";
  }
  const lines = [];
  const byFile = /* @__PURE__ */ new Map();
  for (const match of result.matches) {
    const existing = byFile.get(match.file) || [];
    existing.push({ line: match.line, text: match.text });
    byFile.set(match.file, existing);
  }
  for (const [file3, matches] of byFile) {
    lines.push(`
${file3}:`);
    for (const match of matches) {
      lines.push(`  ${match.line}: ${match.text}`);
    }
  }
  const summary = `Found ${result.totalMatches} matches in ${result.filesSearched} files`;
  if (result.truncated) {
    lines.push(`
${summary} (output truncated)`);
  } else {
    lines.push(`
${summary}`);
  }
  return lines.join("\n");
}

// src/tools/grep/tools.ts
var grep = tool({
  description: 'Fast content search tool with safety limits (60s timeout, 10MB output). Searches file contents using regular expressions. Supports full regex syntax (eg. "log.*Error", "function\\s+\\w+", etc.). Filter files by pattern with the include parameter (e.g. "*.js", "*.{ts,tsx}"). Returns file paths with matches sorted by modification time.',
  args: {
    pattern: tool.schema.string().describe("The regex pattern to search for in file contents"),
    include: tool.schema.string().optional().describe(
      'File pattern to include in the search (e.g. "*.js", "*.{ts,tsx}")'
    ),
    path: tool.schema.string().optional().describe(
      "The directory to search in. Defaults to the current working directory."
    ),
    caseSensitive: tool.schema.boolean().optional().default(false).describe("Perform case-sensitive search (default: false)"),
    wholeWord: tool.schema.boolean().optional().default(false).describe("Match whole words only (default: false)"),
    fixedStrings: tool.schema.boolean().optional().default(false).describe("Treat pattern as literal string (default: false)")
  },
  execute: async (args) => {
    try {
      const globs = args.include ? [args.include] : void 0;
      const paths = args.path ? [args.path] : void 0;
      const result = await runRg({
        pattern: args.pattern,
        paths,
        globs,
        context: 0,
        caseSensitive: args.caseSensitive ?? false,
        wholeWord: args.wholeWord ?? false,
        fixedStrings: args.fixedStrings ?? false
      });
      return formatGrepResult(result);
    } catch (e) {
      return `Error: ${e instanceof Error ? e.message : String(e)}`;
    }
  }
});

// src/tools/lsp/client.ts
var import_node2 = __toESM(require_node(), 1);
import {
  spawn as spawn5
} from "node:child_process";
import { readFileSync as readFileSync43 } from "node:fs";
import { extname as extname3, resolve as resolve5 } from "node:path";
import { pathToFileURL } from "node:url";

// src/tools/lsp/config.ts
import { existsSync as existsSync49 } from "node:fs";
import { homedir as homedir7 } from "node:os";
import { join as join52 } from "node:path";

// src/tools/lsp/constants.ts
var SEVERITY_MAP = {
  1: "error",
  2: "warning",
  3: "information",
  4: "hint"
};
var DEFAULT_MAX_REFERENCES = 200;
var DEFAULT_MAX_DIAGNOSTICS = 200;
var BUILTIN_SERVERS = {
  // JavaScript/TypeScript ecosystem
  typescript: {
    command: ["typescript-language-server", "--stdio"],
    extensions: [".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs", ".mts", ".cts"]
  },
  vue: {
    command: ["vue-language-server", "--stdio"],
    extensions: [".vue"]
  },
  svelte: {
    command: ["svelteserver", "--stdio"],
    extensions: [".svelte"]
  },
  astro: {
    command: ["astro-ls", "--stdio"],
    extensions: [".astro"]
  },
  eslint: {
    command: ["vscode-eslint-language-server", "--stdio"],
    extensions: [
      ".ts",
      ".tsx",
      ".js",
      ".jsx",
      ".mjs",
      ".cjs",
      ".vue",
      ".svelte"
    ]
  },
  tailwindcss: {
    command: ["tailwindcss-language-server", "--stdio"],
    extensions: [".html", ".jsx", ".tsx", ".vue", ".svelte", ".astro"]
  },
  // Backend languages
  gopls: {
    command: ["gopls"],
    extensions: [".go"]
  },
  rust: {
    command: ["rust-analyzer"],
    extensions: [".rs"]
  },
  basedpyright: {
    command: ["basedpyright-langserver", "--stdio"],
    extensions: [".py", ".pyi"]
  },
  pyright: {
    command: ["pyright-langserver", "--stdio"],
    extensions: [".py", ".pyi"]
  },
  clangd: {
    command: ["clangd", "--background-index"],
    extensions: [".c", ".cpp", ".cc", ".cxx", ".h", ".hpp"]
  },
  zls: {
    command: ["zls"],
    extensions: [".zig"]
  }
};
var LSP_INSTALL_HINTS = {
  typescript: "npm install -g typescript-language-server typescript",
  vue: "npm install -g @vue/language-server",
  svelte: "npm install -g svelte-language-server",
  astro: "npm install -g @astrojs/language-server",
  eslint: "npm install -g vscode-langservers-extracted",
  tailwindcss: "npm install -g @tailwindcss/language-server",
  gopls: "go install golang.org/x/tools/gopls@latest",
  rust: "rustup component add rust-analyzer",
  basedpyright: "pip install basedpyright",
  pyright: "pip install pyright",
  clangd: "See https://clangd.llvm.org/installation",
  zls: "See https://github.com/zigtools/zls"
};
var EXT_TO_LANG = {
  // TypeScript/JavaScript
  ".ts": "typescript",
  ".tsx": "typescriptreact",
  ".mts": "typescript",
  ".cts": "typescript",
  ".js": "javascript",
  ".jsx": "javascriptreact",
  ".mjs": "javascript",
  ".cjs": "javascript",
  // Frontend frameworks
  ".vue": "vue",
  ".svelte": "svelte",
  ".astro": "astro",
  // Web
  ".html": "html",
  ".css": "css",
  ".scss": "scss",
  ".less": "less",
  ".json": "json",
  // Backend
  ".go": "go",
  ".rs": "rust",
  ".py": "python",
  ".pyi": "python",
  ".c": "c",
  ".cpp": "cpp",
  ".cc": "cpp",
  ".cxx": "cpp",
  ".h": "c",
  ".hpp": "cpp",
  ".zig": "zig"
};

// src/tools/lsp/config.ts
function findServerForExtension(ext) {
  for (const [id, config3] of Object.entries(BUILTIN_SERVERS)) {
    if (config3.extensions.includes(ext)) {
      const server = {
        id,
        command: config3.command,
        extensions: config3.extensions,
        env: config3.env,
        initialization: config3.initialization
      };
      if (isServerInstalled(config3.command)) {
        return { status: "found", server };
      }
      return {
        status: "not_installed",
        server,
        installHint: LSP_INSTALL_HINTS[id] || `Install '${config3.command[0]}' and add to PATH`
      };
    }
  }
  return { status: "not_configured", extension: ext };
}
function getLanguageId(ext) {
  return EXT_TO_LANG[ext] || "plaintext";
}
function isServerInstalled(command) {
  if (command.length === 0) return false;
  const cmd = command[0];
  if (cmd.includes("/") || cmd.includes("\\")) {
    return existsSync49(cmd);
  }
  const isWindows = process.platform === "win32";
  const ext = isWindows ? ".exe" : "";
  const pathEnv = process.env.PATH || "";
  const pathSeparator = isWindows ? ";" : ":";
  const paths = pathEnv.split(pathSeparator);
  for (const p of paths) {
    if (existsSync49(join52(p, cmd)) || existsSync49(join52(p, cmd + ext))) {
      return true;
    }
  }
  const cwd = process.cwd();
  const localBin = join52(cwd, "node_modules", ".bin", cmd);
  if (existsSync49(localBin) || existsSync49(localBin + ext)) {
    return true;
  }
  const globalBin = join52(homedir7(), ".config", "opencode", "bin", cmd);
  if (existsSync49(globalBin) || existsSync49(globalBin + ext)) {
    return true;
  }
  return false;
}

// src/tools/lsp/client.ts
var LSPServerManager = class _LSPServerManager {
  static instance;
  clients = /* @__PURE__ */ new Map();
  cleanupInterval = null;
  IDLE_TIMEOUT = 5 * 60 * 1e3;
  constructor() {
    this.startCleanupTimer();
    this.registerProcessCleanup();
  }
  registerProcessCleanup() {
    const cleanup = () => {
      for (const [, managed] of this.clients) {
        try {
          managed.client.stop();
        } catch {
        }
      }
      this.clients.clear();
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
        this.cleanupInterval = null;
      }
    };
    process.on("exit", cleanup);
    process.on("SIGINT", () => {
      cleanup();
      process.exit(0);
    });
    process.on("SIGTERM", () => {
      cleanup();
      process.exit(0);
    });
  }
  static getInstance() {
    if (!_LSPServerManager.instance) {
      _LSPServerManager.instance = new _LSPServerManager();
    }
    return _LSPServerManager.instance;
  }
  getKey(root, serverId) {
    return `${root}::${serverId}`;
  }
  startCleanupTimer() {
    if (this.cleanupInterval) return;
    this.cleanupInterval = setInterval(() => {
      this.cleanupIdleClients();
    }, 6e4);
  }
  cleanupIdleClients() {
    const now = Date.now();
    for (const [key, managed] of this.clients) {
      if (managed.refCount === 0 && now - managed.lastUsedAt > this.IDLE_TIMEOUT) {
        managed.client.stop();
        this.clients.delete(key);
      }
    }
  }
  async getClient(root, server) {
    const key = this.getKey(root, server.id);
    const managed = this.clients.get(key);
    if (managed) {
      if (managed.initPromise) {
        await managed.initPromise;
      }
      if (managed.client.isAlive()) {
        managed.refCount++;
        managed.lastUsedAt = Date.now();
        return managed.client;
      }
      await managed.client.stop();
      this.clients.delete(key);
    }
    const client = new LSPClient(root, server);
    const initPromise2 = (async () => {
      await client.start();
      await client.initialize();
    })();
    this.clients.set(key, {
      client,
      lastUsedAt: Date.now(),
      refCount: 1,
      initPromise: initPromise2,
      isInitializing: true
    });
    try {
      await initPromise2;
      const m = this.clients.get(key);
      if (m) {
        m.initPromise = void 0;
        m.isInitializing = false;
      }
    } catch (err) {
      this.clients.delete(key);
      throw err;
    }
    return client;
  }
  releaseClient(root, serverId) {
    const key = this.getKey(root, serverId);
    const managed = this.clients.get(key);
    if (managed && managed.refCount > 0) {
      managed.refCount--;
      managed.lastUsedAt = Date.now();
    }
  }
  isServerInitializing(root, serverId) {
    const key = this.getKey(root, serverId);
    const managed = this.clients.get(key);
    return managed?.isInitializing ?? false;
  }
  async stopAll() {
    for (const [, managed] of this.clients) {
      await managed.client.stop();
    }
    this.clients.clear();
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
};
var lspManager = LSPServerManager.getInstance();
var LSPClient = class {
  constructor(root, server) {
    this.root = root;
    this.server = server;
  }
  proc = null;
  connection = null;
  openedFiles = /* @__PURE__ */ new Set();
  stderrBuffer = [];
  processExited = false;
  diagnosticsStore = /* @__PURE__ */ new Map();
  async start() {
    this.proc = spawn5(this.server.command[0], this.server.command.slice(1), {
      stdio: ["pipe", "pipe", "pipe"],
      cwd: this.root,
      env: {
        ...process.env,
        ...this.server.env
      }
    });
    if (!this.proc) {
      throw new Error(
        `Failed to spawn LSP server: ${this.server.command.join(" ")}`
      );
    }
    this.startStderrReading();
    this.proc.on("exit", () => {
      this.processExited = true;
    });
    this.connection = (0, import_node2.createMessageConnection)(
      new import_node2.StreamMessageReader(this.proc.stdout),
      new import_node2.StreamMessageWriter(this.proc.stdin)
    );
    this.connection.onNotification(
      "textDocument/publishDiagnostics",
      (params) => {
        if (params.uri) {
          this.diagnosticsStore.set(params.uri, params.diagnostics ?? []);
        }
      }
    );
    this.connection.onRequest(
      "workspace/configuration",
      (params) => {
        const items = params.items ?? [];
        return items.map((item) => {
          const configItem = item;
          if (configItem.section === "json")
            return { validate: { enable: true } };
          return {};
        });
      }
    );
    this.connection.onRequest("client/registerCapability", () => null);
    this.connection.onRequest("window/workDoneProgress/create", () => null);
    this.connection.onClose(() => {
      this.processExited = true;
    });
    this.connection.listen();
    await new Promise((resolve7) => setTimeout(resolve7, 100));
    if (this.proc.exitCode !== null) {
      const stderr = this.stderrBuffer.join("\n");
      throw new Error(
        `LSP server exited immediately with code ${this.proc.exitCode}` + (stderr ? `
stderr: ${stderr}` : "")
      );
    }
  }
  startStderrReading() {
    if (!this.proc) return;
    this.proc.stderr.setEncoding("utf8");
    this.proc.stderr.on("data", (chunk) => {
      this.stderrBuffer.push(chunk);
      if (this.stderrBuffer.length > 100) {
        this.stderrBuffer.shift();
      }
    });
  }
  async initialize() {
    if (!this.connection) throw new Error("LSP connection not established");
    const rootUri = pathToFileURL(this.root).href;
    await this.connection.sendRequest("initialize", {
      processId: process.pid,
      rootUri,
      rootPath: this.root,
      workspaceFolders: [{ uri: rootUri, name: "workspace" }],
      capabilities: {
        textDocument: {
          hover: { contentFormat: ["markdown", "plaintext"] },
          definition: { linkSupport: true },
          references: {},
          documentSymbol: { hierarchicalDocumentSymbolSupport: true },
          publishDiagnostics: {},
          rename: {
            prepareSupport: true,
            prepareSupportDefaultBehavior: 1,
            honorsChangeAnnotations: true
          }
        },
        workspace: {
          symbol: {},
          workspaceFolders: true,
          configuration: true,
          applyEdit: true,
          workspaceEdit: { documentChanges: true }
        }
      },
      ...this.server.initialization
    });
    this.connection.sendNotification("initialized");
    await new Promise((r) => setTimeout(r, 300));
  }
  async openFile(filePath14) {
    const absPath = resolve5(filePath14);
    if (this.openedFiles.has(absPath)) return;
    const text = readFileSync43(absPath, "utf-8");
    const ext = extname3(absPath);
    const languageId = getLanguageId(ext);
    this.connection?.sendNotification("textDocument/didOpen", {
      textDocument: {
        uri: pathToFileURL(absPath).href,
        languageId,
        version: 1,
        text
      }
    });
    this.openedFiles.add(absPath);
    await new Promise((r) => setTimeout(r, 1e3));
  }
  async definition(filePath14, line, character) {
    const absPath = resolve5(filePath14);
    await this.openFile(absPath);
    return this.connection?.sendRequest("textDocument/definition", {
      textDocument: { uri: pathToFileURL(absPath).href },
      position: { line: line - 1, character }
    });
  }
  async references(filePath14, line, character, includeDeclaration = true) {
    const absPath = resolve5(filePath14);
    await this.openFile(absPath);
    return this.connection?.sendRequest("textDocument/references", {
      textDocument: { uri: pathToFileURL(absPath).href },
      position: { line: line - 1, character },
      context: { includeDeclaration }
    });
  }
  async diagnostics(filePath14) {
    const absPath = resolve5(filePath14);
    const uri = pathToFileURL(absPath).href;
    await this.openFile(absPath);
    await new Promise((r) => setTimeout(r, 500));
    try {
      const result = await this.connection?.sendRequest(
        "textDocument/diagnostic",
        {
          textDocument: { uri }
        }
      );
      if (result && typeof result === "object" && "items" in result) {
        return result;
      }
    } catch {
    }
    return { items: this.diagnosticsStore.get(uri) ?? [] };
  }
  async rename(filePath14, line, character, newName) {
    const absPath = resolve5(filePath14);
    await this.openFile(absPath);
    return this.connection?.sendRequest("textDocument/rename", {
      textDocument: { uri: pathToFileURL(absPath).href },
      position: { line: line - 1, character },
      newName
    });
  }
  isAlive() {
    return this.proc !== null && !this.processExited && this.proc.exitCode === null;
  }
  async stop() {
    try {
      if (this.connection) {
        await this.connection.sendRequest("shutdown");
        this.connection.sendNotification("exit");
        this.connection.dispose();
      }
    } catch {
    }
    this.proc?.kill();
    this.proc = null;
    this.connection = null;
    this.processExited = true;
    this.diagnosticsStore.clear();
  }
};

// src/tools/lsp/utils.ts
import {
  existsSync as existsSync50,
  readFileSync as readFileSync44,
  statSync as statSync3,
  unlinkSync as unlinkSync5,
  writeFileSync as writeFileSync34
} from "node:fs";
import { dirname as dirname36, extname as extname4, join as join53, resolve as resolve6 } from "node:path";
import { fileURLToPath as fileURLToPath4 } from "node:url";
function findWorkspaceRoot(filePath14) {
  let dir = resolve6(filePath14);
  try {
    if (!statSync3(dir).isDirectory()) {
      dir = dirname36(dir);
    }
  } catch {
    dir = dirname36(dir);
  }
  const markers = [
    ".git",
    "package.json",
    "pyproject.toml",
    "Cargo.toml",
    "go.mod"
  ];
  let prevDir = "";
  while (dir !== prevDir) {
    for (const marker of markers) {
      if (existsSync50(join53(dir, marker))) {
        return dir;
      }
    }
    prevDir = dir;
    dir = dirname36(dir);
  }
  return dirname36(resolve6(filePath14));
}
function uriToPath(uri) {
  return fileURLToPath4(uri);
}
function formatServerLookupError(result) {
  if (result.status === "not_installed") {
    return [
      `LSP server '${result.server.id}' is NOT INSTALLED.`,
      ``,
      `Command not found: ${result.server.command[0]}`,
      ``,
      `To install: ${result.installHint}`
    ].join("\n");
  }
  return `No LSP server configured for extension: ${result.extension}`;
}
async function withLspClient(filePath14, fn) {
  const absPath = resolve6(filePath14);
  const ext = extname4(absPath);
  const result = findServerForExtension(ext);
  if (result.status !== "found") {
    throw new Error(formatServerLookupError(result));
  }
  const server = result.server;
  const root = findWorkspaceRoot(absPath);
  const client = await lspManager.getClient(root, server);
  try {
    return await fn(client);
  } catch (e) {
    if (e instanceof Error && e.message.includes("timeout")) {
      const isInitializing = lspManager.isServerInitializing(root, server.id);
      if (isInitializing) {
        throw new Error(
          `LSP server is still initializing. Please retry in a few seconds.`
        );
      }
    }
    throw e;
  } finally {
    lspManager.releaseClient(root, server.id);
  }
}
function formatLocation(loc) {
  if ("targetUri" in loc) {
    const uri2 = uriToPath(loc.targetUri);
    const line2 = loc.targetRange.start.line + 1;
    const char2 = loc.targetRange.start.character;
    return `${uri2}:${line2}:${char2}`;
  }
  const uri = uriToPath(loc.uri);
  const line = loc.range.start.line + 1;
  const char = loc.range.start.character;
  return `${uri}:${line}:${char}`;
}
function formatSeverity(severity) {
  if (!severity) return "unknown";
  return SEVERITY_MAP[severity] || `unknown(${severity})`;
}
function formatDiagnostic(diag) {
  const severity = formatSeverity(diag.severity);
  const line = diag.range.start.line + 1;
  const char = diag.range.start.character;
  const source = diag.source ? `[${diag.source}]` : "";
  const code = diag.code ? ` (${diag.code})` : "";
  return `${severity}${source}${code} at ${line}:${char}: ${diag.message}`;
}
function filterDiagnosticsBySeverity(diagnostics, severityFilter) {
  if (!severityFilter || severityFilter === "all") {
    return diagnostics;
  }
  const severityMap = {
    error: 1,
    warning: 2,
    information: 3,
    hint: 4
  };
  const targetSeverity = severityMap[severityFilter];
  return diagnostics.filter((d) => d.severity === targetSeverity);
}
function applyTextEditsToFile(filePath14, edits) {
  try {
    const content = readFileSync44(filePath14, "utf-8");
    const lines = content.split("\n");
    const sortedEdits = [...edits].sort((a, b) => {
      if (b.range.start.line !== a.range.start.line) {
        return b.range.start.line - a.range.start.line;
      }
      return b.range.start.character - a.range.start.character;
    });
    for (const edit of sortedEdits) {
      const startLine = edit.range.start.line;
      const startChar = edit.range.start.character;
      const endLine = edit.range.end.line;
      const endChar = edit.range.end.character;
      if (startLine === endLine) {
        const line = lines[startLine] || "";
        lines[startLine] = line.substring(0, startChar) + edit.newText + line.substring(endChar);
      } else {
        const firstLine = lines[startLine] || "";
        const lastLine = lines[endLine] || "";
        const newContent = firstLine.substring(0, startChar) + edit.newText + lastLine.substring(endChar);
        lines.splice(
          startLine,
          endLine - startLine + 1,
          ...newContent.split("\n")
        );
      }
    }
    writeFileSync34(filePath14, lines.join("\n"), "utf-8");
    return { success: true, editCount: edits.length };
  } catch (err) {
    return {
      success: false,
      editCount: 0,
      error: err instanceof Error ? err.message : String(err)
    };
  }
}
function applyWorkspaceEdit(edit) {
  if (!edit) {
    return {
      success: false,
      filesModified: [],
      totalEdits: 0,
      errors: ["No edit provided"]
    };
  }
  const result = {
    success: true,
    filesModified: [],
    totalEdits: 0,
    errors: []
  };
  if (edit.changes) {
    for (const [uri, edits] of Object.entries(edit.changes)) {
      const filePath14 = uriToPath(uri);
      const applyResult = applyTextEditsToFile(filePath14, edits);
      if (applyResult.success) {
        result.filesModified.push(filePath14);
        result.totalEdits += applyResult.editCount;
      } else {
        result.success = false;
        result.errors.push(`${filePath14}: ${applyResult.error}`);
      }
    }
  }
  if (edit.documentChanges) {
    for (const change of edit.documentChanges) {
      if ("kind" in change) {
        if (change.kind === "create") {
          try {
            const filePath14 = uriToPath(change.uri);
            writeFileSync34(filePath14, "", "utf-8");
            result.filesModified.push(filePath14);
          } catch (err) {
            result.success = false;
            result.errors.push(`Create ${change.uri}: ${err}`);
          }
        } else if (change.kind === "rename") {
          try {
            const oldPath = uriToPath(change.oldUri);
            const newPath = uriToPath(change.newUri);
            const content = readFileSync44(oldPath, "utf-8");
            writeFileSync34(newPath, content, "utf-8");
            unlinkSync5(oldPath);
            result.filesModified.push(newPath);
          } catch (err) {
            result.success = false;
            result.errors.push(`Rename ${change.oldUri}: ${err}`);
          }
        } else if (change.kind === "delete") {
          try {
            const filePath14 = uriToPath(change.uri);
            unlinkSync5(filePath14);
            result.filesModified.push(filePath14);
          } catch (err) {
            result.success = false;
            result.errors.push(`Delete ${change.uri}: ${err}`);
          }
        }
      } else {
        const filePath14 = uriToPath(change.textDocument.uri);
        const applyResult = applyTextEditsToFile(filePath14, change.edits);
        if (applyResult.success) {
          result.filesModified.push(filePath14);
          result.totalEdits += applyResult.editCount;
        } else {
          result.success = false;
          result.errors.push(`${filePath14}: ${applyResult.error}`);
        }
      }
    }
  }
  return result;
}
function formatApplyResult(result) {
  const lines = [];
  if (result.success) {
    lines.push(
      `Applied ${result.totalEdits} edit(s) to ${result.filesModified.length} file(s):`
    );
    for (const file3 of result.filesModified) {
      lines.push(`  - ${file3}`);
    }
  } else {
    lines.push("Failed to apply some changes:");
    for (const err of result.errors) {
      lines.push(`  Error: ${err}`);
    }
    if (result.filesModified.length > 0) {
      lines.push(`Successfully modified: ${result.filesModified.join(", ")}`);
    }
  }
  return lines.join("\n");
}

// src/tools/lsp/tools.ts
var formatError3 = (e) => `Error: ${e instanceof Error ? e.message : String(e)}`;
var lsp_goto_definition = tool({
  description: "Jump to symbol definition. Find WHERE something is defined.",
  args: {
    filePath: tool.schema.string().describe("Absolute path to the file"),
    line: tool.schema.number().min(1).describe("1-based line number"),
    character: tool.schema.number().min(0).describe("0-based character offset")
  },
  execute: async (args) => {
    try {
      const result = await withLspClient(args.filePath, async (client) => {
        return await client.definition(
          args.filePath,
          args.line,
          args.character
        );
      });
      if (!result) {
        return "No definition found";
      }
      const locations = Array.isArray(result) ? result : [result];
      if (locations.length === 0) {
        return "No definition found";
      }
      return locations.map(formatLocation).join("\n");
    } catch (e) {
      return formatError3(e);
    }
  }
});
var lsp_find_references = tool({
  description: "Find ALL usages/references of a symbol across the entire workspace.",
  args: {
    filePath: tool.schema.string().describe("Absolute path to the file"),
    line: tool.schema.number().min(1).describe("1-based line number"),
    character: tool.schema.number().min(0).describe("0-based character offset"),
    includeDeclaration: tool.schema.boolean().optional().describe("Include the declaration itself")
  },
  execute: async (args) => {
    try {
      const result = await withLspClient(args.filePath, async (client) => {
        return await client.references(
          args.filePath,
          args.line,
          args.character,
          args.includeDeclaration ?? true
        );
      });
      if (!result || result.length === 0) {
        return "No references found";
      }
      const total = result.length;
      const truncated = total > DEFAULT_MAX_REFERENCES;
      const limited = truncated ? result.slice(0, DEFAULT_MAX_REFERENCES) : result;
      const lines = limited.map(formatLocation);
      if (truncated) {
        lines.unshift(
          `Found ${total} references (showing first ${DEFAULT_MAX_REFERENCES}):`
        );
      }
      return lines.join("\n");
    } catch (e) {
      return formatError3(e);
    }
  }
});
var lsp_diagnostics = tool({
  description: "Get errors, warnings, hints from language server BEFORE running build.",
  args: {
    filePath: tool.schema.string().describe("Absolute path to the file"),
    severity: tool.schema.enum(["error", "warning", "information", "hint", "all"]).optional().describe("Filter by severity level")
  },
  execute: async (args) => {
    try {
      const result = await withLspClient(args.filePath, async (client) => {
        return await client.diagnostics(args.filePath);
      });
      let diagnostics = [];
      if (result) {
        if (Array.isArray(result)) {
          diagnostics = result;
        } else if (result.items) {
          diagnostics = result.items;
        }
      }
      diagnostics = filterDiagnosticsBySeverity(diagnostics, args.severity);
      if (diagnostics.length === 0) {
        return "No diagnostics found";
      }
      const total = diagnostics.length;
      const truncated = total > DEFAULT_MAX_DIAGNOSTICS;
      const limited = truncated ? diagnostics.slice(0, DEFAULT_MAX_DIAGNOSTICS) : diagnostics;
      const lines = limited.map(formatDiagnostic);
      if (truncated) {
        lines.unshift(
          `Found ${total} diagnostics (showing first ${DEFAULT_MAX_DIAGNOSTICS}):`
        );
      }
      return lines.join("\n");
    } catch (e) {
      return formatError3(e);
    }
  }
});
var lsp_rename = tool({
  description: "Rename symbol across entire workspace. APPLIES changes to all files.",
  args: {
    filePath: tool.schema.string().describe("Absolute path to the file"),
    line: tool.schema.number().min(1).describe("1-based line number"),
    character: tool.schema.number().min(0).describe("0-based character offset"),
    newName: tool.schema.string().describe("New symbol name")
  },
  execute: async (args) => {
    try {
      const edit = await withLspClient(args.filePath, async (client) => {
        return await client.rename(
          args.filePath,
          args.line,
          args.character,
          args.newName
        );
      });
      const result = applyWorkspaceEdit(edit);
      return formatApplyResult(result);
    } catch (e) {
      return formatError3(e);
    }
  }
});

// src/tools/automation.ts
import * as fs49 from "node:fs";
import * as path50 from "node:path";
var z16 = tool.schema;
function formatJobs(jobs) {
  if (jobs.length === 0) {
    return "No jobs configured.";
  }
  return jobs.map(
    (job) => `- ${job.id} | ${job.name} | enabled=${job.enabled} | daily=${job.schedule.time} | next=${job.nextRunAt} | approval=${job.requireApproval}`
  ).join("\n");
}
function parseNaturalSchedule(input) {
  const text = input.trim();
  let hour = null;
  let minute = 0;
  const chineseMatch = /(?:\s*(||||))?\s*(\d{1,2})[:]?\s*(\d{1,2})?/.exec(
    text
  );
  if (chineseMatch) {
    const period = chineseMatch[1];
    hour = Number(chineseMatch[2]);
    minute = chineseMatch[3] ? Number(chineseMatch[3]) : 0;
    if (period === "\u4E0B\u5348" || period === "\u665A\u4E0A") {
      if (hour < 12) hour += 12;
    }
    if (period === "\u4E2D\u5348") {
      if (hour < 11) hour += 12;
    }
    if (period === "\u51CC\u6668" && hour === 12) {
      hour = 0;
    }
  }
  if (hour === null) {
    const englishMatch = /(?:every day at|daily\s*(?:at)?)\s*(\d{1,2})(?::(\d{1,2}))?/i.exec(
      text
    );
    if (englishMatch) {
      hour = Number(englishMatch[1]);
      minute = englishMatch[2] ? Number(englishMatch[2]) : 0;
    }
  }
  if (hour !== null) {
    if (Number.isNaN(hour) || Number.isNaN(minute)) return null;
    if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null;
  }
  if (hour === null) return null;
  const cmdPatterns = [
    /(?:|)\s*([^,;]+)$/,
    /(?:run|execute)\s+(.+)$/i
  ];
  let command = null;
  for (const pattern of cmdPatterns) {
    const match = pattern.exec(text);
    if (!match) continue;
    command = match[1].trim();
    break;
  }
  if (!command) {
    return null;
  }
  const time5 = `${String(hour).padStart(2, "0")}:${String(minute).padStart(2, "0")}`;
  return { time: time5, command };
}
function readAutoGitStatus(projectDir) {
  const file3 = path50.join(projectDir, ".opencode", "miya", "auto-git-push.json");
  if (!fs49.existsSync(file3)) return {};
  try {
    return JSON.parse(fs49.readFileSync(file3, "utf-8"));
  } catch {
    return {};
  }
}
function readGatewayStatus(projectDir) {
  const file3 = path50.join(projectDir, ".opencode", "miya", "gateway.json");
  if (!fs49.existsSync(file3)) return {};
  try {
    return JSON.parse(fs49.readFileSync(file3, "utf-8"));
  } catch {
    return {};
  }
}
function createAutomationTools(automationService) {
  const miya_schedule_daily_command = tool({
    description: "Create a daily scheduled command job (HH:mm local time) in Miya automation runtime.",
    args: {
      name: z16.string().describe("Job name"),
      time: z16.string().describe("Daily local time, format HH:mm"),
      command: z16.string().describe("Command to execute"),
      cwd: z16.string().optional().describe("Working directory for command"),
      timeout_ms: z16.number().optional().describe("Execution timeout in milliseconds"),
      require_approval: z16.boolean().optional().describe("Require manual approval for scheduled runs")
    },
    async execute(args) {
      const job = automationService.scheduleDailyCommand({
        name: String(args.name),
        time: String(args.time),
        command: String(args.command),
        cwd: args.cwd ? String(args.cwd) : void 0,
        timeoutMs: typeof args.timeout_ms === "number" ? Number(args.timeout_ms) : void 0,
        requireApproval: typeof args.require_approval === "boolean" ? args.require_approval : false
      });
      return `Scheduled job created.
id=${job.id}
name=${job.name}
time=${job.schedule.time}
next_run=${job.nextRunAt}
require_approval=${job.requireApproval}`;
    }
  });
  const miya_list_jobs = tool({
    description: "List Miya automation jobs.",
    args: {},
    async execute() {
      return formatJobs(automationService.listJobs());
    }
  });
  const miya_delete_job = tool({
    description: "Delete a Miya automation job by id.",
    args: {
      job_id: z16.string().describe("Job id to remove")
    },
    async execute(args) {
      const ok = automationService.deleteJob(String(args.job_id));
      return ok ? `Deleted job ${String(args.job_id)}.` : "Job not found.";
    }
  });
  const miya_set_job_enabled = tool({
    description: "Enable or disable a Miya automation job.",
    args: {
      job_id: z16.string().describe("Job id"),
      enabled: z16.boolean().describe("Whether job should be enabled")
    },
    async execute(args) {
      const job = automationService.setJobEnabled(
        String(args.job_id),
        Boolean(args.enabled)
      );
      if (!job) return "Job not found.";
      return `Job ${job.id} enabled=${job.enabled}, next_run=${job.nextRunAt}`;
    }
  });
  const miya_run_job_now = tool({
    description: "Run a Miya automation job immediately.",
    args: {
      job_id: z16.string().describe("Job id")
    },
    async execute(args) {
      const result = await automationService.runJobNow(String(args.job_id));
      if (!result) return "Job not found.";
      return `Run finished.
status=${result.status}
exit_code=${result.exitCode}
timed_out=${result.timedOut}
stdout:
${result.stdout || "(empty)"}
stderr:
${result.stderr || "(empty)"}`;
    }
  });
  const miya_list_approvals = tool({
    description: "List pending/finished approval requests for scheduled jobs.",
    args: {},
    async execute() {
      const approvals = automationService.listApprovals();
      if (approvals.length === 0) return "No approvals found.";
      return approvals.map(
        (approval) => `- ${approval.id} | job=${approval.jobId} | status=${approval.status} | requested=${approval.requestedAt}`
      ).join("\n");
    }
  });
  const miya_approve_job_run = tool({
    description: "Approve a pending job run request and execute it immediately.",
    args: {
      approval_id: z16.string().describe("Approval request id")
    },
    async execute(args) {
      const result = await automationService.approveAndRun(
        String(args.approval_id)
      );
      if (!result) {
        return "Approval not found or no longer pending.";
      }
      return `Approved ${result.approval.id}.
run_status=${result.result?.status ?? "unknown"}
exit_code=${result.result?.exitCode ?? "n/a"}
timed_out=${result.result?.timedOut ?? "n/a"}`;
    }
  });
  const miya_reject_job_run = tool({
    description: "Reject a pending scheduled job approval request.",
    args: {
      approval_id: z16.string().describe("Approval request id")
    },
    async execute(args) {
      const approval = automationService.rejectApproval(String(args.approval_id));
      if (!approval) {
        return "Approval not found or no longer pending.";
      }
      return `Rejected ${approval.id}.`;
    }
  });
  const miya_job_history = tool({
    description: "Show recent Miya job execution history.",
    args: {
      limit: z16.number().optional().describe("Maximum records to return (default 20)")
    },
    async execute(args) {
      const limit = typeof args.limit === "number" && args.limit > 0 ? Math.min(200, Number(args.limit)) : 20;
      const records = automationService.listHistory(limit);
      if (records.length === 0) return "No history records found.";
      return records.map(
        (record3) => `- ${record3.id} | job=${record3.jobName} | trigger=${record3.trigger} | status=${record3.status} | exit=${record3.exitCode} | started=${record3.startedAt}`
      ).join("\n");
    }
  });
  const miya_status_panel = tool({
    description: "Show compact Miya runtime status panel for jobs and approvals.",
    args: {},
    async execute() {
      const jobs = automationService.listJobs();
      const approvals = automationService.listApprovals().filter((item) => item.status === "pending");
      const history = automationService.listHistory(5);
      const historyText = history.length === 0 ? "(no runs yet)" : history.map(
        (item) => `- ${item.startedAt} | ${item.jobName} | ${item.status} | exit=${item.exitCode}`
      ).join("\n");
      const safety = getSafetySnapshot(automationService.getProjectDir());
      const safetyText = safety.recent.length === 0 ? "(none)" : safety.recent.map(
        (item) => `- ${item.created_at} | ${item.status} | ${item.tier} | ${item.reason} | trace=${item.trace_id}`
      ).join("\n");
      const autoGit = readAutoGitStatus(automationService.getProjectDir());
      const autoGitText = autoGit.status && autoGit.updated_at ? `${autoGit.updated_at} | ${autoGit.status} | reason=${autoGit.reason ?? "n/a"} | trace=${autoGit.trace ?? "n/a"} | target=${autoGit.target_ref ?? "n/a"}` : "(none)";
      const gateway = readGatewayStatus(automationService.getProjectDir());
      const gatewayText = gateway.url && gateway.status ? `${gateway.status} | ${gateway.url} | port=${gateway.port ?? "n/a"}` : "(not started)";
      return `<details>
<summary>Miya Control Plane</summary>

Miya status
jobs_total=${jobs.length}
jobs_enabled=${jobs.filter((job) => job.enabled).length}
approvals_pending=${approvals.length}
kill_switch_active=${safety.kill.active}
kill_switch_reason=${safety.kill.reason ?? "n/a"}
gateway=${gatewayText}
auto_git_last=${autoGitText}

Jobs:
${formatJobs(jobs)}

Pending approvals:
${approvals.length === 0 ? "(none)" : approvals.map(
        (item) => `- ${item.id} | job=${item.jobId} | requested=${item.requestedAt}`
      ).join("\n")}

Recent runs:
${historyText}

Recent self-approval:
${safetyText}
</details>`;
    }
  });
  const miya_schedule_from_text = tool({
    description: "Create daily schedule from a natural-language request (Chinese/English basic patterns).",
    args: {
      request: z16.string().describe("Natural-language automation request"),
      name: z16.string().optional().describe("Optional job name override")
    },
    async execute(args) {
      const request = String(args.request);
      const parsed = parseNaturalSchedule(request);
      if (!parsed) {
        return "Unable to parse schedule or command. Please include daily time and explicit command.";
      }
      const risky = /(|||trade|broker|email|mail)/i.test(request);
      const job = automationService.scheduleDailyCommand({
        name: args.name ? String(args.name) : `nl-${parsed.time}-${Date.now()}`,
        time: parsed.time,
        command: parsed.command,
        requireApproval: risky
      });
      return `Scheduled from natural language.
id=${job.id}
time=${job.schedule.time}
command=${job.action.command}
require_approval=${job.requireApproval}`;
    }
  });
  return {
    miya_schedule_daily_command,
    miya_list_jobs,
    miya_delete_job,
    miya_set_job_enabled,
    miya_run_job_now,
    miya_list_approvals,
    miya_approve_job_run,
    miya_reject_job_run,
    miya_job_history,
    miya_status_panel,
    miya_schedule_from_text
  };
}

// src/tools/workflow.ts
var z17 = tool.schema;
function sid(ctx) {
  if (ctx && typeof ctx === "object" && "sessionID" in ctx) {
    return String(ctx.sessionID);
  }
  return "unknown";
}
function normalizeList2(input) {
  if (!Array.isArray(input)) return [];
  return input.map(String);
}
function sameList(a, b) {
  if (a.length !== b.length) return false;
  const left = [...a].sort();
  const right = [...b].sort();
  for (let i = 0; i < left.length; i++) {
    if (left[i] !== right[i]) return false;
  }
  return true;
}
function createWorkflowTools(projectDir) {
  const save_work = tool({
    description: "Persist current workflow checkpoint to .opencode/cowork-saves",
    args: {
      label: z17.string().optional().describe("Checkpoint label"),
      done: z17.array(z17.string()).optional().describe("Completed items"),
      missing: z17.array(z17.string()).optional().describe("Still missing items"),
      unresolved: z17.array(z17.string()).optional().describe("Known unresolved issues or risks"),
      notes: z17.string().optional().describe("Extra notes")
    },
    async execute(args, toolContext) {
      const sessionID2 = sid(toolContext);
      const record3 = createSaveRecord(projectDir, {
        label: String(args.label ?? "checkpoint"),
        sessionID: sessionID2,
        done: Array.isArray(args.done) ? args.done.map(String) : [],
        missing: Array.isArray(args.missing) ? args.missing.map(String) : [],
        unresolved: Array.isArray(args.unresolved) ? args.unresolved.map(String) : [],
        notes: args.notes ? String(args.notes) : void 0
      });
      return `Saved checkpoint: ${record3.id}
Branch: ${record3.branch ?? "unknown"}
Label: ${record3.label}`;
    }
  });
  const miya_iteration_done = tool({
    description: "Mark one autopilot cycle as completed, persist a checkpoint, and enforce the internal max-cycle guard.",
    args: {
      done: z17.array(z17.string()).optional().describe("Completed items"),
      missing: z17.array(z17.string()).optional().describe("Still missing items"),
      unresolved: z17.array(z17.string()).optional().describe("Known unresolved issues or risks"),
      notes: z17.string().optional().describe("Extra notes")
    },
    async execute(args, toolContext) {
      const sessionID2 = sid(toolContext);
      if (sessionID2 === "unknown") return "Session id unavailable.";
      const state2 = getSessionState(projectDir, sessionID2);
      const done = normalizeList2(args.done);
      const missing = normalizeList2(args.missing);
      const unresolved = normalizeList2(args.unresolved);
      const next = state2.iterationCompleted + 1;
      const record3 = createSaveRecord(projectDir, {
        label: `iter-${next}`,
        sessionID: sessionID2,
        done,
        missing,
        unresolved,
        notes: args.notes ? String(args.notes) : void 0
      });
      const stalled = sameList(state2.lastMissing, missing) && sameList(state2.lastUnresolved, unresolved) && (missing.length > 0 || unresolved.length > 0);
      state2.iterationCompleted = next;
      state2.lastDone = done;
      state2.lastMissing = missing;
      state2.lastUnresolved = unresolved;
      const window = Math.max(0, state2.iterationCompleted - state2.windowStartIteration);
      const limit = state2.maxIterationsPerWindow;
      const capped = state2.loopEnabled && window >= limit;
      state2.awaitingConfirmation = capped;
      setSessionState(projectDir, sessionID2, state2);
      const unresolvedWork = missing.length > 0 || unresolved.length > 0;
      const reachedWithGaps = capped && unresolvedWork;
      const completed = missing.length === 0;
      return [
        `MIYA_ITERATION_COMPLETED=${state2.iterationCompleted}`,
        `MIYA_LOOP_LIMIT_REACHED=${reachedWithGaps}`,
        `MIYA_LOOP_WINDOW_CAPPED=${capped}`,
        `MIYA_LOOP_COMPLETE=${completed}`,
        `MIYA_LOOP_STALLED=${stalled}`,
        `checkpoint=${record3.id}`,
        reachedWithGaps ? [
          "",
          "Loop cap reached (max cycles exhausted).",
          "Do not ask the user for approval.",
          "Finalize now with one of:",
          "- degraded completion: safest usable state + explicit residual risk list + queued follow-up jobs",
          "- hard failure: minimal reproducible blocker + next viable path"
        ].join("\n") : "",
        stalled ? [
          "",
          "Progress stalled: missing/unresolved did not improve.",
          "Stop iterating and output replayable failure package."
        ].join("\n") : ""
      ].filter(Boolean).join("\n");
    }
  });
  const load_work = tool({
    description: "Load a saved checkpoint from .opencode/cowork-saves with branch safety check",
    args: {
      id: z17.string().describe("Checkpoint id (filename without .json)"),
      confirm_branch_mismatch: z17.boolean().optional().describe("Set true to proceed when saved branch != current branch")
    },
    async execute(args) {
      const record3 = loadSaveRecord(projectDir, String(args.id));
      if (!record3) {
        return `Save not found: ${String(args.id)}`;
      }
      const currentBranch = getCurrentBranch(projectDir);
      const mismatch = record3.branch && currentBranch && record3.branch !== currentBranch;
      if (mismatch && args.confirm_branch_mismatch !== true) {
        return `Branch mismatch detected. Saved on '${record3.branch}', current is '${currentBranch}'. Re-run load_work with confirm_branch_mismatch=true to proceed.`;
      }
      return `Loaded checkpoint ${record3.id}
Label: ${record3.label}
Saved branch: ${record3.branch ?? "unknown"}
Current branch: ${currentBranch ?? "unknown"}
Done: ${record3.done.length}
Missing: ${record3.missing.length}
Unresolved: ${record3.unresolved.length}
Notes: ${record3.notes ?? "(none)"}`;
    }
  });
  const check_work = tool({
    description: "Check completion status for one checkpoint or all checkpoints in .opencode/cowork-saves",
    args: {
      id: z17.string().optional().describe("Checkpoint id to inspect"),
      all: z17.boolean().optional().describe("Check all checkpoints")
    },
    async execute(args) {
      if (args.id) {
        const record3 = loadSaveRecord(projectDir, String(args.id));
        if (!record3) {
          return `Save not found: ${String(args.id)}`;
        }
        const result = evaluateSave(record3);
        return `Checkpoint ${record3.id}: ${result.status}
Reason: ${result.reason}`;
      }
      const records = listSaveRecords(projectDir);
      if (records.length === 0) {
        return "No checkpoints found.";
      }
      const lines = records.map((record3) => {
        const result = evaluateSave(record3);
        return `- ${record3.id} [${result.status}] ${record3.label} (${result.reason})`;
      });
      return `Checkpoints:
${lines.join("\n")}`;
    }
  });
  const quality_gate = tool({
    description: "Hard quality gate evaluation. Passes only when all three scores meet threshold.",
    args: {
      architecture_score: z17.number().min(0).max(10),
      docs_score: z17.number().min(0).max(10),
      domain_score: z17.number().min(0).max(10),
      threshold: z17.number().min(0).max(10).optional()
    },
    async execute(args) {
      const threshold = typeof args.threshold === "number" ? args.threshold : 9.2;
      const a = Number(args.architecture_score);
      const d = Number(args.docs_score);
      const x = Number(args.domain_score);
      const pass = a >= threshold && d >= threshold && x >= threshold;
      if (!pass) {
        return `QUALITY_GATE=FAIL
threshold=${threshold}
architecture=${a}
docs=${d}
domain=${x}`;
      }
      return `QUALITY_GATE=PASS
threshold=${threshold}
architecture=${a}
docs=${d}
domain=${x}`;
    }
  });
  const cancel_work = tool({
    description: "Cancel loop-mode for current session and reset loop guard counters.",
    args: {
      reason: z17.string().optional()
    },
    async execute(args, toolContext) {
      const sessionID2 = sid(toolContext);
      if (sessionID2 !== "unknown") {
        resetSessionState(projectDir, sessionID2);
      }
      return `Loop canceled for session ${sessionID2}. Reason: ${String(args.reason ?? "n/a")}`;
    }
  });
  const loop_state = tool({
    description: "Inspect current loop guard state for this session.",
    args: {},
    async execute(_args, toolContext) {
      const sessionID2 = sid(toolContext);
      if (sessionID2 === "unknown") {
        return "Session id unavailable.";
      }
      const state2 = getSessionState(projectDir, sessionID2);
      return [
        `session=${sessionID2}`,
        `loop_enabled=${state2.loopEnabled}`,
        `auto_continue=${state2.autoContinue}`,
        `max_iterations_per_window=${state2.maxIterationsPerWindow}`,
        `iteration_completed=${state2.iterationCompleted}`,
        `window_start_iteration=${state2.windowStartIteration}`,
        `awaiting_confirmation=${state2.awaitingConfirmation}`,
        `strict_quality_gate=${state2.strictQualityGate}`,
        `last_done=${state2.lastDone.length}`,
        `last_missing=${state2.lastMissing.length}`,
        `last_unresolved=${state2.lastUnresolved.length}`
      ].join("\n");
    }
  });
  const strict_quality_gate_set = tool({
    description: "Enable or disable strict quality gate mode for this session.",
    args: {
      enabled: z17.boolean()
    },
    async execute(args, toolContext) {
      const sessionID2 = toolContext && typeof toolContext === "object" && "sessionID" in toolContext ? String(toolContext.sessionID) : "unknown";
      if (sessionID2 === "unknown") {
        return "Session id unavailable.";
      }
      const current = getSessionState(projectDir, sessionID2);
      current.strictQualityGate = Boolean(args.enabled);
      setSessionState(projectDir, sessionID2, current);
      return `strict_quality_gate=${current.strictQualityGate}`;
    }
  });
  return {
    save_work,
    load_work,
    check_work,
    quality_gate,
    cancel_work,
    loop_state,
    strict_quality_gate_set,
    miya_iteration_done
  };
}

// src/tools/learning.ts
var z18 = tool.schema;
function createLearningTools(projectDir) {
  const miya_learning_drafts = tool({
    description: "Inspect/recommend/approve learning skill drafts generated from Ralph + memory-reflect.",
    args: {
      mode: z18.enum(["list", "recommend", "accept", "reject", "stats"]).default("stats"),
      id: z18.string().optional(),
      query: z18.string().optional(),
      threshold: z18.number().optional(),
      limit: z18.number().optional()
    },
    async execute(args) {
      const mode = String(args.mode ?? "stats");
      if (mode === "list") {
        const drafts = listSkillDrafts(projectDir, {
          limit: typeof args.limit === "number" ? Number(args.limit) : 30
        });
        if (drafts.length === 0) return "learning_drafts=empty";
        return drafts.map(
          (item) => [
            `id=${item.id}`,
            `status=${item.status}`,
            `source=${item.source}`,
            `confidence=${item.confidence.toFixed(2)}`,
            `uses=${item.uses}`,
            `hit_rate=${item.uses > 0 ? (item.hits / item.uses).toFixed(2) : "0.00"}`,
            `title=${item.title}`
          ].join(" | ")
        ).join("\n");
      }
      if (mode === "recommend") {
        const query = String(args.query ?? "").trim();
        if (!query) return "error=query_required";
        const result = buildLearningInjection(projectDir, query, {
          threshold: typeof args.threshold === "number" ? Number(args.threshold) : void 0,
          limit: typeof args.limit === "number" ? Number(args.limit) : void 0
        });
        if (!result.snippet) return "learning_recommendation=none";
        return [result.snippet, `matched=${result.matchedDraftIDs.join(",")}`].join("\n");
      }
      if (mode === "accept" || mode === "reject") {
        const id = String(args.id ?? "").trim();
        if (!id) return "error=id_required";
        const updated = setSkillDraftStatus(projectDir, id, mode === "accept" ? "accepted" : "rejected");
        if (!updated) return "error=draft_not_found";
        return `updated=true
id=${updated.id}
status=${updated.status}`;
      }
      const stats = getLearningStats(projectDir);
      return [
        `total=${stats.total}`,
        `draft=${stats.byStatus.draft}`,
        `recommended=${stats.byStatus.recommended}`,
        `accepted=${stats.byStatus.accepted}`,
        `rejected=${stats.byStatus.rejected}`,
        `uses=${stats.totalUses}`,
        `hit_rate=${stats.hitRate}`
      ].join("\n");
    }
  });
  return {
    miya_learning_drafts
  };
}

// src/config/runtime-merge.ts
function mergePluginAgentConfigs(existingAgents, pluginAgents) {
  const next = {
    ...existingAgents ?? {}
  };
  for (const [agentName, pluginAgent] of Object.entries(pluginAgents)) {
    const existing = next[agentName];
    if (!existing || typeof existing !== "object") {
      next[agentName] = { ...pluginAgent };
      continue;
    }
    const pluginPermission = pluginAgent.permission && typeof pluginAgent.permission === "object" && !Array.isArray(pluginAgent.permission) ? pluginAgent.permission : {};
    const existingPermission = existing.permission && typeof existing.permission === "object" && !Array.isArray(existing.permission) ? existing.permission : {};
    next[agentName] = {
      ...pluginAgent,
      ...existing,
      permission: {
        ...pluginPermission,
        ...existingPermission
      }
    };
  }
  return next;
}

// src/index.ts
function isPlainObject3(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function deepMergeObject(base, override) {
  const result = { ...base };
  for (const [key, overrideValue] of Object.entries(override)) {
    const baseValue = result[key];
    if (isPlainObject3(baseValue) && isPlainObject3(overrideValue)) {
      result[key] = deepMergeObject(baseValue, overrideValue);
      continue;
    }
    result[key] = overrideValue;
  }
  return result;
}
var autoUiOpenAtByDir = /* @__PURE__ */ new Map();
var dockLaunchAtByDir = /* @__PURE__ */ new Map();
function resolveMiyaRoot(projectDir) {
  const nestedRoot = path51.join(projectDir, "miya-src");
  if (fs50.existsSync(path51.join(nestedRoot, "src", "index.ts"))) {
    return nestedRoot;
  }
  if (fs50.existsSync(path51.join(projectDir, "src", "index.ts"))) {
    return projectDir;
  }
  return nestedRoot;
}
function autoUiOpenGuardFile(projectDir) {
  return path51.join(projectDir, ".opencode", "miya", "ui-auto-open.guard.json");
}
function dockLaunchGuardFile(projectDir) {
  return path51.join(projectDir, ".opencode", "miya", "dock-launch.guard.json");
}
function readLaunchGuard(file3) {
  if (!fs50.existsSync(file3)) return { atMs: 0, pid: 0 };
  try {
    const parsed = JSON.parse(fs50.readFileSync(file3, "utf-8"));
    const atMs = Number(parsed?.atMs ?? 0);
    const pid = Number(parsed?.pid ?? 0);
    return {
      atMs: Number.isFinite(atMs) ? atMs : 0,
      pid: Number.isFinite(pid) ? pid : 0
    };
  } catch {
    return { atMs: 0, pid: 0 };
  }
}
function readLastAutoUiOpen(projectDir) {
  return readLaunchGuard(autoUiOpenGuardFile(projectDir));
}
function writeLaunchGuard(file3, atMs, pid) {
  fs50.mkdirSync(path51.dirname(file3), { recursive: true });
  fs50.writeFileSync(
    file3,
    `${JSON.stringify({ atMs, pid, at: new Date(atMs).toISOString() }, null, 2)}
`,
    "utf-8"
  );
}
function writeLastAutoUiOpenAt(projectDir, atMs) {
  writeLaunchGuard(autoUiOpenGuardFile(projectDir), atMs, process.pid);
}
function readLastDockLaunch(projectDir) {
  return readLaunchGuard(dockLaunchGuardFile(projectDir));
}
function writeLastDockLaunchAt(projectDir, atMs) {
  writeLaunchGuard(dockLaunchGuardFile(projectDir), atMs, process.pid);
}
function isPidAlive2(pid) {
  if (!Number.isFinite(pid) || pid <= 0) return false;
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
function openUrlSilently(url3) {
  if (process.platform === "win32") {
    const child2 = spawn6("explorer.exe", [url3], {
      detached: true,
      stdio: "ignore",
      windowsHide: true
    });
    child2.unref();
    return;
  }
  if (process.platform === "darwin") {
    const child2 = spawn6("open", [url3], {
      detached: true,
      stdio: "ignore"
    });
    child2.unref();
    return;
  }
  const child = spawn6("xdg-open", [url3], {
    detached: true,
    stdio: "ignore"
  });
  child.unref();
}
function launchDockSilently(projectDir) {
  if (process.platform !== "win32") return;
  const miyaRoot = resolveMiyaRoot(projectDir);
  const pidFile = path51.join(miyaRoot, "tools", "miya-dock", "miya-dock.pid");
  if (fs50.existsSync(pidFile)) {
    try {
      const pid = Number(fs50.readFileSync(pidFile, "utf-8").trim());
      if (isPidAlive2(pid)) return;
    } catch {
    }
  }
  const dockScript = path51.join(miyaRoot, "tools", "miya-dock", "miya-dock.ps1");
  const bat = path51.join(miyaRoot, "tools", "miya-dock", "miya-launch.bat");
  if (!fs50.existsSync(dockScript) && !fs50.existsSync(bat)) return;
  const now = Date.now();
  const memLast = dockLaunchAtByDir.get(projectDir) ?? 0;
  const persisted = readLastDockLaunch(projectDir);
  const cooldownMs = 5 * 6e4;
  const throttleByPersisted = persisted.atMs > 0 && isPidAlive2(persisted.pid) && now - persisted.atMs < cooldownMs;
  if (now - memLast < 15e3 || throttleByPersisted) {
    return;
  }
  dockLaunchAtByDir.set(projectDir, now);
  writeLastDockLaunchAt(projectDir, now);
  const child = fs50.existsSync(dockScript) ? spawn6(
    "powershell.exe",
    [
      "-NoLogo",
      "-NoProfile",
      "-WindowStyle",
      "Hidden",
      "-ExecutionPolicy",
      "Bypass",
      "-File",
      dockScript,
      "-ProjectRoot",
      projectDir,
      "-TryStartGateway"
    ],
    {
      cwd: projectDir,
      detached: true,
      stdio: "ignore",
      windowsHide: true
    }
  ) : spawn6("cmd", ["/c", bat], {
    cwd: projectDir,
    detached: true,
    stdio: "ignore",
    windowsHide: true
  });
  child.unref();
}
function gatewayTerminalLockFile(projectDir) {
  return path51.join(projectDir, ".opencode", "miya", "gateway-terminal.lock.json");
}
function gatewayTerminalLaunchGuardFile(projectDir) {
  return path51.join(projectDir, ".opencode", "miya", "gateway-terminal-launch.guard.json");
}
function writeLastGatewayTerminalLaunchAt(projectDir, atMs) {
  const file3 = gatewayTerminalLaunchGuardFile(projectDir);
  fs50.mkdirSync(path51.dirname(file3), { recursive: true });
  fs50.writeFileSync(
    file3,
    `${JSON.stringify({ atMs, pid: process.pid, at: new Date(atMs).toISOString() }, null, 2)}
`,
    "utf-8"
  );
}
function readGatewayTerminalOwnerPid(projectDir) {
  const file3 = gatewayTerminalLockFile(projectDir);
  if (!fs50.existsSync(file3)) return 0;
  try {
    const parsed = JSON.parse(fs50.readFileSync(file3, "utf-8"));
    const pid = Number(parsed.pid ?? 0);
    return Number.isFinite(pid) ? pid : 0;
  } catch {
    return 0;
  }
}
function resolveGatewayTerminalNodeBinary() {
  const candidates = [
    process.env.MIYA_NODE_BIN?.trim() || null,
    process.execPath,
    process.platform === "win32" ? "node.exe" : "node"
  ].filter((item) => Boolean(item));
  for (const candidate of candidates) {
    try {
      const probe = spawnSync9(candidate, ["--version"], {
        stdio: "ignore",
        timeout: 2e3,
        windowsHide: true
      });
      if (probe.status === 0) return candidate;
    } catch {
    }
  }
  return null;
}
function launchGatewayTerminalDetached(projectDir) {
  if (process.platform !== "win32") return;
  const lockPid = readGatewayTerminalOwnerPid(projectDir);
  if (isPidAlive2(lockPid)) return;
  const now = Date.now();
  const last = readLaunchGuard(gatewayTerminalLaunchGuardFile(projectDir));
  if (last.atMs > 0 && now - last.atMs < 2e4) return;
  const nodeBinary = resolveGatewayTerminalNodeBinary();
  if (!nodeBinary) return;
  const miyaRoot = resolveMiyaRoot(projectDir);
  const distCli = path51.join(miyaRoot, "dist", "cli", "index.js");
  const srcCli = path51.join(miyaRoot, "src", "cli", "index.ts");
  const script = fs50.existsSync(distCli) && fs50.statSync(distCli).isFile() ? `"${nodeBinary}" "${distCli}" gateway terminal --workspace "${projectDir}"` : fs50.existsSync(srcCli) && fs50.statSync(srcCli).isFile() ? `"${nodeBinary}" --import tsx "${srcCli}" gateway terminal --workspace "${projectDir}"` : "";
  if (!script) return;
  writeLastGatewayTerminalLaunchAt(projectDir, now);
  const cmdLine = `start "miya-gateway" cmd /k ${script}`;
  const child = spawn6("cmd.exe", ["/d", "/c", cmdLine], {
    cwd: projectDir,
    detached: true,
    stdio: "ignore",
    windowsHide: true
  });
  child.unref();
}
function shouldAutoOpenUi(projectDir, cooldownMs) {
  const last = autoUiOpenAtByDir.get(projectDir) ?? 0;
  const persisted = readLastAutoUiOpen(projectDir);
  const now = Date.now();
  const minCooldownMs = Math.max(1e4, Math.min(cooldownMs, 24 * 6e4));
  if (now - last < 1e4) return false;
  if (persisted.atMs > 0 && isPidAlive2(persisted.pid) && now - persisted.atMs < minCooldownMs) {
    return false;
  }
  autoUiOpenAtByDir.set(projectDir, now);
  writeLastAutoUiOpenAt(projectDir, now);
  return true;
}
function isInteractiveSession() {
  return Boolean(process.stdin.isTTY && process.stdout.isTTY);
}
function parseModelRef(model) {
  if (typeof model !== "string") return null;
  const text = model.trim();
  if (!text) return null;
  const slash = text.indexOf("/");
  if (slash <= 0 || slash >= text.length - 1) return null;
  return {
    providerID: text.slice(0, slash),
    modelID: text.slice(slash + 1)
  };
}
var LEGACY_MODEL_REWRITE2 = {
  "openrouter/minimax/z-ai/glm-5": "openrouter/z-ai/glm-5"
};
function providerHasModel(providerMap, model) {
  const parsed = parseModelRef(model);
  if (!parsed) return false;
  const provider = providerMap[parsed.providerID];
  if (!isPlainObject3(provider)) return null;
  const models = provider.models;
  if (!isPlainObject3(models)) return null;
  return Object.hasOwn(models, parsed.modelID);
}
function sanitizeConfiguredAgentModels(opencodeConfig) {
  const agentMap = isPlainObject3(opencodeConfig.agent) ? opencodeConfig.agent : {};
  const providerMap = isPlainObject3(opencodeConfig.provider) ? opencodeConfig.provider : {};
  const adjusted = [];
  for (const [agentName, rawAgent] of Object.entries(agentMap)) {
    if (!isPlainObject3(rawAgent)) continue;
    const modelRaw = typeof rawAgent.model === "string" ? rawAgent.model.trim() : "";
    const model = LEGACY_MODEL_REWRITE2[modelRaw] ?? modelRaw;
    if (!model) continue;
    if (model !== modelRaw) {
      rawAgent.model = model;
      adjusted.push({ agent: agentName, from: modelRaw, to: model });
      continue;
    }
    const exists = providerHasModel(providerMap, model);
    if (exists === null) continue;
    if (exists) continue;
    delete rawAgent.model;
    delete rawAgent.providerID;
    adjusted.push({ agent: agentName, from: model, to: null });
  }
  return { adjusted };
}
var MiyaPlugin = async (ctx) => {
  const config3 = loadPluginConfig(ctx.directory);
  const agents = getAgentConfigs(config3, ctx.directory);
  const tmuxConfig = {
    enabled: config3.tmux?.enabled ?? false,
    layout: config3.tmux?.layout ?? "main-vertical",
    main_pane_size: config3.tmux?.main_pane_size ?? 60
  };
  log("[plugin] initialized with tmux config", {
    tmuxConfig,
    rawTmuxConfig: config3.tmux,
    directory: ctx.directory
  });
  if (tmuxConfig.enabled) {
    startTmuxCheck();
  }
  const backgroundManager = new BackgroundTaskManager(ctx, tmuxConfig, config3);
  const dashboardConfig = config3.ui?.dashboard ?? {};
  const gatewayTerminalAutoStart = process.platform === "win32" && process.env.MIYA_GATEWAY_TERMINAL_AUTO_START !== "0" && dashboardConfig.gatewayTerminalAutoStart !== false;
  if (gatewayTerminalAutoStart) {
    launchGatewayTerminalDetached(ctx.directory);
  } else {
    startGatewayWithLog(ctx.directory);
  }
  const gatewayOwner = isGatewayOwner(ctx.directory);
  const autoOpenEnabled = dashboardConfig.openOnStart !== false;
  const autoOpenBlockedByEnv = process.env.MIYA_AUTO_UI_OPEN === "0";
  const autoOpenCooldownMs = typeof dashboardConfig.autoOpenCooldownMs === "number" ? Math.max(1e4, Math.min(24 * 6e4, Math.floor(Number(dashboardConfig.autoOpenCooldownMs)))) : 2 * 6e4;
  const dockAutoLaunch = process.env.MIYA_DOCK_AUTO_LAUNCH === "1" || dashboardConfig.dockAutoLaunch === true || process.platform === "win32" && dashboardConfig.dockAutoLaunch !== false;
  const interactiveSession = isInteractiveSession();
  const allowAutoOpenWithoutTty = process.env.MIYA_AUTO_UI_OPEN_NO_TTY === "1" || process.platform === "win32" && process.env.MIYA_AUTO_UI_OPEN_NO_TTY !== "0";
  const canAutoOpenInSession = interactiveSession || allowAutoOpenWithoutTty;
  if (autoOpenEnabled && !autoOpenBlockedByEnv && canAutoOpenInSession && shouldAutoOpenUi(ctx.directory, autoOpenCooldownMs)) {
    setTimeout(async () => {
      try {
        const state2 = ensureGatewayRunning(ctx.directory);
        const healthy = await probeGatewayAlive(state2.url, 1500);
        if (!healthy) {
          log("[miya] auto ui open skipped: gateway unhealthy", { url: state2.url });
          return;
        }
        if (dockAutoLaunch) {
          launchDockSilently(ctx.directory);
        } else {
          openUrlSilently(state2.url);
        }
        log("[miya] auto ui open triggered", {
          url: state2.url,
          dockAutoLaunch,
          cooldownMs: autoOpenCooldownMs
        });
      } catch (error92) {
        log("[miya] auto ui open failed", {
          error: error92 instanceof Error ? error92.message : String(error92)
        });
      }
    }, 1200);
  } else {
    log("[miya] auto ui open skipped", {
      autoOpenEnabled,
      autoOpenBlockedByEnv,
      interactiveSession,
      canAutoOpenInSession,
      cooldownMs: autoOpenCooldownMs
    });
  }
  if (gatewayOwner) {
    const daemonLaunch = ensureMiyaLauncher(ctx.directory);
    log("[miya-launcher] daemon bootstrap", daemonLaunch);
    setTimeout(async () => {
      try {
        const daemon = getLauncherDaemonSnapshot(ctx.directory);
        await ctx.client.tui.showToast({
          query: { directory: ctx.directory },
          body: {
            title: "Miya",
            message: daemon.connected ? "Miya Daemon Connected" : daemon.statusText || "Miya Daemon Connecting",
            variant: daemon.connected ? "success" : "info",
            duration: 3e3
          }
        });
      } catch {
      }
    }, 4e3);
    subscribeLauncherEvents(ctx.directory, (event) => {
      if (event.type !== "job.progress") return;
      const status = String(event.payload?.status ?? "").trim().toLowerCase();
      if (status !== "completed" && status !== "failed" && status !== "degraded" && status !== "canceled") {
        return;
      }
      const jobID = String(event.payload?.jobID ?? event.snapshot.activeJobID ?? "").trim();
      const phase = String(event.payload?.phase ?? "").trim();
      const progress = Number(event.payload?.progress ?? 0);
      const messageParts = [`job=${jobID || "unknown"}`, `status=${status}`];
      if (phase) messageParts.push(`phase=${phase}`);
      if (Number.isFinite(progress)) messageParts.push(`progress=${Math.floor(progress)}%`);
      void ctx.client.tui.showToast({
        query: { directory: ctx.directory },
        body: {
          title: "Miya Job",
          message: messageParts.join(" | "),
          variant: status === "completed" ? "success" : status === "failed" ? "error" : "info",
          duration: 3500
        }
      }).catch(() => {
      });
    });
  } else {
    log("[miya] follower instance detected; skip daemon bootstrap/toast", {
      directory: ctx.directory
    });
  }
  const automationService = new MiyaAutomationService(ctx.directory);
  if (gatewayOwner) {
    automationService.start();
  }
  registerGatewayDependencies(ctx.directory, {
    client: ctx.client,
    backgroundManager,
    automationService,
    extraSkillDirs: []
  });
  const backgroundTools = createBackgroundTools(
    ctx,
    backgroundManager,
    tmuxConfig,
    config3
  );
  const automationTools = createAutomationTools(automationService);
  const workflowTools = createWorkflowTools(ctx.directory);
  const learningTools = createLearningTools(ctx.directory);
  const autopilotTools = createAutopilotTools(ctx.directory);
  const autoflowTools = createAutoflowTools(ctx.directory, backgroundManager);
  const ralphTools = createRalphTools(ctx.directory);
  const nodeTools = createNodeTools(ctx.directory);
  const multimodalTools = createMultimodalTools(ctx.directory);
  const soulTools = createSoulTools(ctx.directory);
  const ultraworkTools = createUltraworkTools(ctx, backgroundManager);
  const routerTools = createRouterTools(ctx.directory);
  const mcpTools = createMcpTools();
  const safetyTools = createSafetyTools(ctx);
  const configTools = createConfigTools(ctx);
  const intakeTools = createIntakeTools(ctx);
  const gatewayTools = createGatewayTools(ctx);
  const defaultDisabledMcps = [];
  const disabledMcps = config3.disabled_mcps ?? defaultDisabledMcps;
  const mcps = createBuiltinMcps(disabledMcps);
  const tmuxSessionManager = new TmuxSessionManager(ctx, tmuxConfig);
  const loopGuardHook = createLoopGuardHook(ctx.directory);
  const persistentAutoflowHook = createPersistentAutoflowHook(
    ctx.directory,
    backgroundManager
  );
  const phaseReminderHook = createPhaseReminderHook();
  const slashCommandBridgeHook = createSlashCommandBridgeHook();
  const postReadNudgeHook = createPostReadNudgeHook();
  const postWriteSimplicityHook = createPostWriteSimplicityHook();
  const contextGovernorHook = createContextGovernorHook(config3.contextGovernance);
  const slimCompatEnabled = config3.slimCompat?.enabled ?? true;
  const postWriteSimplicityEnabled = slimCompatEnabled && (config3.slimCompat?.enablePostWriteSimplicityNudge ?? true);
  const onPermissionAsked = async (input, output) => {
    const _ = output;
    const patterns = Array.isArray(input.pattern) ? input.pattern.map(String) : typeof input.pattern === "string" ? [String(input.pattern)] : [];
    log("[miya] permission.ask observed", {
      sessionID: String(input.sessionID ?? "main"),
      permission: String(input.type ?? ""),
      messageID: input.messageID ? String(input.messageID) : void 0,
      callID: input.callID ? String(input.callID) : void 0,
      patterns
    });
  };
  const onToolExecuteBefore = async (input, output) => {
    const tool2 = String(input.tool ?? "");
    const sessionID2 = String(input.sessionID ?? "main");
    const callID = typeof input.callID === "string" ? input.callID : void 0;
    const argSummary = [];
    if (output.args && typeof output.args === "object") {
      for (const [key, value] of Object.entries(output.args)) {
        if (typeof value === "string") {
          argSummary.push(`${key}=${value.slice(0, 180)}`);
          continue;
        }
        if (Array.isArray(value)) {
          const items = value.map((item) => typeof item === "string" ? item : "").filter(Boolean).slice(0, 8).join(",");
          if (items) argSummary.push(`${key}=[${items.slice(0, 180)}]`);
        }
      }
    }
    const intakeGate = shouldInterceptWriteAfterWebsearch(ctx.directory, {
      sessionID: sessionID2,
      permission: tool2
    });
    if (intakeGate.intercept) {
      throw new Error("miya_intake_gate_blocked:write_after_websearch_requires_revalidation");
    }
    const safety = await handlePermissionAsk(ctx.directory, {
      sessionID: sessionID2,
      permission: tool2,
      patterns: argSummary,
      metadata: output.args && typeof output.args === "object" ? output.args : {},
      toolCallID: callID
    });
    if (safety.status === "deny") {
      throw new Error(`miya_safety_gate_denied:${safety.reason}`);
    }
  };
  const onToolExecuteAfter = async (input, output) => {
    await postReadNudgeHook["tool.execute.after"](input, output);
    if (postWriteSimplicityEnabled) {
      await postWriteSimplicityHook["tool.execute.after"](input, output);
    }
    await contextGovernorHook["tool.execute.after"](input, output);
    trackWebsearchToolOutput(
      typeof input.sessionID === "string" ? input.sessionID : "main",
      String(input.tool ?? ""),
      String(output.output ?? "")
    );
  };
  assertRequiredHookHandlers({
    "tool.execute.before": onToolExecuteBefore,
    "tool.execute.after": onToolExecuteAfter,
    "permission.ask": onPermissionAsked
  });
  return {
    name: "miya",
    agent: agents,
    tool: {
      ...backgroundTools,
      ...automationTools,
      ...workflowTools,
      ...learningTools,
      ...autopilotTools,
      ...autoflowTools,
      ...ralphTools,
      ...nodeTools,
      ...multimodalTools,
      ...soulTools,
      ...ultraworkTools,
      ...routerTools,
      ...mcpTools,
      ...safetyTools,
      ...configTools,
      ...intakeTools,
      ...gatewayTools,
      lsp_goto_definition,
      lsp_find_references,
      lsp_diagnostics,
      lsp_rename,
      grep,
      ast_grep_search,
      ast_grep_replace
    },
    mcp: mcps,
    config: async (opencodeConfig) => {
      const persistedRuntime = readPersistedAgentRuntime(ctx.directory);
      const existingDefaultAgent = normalizeAgentName(
        String(
          opencodeConfig.default_agent ?? opencodeConfig.defaultAgent ?? ""
        )
      ) ?? void 0;
      if (!existingDefaultAgent) {
        opencodeConfig.default_agent = persistedRuntime.activeAgentId ?? "1-task-manager";
      }
      const commandConfig = opencodeConfig.command ?? {};
      opencodeConfig.command = commandConfig;
      if (!commandConfig.miya) {
        commandConfig.miya = {
          description: "Open Miya control plane panel",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_status_panel` exactly once. Return only the tool output verbatim. If tool invocation fails, return the exact error text only."
        };
      }
      if (!commandConfig["miya-schedule"]) {
        commandConfig["miya-schedule"] = {
          description: "Create daily schedule from natural language",
          agent: "1-task-manager",
          template: 'MANDATORY: Call tool `miya_schedule_from_text` with request="$ARGUMENTS". Return only tool output.'
        };
      }
      if (!commandConfig["miya-jobs"]) {
        commandConfig["miya-jobs"] = {
          description: "List Miya jobs",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_list_jobs` once. Return only tool output."
        };
      }
      if (!commandConfig["miya-approvals"]) {
        commandConfig["miya-approvals"] = {
          description: "List pending Miya approvals",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_list_approvals` once. Return only tool output."
        };
      }
      if (!commandConfig["miya-history"]) {
        commandConfig["miya-history"] = {
          description: "Show recent Miya automation history",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_job_history` with limit=20. Return only tool output."
        };
      }
      if (!commandConfig["miya-safety"]) {
        commandConfig["miya-safety"] = {
          description: "Show Miya safety status (kill-switch and approvals)",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_kill_status` once. Then summarize latest `miya_status_panel` in 5 lines max."
        };
      }
      if (!commandConfig["miya-gateway-start"]) {
        commandConfig["miya-gateway-start"] = {
          description: "Start Miya Gateway and print runtime URL",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_gateway_start` exactly once. Return only tool output. If tool call fails, return exact error text only."
        };
      }
      if (!commandConfig["miya-gateway-shutdown"]) {
        commandConfig["miya-gateway-shutdown"] = {
          description: "Stop Miya Gateway runtime",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_gateway_shutdown` exactly once. Return only tool output."
        };
      }
      if (!commandConfig["miya-ui-open"]) {
        commandConfig["miya-ui-open"] = {
          description: "Open Miya web control console in default browser",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_ui_open` exactly once. Return only tool output."
        };
      }
      if (!commandConfig["miya-config-get"]) {
        commandConfig["miya-config-get"] = {
          description: "Read Miya config key",
          agent: "1-task-manager",
          template: 'MANDATORY: Call tool `miya_config_get` with key="$ARGUMENTS". Return only tool output.'
        };
      }
      if (!commandConfig["miya-config-validate"]) {
        commandConfig["miya-config-validate"] = {
          description: "Validate Miya config patch JSON",
          agent: "1-task-manager",
          template: "MANDATORY: Parse $ARGUMENTS as JSON patch payload, then call tool `miya_config_validate`. Return only tool output."
        };
      }
      if (!commandConfig["miya-intake"]) {
        commandConfig["miya-intake"] = {
          description: "List intake gate pending/allow/deny records",
          agent: "1-task-manager",
          template: 'MANDATORY: Call tool `miya_intake_list` with target="all". Return only tool output.'
        };
      }
      if (!commandConfig["miya-intake-pending"]) {
        commandConfig["miya-intake-pending"] = {
          description: "List pending intake proposals",
          agent: "1-task-manager",
          template: 'MANDATORY: Call tool `miya_intake_list` with target="pending". Return only tool output.'
        };
      }
      if (!commandConfig.miya_gateway_start) {
        commandConfig.miya_gateway_start = { ...commandConfig["miya-gateway-start"] };
      }
      if (!commandConfig.miya_gateway_shutdown) {
        commandConfig.miya_gateway_shutdown = {
          ...commandConfig["miya-gateway-shutdown"]
        };
      }
      if (!commandConfig["miya.gateway.start"]) {
        commandConfig["miya.gateway.start"] = {
          description: "Alias of miya-gateway-start",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_gateway_start` exactly once. Return only tool output. If tool call fails, return exact error text only."
        };
      }
      if (!commandConfig["miya.gateway.shutdown"]) {
        commandConfig["miya.gateway.shutdown"] = {
          description: "Alias of miya-gateway-shutdown",
          agent: "1-task-manager",
          template: "MANDATORY: Call tool `miya_gateway_shutdown` exactly once. Return only tool output."
        };
      }
      opencodeConfig.agent = mergePluginAgentConfigs(
        opencodeConfig.agent,
        agents
      );
      const configAgent = opencodeConfig.agent;
      const existingProvider = isPlainObject3(opencodeConfig.provider) ? opencodeConfig.provider : {};
      const pluginProvider = isPlainObject3(config3.provider) ? config3.provider : {};
      opencodeConfig.provider = deepMergeObject(existingProvider, pluginProvider);
      const sanitizeResult = sanitizeConfiguredAgentModels(opencodeConfig);
      if (sanitizeResult.adjusted.length > 0) {
        log("[model-persistence] sanitized invalid agent model assignments", {
          adjusted: sanitizeResult.adjusted
        });
      }
      const configMcp = opencodeConfig.mcp;
      if (!configMcp) {
        opencodeConfig.mcp = { ...mcps };
      } else {
        Object.assign(configMcp, mcps);
      }
      const allMcpNames = Object.keys(mcps);
      for (const [agentName, agentConfig] of Object.entries(agents)) {
        const agentMcps = agentConfig?.mcps;
        if (!agentMcps) continue;
        if (!configAgent[agentName]) {
          configAgent[agentName] = { ...agentConfig };
        }
        const agentConfigEntry = configAgent[agentName];
        const agentPermission = agentConfigEntry.permission ?? {};
        const allowedMcps = parseList(agentMcps, allMcpNames);
        for (const mcpName of allMcpNames) {
          const sanitizedMcpName = mcpName.replace(/[^a-zA-Z0-9_-]/g, "_");
          const permissionKey = `${sanitizedMcpName}_*`;
          const action = allowedMcps.includes(mcpName) ? "allow" : "deny";
          if (!(permissionKey in agentPermission)) {
            agentPermission[permissionKey] = action;
          }
        }
        agentConfigEntry.permission = agentPermission;
      }
      const syncResult = persistAgentRuntimeFromConfigSnapshot(
        ctx.directory,
        opencodeConfig
      );
      if (syncResult.updated > 0) {
        log("[model-persistence] synchronized from opencode config snapshot", {
          updated: syncResult.updated,
          activeAgentId: syncResult.activeAgentId
        });
      }
    },
    event: async (input) => {
      const selections = extractAgentModelSelectionsFromEvent(input.event);
      for (const modelSelection of selections) {
        const changed = persistAgentRuntimeSelection(ctx.directory, {
          agentName: modelSelection.agentName,
          model: modelSelection.model,
          variant: modelSelection.variant,
          providerID: modelSelection.providerID,
          options: modelSelection.options,
          apiKey: modelSelection.apiKey,
          baseURL: modelSelection.baseURL,
          activeAgentId: modelSelection.activeAgentId
        });
        if (changed) {
          log(`[model-persistence] updated from ${modelSelection.source}`, {
            agent: modelSelection.agentName,
            model: modelSelection.model
          });
          const optionKeys = modelSelection.options && typeof modelSelection.options === "object" && !Array.isArray(modelSelection.options) ? Object.keys(modelSelection.options) : [];
          if (optionKeys.length > 0 || typeof modelSelection.providerID === "string" && modelSelection.providerID.trim().length > 0 || typeof modelSelection.apiKey === "string" && modelSelection.apiKey.trim().length > 0 || typeof modelSelection.baseURL === "string" && modelSelection.baseURL.trim().length > 0) {
            appendProviderOverrideAudit(ctx.directory, {
              source: modelSelection.source,
              agentName: modelSelection.agentName,
              model: modelSelection.model,
              providerID: modelSelection.providerID,
              activeAgentId: modelSelection.activeAgentId,
              hasApiKey: typeof modelSelection.apiKey === "string" && modelSelection.apiKey.trim().length > 0,
              hasBaseURL: typeof modelSelection.baseURL === "string" && modelSelection.baseURL.trim().length > 0,
              optionKeys
            });
          }
        }
      }
      await tmuxSessionManager.onSessionCreated(
        input.event
      );
      await backgroundManager.handleSessionStatus(
        input.event
      );
      await persistentAutoflowHook.onEvent(
        input.event
      );
      await tmuxSessionManager.onSessionStatus(
        input.event
      );
      await tmuxSessionManager.onSessionDeleted(
        input.event
      );
      void automationService.tick();
    },
    // Inject loop guard + phase reminder before sending to API.
    "experimental.chat.messages.transform": async (input, output) => {
      await slashCommandBridgeHook["experimental.chat.messages.transform"](
        input,
        output
      );
      await loopGuardHook["experimental.chat.messages.transform"](input, output);
      await phaseReminderHook["experimental.chat.messages.transform"](input, output);
      await contextGovernorHook["experimental.chat.messages.transform"](input, output);
    },
    // Nudge after file reads to encourage delegation + track websearch usage for intake gate
    "tool.execute.before": async (input, output) => {
      await onToolExecuteBefore(input, output);
    },
    // Nudge after file reads to encourage delegation + track websearch usage for intake gate
    "tool.execute.after": onToolExecuteAfter,
    // OpenCode permission hook key from @opencode-ai/plugin types.
    "permission.ask": onPermissionAsked
  };
};
var index_default = MiyaPlugin;
export {
  index_default as default
};
