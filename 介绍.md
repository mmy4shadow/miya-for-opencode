根据下面的要求优化和修改miya插件，

Miya = OpenCode 里的全自动控制平面（Autopilot）：你只给目标/要求（文字或语音），它自动组织多角色 Agents 在 OpenCode 原生会话里完成编程、浏览器与桌面操作、消息投递与日程自动化；不向你要逐步批准，而是每次行动前做一轮“自我审批（自检 + 验证 + 回滚预案）”，并在失败时最多进行 3 次完整的内部对话循环自我修复，过程不打断你。
它的控制台形态对齐 OpenClaw：Gateway 长驻 + 同端口 Web 控制台 + Node 执行体（语音/桌面/浏览器）通过 WebSocket 统一连接。

1）你打开 OpenCode 后，Miya 是什么样
1.1 Chat：完全用 OpenCode 原生（你不需要“换聊天”）

你日常聊天、上下文、会话记录、子任务会话、工具调用展示……全部仍在 OpenCode 原生 Chat 里。

语音指令也不会跑到“另一个聊天框”：语音只是输入方式，最终仍然变成 OpenCode 会话里的一条消息。

OpenCode 的 agent 体系本来就支持 primary/subagent、以及“不同 agent 不同工具权限”的机制（例如 Build 全开、Plan 受限），Miya 只是把这些原生能力变成自动编队。

1.2 左侧 “Miya” 控制台：只管“驾驶舱”，不抢 Chat

Miya 在左侧新增一个栏目（或等价的内嵌面板），里面不是聊天，而是 6 个“驾驶舱页面”：

Autopilot 状态：当前任务、进度、正在跑的 agents、当前循环次数（0/3、1/3…）

Self-Approval（自我审批）记录：每一步动作的自检结论、证据、回滚点

Runtime：语音/桌面/浏览器节点在线状态与权限状态（Accessibility/Screen Recording 等）

Jobs（自动化）：定时/触发任务列表、执行历史、失败摘要（无需你审批）

Skills（包管理）：按项目启用/禁用技能包、更新、版本锁定

Kill Switch：一键停机（立即停止桌面输入、停止外发消息、停止 exec、停止浏览器动作）

控制台的技术形态与 OpenClaw Control UI 类似：由网关提供静态 SPA，并直接通过同端口 WebSocket 和网关通信。

2）“不需要你审批”的含义：Miya 仍然有“权限”，但用的是 全自动自检互锁

你说“像 OpenClaw 一样给足权限”，这在 OpenClaw 的语义里对应：

exec.security = full：允许一切（跳过 allowlist 限制）

exec.ask = off：不提示、不等待人类批准
并且文档明确提到 /exec security=full 会按设计跳过 approvals。

Miya 成品默认就是这种“全权 Autopilot”：
你不再点“批准/拒绝”，你只给“目标 + 约束”，Miya 自己决定怎么做。

但为了不把机器玩崩，Miya 会把“审批”从“你审批”换成“它自己审批”，具体是：

2.1 自我审批（Self-Approval）= 两个代理签字 + 证据必须齐

每一个“有副作用”的动作（写文件、运行命令、发消息、桌面点击、删除/覆盖等）都必须通过同一套自我审批流程：

**Executor（执行官）**提出动作计划：要做什么、怎么做、预期结果

**Architect/Verifier（审计官）**在执行前做验证：

需要什么证据能证明“动作是对的/安全的”

运行哪些验证（测试、lint、dry-run、截图对比、幂等检查）

失败如何回滚

只有当 Verifier 给出“可执行”结论，Executor 才会真正下手。

这和 oh-my-claudecode 的“architect verification”“verification tiers（LIGHT/STANDARD/THOROUGH）”思想一致：没有新鲜验证证据就不允许宣称完成。

2.2 自我审批的输出会写进驾驶舱（可追责、可复盘）

你不需要点确认，但你随时可以打开“Self-Approval”页看到它每一步为什么这么做、跑了什么验证、证据是什么、回滚点在哪。

3）你要的循环机制：像 OMC 的自我修复，但最多 3 次“完整对话循环”，且不打断你

oh-my-claudecode 的 Autopilot/Ralph 核心特征是：并行执行 + 持续验证 + 自我修复 loop 直到完成。
你给的约束是：最多循环 3 次，而且是 3 次完整对话循环，不要中途打断你。

Miya 成品的实现方式是：

3.1 什么叫“一次完整对话循环”

一次循环不是“多问你两句”，而是 内部多代理的一整轮闭环（你看不见也不需要回应）：

Cycle 1：理解 → 计划 → 执行 → 验证 → 汇总
Cycle 2：复盘失败点 → 修正策略/工具 → 再执行 → 再验证 → 汇总
Cycle 3：最后一次纠错机会 → 强化验证/降级方案 → 执行 → 验证 → 汇总

每一轮都会产出：

本轮做了哪些动作（代码/命令/桌面/浏览器）

本轮验证证据（测试输出摘要、截图比对、日志要点）

本轮是否达标（通过/未通过）

下一轮要如何改变策略（如果还有下一轮）

3.2 “不打断对话”怎么体现

你发出一个要求后，Miya 不会在中间插一句“我需要你批准”或“你要不要继续”。

它会在后台跑完最多 3 个循环，然后在 OpenCode 原生 Chat 里给你一个连贯的最终答复（附上结果与证据），并在控制台里留下完整流水线痕迹（你想看再看）。

3.3 如果 3 轮仍然无法完成

Miya 会做两种“最小打扰”的收尾之一（仍然不把你拖进审批）：

降级完成：给出一个“满足你约束的最接近结果”（例如先让系统稳定可用、把剩余风险列出并自动创建后续任务）

硬失败但可复现：给出明确“卡在哪里 + 最小复现 + 下一步可行路径”，并自动把这件事加入自动化任务池里择机再试

4）你一句话下去，Miya 具体怎么做事（包含：编程 + 电脑操控 + 语音）
4.1 输入统一：文字/语音/快捷命令都进入同一个编排

你说：

“把 opencode 的某模块重构一下，并用微信告诉张三我今晚 10 点前给方案。”

Miya 实际会拆成同一个任务链：

OpenCode Chat 接收消息（原生会话）

意图识别：这是“编程 + 外发消息（副作用）”的复合任务

OMO 式多角色编队（自动并行）：

架构/实现/测试/审阅 agent 处理重构

沟通/文案 agent 生成微信消息草稿

操作员 agent 准备桌面动作脚本（聚焦微信→定位输入框→粘贴→发送）

自我审批分别对两条链进行签字：

编程链：跑测试/静态检查、确保改动可回滚

微信链：截图确认目标联系人/对话框、对比发送前后 UI 状态

执行：自动完成重构与消息发送

最终汇总：在 Chat 给你一条最终结果（重构内容、证据、消息已发送的确认信息、可回放链接）

4.2 电脑操控：不写微信/飞书/邮箱接口，直接操控现有客户端

Miya 的“对外沟通”默认走 桌面通用自动化（像 OpenClaw Nodes 那样把能力挂在 node 上）：

聚焦窗口

读取 UI（优先 Accessibility / UIA 权威信息；必要时截图识别）

点击/输入/粘贴/发送

用截图/可访问性状态做发送后校验

OpenClaw 的节点体系正是把“设备能力”作为 role: node 接入网关，并在本地存储 node token/连接信息；节点还会暴露权限映射（例如 screenRecording、accessibility 是否已授予）。

4.3 语音：你说一句话，Miya 自己组织团队执行

语音模式下，体验更像 OMC 的“Just ask → autopilot handles the rest”：

你不需要学命令，“说你要什么”即可触发 Autopilot

Autopilot 具备：自动规划、并行执行、持续验证、self-correction loop 直到完成（但 Miya 限制为最多 3 轮）

5）Skills：完全兼容 OpenCode 原生机制（不是另造一套）

成品 Miya 的 Skills 不是“另一个技能市场”，而是 OpenCode 原生插件/agents/配置的打包方式：

一个 Skill 包可以包含：

OpenCode 插件（hooks、tools、事件订阅）

Agents 配置（新增/覆盖角色与权限）

可选：MCP servers 配置、项目规则模板

OpenCode 本身就支持从 .opencode/plugins/（项目级）与 ~/.config/opencode/plugins/（全局）加载插件，也支持在配置里声明 npm 插件并由 Bun 自动安装缓存。

所以你最终看到的 Skill 更像：

“一键把 miya 变成更强的编程团队/更强的桌面操作员/更强的语音陪伴”
而不是“把聊天迁走、把工具体系迁走”。

6）Miya 的“自发完善/自我进化”：你只提要求，它自己写代码把自己升级

你要求：

“给 miya 增加一个功能：当我说‘开始专注’，它就自动把语音切成只听不说，并在我停键盘 2 分钟时才说一句陪伴。”

Miya 的成品行为是：

把这个需求当成一个正常开发任务进入 OpenCode 会话

Autopilot 编队：产品/架构/实现/测试/审阅并行

自我审批：在写入前要求“新鲜验证证据”（至少跑一轮相关测试/模拟）

执行落地：改代码、更新 Skills 包版本、写迁移脚本、生成变更记录

最终汇总：在 Chat 告诉你“已完成 + 证据 + 如何使用”

这整件事不需要你批准每一步，因为它运行在你指定的“全权模式”上（类似 OpenClaw 的 full / ask off 配置语义）。

7）最后：成品 Miya 的“默认安全形态”在你这套需求里是什么

你要求“不给你审批、给足权限”，那成品 Miya 的安全就不靠“人点批准”，而靠三件事：

本地优先、网关统一：控制平面默认绑定 loopback，通过 WebSocket 管理一切（对齐 OpenClaw 网关形态）。

自我审批必须有证据：architect/verifier 必须先拿到验证证据才允许执行（对齐 OMC verification tiers 的精神）。

一键急停：你不审批，但你永远可以一键停掉“桌面输入/外发/exec/浏览器动作”，把系统拉回安全态。           

自动git：每次做了修改都要自动保存到GitHub上，必须在每次对话停止前先保存，地址为https://github.com/mmy4shadow/miya-for-opencode.git

---

## 当前落地状态（2026-02-11）

1. 已新增项目规则文件：`AGENTS.md`
2. 已新增自动化 Git Hook 插件：`plugin/auto-git-push.ts`
3. Hook 行为：
   - 监听 `tool.execute.before` / `tool.execute.after`
   - 在写入类工具后自动执行 `git add + commit + push`
   - 在 `session.idle`（对话空闲）时再做一次兜底同步
   - 默认只暂存“本轮触达文件 + 已跟踪改动”，避免误把整个超大目录一次性提交
   - 自动将远端固定为 `https://github.com/mmy4shadow/miya-for-opencode.git`
4. 若本地目录还不是 Git 仓库，Hook 会自动初始化并绑定远端。
